/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	__webpack_require__(1);
	__webpack_require__(24);
	__webpack_require__(27);

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _jquery = __webpack_require__(2);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _react = __webpack_require__(3);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(4);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _tinymce = __webpack_require__(5);
	
	var _tinymce2 = _interopRequireDefault(_tinymce);
	
	var _Injector = __webpack_require__(6);
	
	var _ShortcodeSerialiser = __webpack_require__(7);
	
	var _ShortcodeSerialiser2 = _interopRequireDefault(_ShortcodeSerialiser);
	
	var _InsertEmbedModal = __webpack_require__(8);
	
	var _InsertEmbedModal2 = _interopRequireDefault(_InsertEmbedModal);
	
	var _i18n = __webpack_require__(9);
	
	var _i18n2 = _interopRequireDefault(_i18n);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/* global tinymce, window */
	var InjectableInsertEmbedModal = (0, _Injector.loadComponent)(_InsertEmbedModal2.default);
	var filter = 'div[data-shortcode="embed"]';
	
	/**
	 * Embed shortcodes are split into an outer <div> element and an inner <img>
	 * placeholder based on the thumbnail url provided by the oembed shortcode provider.
	 */
	(function () {
	  var ssembed = {
	    init: function init(editor) {
	      var insertTitle = _i18n2.default._t('AssetAdmin.INSERT_VIA_URL', 'Insert media via URL');
	      var editTitle = _i18n2.default._t('AssetAdmin.EDIT_MEDIA', 'Edit media');
	      var contextTitle = _i18n2.default._t('AssetAdmin.MEDIA', 'Media');
	      editor.addButton('ssembed', {
	        title: insertTitle,
	        icon: 'media',
	        cmd: 'ssembed',
	        stateSelector: filter
	      });
	      editor.addMenuItem('ssembed', {
	        text: contextTitle,
	        icon: 'media',
	        cmd: 'ssembed'
	      });
	      editor.addButton('ssembededit', {
	        title: editTitle,
	        icon: 'editimage',
	        cmd: 'ssembed'
	      });
	      editor.addContextToolbar(function (embed) {
	        return editor.dom.is(embed, filter);
	      }, 'alignleft aligncenter alignright | ssembededit');
	
	      editor.addCommand('ssembed', function () {
	        // See HtmlEditorField.js
	        (0, _jquery2.default)('#' + editor.id).entwine('ss').openEmbedDialog();
	      });
	
	      // Replace the tinymce default media commands with the ssembed command
	      editor.on('BeforeExecCommand', function (e) {
	        var cmd = e.command;
	        var ui = e.ui;
	        var val = e.value;
	        if (cmd === 'mceAdvMedia' || cmd === 'mceAdvMedia') {
	          e.preventDefault();
	          editor.execCommand('ssembed', ui, val);
	        }
	      });
	
	      editor.on('SaveContent', function (o) {
	        var content = (0, _jquery2.default)('<div>' + o.content + '</div>');
	
	        // Transform [embed] shortcodes
	        content.find(filter).each(function replaceWithShortCode() {
	          // Note: embed <div> contains placeholder <img>, and potentially caption <p>
	          var embed = (0, _jquery2.default)(this);
	          // If placeholder has been removed, remove data-* properties and
	          // convert to non-shortcode div
	          var placeholder = embed.find('img.placeholder');
	          if (placeholder.length === 0) {
	            embed.removeAttr('data-url');
	            embed.removeAttr('data-shortcode');
	            return;
	          }
	
	          // Find nested element data
	          var caption = embed.find('.caption').text();
	          var width = parseInt(placeholder.attr('width'), 10);
	          var height = parseInt(placeholder.attr('height'), 10);
	          var url = embed.data('url');
	          var properties = (0, _ShortcodeSerialiser.sanitiseShortCodeProperties)({
	            url: url,
	            thumbnail: placeholder.prop('src'),
	            class: embed.prop('class'),
	            width: isNaN(width) ? null : width,
	            height: isNaN(height) ? null : height,
	            caption: caption
	          });
	          var shortCode = _ShortcodeSerialiser2.default.serialise({
	            name: 'embed',
	            properties: properties,
	            wrapped: true,
	            content: properties.url
	          });
	          embed.replaceWith(shortCode);
	        });
	
	        // eslint-disable-next-line no-param-reassign
	        o.content = content.html();
	      });
	      editor.on('BeforeSetContent', function (o) {
	        var content = o.content;
	
	        // Transform [embed] tag
	        var match = _ShortcodeSerialiser2.default.match('embed', true, content);
	        while (match) {
	          var data = match.properties;
	
	          // Add base div
	          var base = (0, _jquery2.default)('<div/>').attr('data-url', data.url || match.content).attr('data-shortcode', 'embed').addClass(data.class).addClass('ss-htmleditorfield-file embed');
	
	          // Add placeholder
	          var placeholder = (0, _jquery2.default)('<img />').attr('src', data.thumbnail).addClass('placeholder');
	
	          // Set dimensions
	          if (data.width) {
	            placeholder.attr('width', data.width);
	          }
	          if (data.height) {
	            placeholder.attr('height', data.height);
	          }
	
	          base.append(placeholder);
	
	          // Add caption p tag
	          if (data.caption) {
	            var caption = (0, _jquery2.default)('<p />').addClass('caption').text(data.caption);
	            base.append(caption);
	          }
	
	          // Inject into code
	          content = content.replace(match.original, (0, _jquery2.default)('<div/>').append(base).html());
	
	          // Search for next match
	          match = _ShortcodeSerialiser2.default.match('embed', true, content);
	        }
	
	        // eslint-disable-next-line no-param-reassign
	        o.content = content;
	      });
	    }
	  };
	
	  _tinymce2.default.PluginManager.add('ssembed', function (editor) {
	    return ssembed.init(editor);
	  });
	})();
	
	_jquery2.default.entwine('ss', function ($) {
	  $('.js-injector-boot #insert-embed-react__dialog-wrapper').entwine({
	    Element: null,
	
	    Data: {},
	
	    onunmatch: function onunmatch() {
	      // solves errors given by ReactDOM "no matched root found" error.
	      this._clearModal();
	    },
	    _clearModal: function _clearModal() {
	      _reactDom2.default.unmountComponentAtNode(this[0]);
	      // this.empty();
	    },
	    open: function open() {
	      this._renderModal(true);
	    },
	    close: function close() {
	      this.setData({});
	      this._renderModal(false);
	    },
	
	
	    /**
	     * Renders the react modal component
	     *
	     * @param {boolean} isOpen
	     * @private
	     */
	    _renderModal: function _renderModal(isOpen) {
	      var _this = this;
	
	      var handleHide = function handleHide() {
	        return _this.close();
	      };
	      // Inserts embed into page
	      var handleInsert = function handleInsert() {
	        return _this._handleInsert.apply(_this, arguments);
	      };
	      // Create edit form from url
	      var handleCreate = function handleCreate() {
	        return _this._handleCreate.apply(_this, arguments);
	      };
	      var handleLoadingError = function handleLoadingError() {
	        return _this._handleLoadingError.apply(_this, arguments);
	      };
	      var attrs = this.getOriginalAttributes();
	
	      // create/update the react component
	      _reactDom2.default.render(_react2.default.createElement(InjectableInsertEmbedModal, {
	        isOpen: isOpen,
	        onCreate: handleCreate,
	        onInsert: handleInsert,
	        onClosed: handleHide,
	        onLoadingError: handleLoadingError,
	        bodyClassName: 'modal__dialog',
	        className: 'insert-embed-react__dialog-wrapper',
	        fileAttributes: attrs
	      }), this[0]);
	    },
	    _handleLoadingError: function _handleLoadingError() {
	      this.setData({});
	      this.open();
	    },
	
	
	    /**
	     * Handles inserting the selected file in the modal
	     *
	     * @param {object} data
	     * @returns {Promise}
	     * @private
	     */
	    _handleInsert: function _handleInsert(data) {
	      var oldData = this.getData();
	      this.setData(Object.assign({ Url: oldData.Url }, data));
	      this.insertRemote();
	      this.close();
	    },
	    _handleCreate: function _handleCreate(data) {
	      this.setData(Object.assign({}, this.getData(), data));
	      this.open();
	    },
	
	
	    /**
	     * Find the selected node and get attributes associated to attach the data to the form
	     *
	     * @returns {object}
	     */
	    getOriginalAttributes: function getOriginalAttributes() {
	      var data = this.getData();
	      var $field = this.getElement();
	      if (!$field) {
	        return data;
	      }
	
	      var node = $($field.getEditor().getSelectedNode());
	      if (!node.length) {
	        return data;
	      }
	
	      // Find root embed shortcode
	      var element = node.closest(filter).add(node.filter(filter));
	      if (!element.length) {
	        return data;
	      }
	      var image = element.find('img.placeholder');
	      // If image has been removed then this shortcode is invalid
	      if (image.length === 0) {
	        return data;
	      }
	
	      var caption = element.find('.caption').text();
	      var width = parseInt(image.width(), 10);
	      var height = parseInt(image.height(), 10);
	
	      return {
	        Url: element.data('url') || data.Url,
	        CaptionText: caption,
	        PreviewUrl: image.attr('src'),
	        Width: isNaN(width) ? null : width,
	        Height: isNaN(height) ? null : height,
	        Placement: this.findPosition(element.prop('class'))
	      };
	    },
	
	
	    /**
	     * Calculate placement from css class
	     */
	    findPosition: function findPosition(cssClass) {
	      var alignments = ['leftAlone', 'center', 'rightAlone', 'left', 'right'];
	      if (typeof cssClass !== 'string') {
	        return '';
	      }
	      var classes = cssClass.split(' ');
	      return alignments.find(function (alignment) {
	        return classes.indexOf(alignment) > -1;
	      });
	    },
	    insertRemote: function insertRemote() {
	      var $field = this.getElement();
	      if (!$field) {
	        return false;
	      }
	      var editor = $field.getEditor();
	      if (!editor) {
	        return false;
	      }
	
	      var data = this.getData();
	
	      // Add base div
	      var base = (0, _jquery2.default)('<div/>').attr('data-url', data.Url).attr('data-shortcode', 'embed').addClass(data.Placement).addClass('ss-htmleditorfield-file embed');
	
	      // Add placeholder image
	      var placeholder = (0, _jquery2.default)('<img />').attr('src', data.PreviewUrl).addClass('placeholder');
	
	      // Set dimensions
	      if (data.Width) {
	        placeholder.attr('width', data.Width);
	      }
	      if (data.Height) {
	        placeholder.attr('height', data.Height);
	      }
	
	      // Add to base
	      base.append(placeholder);
	
	      // Add caption p tag
	      if (data.CaptionText) {
	        var caption = (0, _jquery2.default)('<p />').addClass('caption').text(data.CaptionText);
	        base.append(caption);
	      }
	
	      // Find best place to put this embed
	      var node = $(editor.getSelectedNode());
	      var replacee = $(null);
	      if (node.length) {
	        replacee = node.filter(filter);
	
	        // Find find closest existing embed
	        if (replacee.length === 0) {
	          replacee = node.closest(filter);
	        }
	
	        // Fail over to check if the node is an image
	        if (replacee.length === 0) {
	          replacee = node.filter('img.placeholder');
	        }
	      }
	
	      // Inject
	      if (replacee.length) {
	        replacee.replaceWith(base);
	      } else {
	        // Otherwise insert the whole HTML content
	        editor.repaint();
	        editor.insertContent($('<div />').append(base.clone()).html(), { skip_undo: 1 });
	      }
	
	      editor.addUndo();
	      editor.repaint();
	
	      return true;
	    }
	  });
	});

/***/ }),
/* 2 */
/***/ (function(module, exports) {

	module.exports = jQuery;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	module.exports = React;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	module.exports = ReactDom;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
	 * Licensed under the LGPL or a commercial license.
	 * For LGPL see License.txt in the project root for license information.
	 * For commercial licenses see https://www.tiny.cloud/
	 *
	 * Version: 5.2.1 (2020-03-25)
	 */
	(function (domGlobals) {
	    'use strict';
	
	    var noop = function () {
	    };
	    var compose = function (fa, fb) {
	      return function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	          args[_i] = arguments[_i];
	        }
	        return fa(fb.apply(null, args));
	      };
	    };
	    var constant = function (value) {
	      return function () {
	        return value;
	      };
	    };
	    var identity = function (x) {
	      return x;
	    };
	    function curry(fn) {
	      var initialArgs = [];
	      for (var _i = 1; _i < arguments.length; _i++) {
	        initialArgs[_i - 1] = arguments[_i];
	      }
	      return function () {
	        var restArgs = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	          restArgs[_i] = arguments[_i];
	        }
	        var all = initialArgs.concat(restArgs);
	        return fn.apply(null, all);
	      };
	    }
	    var not = function (f) {
	      return function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	          args[_i] = arguments[_i];
	        }
	        return !f.apply(null, args);
	      };
	    };
	    var die = function (msg) {
	      return function () {
	        throw new Error(msg);
	      };
	    };
	    var never = constant(false);
	    var always = constant(true);
	
	    var none = function () {
	      return NONE;
	    };
	    var NONE = function () {
	      var eq = function (o) {
	        return o.isNone();
	      };
	      var call = function (thunk) {
	        return thunk();
	      };
	      var id = function (n) {
	        return n;
	      };
	      var me = {
	        fold: function (n, s) {
	          return n();
	        },
	        is: never,
	        isSome: never,
	        isNone: always,
	        getOr: id,
	        getOrThunk: call,
	        getOrDie: function (msg) {
	          throw new Error(msg || 'error: getOrDie called on none.');
	        },
	        getOrNull: constant(null),
	        getOrUndefined: constant(undefined),
	        or: id,
	        orThunk: call,
	        map: none,
	        each: noop,
	        bind: none,
	        exists: never,
	        forall: always,
	        filter: none,
	        equals: eq,
	        equals_: eq,
	        toArray: function () {
	          return [];
	        },
	        toString: constant('none()')
	      };
	      if (Object.freeze) {
	        Object.freeze(me);
	      }
	      return me;
	    }();
	    var some = function (a) {
	      var constant_a = constant(a);
	      var self = function () {
	        return me;
	      };
	      var bind = function (f) {
	        return f(a);
	      };
	      var me = {
	        fold: function (n, s) {
	          return s(a);
	        },
	        is: function (v) {
	          return a === v;
	        },
	        isSome: always,
	        isNone: never,
	        getOr: constant_a,
	        getOrThunk: constant_a,
	        getOrDie: constant_a,
	        getOrNull: constant_a,
	        getOrUndefined: constant_a,
	        or: self,
	        orThunk: self,
	        map: function (f) {
	          return some(f(a));
	        },
	        each: function (f) {
	          f(a);
	        },
	        bind: bind,
	        exists: bind,
	        forall: bind,
	        filter: function (f) {
	          return f(a) ? me : NONE;
	        },
	        toArray: function () {
	          return [a];
	        },
	        toString: function () {
	          return 'some(' + a + ')';
	        },
	        equals: function (o) {
	          return o.is(a);
	        },
	        equals_: function (o, elementEq) {
	          return o.fold(never, function (b) {
	            return elementEq(a, b);
	          });
	        }
	      };
	      return me;
	    };
	    var from = function (value) {
	      return value === null || value === undefined ? NONE : some(value);
	    };
	    var Option = {
	      some: some,
	      none: none,
	      from: from
	    };
	
	    var typeOf = function (x) {
	      if (x === null) {
	        return 'null';
	      }
	      var t = typeof x;
	      if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {
	        return 'array';
	      }
	      if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {
	        return 'string';
	      }
	      return t;
	    };
	    var isType = function (type) {
	      return function (value) {
	        return typeOf(value) === type;
	      };
	    };
	    var isString = isType('string');
	    var isObject = isType('object');
	    var isArray = isType('array');
	    var isNull = isType('null');
	    var isBoolean = isType('boolean');
	    var isFunction = isType('function');
	    var isNumber = isType('number');
	
	    var nativeSlice = Array.prototype.slice;
	    var nativeIndexOf = Array.prototype.indexOf;
	    var nativePush = Array.prototype.push;
	    var rawIndexOf = function (ts, t) {
	      return nativeIndexOf.call(ts, t);
	    };
	    var indexOf = function (xs, x) {
	      var r = rawIndexOf(xs, x);
	      return r === -1 ? Option.none() : Option.some(r);
	    };
	    var contains = function (xs, x) {
	      return rawIndexOf(xs, x) > -1;
	    };
	    var exists = function (xs, pred) {
	      for (var i = 0, len = xs.length; i < len; i++) {
	        var x = xs[i];
	        if (pred(x, i)) {
	          return true;
	        }
	      }
	      return false;
	    };
	    var map = function (xs, f) {
	      var len = xs.length;
	      var r = new Array(len);
	      for (var i = 0; i < len; i++) {
	        var x = xs[i];
	        r[i] = f(x, i);
	      }
	      return r;
	    };
	    var each = function (xs, f) {
	      for (var i = 0, len = xs.length; i < len; i++) {
	        var x = xs[i];
	        f(x, i);
	      }
	    };
	    var eachr = function (xs, f) {
	      for (var i = xs.length - 1; i >= 0; i--) {
	        var x = xs[i];
	        f(x, i);
	      }
	    };
	    var partition = function (xs, pred) {
	      var pass = [];
	      var fail = [];
	      for (var i = 0, len = xs.length; i < len; i++) {
	        var x = xs[i];
	        var arr = pred(x, i) ? pass : fail;
	        arr.push(x);
	      }
	      return {
	        pass: pass,
	        fail: fail
	      };
	    };
	    var filter = function (xs, pred) {
	      var r = [];
	      for (var i = 0, len = xs.length; i < len; i++) {
	        var x = xs[i];
	        if (pred(x, i)) {
	          r.push(x);
	        }
	      }
	      return r;
	    };
	    var foldr = function (xs, f, acc) {
	      eachr(xs, function (x) {
	        acc = f(acc, x);
	      });
	      return acc;
	    };
	    var foldl = function (xs, f, acc) {
	      each(xs, function (x) {
	        acc = f(acc, x);
	      });
	      return acc;
	    };
	    var find = function (xs, pred) {
	      for (var i = 0, len = xs.length; i < len; i++) {
	        var x = xs[i];
	        if (pred(x, i)) {
	          return Option.some(x);
	        }
	      }
	      return Option.none();
	    };
	    var findIndex = function (xs, pred) {
	      for (var i = 0, len = xs.length; i < len; i++) {
	        var x = xs[i];
	        if (pred(x, i)) {
	          return Option.some(i);
	        }
	      }
	      return Option.none();
	    };
	    var flatten = function (xs) {
	      var r = [];
	      for (var i = 0, len = xs.length; i < len; ++i) {
	        if (!isArray(xs[i])) {
	          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);
	        }
	        nativePush.apply(r, xs[i]);
	      }
	      return r;
	    };
	    var bind = function (xs, f) {
	      return flatten(map(xs, f));
	    };
	    var forall = function (xs, pred) {
	      for (var i = 0, len = xs.length; i < len; ++i) {
	        var x = xs[i];
	        if (pred(x, i) !== true) {
	          return false;
	        }
	      }
	      return true;
	    };
	    var reverse = function (xs) {
	      var r = nativeSlice.call(xs, 0);
	      r.reverse();
	      return r;
	    };
	    var difference = function (a1, a2) {
	      return filter(a1, function (x) {
	        return !contains(a2, x);
	      });
	    };
	    var mapToObject = function (xs, f) {
	      var r = {};
	      for (var i = 0, len = xs.length; i < len; i++) {
	        var x = xs[i];
	        r[String(x)] = f(x, i);
	      }
	      return r;
	    };
	    var sort = function (xs, comparator) {
	      var copy = nativeSlice.call(xs, 0);
	      copy.sort(comparator);
	      return copy;
	    };
	    var head = function (xs) {
	      return xs.length === 0 ? Option.none() : Option.some(xs[0]);
	    };
	    var last = function (xs) {
	      return xs.length === 0 ? Option.none() : Option.some(xs[xs.length - 1]);
	    };
	    var from$1 = isFunction(Array.from) ? Array.from : function (x) {
	      return nativeSlice.call(x);
	    };
	
	    var keys = Object.keys;
	    var hasOwnProperty = Object.hasOwnProperty;
	    var each$1 = function (obj, f) {
	      var props = keys(obj);
	      for (var k = 0, len = props.length; k < len; k++) {
	        var i = props[k];
	        var x = obj[i];
	        f(x, i);
	      }
	    };
	    var map$1 = function (obj, f) {
	      return tupleMap(obj, function (x, i) {
	        return {
	          k: i,
	          v: f(x, i)
	        };
	      });
	    };
	    var tupleMap = function (obj, f) {
	      var r = {};
	      each$1(obj, function (x, i) {
	        var tuple = f(x, i);
	        r[tuple.k] = tuple.v;
	      });
	      return r;
	    };
	    var objAcc = function (r) {
	      return function (x, i) {
	        r[i] = x;
	      };
	    };
	    var internalFilter = function (obj, pred, onTrue, onFalse) {
	      var r = {};
	      each$1(obj, function (x, i) {
	        (pred(x, i) ? onTrue : onFalse)(x, i);
	      });
	      return r;
	    };
	    var bifilter = function (obj, pred) {
	      var t = {};
	      var f = {};
	      internalFilter(obj, pred, objAcc(t), objAcc(f));
	      return {
	        t: t,
	        f: f
	      };
	    };
	    var filter$1 = function (obj, pred) {
	      var t = {};
	      internalFilter(obj, pred, objAcc(t), noop);
	      return t;
	    };
	    var get = function (obj, key) {
	      return has(obj, key) ? Option.from(obj[key]) : Option.none();
	    };
	    var has = function (obj, key) {
	      return hasOwnProperty.call(obj, key);
	    };
	
	    var __assign = function () {
	      __assign = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	          s = arguments[i];
	          for (var p in s)
	            if (Object.prototype.hasOwnProperty.call(s, p))
	              t[p] = s[p];
	        }
	        return t;
	      };
	      return __assign.apply(this, arguments);
	    };
	    function __rest(s, e) {
	      var t = {};
	      for (var p in s)
	        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	          t[p] = s[p];
	      if (s != null && typeof Object.getOwnPropertySymbols === 'function')
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	            t[p[i]] = s[p[i]];
	        }
	      return t;
	    }
	    function __spreadArrays() {
	      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
	        s += arguments[i].length;
	      for (var r = Array(s), k = 0, i = 0; i < il; i++)
	        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
	          r[k] = a[j];
	      return r;
	    }
	
	    var fromHtml = function (html, scope) {
	      var doc = scope || domGlobals.document;
	      var div = doc.createElement('div');
	      div.innerHTML = html;
	      if (!div.hasChildNodes() || div.childNodes.length > 1) {
	        domGlobals.console.error('HTML does not have a single root node', html);
	        throw new Error('HTML must have a single root node');
	      }
	      return fromDom(div.childNodes[0]);
	    };
	    var fromTag = function (tag, scope) {
	      var doc = scope || domGlobals.document;
	      var node = doc.createElement(tag);
	      return fromDom(node);
	    };
	    var fromText = function (text, scope) {
	      var doc = scope || domGlobals.document;
	      var node = doc.createTextNode(text);
	      return fromDom(node);
	    };
	    var fromDom = function (node) {
	      if (node === null || node === undefined) {
	        throw new Error('Node cannot be null or undefined');
	      }
	      return { dom: constant(node) };
	    };
	    var fromPoint = function (docElm, x, y) {
	      var doc = docElm.dom();
	      return Option.from(doc.elementFromPoint(x, y)).map(fromDom);
	    };
	    var Element = {
	      fromHtml: fromHtml,
	      fromTag: fromTag,
	      fromText: fromText,
	      fromDom: fromDom,
	      fromPoint: fromPoint
	    };
	
	    var Cell = function (initial) {
	      var value = initial;
	      var get = function () {
	        return value;
	      };
	      var set = function (v) {
	        value = v;
	      };
	      var clone = function () {
	        return Cell(get());
	      };
	      return {
	        get: get,
	        set: set,
	        clone: clone
	      };
	    };
	
	    var firstMatch = function (regexes, s) {
	      for (var i = 0; i < regexes.length; i++) {
	        var x = regexes[i];
	        if (x.test(s)) {
	          return x;
	        }
	      }
	      return undefined;
	    };
	    var find$1 = function (regexes, agent) {
	      var r = firstMatch(regexes, agent);
	      if (!r) {
	        return {
	          major: 0,
	          minor: 0
	        };
	      }
	      var group = function (i) {
	        return Number(agent.replace(r, '$' + i));
	      };
	      return nu(group(1), group(2));
	    };
	    var detect = function (versionRegexes, agent) {
	      var cleanedAgent = String(agent).toLowerCase();
	      if (versionRegexes.length === 0) {
	        return unknown();
	      }
	      return find$1(versionRegexes, cleanedAgent);
	    };
	    var unknown = function () {
	      return nu(0, 0);
	    };
	    var nu = function (major, minor) {
	      return {
	        major: major,
	        minor: minor
	      };
	    };
	    var Version = {
	      nu: nu,
	      detect: detect,
	      unknown: unknown
	    };
	
	    var edge = 'Edge';
	    var chrome = 'Chrome';
	    var ie = 'IE';
	    var opera = 'Opera';
	    var firefox = 'Firefox';
	    var safari = 'Safari';
	    var isBrowser = function (name, current) {
	      return function () {
	        return current === name;
	      };
	    };
	    var unknown$1 = function () {
	      return nu$1({
	        current: undefined,
	        version: Version.unknown()
	      });
	    };
	    var nu$1 = function (info) {
	      var current = info.current;
	      var version = info.version;
	      return {
	        current: current,
	        version: version,
	        isEdge: isBrowser(edge, current),
	        isChrome: isBrowser(chrome, current),
	        isIE: isBrowser(ie, current),
	        isOpera: isBrowser(opera, current),
	        isFirefox: isBrowser(firefox, current),
	        isSafari: isBrowser(safari, current)
	      };
	    };
	    var Browser = {
	      unknown: unknown$1,
	      nu: nu$1,
	      edge: constant(edge),
	      chrome: constant(chrome),
	      ie: constant(ie),
	      opera: constant(opera),
	      firefox: constant(firefox),
	      safari: constant(safari)
	    };
	
	    var windows = 'Windows';
	    var ios = 'iOS';
	    var android = 'Android';
	    var linux = 'Linux';
	    var osx = 'OSX';
	    var solaris = 'Solaris';
	    var freebsd = 'FreeBSD';
	    var chromeos = 'ChromeOS';
	    var isOS = function (name, current) {
	      return function () {
	        return current === name;
	      };
	    };
	    var unknown$2 = function () {
	      return nu$2({
	        current: undefined,
	        version: Version.unknown()
	      });
	    };
	    var nu$2 = function (info) {
	      var current = info.current;
	      var version = info.version;
	      return {
	        current: current,
	        version: version,
	        isWindows: isOS(windows, current),
	        isiOS: isOS(ios, current),
	        isAndroid: isOS(android, current),
	        isOSX: isOS(osx, current),
	        isLinux: isOS(linux, current),
	        isSolaris: isOS(solaris, current),
	        isFreeBSD: isOS(freebsd, current),
	        isChromeOS: isOS(chromeos, current)
	      };
	    };
	    var OperatingSystem = {
	      unknown: unknown$2,
	      nu: nu$2,
	      windows: constant(windows),
	      ios: constant(ios),
	      android: constant(android),
	      linux: constant(linux),
	      osx: constant(osx),
	      solaris: constant(solaris),
	      freebsd: constant(freebsd),
	      chromeos: constant(chromeos)
	    };
	
	    var DeviceType = function (os, browser, userAgent, mediaMatch) {
	      var isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;
	      var isiPhone = os.isiOS() && !isiPad;
	      var isMobile = os.isiOS() || os.isAndroid();
	      var isTouch = isMobile || mediaMatch('(pointer:coarse)');
	      var isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');
	      var isPhone = isiPhone || isMobile && !isTablet;
	      var iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;
	      var isDesktop = !isPhone && !isTablet && !iOSwebview;
	      return {
	        isiPad: constant(isiPad),
	        isiPhone: constant(isiPhone),
	        isTablet: constant(isTablet),
	        isPhone: constant(isPhone),
	        isTouch: constant(isTouch),
	        isAndroid: os.isAndroid,
	        isiOS: os.isiOS,
	        isWebView: constant(iOSwebview),
	        isDesktop: constant(isDesktop)
	      };
	    };
	
	    var detect$1 = function (candidates, userAgent) {
	      var agent = String(userAgent).toLowerCase();
	      return find(candidates, function (candidate) {
	        return candidate.search(agent);
	      });
	    };
	    var detectBrowser = function (browsers, userAgent) {
	      return detect$1(browsers, userAgent).map(function (browser) {
	        var version = Version.detect(browser.versionRegexes, userAgent);
	        return {
	          current: browser.name,
	          version: version
	        };
	      });
	    };
	    var detectOs = function (oses, userAgent) {
	      return detect$1(oses, userAgent).map(function (os) {
	        var version = Version.detect(os.versionRegexes, userAgent);
	        return {
	          current: os.name,
	          version: version
	        };
	      });
	    };
	    var UaString = {
	      detectBrowser: detectBrowser,
	      detectOs: detectOs
	    };
	
	    var checkRange = function (str, substr, start) {
	      if (substr === '') {
	        return true;
	      }
	      if (str.length < substr.length) {
	        return false;
	      }
	      var x = str.substr(start, start + substr.length);
	      return x === substr;
	    };
	    var contains$1 = function (str, substr) {
	      return str.indexOf(substr) !== -1;
	    };
	    var startsWith = function (str, prefix) {
	      return checkRange(str, prefix, 0);
	    };
	    var trim = function (str) {
	      return str.replace(/^\s+|\s+$/g, '');
	    };
	    var lTrim = function (str) {
	      return str.replace(/^\s+/g, '');
	    };
	    var rTrim = function (str) {
	      return str.replace(/\s+$/g, '');
	    };
	
	    var normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
	    var checkContains = function (target) {
	      return function (uastring) {
	        return contains$1(uastring, target);
	      };
	    };
	    var browsers = [
	      {
	        name: 'Edge',
	        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
	        search: function (uastring) {
	          return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');
	        }
	      },
	      {
	        name: 'Chrome',
	        versionRegexes: [
	          /.*?chrome\/([0-9]+)\.([0-9]+).*/,
	          normalVersionRegex
	        ],
	        search: function (uastring) {
	          return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');
	        }
	      },
	      {
	        name: 'IE',
	        versionRegexes: [
	          /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
	          /.*?rv:([0-9]+)\.([0-9]+).*/
	        ],
	        search: function (uastring) {
	          return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');
	        }
	      },
	      {
	        name: 'Opera',
	        versionRegexes: [
	          normalVersionRegex,
	          /.*?opera\/([0-9]+)\.([0-9]+).*/
	        ],
	        search: checkContains('opera')
	      },
	      {
	        name: 'Firefox',
	        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
	        search: checkContains('firefox')
	      },
	      {
	        name: 'Safari',
	        versionRegexes: [
	          normalVersionRegex,
	          /.*?cpu os ([0-9]+)_([0-9]+).*/
	        ],
	        search: function (uastring) {
	          return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');
	        }
	      }
	    ];
	    var oses = [
	      {
	        name: 'Windows',
	        search: checkContains('win'),
	        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
	      },
	      {
	        name: 'iOS',
	        search: function (uastring) {
	          return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');
	        },
	        versionRegexes: [
	          /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
	          /.*cpu os ([0-9]+)_([0-9]+).*/,
	          /.*cpu iphone os ([0-9]+)_([0-9]+).*/
	        ]
	      },
	      {
	        name: 'Android',
	        search: checkContains('android'),
	        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
	      },
	      {
	        name: 'OSX',
	        search: checkContains('mac os x'),
	        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
	      },
	      {
	        name: 'Linux',
	        search: checkContains('linux'),
	        versionRegexes: []
	      },
	      {
	        name: 'Solaris',
	        search: checkContains('sunos'),
	        versionRegexes: []
	      },
	      {
	        name: 'FreeBSD',
	        search: checkContains('freebsd'),
	        versionRegexes: []
	      },
	      {
	        name: 'ChromeOS',
	        search: checkContains('cros'),
	        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
	      }
	    ];
	    var PlatformInfo = {
	      browsers: constant(browsers),
	      oses: constant(oses)
	    };
	
	    var detect$2 = function (userAgent, mediaMatch) {
	      var browsers = PlatformInfo.browsers();
	      var oses = PlatformInfo.oses();
	      var browser = UaString.detectBrowser(browsers, userAgent).fold(Browser.unknown, Browser.nu);
	      var os = UaString.detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);
	      var deviceType = DeviceType(os, browser, userAgent, mediaMatch);
	      return {
	        browser: browser,
	        os: os,
	        deviceType: deviceType
	      };
	    };
	    var PlatformDetection = { detect: detect$2 };
	
	    var mediaMatch = function (query) {
	      return domGlobals.window.matchMedia(query).matches;
	    };
	    var platform = Cell(PlatformDetection.detect(domGlobals.navigator.userAgent, mediaMatch));
	    var detect$3 = function () {
	      return platform.get();
	    };
	
	    var Immutable = function () {
	      var fields = [];
	      for (var _i = 0; _i < arguments.length; _i++) {
	        fields[_i] = arguments[_i];
	      }
	      return function () {
	        var values = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	          values[_i] = arguments[_i];
	        }
	        if (fields.length !== values.length) {
	          throw new Error('Wrong number of arguments to struct. Expected "[' + fields.length + ']", got ' + values.length + ' arguments');
	        }
	        var struct = {};
	        each(fields, function (name, i) {
	          struct[name] = constant(values[i]);
	        });
	        return struct;
	      };
	    };
	
	    var toArray = function (target, f) {
	      var r = [];
	      var recurse = function (e) {
	        r.push(e);
	        return f(e);
	      };
	      var cur = f(target);
	      do {
	        cur = cur.bind(recurse);
	      } while (cur.isSome());
	      return r;
	    };
	    var Recurse = { toArray: toArray };
	
	    var compareDocumentPosition = function (a, b, match) {
	      return (a.compareDocumentPosition(b) & match) !== 0;
	    };
	    var documentPositionPreceding = function (a, b) {
	      return compareDocumentPosition(a, b, domGlobals.Node.DOCUMENT_POSITION_PRECEDING);
	    };
	    var documentPositionContainedBy = function (a, b) {
	      return compareDocumentPosition(a, b, domGlobals.Node.DOCUMENT_POSITION_CONTAINED_BY);
	    };
	    var Node = {
	      documentPositionPreceding: documentPositionPreceding,
	      documentPositionContainedBy: documentPositionContainedBy
	    };
	
	    var ATTRIBUTE = domGlobals.Node.ATTRIBUTE_NODE;
	    var CDATA_SECTION = domGlobals.Node.CDATA_SECTION_NODE;
	    var COMMENT = domGlobals.Node.COMMENT_NODE;
	    var DOCUMENT = domGlobals.Node.DOCUMENT_NODE;
	    var DOCUMENT_TYPE = domGlobals.Node.DOCUMENT_TYPE_NODE;
	    var DOCUMENT_FRAGMENT = domGlobals.Node.DOCUMENT_FRAGMENT_NODE;
	    var ELEMENT = domGlobals.Node.ELEMENT_NODE;
	    var TEXT = domGlobals.Node.TEXT_NODE;
	    var PROCESSING_INSTRUCTION = domGlobals.Node.PROCESSING_INSTRUCTION_NODE;
	    var ENTITY_REFERENCE = domGlobals.Node.ENTITY_REFERENCE_NODE;
	    var ENTITY = domGlobals.Node.ENTITY_NODE;
	    var NOTATION = domGlobals.Node.NOTATION_NODE;
	
	    var ELEMENT$1 = ELEMENT;
	    var DOCUMENT$1 = DOCUMENT;
	    var is = function (element, selector) {
	      var dom = element.dom();
	      if (dom.nodeType !== ELEMENT$1) {
	        return false;
	      } else {
	        var elem = dom;
	        if (elem.matches !== undefined) {
	          return elem.matches(selector);
	        } else if (elem.msMatchesSelector !== undefined) {
	          return elem.msMatchesSelector(selector);
	        } else if (elem.webkitMatchesSelector !== undefined) {
	          return elem.webkitMatchesSelector(selector);
	        } else if (elem.mozMatchesSelector !== undefined) {
	          return elem.mozMatchesSelector(selector);
	        } else {
	          throw new Error('Browser lacks native selectors');
	        }
	      }
	    };
	    var bypassSelector = function (dom) {
	      return dom.nodeType !== ELEMENT$1 && dom.nodeType !== DOCUMENT$1 || dom.childElementCount === 0;
	    };
	    var all = function (selector, scope) {
	      var base = scope === undefined ? domGlobals.document : scope.dom();
	      return bypassSelector(base) ? [] : map(base.querySelectorAll(selector), Element.fromDom);
	    };
	    var one = function (selector, scope) {
	      var base = scope === undefined ? domGlobals.document : scope.dom();
	      return bypassSelector(base) ? Option.none() : Option.from(base.querySelector(selector)).map(Element.fromDom);
	    };
	
	    var eq = function (e1, e2) {
	      return e1.dom() === e2.dom();
	    };
	    var regularContains = function (e1, e2) {
	      var d1 = e1.dom();
	      var d2 = e2.dom();
	      return d1 === d2 ? false : d1.contains(d2);
	    };
	    var ieContains = function (e1, e2) {
	      return Node.documentPositionContainedBy(e1.dom(), e2.dom());
	    };
	    var browser = detect$3().browser;
	    var contains$2 = browser.isIE() ? ieContains : regularContains;
	
	    var owner = function (element) {
	      return Element.fromDom(element.dom().ownerDocument);
	    };
	    var documentElement = function (element) {
	      return Element.fromDom(element.dom().ownerDocument.documentElement);
	    };
	    var defaultView = function (element) {
	      return Element.fromDom(element.dom().ownerDocument.defaultView);
	    };
	    var parent = function (element) {
	      return Option.from(element.dom().parentNode).map(Element.fromDom);
	    };
	    var parents = function (element, isRoot) {
	      var stop = isFunction(isRoot) ? isRoot : never;
	      var dom = element.dom();
	      var ret = [];
	      while (dom.parentNode !== null && dom.parentNode !== undefined) {
	        var rawParent = dom.parentNode;
	        var p = Element.fromDom(rawParent);
	        ret.push(p);
	        if (stop(p) === true) {
	          break;
	        } else {
	          dom = rawParent;
	        }
	      }
	      return ret;
	    };
	    var prevSibling = function (element) {
	      return Option.from(element.dom().previousSibling).map(Element.fromDom);
	    };
	    var nextSibling = function (element) {
	      return Option.from(element.dom().nextSibling).map(Element.fromDom);
	    };
	    var prevSiblings = function (element) {
	      return reverse(Recurse.toArray(element, prevSibling));
	    };
	    var nextSiblings = function (element) {
	      return Recurse.toArray(element, nextSibling);
	    };
	    var children = function (element) {
	      return map(element.dom().childNodes, Element.fromDom);
	    };
	    var child = function (element, index) {
	      var cs = element.dom().childNodes;
	      return Option.from(cs[index]).map(Element.fromDom);
	    };
	    var firstChild = function (element) {
	      return child(element, 0);
	    };
	    var lastChild = function (element) {
	      return child(element, element.dom().childNodes.length - 1);
	    };
	    var childNodesCount = function (element) {
	      return element.dom().childNodes.length;
	    };
	    var spot = Immutable('element', 'offset');
	
	    var before = function (marker, element) {
	      var parent$1 = parent(marker);
	      parent$1.each(function (v) {
	        v.dom().insertBefore(element.dom(), marker.dom());
	      });
	    };
	    var after = function (marker, element) {
	      var sibling = nextSibling(marker);
	      sibling.fold(function () {
	        var parent$1 = parent(marker);
	        parent$1.each(function (v) {
	          append(v, element);
	        });
	      }, function (v) {
	        before(v, element);
	      });
	    };
	    var prepend = function (parent, element) {
	      var firstChild$1 = firstChild(parent);
	      firstChild$1.fold(function () {
	        append(parent, element);
	      }, function (v) {
	        parent.dom().insertBefore(element.dom(), v.dom());
	      });
	    };
	    var append = function (parent, element) {
	      parent.dom().appendChild(element.dom());
	    };
	    var wrap = function (element, wrapper) {
	      before(element, wrapper);
	      append(wrapper, element);
	    };
	
	    var before$1 = function (marker, elements) {
	      each(elements, function (x) {
	        before(marker, x);
	      });
	    };
	    var append$1 = function (parent, elements) {
	      each(elements, function (x) {
	        append(parent, x);
	      });
	    };
	
	    var empty = function (element) {
	      element.dom().textContent = '';
	      each(children(element), function (rogue) {
	        remove(rogue);
	      });
	    };
	    var remove = function (element) {
	      var dom = element.dom();
	      if (dom.parentNode !== null) {
	        dom.parentNode.removeChild(dom);
	      }
	    };
	    var unwrap = function (wrapper) {
	      var children$1 = children(wrapper);
	      if (children$1.length > 0) {
	        before$1(wrapper, children$1);
	      }
	      remove(wrapper);
	    };
	
	    var Global = typeof domGlobals.window !== 'undefined' ? domGlobals.window : Function('return this;')();
	
	    var name = function (element) {
	      var r = element.dom().nodeName;
	      return r.toLowerCase();
	    };
	    var type = function (element) {
	      return element.dom().nodeType;
	    };
	    var isType$1 = function (t) {
	      return function (element) {
	        return type(element) === t;
	      };
	    };
	    var isElement = isType$1(ELEMENT);
	    var isText = isType$1(TEXT);
	
	    var inBody = function (element) {
	      var dom = isText(element) ? element.dom().parentNode : element.dom();
	      return dom !== undefined && dom !== null && dom.ownerDocument.body.contains(dom);
	    };
	
	    var r = function (left, top) {
	      var translate = function (x, y) {
	        return r(left + x, top + y);
	      };
	      return {
	        left: constant(left),
	        top: constant(top),
	        translate: translate
	      };
	    };
	    var Position = r;
	
	    var boxPosition = function (dom) {
	      var box = dom.getBoundingClientRect();
	      return Position(box.left, box.top);
	    };
	    var firstDefinedOrZero = function (a, b) {
	      return a !== undefined ? a : b !== undefined ? b : 0;
	    };
	    var absolute = function (element) {
	      var doc = element.dom().ownerDocument;
	      var body = doc.body;
	      var win = doc.defaultView;
	      var html = doc.documentElement;
	      if (body === element.dom()) {
	        return Position(body.offsetLeft, body.offsetTop);
	      }
	      var scrollTop = firstDefinedOrZero(win.pageYOffset, html.scrollTop);
	      var scrollLeft = firstDefinedOrZero(win.pageXOffset, html.scrollLeft);
	      var clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);
	      var clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);
	      return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);
	    };
	    var viewport = function (element) {
	      var dom = element.dom();
	      var doc = dom.ownerDocument;
	      var body = doc.body;
	      if (body === dom) {
	        return Position(body.offsetLeft, body.offsetTop);
	      }
	      if (!inBody(element)) {
	        return Position(0, 0);
	      }
	      return boxPosition(dom);
	    };
	
	    var isSafari = detect$3().browser.isSafari();
	    var get$1 = function (_DOC) {
	      var doc = _DOC !== undefined ? _DOC.dom() : domGlobals.document;
	      var x = doc.body.scrollLeft || doc.documentElement.scrollLeft;
	      var y = doc.body.scrollTop || doc.documentElement.scrollTop;
	      return Position(x, y);
	    };
	    var to = function (x, y, _DOC) {
	      var doc = _DOC !== undefined ? _DOC.dom() : domGlobals.document;
	      var win = doc.defaultView;
	      win.scrollTo(x, y);
	    };
	    var intoView = function (element, alignToTop) {
	      if (isSafari && isFunction(element.dom().scrollIntoViewIfNeeded)) {
	        element.dom().scrollIntoViewIfNeeded(false);
	      } else {
	        element.dom().scrollIntoView(alignToTop);
	      }
	    };
	
	    var get$2 = function (_win) {
	      var win = _win === undefined ? domGlobals.window : _win;
	      return Option.from(win['visualViewport']);
	    };
	    var bounds = function (x, y, width, height) {
	      return {
	        x: constant(x),
	        y: constant(y),
	        width: constant(width),
	        height: constant(height),
	        right: constant(x + width),
	        bottom: constant(y + height)
	      };
	    };
	    var getBounds = function (_win) {
	      var win = _win === undefined ? domGlobals.window : _win;
	      var doc = win.document;
	      var scroll = get$1(Element.fromDom(doc));
	      return get$2(win).fold(function () {
	        var html = win.document.documentElement;
	        var width = html.clientWidth;
	        var height = html.clientHeight;
	        return bounds(scroll.left(), scroll.top(), width, height);
	      }, function (visualViewport) {
	        return bounds(Math.max(visualViewport.pageLeft, scroll.left()), Math.max(visualViewport.pageTop, scroll.top()), visualViewport.width, visualViewport.height);
	      });
	    };
	
	    var isNodeType = function (type) {
	      return function (node) {
	        return !!node && node.nodeType === type;
	      };
	    };
	    var isRestrictedNode = function (node) {
	      return !!node && !Object.getPrototypeOf(node);
	    };
	    var isElement$1 = isNodeType(1);
	    var matchNodeNames = function (names) {
	      var lowercasedNames = names.map(function (s) {
	        return s.toLowerCase();
	      });
	      return function (node) {
	        if (node && node.nodeName) {
	          var nodeName = node.nodeName.toLowerCase();
	          return contains(lowercasedNames, nodeName);
	        }
	        return false;
	      };
	    };
	    var matchStyleValues = function (name, values) {
	      var items = values.toLowerCase().split(' ');
	      return function (node) {
	        var i, cssValue;
	        if (isElement$1(node)) {
	          for (i = 0; i < items.length; i++) {
	            var computed = node.ownerDocument.defaultView.getComputedStyle(node, null);
	            cssValue = computed ? computed.getPropertyValue(name) : null;
	            if (cssValue === items[i]) {
	              return true;
	            }
	          }
	        }
	        return false;
	      };
	    };
	    var hasPropValue = function (propName, propValue) {
	      return function (node) {
	        return isElement$1(node) && node[propName] === propValue;
	      };
	    };
	    var hasAttribute = function (attrName, attrValue) {
	      return function (node) {
	        return isElement$1(node) && node.hasAttribute(attrName);
	      };
	    };
	    var hasAttributeValue = function (attrName, attrValue) {
	      return function (node) {
	        return isElement$1(node) && node.getAttribute(attrName) === attrValue;
	      };
	    };
	    var isBogus = function (node) {
	      return isElement$1(node) && node.hasAttribute('data-mce-bogus');
	    };
	    var isBogusAll = function (node) {
	      return isElement$1(node) && node.getAttribute('data-mce-bogus') === 'all';
	    };
	    var isTable = function (node) {
	      return isElement$1(node) && node.tagName === 'TABLE';
	    };
	    var hasContentEditableState = function (value) {
	      return function (node) {
	        if (isElement$1(node)) {
	          if (node.contentEditable === value) {
	            return true;
	          }
	          if (node.getAttribute('data-mce-contenteditable') === value) {
	            return true;
	          }
	        }
	        return false;
	      };
	    };
	    var isTextareaOrInput = matchNodeNames([
	      'textarea',
	      'input'
	    ]);
	    var isText$1 = isNodeType(3);
	    var isComment = isNodeType(8);
	    var isDocument = isNodeType(9);
	    var isDocumentFragment = isNodeType(11);
	    var isBr = matchNodeNames(['br']);
	    var isContentEditableTrue = hasContentEditableState('true');
	    var isContentEditableFalse = hasContentEditableState('false');
	    var NodeType = {
	      isText: isText$1,
	      isElement: isElement$1,
	      isComment: isComment,
	      isDocument: isDocument,
	      isDocumentFragment: isDocumentFragment,
	      isBr: isBr,
	      isContentEditableTrue: isContentEditableTrue,
	      isContentEditableFalse: isContentEditableFalse,
	      isRestrictedNode: isRestrictedNode,
	      matchNodeNames: matchNodeNames,
	      hasPropValue: hasPropValue,
	      hasAttribute: hasAttribute,
	      hasAttributeValue: hasAttributeValue,
	      matchStyleValues: matchStyleValues,
	      isBogus: isBogus,
	      isBogusAll: isBogusAll,
	      isTable: isTable,
	      isTextareaOrInput: isTextareaOrInput
	    };
	
	    var isSupported = function (dom) {
	      return dom.style !== undefined && isFunction(dom.style.getPropertyValue);
	    };
	
	    var rawSet = function (dom, key, value) {
	      if (isString(value) || isBoolean(value) || isNumber(value)) {
	        dom.setAttribute(key, value + '');
	      } else {
	        domGlobals.console.error('Invalid call to Attr.set. Key ', key, ':: Value ', value, ':: Element ', dom);
	        throw new Error('Attribute value was not simple');
	      }
	    };
	    var set = function (element, key, value) {
	      rawSet(element.dom(), key, value);
	    };
	    var setAll = function (element, attrs) {
	      var dom = element.dom();
	      each$1(attrs, function (v, k) {
	        rawSet(dom, k, v);
	      });
	    };
	    var get$3 = function (element, key) {
	      var v = element.dom().getAttribute(key);
	      return v === null ? undefined : v;
	    };
	    var getOpt = function (element, key) {
	      return Option.from(get$3(element, key));
	    };
	    var has$1 = function (element, key) {
	      var dom = element.dom();
	      return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;
	    };
	    var remove$1 = function (element, key) {
	      element.dom().removeAttribute(key);
	    };
	
	    var get$4 = function (element, property) {
	      var dom = element.dom();
	      var styles = domGlobals.window.getComputedStyle(dom);
	      var r = styles.getPropertyValue(property);
	      var v = r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;
	      return v === null ? undefined : v;
	    };
	    var getUnsafeProperty = function (dom, property) {
	      return isSupported(dom) ? dom.style.getPropertyValue(property) : '';
	    };
	    var getRaw = function (element, property) {
	      var dom = element.dom();
	      var raw = getUnsafeProperty(dom, property);
	      return Option.from(raw).filter(function (r) {
	        return r.length > 0;
	      });
	    };
	    var getAllRaw = function (element) {
	      var css = {};
	      var dom = element.dom();
	      if (isSupported(dom)) {
	        for (var i = 0; i < dom.style.length; i++) {
	          var ruleName = dom.style.item(i);
	          css[ruleName] = dom.style[ruleName];
	        }
	      }
	      return css;
	    };
	    var reflow = function (e) {
	      return e.dom().offsetWidth;
	    };
	
	    var browser$1 = detect$3().browser;
	    var firstElement = function (nodes) {
	      return find(nodes, isElement);
	    };
	    var getTableCaptionDeltaY = function (elm) {
	      if (browser$1.isFirefox() && name(elm) === 'table') {
	        return firstElement(children(elm)).filter(function (elm) {
	          return name(elm) === 'caption';
	        }).bind(function (caption) {
	          return firstElement(nextSiblings(caption)).map(function (body) {
	            var bodyTop = body.dom().offsetTop;
	            var captionTop = caption.dom().offsetTop;
	            var captionHeight = caption.dom().offsetHeight;
	            return bodyTop <= captionTop ? -captionHeight : 0;
	          });
	        }).getOr(0);
	      } else {
	        return 0;
	      }
	    };
	    var hasChild = function (elm, child) {
	      return elm.children && contains(elm.children, child);
	    };
	    var getPos = function (body, elm, rootElm) {
	      var x = 0, y = 0, offsetParent;
	      var doc = body.ownerDocument;
	      var pos;
	      rootElm = rootElm ? rootElm : body;
	      if (elm) {
	        if (rootElm === body && elm.getBoundingClientRect && get$4(Element.fromDom(body), 'position') === 'static') {
	          pos = elm.getBoundingClientRect();
	          x = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - doc.documentElement.clientLeft;
	          y = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - doc.documentElement.clientTop;
	          return {
	            x: x,
	            y: y
	          };
	        }
	        offsetParent = elm;
	        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {
	          x += offsetParent.offsetLeft || 0;
	          y += offsetParent.offsetTop || 0;
	          offsetParent = offsetParent.offsetParent;
	        }
	        offsetParent = elm.parentNode;
	        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {
	          x -= offsetParent.scrollLeft || 0;
	          y -= offsetParent.scrollTop || 0;
	          offsetParent = offsetParent.parentNode;
	        }
	        y += getTableCaptionDeltaY(Element.fromDom(elm));
	      }
	      return {
	        x: x,
	        y: y
	      };
	    };
	    var Position$1 = { getPos: getPos };
	
	    var exports$1 = {}, module$1 = { exports: exports$1 };
	    (function (define, exports, module, require) {
	      (function (f) {
	        if (typeof exports === 'object' && typeof module !== 'undefined') {
	          module.exports = f();
	        } else if (typeof define === 'function' && define.amd) {
	          define([], f);
	        } else {
	          var g;
	          if (typeof window !== 'undefined') {
	            g = window;
	          } else if (typeof global !== 'undefined') {
	            g = global;
	          } else if (typeof self !== 'undefined') {
	            g = self;
	          } else {
	            g = this;
	          }
	          g.EphoxContactWrapper = f();
	        }
	      }(function () {
	        return function () {
	          function r(e, n, t) {
	            function o(i, f) {
	              if (!n[i]) {
	                if (!e[i]) {
	                  var c = 'function' == typeof require && require;
	                  if (!f && c)
	                    return c(i, !0);
	                  if (u)
	                    return u(i, !0);
	                  var a = new Error('Cannot find module \'' + i + '\'');
	                  throw a.code = 'MODULE_NOT_FOUND', a;
	                }
	                var p = n[i] = { exports: {} };
	                e[i][0].call(p.exports, function (r) {
	                  var n = e[i][1][r];
	                  return o(n || r);
	                }, p, p.exports, r, e, n, t);
	              }
	              return n[i].exports;
	            }
	            for (var u = 'function' == typeof require && require, i = 0; i < t.length; i++)
	              o(t[i]);
	            return o;
	          }
	          return r;
	        }()({
	          1: [
	            function (require, module, exports) {
	              var process = module.exports = {};
	              var cachedSetTimeout;
	              var cachedClearTimeout;
	              function defaultSetTimout() {
	                throw new Error('setTimeout has not been defined');
	              }
	              function defaultClearTimeout() {
	                throw new Error('clearTimeout has not been defined');
	              }
	              (function () {
	                try {
	                  if (typeof setTimeout === 'function') {
	                    cachedSetTimeout = setTimeout;
	                  } else {
	                    cachedSetTimeout = defaultSetTimout;
	                  }
	                } catch (e) {
	                  cachedSetTimeout = defaultSetTimout;
	                }
	                try {
	                  if (typeof clearTimeout === 'function') {
	                    cachedClearTimeout = clearTimeout;
	                  } else {
	                    cachedClearTimeout = defaultClearTimeout;
	                  }
	                } catch (e) {
	                  cachedClearTimeout = defaultClearTimeout;
	                }
	              }());
	              function runTimeout(fun) {
	                if (cachedSetTimeout === setTimeout) {
	                  return setTimeout(fun, 0);
	                }
	                if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	                  cachedSetTimeout = setTimeout;
	                  return setTimeout(fun, 0);
	                }
	                try {
	                  return cachedSetTimeout(fun, 0);
	                } catch (e) {
	                  try {
	                    return cachedSetTimeout.call(null, fun, 0);
	                  } catch (e) {
	                    return cachedSetTimeout.call(this, fun, 0);
	                  }
	                }
	              }
	              function runClearTimeout(marker) {
	                if (cachedClearTimeout === clearTimeout) {
	                  return clearTimeout(marker);
	                }
	                if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	                  cachedClearTimeout = clearTimeout;
	                  return clearTimeout(marker);
	                }
	                try {
	                  return cachedClearTimeout(marker);
	                } catch (e) {
	                  try {
	                    return cachedClearTimeout.call(null, marker);
	                  } catch (e) {
	                    return cachedClearTimeout.call(this, marker);
	                  }
	                }
	              }
	              var queue = [];
	              var draining = false;
	              var currentQueue;
	              var queueIndex = -1;
	              function cleanUpNextTick() {
	                if (!draining || !currentQueue) {
	                  return;
	                }
	                draining = false;
	                if (currentQueue.length) {
	                  queue = currentQueue.concat(queue);
	                } else {
	                  queueIndex = -1;
	                }
	                if (queue.length) {
	                  drainQueue();
	                }
	              }
	              function drainQueue() {
	                if (draining) {
	                  return;
	                }
	                var timeout = runTimeout(cleanUpNextTick);
	                draining = true;
	                var len = queue.length;
	                while (len) {
	                  currentQueue = queue;
	                  queue = [];
	                  while (++queueIndex < len) {
	                    if (currentQueue) {
	                      currentQueue[queueIndex].run();
	                    }
	                  }
	                  queueIndex = -1;
	                  len = queue.length;
	                }
	                currentQueue = null;
	                draining = false;
	                runClearTimeout(timeout);
	              }
	              process.nextTick = function (fun) {
	                var args = new Array(arguments.length - 1);
	                if (arguments.length > 1) {
	                  for (var i = 1; i < arguments.length; i++) {
	                    args[i - 1] = arguments[i];
	                  }
	                }
	                queue.push(new Item(fun, args));
	                if (queue.length === 1 && !draining) {
	                  runTimeout(drainQueue);
	                }
	              };
	              function Item(fun, array) {
	                this.fun = fun;
	                this.array = array;
	              }
	              Item.prototype.run = function () {
	                this.fun.apply(null, this.array);
	              };
	              process.title = 'browser';
	              process.browser = true;
	              process.env = {};
	              process.argv = [];
	              process.version = '';
	              process.versions = {};
	              function noop() {
	              }
	              process.on = noop;
	              process.addListener = noop;
	              process.once = noop;
	              process.off = noop;
	              process.removeListener = noop;
	              process.removeAllListeners = noop;
	              process.emit = noop;
	              process.prependListener = noop;
	              process.prependOnceListener = noop;
	              process.listeners = function (name) {
	                return [];
	              };
	              process.binding = function (name) {
	                throw new Error('process.binding is not supported');
	              };
	              process.cwd = function () {
	                return '/';
	              };
	              process.chdir = function (dir) {
	                throw new Error('process.chdir is not supported');
	              };
	              process.umask = function () {
	                return 0;
	              };
	            },
	            {}
	          ],
	          2: [
	            function (require, module, exports) {
	              (function (setImmediate) {
	                (function (root) {
	                  var setTimeoutFunc = setTimeout;
	                  function noop() {
	                  }
	                  function bind(fn, thisArg) {
	                    return function () {
	                      fn.apply(thisArg, arguments);
	                    };
	                  }
	                  function Promise(fn) {
	                    if (typeof this !== 'object')
	                      throw new TypeError('Promises must be constructed via new');
	                    if (typeof fn !== 'function')
	                      throw new TypeError('not a function');
	                    this._state = 0;
	                    this._handled = false;
	                    this._value = undefined;
	                    this._deferreds = [];
	                    doResolve(fn, this);
	                  }
	                  function handle(self, deferred) {
	                    while (self._state === 3) {
	                      self = self._value;
	                    }
	                    if (self._state === 0) {
	                      self._deferreds.push(deferred);
	                      return;
	                    }
	                    self._handled = true;
	                    Promise._immediateFn(function () {
	                      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
	                      if (cb === null) {
	                        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
	                        return;
	                      }
	                      var ret;
	                      try {
	                        ret = cb(self._value);
	                      } catch (e) {
	                        reject(deferred.promise, e);
	                        return;
	                      }
	                      resolve(deferred.promise, ret);
	                    });
	                  }
	                  function resolve(self, newValue) {
	                    try {
	                      if (newValue === self)
	                        throw new TypeError('A promise cannot be resolved with itself.');
	                      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
	                        var then = newValue.then;
	                        if (newValue instanceof Promise) {
	                          self._state = 3;
	                          self._value = newValue;
	                          finale(self);
	                          return;
	                        } else if (typeof then === 'function') {
	                          doResolve(bind(then, newValue), self);
	                          return;
	                        }
	                      }
	                      self._state = 1;
	                      self._value = newValue;
	                      finale(self);
	                    } catch (e) {
	                      reject(self, e);
	                    }
	                  }
	                  function reject(self, newValue) {
	                    self._state = 2;
	                    self._value = newValue;
	                    finale(self);
	                  }
	                  function finale(self) {
	                    if (self._state === 2 && self._deferreds.length === 0) {
	                      Promise._immediateFn(function () {
	                        if (!self._handled) {
	                          Promise._unhandledRejectionFn(self._value);
	                        }
	                      });
	                    }
	                    for (var i = 0, len = self._deferreds.length; i < len; i++) {
	                      handle(self, self._deferreds[i]);
	                    }
	                    self._deferreds = null;
	                  }
	                  function Handler(onFulfilled, onRejected, promise) {
	                    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
	                    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
	                    this.promise = promise;
	                  }
	                  function doResolve(fn, self) {
	                    var done = false;
	                    try {
	                      fn(function (value) {
	                        if (done)
	                          return;
	                        done = true;
	                        resolve(self, value);
	                      }, function (reason) {
	                        if (done)
	                          return;
	                        done = true;
	                        reject(self, reason);
	                      });
	                    } catch (ex) {
	                      if (done)
	                        return;
	                      done = true;
	                      reject(self, ex);
	                    }
	                  }
	                  Promise.prototype['catch'] = function (onRejected) {
	                    return this.then(null, onRejected);
	                  };
	                  Promise.prototype.then = function (onFulfilled, onRejected) {
	                    var prom = new this.constructor(noop);
	                    handle(this, new Handler(onFulfilled, onRejected, prom));
	                    return prom;
	                  };
	                  Promise.all = function (arr) {
	                    var args = Array.prototype.slice.call(arr);
	                    return new Promise(function (resolve, reject) {
	                      if (args.length === 0)
	                        return resolve([]);
	                      var remaining = args.length;
	                      function res(i, val) {
	                        try {
	                          if (val && (typeof val === 'object' || typeof val === 'function')) {
	                            var then = val.then;
	                            if (typeof then === 'function') {
	                              then.call(val, function (val) {
	                                res(i, val);
	                              }, reject);
	                              return;
	                            }
	                          }
	                          args[i] = val;
	                          if (--remaining === 0) {
	                            resolve(args);
	                          }
	                        } catch (ex) {
	                          reject(ex);
	                        }
	                      }
	                      for (var i = 0; i < args.length; i++) {
	                        res(i, args[i]);
	                      }
	                    });
	                  };
	                  Promise.resolve = function (value) {
	                    if (value && typeof value === 'object' && value.constructor === Promise) {
	                      return value;
	                    }
	                    return new Promise(function (resolve) {
	                      resolve(value);
	                    });
	                  };
	                  Promise.reject = function (value) {
	                    return new Promise(function (resolve, reject) {
	                      reject(value);
	                    });
	                  };
	                  Promise.race = function (values) {
	                    return new Promise(function (resolve, reject) {
	                      for (var i = 0, len = values.length; i < len; i++) {
	                        values[i].then(resolve, reject);
	                      }
	                    });
	                  };
	                  Promise._immediateFn = typeof setImmediate === 'function' ? function (fn) {
	                    setImmediate(fn);
	                  } : function (fn) {
	                    setTimeoutFunc(fn, 0);
	                  };
	                  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
	                    if (typeof console !== 'undefined' && console) {
	                      console.warn('Possible Unhandled Promise Rejection:', err);
	                    }
	                  };
	                  Promise._setImmediateFn = function _setImmediateFn(fn) {
	                    Promise._immediateFn = fn;
	                  };
	                  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
	                    Promise._unhandledRejectionFn = fn;
	                  };
	                  if (typeof module !== 'undefined' && module.exports) {
	                    module.exports = Promise;
	                  } else if (!root.Promise) {
	                    root.Promise = Promise;
	                  }
	                }(this));
	              }.call(this, require('timers').setImmediate));
	            },
	            { 'timers': 3 }
	          ],
	          3: [
	            function (require, module, exports) {
	              (function (setImmediate, clearImmediate) {
	                var nextTick = require('process/browser.js').nextTick;
	                var apply = Function.prototype.apply;
	                var slice = Array.prototype.slice;
	                var immediateIds = {};
	                var nextImmediateId = 0;
	                exports.setTimeout = function () {
	                  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	                };
	                exports.setInterval = function () {
	                  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	                };
	                exports.clearTimeout = exports.clearInterval = function (timeout) {
	                  timeout.close();
	                };
	                function Timeout(id, clearFn) {
	                  this._id = id;
	                  this._clearFn = clearFn;
	                }
	                Timeout.prototype.unref = Timeout.prototype.ref = function () {
	                };
	                Timeout.prototype.close = function () {
	                  this._clearFn.call(window, this._id);
	                };
	                exports.enroll = function (item, msecs) {
	                  clearTimeout(item._idleTimeoutId);
	                  item._idleTimeout = msecs;
	                };
	                exports.unenroll = function (item) {
	                  clearTimeout(item._idleTimeoutId);
	                  item._idleTimeout = -1;
	                };
	                exports._unrefActive = exports.active = function (item) {
	                  clearTimeout(item._idleTimeoutId);
	                  var msecs = item._idleTimeout;
	                  if (msecs >= 0) {
	                    item._idleTimeoutId = setTimeout(function onTimeout() {
	                      if (item._onTimeout)
	                        item._onTimeout();
	                    }, msecs);
	                  }
	                };
	                exports.setImmediate = typeof setImmediate === 'function' ? setImmediate : function (fn) {
	                  var id = nextImmediateId++;
	                  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
	                  immediateIds[id] = true;
	                  nextTick(function onNextTick() {
	                    if (immediateIds[id]) {
	                      if (args) {
	                        fn.apply(null, args);
	                      } else {
	                        fn.call(null);
	                      }
	                      exports.clearImmediate(id);
	                    }
	                  });
	                  return id;
	                };
	                exports.clearImmediate = typeof clearImmediate === 'function' ? clearImmediate : function (id) {
	                  delete immediateIds[id];
	                };
	              }.call(this, require('timers').setImmediate, require('timers').clearImmediate));
	            },
	            {
	              'process/browser.js': 1,
	              'timers': 3
	            }
	          ],
	          4: [
	            function (require, module, exports) {
	              var promisePolyfill = require('promise-polyfill');
	              var Global = function () {
	                if (typeof window !== 'undefined') {
	                  return window;
	                } else {
	                  return Function('return this;')();
	                }
	              }();
	              module.exports = { boltExport: Global.Promise || promisePolyfill };
	            },
	            { 'promise-polyfill': 2 }
	          ]
	        }, {}, [4])(4);
	      }));
	    }(undefined, exports$1, module$1, undefined));
	    var Promise = module$1.exports.boltExport;
	
	    var nu$3 = function (baseFn) {
	      var data = Option.none();
	      var callbacks = [];
	      var map = function (f) {
	        return nu$3(function (nCallback) {
	          get(function (data) {
	            nCallback(f(data));
	          });
	        });
	      };
	      var get = function (nCallback) {
	        if (isReady()) {
	          call(nCallback);
	        } else {
	          callbacks.push(nCallback);
	        }
	      };
	      var set = function (x) {
	        data = Option.some(x);
	        run(callbacks);
	        callbacks = [];
	      };
	      var isReady = function () {
	        return data.isSome();
	      };
	      var run = function (cbs) {
	        each(cbs, call);
	      };
	      var call = function (cb) {
	        data.each(function (x) {
	          domGlobals.setTimeout(function () {
	            cb(x);
	          }, 0);
	        });
	      };
	      baseFn(set);
	      return {
	        get: get,
	        map: map,
	        isReady: isReady
	      };
	    };
	    var pure = function (a) {
	      return nu$3(function (callback) {
	        callback(a);
	      });
	    };
	    var LazyValue = {
	      nu: nu$3,
	      pure: pure
	    };
	
	    var errorReporter = function (err) {
	      domGlobals.setTimeout(function () {
	        throw err;
	      }, 0);
	    };
	    var make = function (run) {
	      var get = function (callback) {
	        run().then(callback, errorReporter);
	      };
	      var map = function (fab) {
	        return make(function () {
	          return run().then(fab);
	        });
	      };
	      var bind = function (aFutureB) {
	        return make(function () {
	          return run().then(function (v) {
	            return aFutureB(v).toPromise();
	          });
	        });
	      };
	      var anonBind = function (futureB) {
	        return make(function () {
	          return run().then(function () {
	            return futureB.toPromise();
	          });
	        });
	      };
	      var toLazy = function () {
	        return LazyValue.nu(get);
	      };
	      var toCached = function () {
	        var cache = null;
	        return make(function () {
	          if (cache === null) {
	            cache = run();
	          }
	          return cache;
	        });
	      };
	      var toPromise = run;
	      return {
	        map: map,
	        bind: bind,
	        anonBind: anonBind,
	        toLazy: toLazy,
	        toCached: toCached,
	        toPromise: toPromise,
	        get: get
	      };
	    };
	    var nu$4 = function (baseFn) {
	      return make(function () {
	        return new Promise(baseFn);
	      });
	    };
	    var pure$1 = function (a) {
	      return make(function () {
	        return Promise.resolve(a);
	      });
	    };
	    var Future = {
	      nu: nu$4,
	      pure: pure$1
	    };
	
	    var par = function (asyncValues, nu) {
	      return nu(function (callback) {
	        var r = [];
	        var count = 0;
	        var cb = function (i) {
	          return function (value) {
	            r[i] = value;
	            count++;
	            if (count >= asyncValues.length) {
	              callback(r);
	            }
	          };
	        };
	        if (asyncValues.length === 0) {
	          callback([]);
	        } else {
	          each(asyncValues, function (asyncValue, i) {
	            asyncValue.get(cb(i));
	          });
	        }
	      });
	    };
	
	    var par$1 = function (futures) {
	      return par(futures, Future.nu);
	    };
	
	    var value = function (o) {
	      var is = function (v) {
	        return o === v;
	      };
	      var or = function (opt) {
	        return value(o);
	      };
	      var orThunk = function (f) {
	        return value(o);
	      };
	      var map = function (f) {
	        return value(f(o));
	      };
	      var mapError = function (f) {
	        return value(o);
	      };
	      var each = function (f) {
	        f(o);
	      };
	      var bind = function (f) {
	        return f(o);
	      };
	      var fold = function (_, onValue) {
	        return onValue(o);
	      };
	      var exists = function (f) {
	        return f(o);
	      };
	      var forall = function (f) {
	        return f(o);
	      };
	      var toOption = function () {
	        return Option.some(o);
	      };
	      return {
	        is: is,
	        isValue: always,
	        isError: never,
	        getOr: constant(o),
	        getOrThunk: constant(o),
	        getOrDie: constant(o),
	        or: or,
	        orThunk: orThunk,
	        fold: fold,
	        map: map,
	        mapError: mapError,
	        each: each,
	        bind: bind,
	        exists: exists,
	        forall: forall,
	        toOption: toOption
	      };
	    };
	    var error = function (message) {
	      var getOrThunk = function (f) {
	        return f();
	      };
	      var getOrDie = function () {
	        return die(String(message))();
	      };
	      var or = function (opt) {
	        return opt;
	      };
	      var orThunk = function (f) {
	        return f();
	      };
	      var map = function (f) {
	        return error(message);
	      };
	      var mapError = function (f) {
	        return error(f(message));
	      };
	      var bind = function (f) {
	        return error(message);
	      };
	      var fold = function (onError, _) {
	        return onError(message);
	      };
	      return {
	        is: never,
	        isValue: never,
	        isError: always,
	        getOr: identity,
	        getOrThunk: getOrThunk,
	        getOrDie: getOrDie,
	        or: or,
	        orThunk: orThunk,
	        fold: fold,
	        map: map,
	        mapError: mapError,
	        each: noop,
	        bind: bind,
	        exists: never,
	        forall: always,
	        toOption: Option.none
	      };
	    };
	    var fromOption = function (opt, err) {
	      return opt.fold(function () {
	        return error(err);
	      }, value);
	    };
	    var Result = {
	      value: value,
	      error: error,
	      fromOption: fromOption
	    };
	
	    var promise = function () {
	      function bind(fn, thisArg) {
	        return function () {
	          fn.apply(thisArg, arguments);
	        };
	      }
	      var isArray = Array.isArray || function (value) {
	        return Object.prototype.toString.call(value) === '[object Array]';
	      };
	      var Promise = function (fn) {
	        if (typeof this !== 'object') {
	          throw new TypeError('Promises must be constructed via new');
	        }
	        if (typeof fn !== 'function') {
	          throw new TypeError('not a function');
	        }
	        this._state = null;
	        this._value = null;
	        this._deferreds = [];
	        doResolve(fn, bind(resolve, this), bind(reject, this));
	      };
	      var asap = Promise.immediateFn || typeof domGlobals.setImmediate === 'function' && domGlobals.setImmediate || function (fn) {
	        domGlobals.setTimeout(fn, 1);
	      };
	      function handle(deferred) {
	        var me = this;
	        if (this._state === null) {
	          this._deferreds.push(deferred);
	          return;
	        }
	        asap(function () {
	          var cb = me._state ? deferred.onFulfilled : deferred.onRejected;
	          if (cb === null) {
	            (me._state ? deferred.resolve : deferred.reject)(me._value);
	            return;
	          }
	          var ret;
	          try {
	            ret = cb(me._value);
	          } catch (e) {
	            deferred.reject(e);
	            return;
	          }
	          deferred.resolve(ret);
	        });
	      }
	      function resolve(newValue) {
	        try {
	          if (newValue === this) {
	            throw new TypeError('A promise cannot be resolved with itself.');
	          }
	          if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
	            var then = newValue.then;
	            if (typeof then === 'function') {
	              doResolve(bind(then, newValue), bind(resolve, this), bind(reject, this));
	              return;
	            }
	          }
	          this._state = true;
	          this._value = newValue;
	          finale.call(this);
	        } catch (e) {
	          reject.call(this, e);
	        }
	      }
	      function reject(newValue) {
	        this._state = false;
	        this._value = newValue;
	        finale.call(this);
	      }
	      function finale() {
	        for (var i = 0, len = this._deferreds.length; i < len; i++) {
	          handle.call(this, this._deferreds[i]);
	        }
	        this._deferreds = null;
	      }
	      function Handler(onFulfilled, onRejected, resolve, reject) {
	        this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
	        this.onRejected = typeof onRejected === 'function' ? onRejected : null;
	        this.resolve = resolve;
	        this.reject = reject;
	      }
	      function doResolve(fn, onFulfilled, onRejected) {
	        var done = false;
	        try {
	          fn(function (value) {
	            if (done) {
	              return;
	            }
	            done = true;
	            onFulfilled(value);
	          }, function (reason) {
	            if (done) {
	              return;
	            }
	            done = true;
	            onRejected(reason);
	          });
	        } catch (ex) {
	          if (done) {
	            return;
	          }
	          done = true;
	          onRejected(ex);
	        }
	      }
	      Promise.prototype.catch = function (onRejected) {
	        return this.then(null, onRejected);
	      };
	      Promise.prototype.then = function (onFulfilled, onRejected) {
	        var me = this;
	        return new Promise(function (resolve, reject) {
	          handle.call(me, new Handler(onFulfilled, onRejected, resolve, reject));
	        });
	      };
	      Promise.all = function () {
	        var args = Array.prototype.slice.call(arguments.length === 1 && isArray(arguments[0]) ? arguments[0] : arguments);
	        return new Promise(function (resolve, reject) {
	          if (args.length === 0) {
	            return resolve([]);
	          }
	          var remaining = args.length;
	          function res(i, val) {
	            try {
	              if (val && (typeof val === 'object' || typeof val === 'function')) {
	                var then = val.then;
	                if (typeof then === 'function') {
	                  then.call(val, function (val) {
	                    res(i, val);
	                  }, reject);
	                  return;
	                }
	              }
	              args[i] = val;
	              if (--remaining === 0) {
	                resolve(args);
	              }
	            } catch (ex) {
	              reject(ex);
	            }
	          }
	          for (var i = 0; i < args.length; i++) {
	            res(i, args[i]);
	          }
	        });
	      };
	      Promise.resolve = function (value) {
	        if (value && typeof value === 'object' && value.constructor === Promise) {
	          return value;
	        }
	        return new Promise(function (resolve) {
	          resolve(value);
	        });
	      };
	      Promise.reject = function (value) {
	        return new Promise(function (resolve, reject) {
	          reject(value);
	        });
	      };
	      Promise.race = function (values) {
	        return new Promise(function (resolve, reject) {
	          for (var i = 0, len = values.length; i < len; i++) {
	            values[i].then(resolve, reject);
	          }
	        });
	      };
	      return Promise;
	    };
	    var promiseObj = window.Promise ? window.Promise : promise();
	
	    var requestAnimationFramePromise;
	    var requestAnimationFrame = function (callback, element) {
	      var i, requestAnimationFrameFunc = domGlobals.window.requestAnimationFrame;
	      var vendors = [
	        'ms',
	        'moz',
	        'webkit'
	      ];
	      var featurefill = function (callback) {
	        domGlobals.window.setTimeout(callback, 0);
	      };
	      for (i = 0; i < vendors.length && !requestAnimationFrameFunc; i++) {
	        requestAnimationFrameFunc = domGlobals.window[vendors[i] + 'RequestAnimationFrame'];
	      }
	      if (!requestAnimationFrameFunc) {
	        requestAnimationFrameFunc = featurefill;
	      }
	      requestAnimationFrameFunc(callback, element);
	    };
	    var wrappedSetTimeout = function (callback, time) {
	      if (typeof time !== 'number') {
	        time = 0;
	      }
	      return domGlobals.setTimeout(callback, time);
	    };
	    var wrappedSetInterval = function (callback, time) {
	      if (typeof time !== 'number') {
	        time = 1;
	      }
	      return domGlobals.setInterval(callback, time);
	    };
	    var wrappedClearTimeout = function (id) {
	      return domGlobals.clearTimeout(id);
	    };
	    var wrappedClearInterval = function (id) {
	      return domGlobals.clearInterval(id);
	    };
	    var debounce = function (callback, time) {
	      var timer, func;
	      func = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	          args[_i] = arguments[_i];
	        }
	        domGlobals.clearTimeout(timer);
	        timer = wrappedSetTimeout(function () {
	          callback.apply(this, args);
	        }, time);
	      };
	      func.stop = function () {
	        domGlobals.clearTimeout(timer);
	      };
	      return func;
	    };
	    var Delay = {
	      requestAnimationFrame: function (callback, element) {
	        if (requestAnimationFramePromise) {
	          requestAnimationFramePromise.then(callback);
	          return;
	        }
	        requestAnimationFramePromise = new promiseObj(function (resolve) {
	          if (!element) {
	            element = domGlobals.document.body;
	          }
	          requestAnimationFrame(resolve, element);
	        }).then(callback);
	      },
	      setTimeout: wrappedSetTimeout,
	      setInterval: wrappedSetInterval,
	      setEditorTimeout: function (editor, callback, time) {
	        return wrappedSetTimeout(function () {
	          if (!editor.removed) {
	            callback();
	          }
	        }, time);
	      },
	      setEditorInterval: function (editor, callback, time) {
	        var timer;
	        timer = wrappedSetInterval(function () {
	          if (!editor.removed) {
	            callback();
	          } else {
	            domGlobals.clearInterval(timer);
	          }
	        }, time);
	        return timer;
	      },
	      debounce: debounce,
	      throttle: debounce,
	      clearInterval: wrappedClearInterval,
	      clearTimeout: wrappedClearTimeout
	    };
	
	    var userAgent = domGlobals.navigator.userAgent;
	    var platform$1 = detect$3();
	    var browser$2 = platform$1.browser;
	    var os = platform$1.os;
	    var deviceType = platform$1.deviceType;
	    var webkit = /WebKit/.test(userAgent) && !browser$2.isEdge();
	    var fileApi = 'FormData' in domGlobals.window && 'FileReader' in domGlobals.window && 'URL' in domGlobals.window && !!domGlobals.URL.createObjectURL;
	    var windowsPhone = userAgent.indexOf('Windows Phone') !== -1;
	    var Env = {
	      opera: browser$2.isOpera(),
	      webkit: webkit,
	      ie: browser$2.isIE() || browser$2.isEdge() ? browser$2.version.major : false,
	      gecko: browser$2.isFirefox(),
	      mac: os.isOSX() || os.isiOS(),
	      iOS: deviceType.isiPad() || deviceType.isiPhone(),
	      android: os.isAndroid(),
	      contentEditable: true,
	      transparentSrc: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
	      caretAfter: true,
	      range: domGlobals.window.getSelection && 'Range' in domGlobals.window,
	      documentMode: browser$2.isIE() ? domGlobals.document.documentMode || 7 : 10,
	      fileApi: fileApi,
	      ceFalse: true,
	      cacheSuffix: null,
	      container: null,
	      experimentalShadowDom: false,
	      canHaveCSP: !browser$2.isIE(),
	      desktop: deviceType.isDesktop(),
	      windowsPhone: windowsPhone,
	      browser: {
	        current: browser$2.current,
	        version: browser$2.version,
	        isChrome: browser$2.isChrome,
	        isEdge: browser$2.isEdge,
	        isFirefox: browser$2.isFirefox,
	        isIE: browser$2.isIE,
	        isOpera: browser$2.isOpera,
	        isSafari: browser$2.isSafari
	      },
	      os: {
	        current: os.current,
	        version: os.version,
	        isAndroid: os.isAndroid,
	        isChromeOS: os.isChromeOS,
	        isFreeBSD: os.isFreeBSD,
	        isiOS: os.isiOS,
	        isLinux: os.isLinux,
	        isOSX: os.isOSX,
	        isSolaris: os.isSolaris,
	        isWindows: os.isWindows
	      },
	      deviceType: {
	        isDesktop: deviceType.isDesktop,
	        isiPad: deviceType.isiPad,
	        isiPhone: deviceType.isiPhone,
	        isPhone: deviceType.isPhone,
	        isTablet: deviceType.isTablet,
	        isTouch: deviceType.isTouch,
	        isWebView: deviceType.isWebView
	      }
	    };
	
	    var isArray$1 = Array.isArray;
	    var toArray$1 = function (obj) {
	      var array = obj, i, l;
	      if (!isArray$1(obj)) {
	        array = [];
	        for (i = 0, l = obj.length; i < l; i++) {
	          array[i] = obj[i];
	        }
	      }
	      return array;
	    };
	    var each$2 = function (o, cb, s) {
	      var n, l;
	      if (!o) {
	        return 0;
	      }
	      s = s || o;
	      if (o.length !== undefined) {
	        for (n = 0, l = o.length; n < l; n++) {
	          if (cb.call(s, o[n], n, o) === false) {
	            return 0;
	          }
	        }
	      } else {
	        for (n in o) {
	          if (o.hasOwnProperty(n)) {
	            if (cb.call(s, o[n], n, o) === false) {
	              return 0;
	            }
	          }
	        }
	      }
	      return 1;
	    };
	    var map$2 = function (array, callback) {
	      var out = [];
	      each$2(array, function (item, index) {
	        out.push(callback(item, index, array));
	      });
	      return out;
	    };
	    var filter$2 = function (a, f) {
	      var o = [];
	      each$2(a, function (v, index) {
	        if (!f || f(v, index, a)) {
	          o.push(v);
	        }
	      });
	      return o;
	    };
	    var indexOf$1 = function (a, v) {
	      var i, l;
	      if (a) {
	        for (i = 0, l = a.length; i < l; i++) {
	          if (a[i] === v) {
	            return i;
	          }
	        }
	      }
	      return -1;
	    };
	    var reduce = function (collection, iteratee, accumulator, thisArg) {
	      var i = 0;
	      if (arguments.length < 3) {
	        accumulator = collection[0];
	      }
	      for (; i < collection.length; i++) {
	        accumulator = iteratee.call(thisArg, accumulator, collection[i], i);
	      }
	      return accumulator;
	    };
	    var findIndex$1 = function (array, predicate, thisArg) {
	      var i, l;
	      for (i = 0, l = array.length; i < l; i++) {
	        if (predicate.call(thisArg, array[i], i, array)) {
	          return i;
	        }
	      }
	      return -1;
	    };
	    var find$2 = function (array, predicate, thisArg) {
	      var idx = findIndex$1(array, predicate, thisArg);
	      if (idx !== -1) {
	        return array[idx];
	      }
	      return undefined;
	    };
	    var last$1 = function (collection) {
	      return collection[collection.length - 1];
	    };
	    var ArrUtils = {
	      isArray: isArray$1,
	      toArray: toArray$1,
	      each: each$2,
	      map: map$2,
	      filter: filter$2,
	      indexOf: indexOf$1,
	      reduce: reduce,
	      findIndex: findIndex$1,
	      find: find$2,
	      last: last$1
	    };
	
	    var whiteSpaceRegExp = /^\s*|\s*$/g;
	    var trim$1 = function (str) {
	      return str === null || str === undefined ? '' : ('' + str).replace(whiteSpaceRegExp, '');
	    };
	    var is$1 = function (obj, type) {
	      if (!type) {
	        return obj !== undefined;
	      }
	      if (type === 'array' && ArrUtils.isArray(obj)) {
	        return true;
	      }
	      return typeof obj === type;
	    };
	    var makeMap = function (items, delim, map) {
	      var i;
	      items = items || [];
	      delim = delim || ',';
	      if (typeof items === 'string') {
	        items = items.split(delim);
	      }
	      map = map || {};
	      i = items.length;
	      while (i--) {
	        map[items[i]] = {};
	      }
	      return map;
	    };
	    var hasOwnProperty$1 = function (obj, prop) {
	      return Object.prototype.hasOwnProperty.call(obj, prop);
	    };
	    var create = function (s, p, root) {
	      var self = this;
	      var sp, ns, cn, scn, c, de = 0;
	      s = /^((static) )?([\w.]+)(:([\w.]+))?/.exec(s);
	      cn = s[3].match(/(^|\.)(\w+)$/i)[2];
	      ns = self.createNS(s[3].replace(/\.\w+$/, ''), root);
	      if (ns[cn]) {
	        return;
	      }
	      if (s[2] === 'static') {
	        ns[cn] = p;
	        if (this.onCreate) {
	          this.onCreate(s[2], s[3], ns[cn]);
	        }
	        return;
	      }
	      if (!p[cn]) {
	        p[cn] = function () {
	        };
	        de = 1;
	      }
	      ns[cn] = p[cn];
	      self.extend(ns[cn].prototype, p);
	      if (s[5]) {
	        sp = self.resolve(s[5]).prototype;
	        scn = s[5].match(/\.(\w+)$/i)[1];
	        c = ns[cn];
	        if (de) {
	          ns[cn] = function () {
	            return sp[scn].apply(this, arguments);
	          };
	        } else {
	          ns[cn] = function () {
	            this.parent = sp[scn];
	            return c.apply(this, arguments);
	          };
	        }
	        ns[cn].prototype[cn] = ns[cn];
	        self.each(sp, function (f, n) {
	          ns[cn].prototype[n] = sp[n];
	        });
	        self.each(p, function (f, n) {
	          if (sp[n]) {
	            ns[cn].prototype[n] = function () {
	              this.parent = sp[n];
	              return f.apply(this, arguments);
	            };
	          } else {
	            if (n !== cn) {
	              ns[cn].prototype[n] = f;
	            }
	          }
	        });
	      }
	      self.each(p.static, function (f, n) {
	        ns[cn][n] = f;
	      });
	    };
	    var extend = function (obj, ext) {
	      var x = [];
	      for (var _i = 2; _i < arguments.length; _i++) {
	        x[_i - 2] = arguments[_i];
	      }
	      var i, l, name;
	      var args = arguments;
	      var value;
	      for (i = 1, l = args.length; i < l; i++) {
	        ext = args[i];
	        for (name in ext) {
	          if (ext.hasOwnProperty(name)) {
	            value = ext[name];
	            if (value !== undefined) {
	              obj[name] = value;
	            }
	          }
	        }
	      }
	      return obj;
	    };
	    var walk = function (o, f, n, s) {
	      s = s || this;
	      if (o) {
	        if (n) {
	          o = o[n];
	        }
	        ArrUtils.each(o, function (o, i) {
	          if (f.call(s, o, i, n) === false) {
	            return false;
	          }
	          walk(o, f, n, s);
	        });
	      }
	    };
	    var createNS = function (n, o) {
	      var i, v;
	      o = o || domGlobals.window;
	      n = n.split('.');
	      for (i = 0; i < n.length; i++) {
	        v = n[i];
	        if (!o[v]) {
	          o[v] = {};
	        }
	        o = o[v];
	      }
	      return o;
	    };
	    var resolve = function (n, o) {
	      var i, l;
	      o = o || domGlobals.window;
	      n = n.split('.');
	      for (i = 0, l = n.length; i < l; i++) {
	        o = o[n[i]];
	        if (!o) {
	          break;
	        }
	      }
	      return o;
	    };
	    var explode = function (s, d) {
	      if (!s || is$1(s, 'array')) {
	        return s;
	      }
	      return ArrUtils.map(s.split(d || ','), trim$1);
	    };
	    var _addCacheSuffix = function (url) {
	      var cacheSuffix = Env.cacheSuffix;
	      if (cacheSuffix) {
	        url += (url.indexOf('?') === -1 ? '?' : '&') + cacheSuffix;
	      }
	      return url;
	    };
	    var Tools = {
	      trim: trim$1,
	      isArray: ArrUtils.isArray,
	      is: is$1,
	      toArray: ArrUtils.toArray,
	      makeMap: makeMap,
	      each: ArrUtils.each,
	      map: ArrUtils.map,
	      grep: ArrUtils.filter,
	      inArray: ArrUtils.indexOf,
	      hasOwn: hasOwnProperty$1,
	      extend: extend,
	      create: create,
	      walk: walk,
	      createNS: createNS,
	      resolve: resolve,
	      explode: explode,
	      _addCacheSuffix: _addCacheSuffix
	    };
	
	    function StyleSheetLoader(document, settings) {
	      if (settings === void 0) {
	        settings = {};
	      }
	      var idCount = 0;
	      var loadedStates = {};
	      var maxLoadTime;
	      maxLoadTime = settings.maxLoadTime || 5000;
	      var _setReferrerPolicy = function (referrerPolicy) {
	        settings.referrerPolicy = referrerPolicy;
	      };
	      var appendToHead = function (node) {
	        document.getElementsByTagName('head')[0].appendChild(node);
	      };
	      var load = function (url, loadedCallback, errorCallback) {
	        var link, style, startTime, state;
	        var resolve = function (status) {
	          state.status = status;
	          state.passed = [];
	          state.failed = [];
	          if (link) {
	            link.onload = null;
	            link.onerror = null;
	            link = null;
	          }
	        };
	        var passed = function () {
	          var callbacks = state.passed;
	          var i = callbacks.length;
	          while (i--) {
	            callbacks[i]();
	          }
	          resolve(2);
	        };
	        var failed = function () {
	          var callbacks = state.failed;
	          var i = callbacks.length;
	          while (i--) {
	            callbacks[i]();
	          }
	          resolve(3);
	        };
	        var isOldWebKit = function () {
	          var webKitChunks = domGlobals.navigator.userAgent.match(/WebKit\/(\d*)/);
	          return !!(webKitChunks && parseInt(webKitChunks[1], 10) < 536);
	        };
	        var wait = function (testCallback, waitCallback) {
	          if (!testCallback()) {
	            if (new Date().getTime() - startTime < maxLoadTime) {
	              Delay.setTimeout(waitCallback);
	            } else {
	              failed();
	            }
	          }
	        };
	        var waitForWebKitLinkLoaded = function () {
	          wait(function () {
	            var styleSheets = document.styleSheets;
	            var styleSheet, i = styleSheets.length, owner;
	            while (i--) {
	              styleSheet = styleSheets[i];
	              owner = styleSheet.ownerNode ? styleSheet.ownerNode : styleSheet.owningElement;
	              if (owner && owner.id === link.id) {
	                passed();
	                return true;
	              }
	            }
	          }, waitForWebKitLinkLoaded);
	        };
	        var waitForGeckoLinkLoaded = function () {
	          wait(function () {
	            try {
	              var cssRules = style.sheet.cssRules;
	              passed();
	              return !!cssRules;
	            } catch (ex) {
	            }
	          }, waitForGeckoLinkLoaded);
	        };
	        url = Tools._addCacheSuffix(url);
	        if (!loadedStates[url]) {
	          state = {
	            passed: [],
	            failed: []
	          };
	          loadedStates[url] = state;
	        } else {
	          state = loadedStates[url];
	        }
	        if (loadedCallback) {
	          state.passed.push(loadedCallback);
	        }
	        if (errorCallback) {
	          state.failed.push(errorCallback);
	        }
	        if (state.status === 1) {
	          return;
	        }
	        if (state.status === 2) {
	          passed();
	          return;
	        }
	        if (state.status === 3) {
	          failed();
	          return;
	        }
	        state.status = 1;
	        link = document.createElement('link');
	        link.rel = 'stylesheet';
	        link.type = 'text/css';
	        link.id = 'u' + idCount++;
	        link.async = false;
	        link.defer = false;
	        startTime = new Date().getTime();
	        if (settings.contentCssCors) {
	          link.crossOrigin = 'anonymous';
	        }
	        if (settings.referrerPolicy) {
	          set(Element.fromDom(link), 'referrerpolicy', settings.referrerPolicy);
	        }
	        if ('onload' in link && !isOldWebKit()) {
	          link.onload = waitForWebKitLinkLoaded;
	          link.onerror = failed;
	        } else {
	          if (domGlobals.navigator.userAgent.indexOf('Firefox') > 0) {
	            style = document.createElement('style');
	            style.textContent = '@import "' + url + '"';
	            waitForGeckoLinkLoaded();
	            appendToHead(style);
	            return;
	          }
	          waitForWebKitLinkLoaded();
	        }
	        appendToHead(link);
	        link.href = url;
	      };
	      var loadF = function (url) {
	        return Future.nu(function (resolve) {
	          load(url, compose(resolve, constant(Result.value(url))), compose(resolve, constant(Result.error(url))));
	        });
	      };
	      var unbox = function (result) {
	        return result.fold(identity, identity);
	      };
	      var loadAll = function (urls, success, failure) {
	        par$1(map(urls, loadF)).get(function (result) {
	          var parts = partition(result, function (r) {
	            return r.isValue();
	          });
	          if (parts.fail.length > 0) {
	            failure(parts.fail.map(unbox));
	          } else {
	            success(parts.pass.map(unbox));
	          }
	        });
	      };
	      return {
	        load: load,
	        loadAll: loadAll,
	        _setReferrerPolicy: _setReferrerPolicy
	      };
	    }
	
	    var blocks = [
	      'article',
	      'aside',
	      'details',
	      'div',
	      'dt',
	      'figcaption',
	      'footer',
	      'form',
	      'fieldset',
	      'header',
	      'hgroup',
	      'html',
	      'main',
	      'nav',
	      'section',
	      'summary',
	      'body',
	      'p',
	      'dl',
	      'multicol',
	      'dd',
	      'figure',
	      'address',
	      'center',
	      'blockquote',
	      'h1',
	      'h2',
	      'h3',
	      'h4',
	      'h5',
	      'h6',
	      'listing',
	      'xmp',
	      'pre',
	      'plaintext',
	      'menu',
	      'dir',
	      'ul',
	      'ol',
	      'li',
	      'hr',
	      'table',
	      'tbody',
	      'thead',
	      'tfoot',
	      'th',
	      'tr',
	      'td',
	      'caption'
	    ];
	    var voids = [
	      'area',
	      'base',
	      'basefont',
	      'br',
	      'col',
	      'frame',
	      'hr',
	      'img',
	      'input',
	      'isindex',
	      'link',
	      'meta',
	      'param',
	      'embed',
	      'source',
	      'wbr',
	      'track'
	    ];
	    var tableCells = [
	      'td',
	      'th'
	    ];
	    var tableSections = [
	      'thead',
	      'tbody',
	      'tfoot'
	    ];
	    var textBlocks = [
	      'h1',
	      'h2',
	      'h3',
	      'h4',
	      'h5',
	      'h6',
	      'p',
	      'div',
	      'address',
	      'pre',
	      'form',
	      'blockquote',
	      'center',
	      'dir',
	      'fieldset',
	      'header',
	      'footer',
	      'article',
	      'section',
	      'hgroup',
	      'aside',
	      'nav',
	      'figure'
	    ];
	    var headings = [
	      'h1',
	      'h2',
	      'h3',
	      'h4',
	      'h5',
	      'h6'
	    ];
	    var listItems = [
	      'li',
	      'dd',
	      'dt'
	    ];
	    var lists = [
	      'ul',
	      'ol',
	      'dl'
	    ];
	    var wsElements = [
	      'pre',
	      'script',
	      'textarea',
	      'style'
	    ];
	    var lazyLookup = function (items) {
	      var lookup;
	      return function (node) {
	        lookup = lookup ? lookup : mapToObject(items, constant(true));
	        return lookup.hasOwnProperty(name(node));
	      };
	    };
	    var isHeading = lazyLookup(headings);
	    var isBlock = lazyLookup(blocks);
	    var isTable$1 = function (node) {
	      return name(node) === 'table';
	    };
	    var isInline = function (node) {
	      return isElement(node) && !isBlock(node);
	    };
	    var isBr$1 = function (node) {
	      return isElement(node) && name(node) === 'br';
	    };
	    var isTextBlock = lazyLookup(textBlocks);
	    var isList = lazyLookup(lists);
	    var isListItem = lazyLookup(listItems);
	    var isVoid = lazyLookup(voids);
	    var isTableSection = lazyLookup(tableSections);
	    var isTableCell = lazyLookup(tableCells);
	    var isWsPreserveElement = lazyLookup(wsElements);
	
	    var surroundedBySpans = function (node) {
	      var previousIsSpan = node.previousSibling && node.previousSibling.nodeName === 'SPAN';
	      var nextIsSpan = node.nextSibling && node.nextSibling.nodeName === 'SPAN';
	      return previousIsSpan && nextIsSpan;
	    };
	    var isBookmarkNode = function (node) {
	      return node && node.tagName === 'SPAN' && node.getAttribute('data-mce-type') === 'bookmark';
	    };
	    var trimNode = function (dom, node) {
	      var i, children = node.childNodes;
	      if (NodeType.isElement(node) && isBookmarkNode(node)) {
	        return;
	      }
	      for (i = children.length - 1; i >= 0; i--) {
	        trimNode(dom, children[i]);
	      }
	      if (NodeType.isDocument(node) === false) {
	        if (NodeType.isText(node) && node.nodeValue.length > 0) {
	          var trimmedLength = Tools.trim(node.nodeValue).length;
	          if (dom.isBlock(node.parentNode) || trimmedLength > 0) {
	            return;
	          }
	          if (trimmedLength === 0 && surroundedBySpans(node)) {
	            return;
	          }
	        } else if (NodeType.isElement(node)) {
	          children = node.childNodes;
	          if (children.length === 1 && isBookmarkNode(children[0])) {
	            node.parentNode.insertBefore(children[0], node);
	          }
	          if (children.length || isVoid(Element.fromDom(node))) {
	            return;
	          }
	        }
	        dom.remove(node);
	      }
	      return node;
	    };
	    var TrimNode = { trimNode: trimNode };
	
	    var makeMap$1 = Tools.makeMap;
	    var namedEntities, baseEntities, reverseEntities;
	    var attrsCharsRegExp = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
	    var textCharsRegExp = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
	    var rawCharsRegExp = /[<>&\"\']/g;
	    var entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;
	    var asciiMap = {
	      128: '\u20AC',
	      130: '\u201A',
	      131: '\u0192',
	      132: '\u201E',
	      133: '\u2026',
	      134: '\u2020',
	      135: '\u2021',
	      136: '\u02c6',
	      137: '\u2030',
	      138: '\u0160',
	      139: '\u2039',
	      140: '\u0152',
	      142: '\u017d',
	      145: '\u2018',
	      146: '\u2019',
	      147: '\u201C',
	      148: '\u201D',
	      149: '\u2022',
	      150: '\u2013',
	      151: '\u2014',
	      152: '\u02DC',
	      153: '\u2122',
	      154: '\u0161',
	      155: '\u203A',
	      156: '\u0153',
	      158: '\u017e',
	      159: '\u0178'
	    };
	    baseEntities = {
	      '"': '&quot;',
	      '\'': '&#39;',
	      '<': '&lt;',
	      '>': '&gt;',
	      '&': '&amp;',
	      '`': '&#96;'
	    };
	    reverseEntities = {
	      '&lt;': '<',
	      '&gt;': '>',
	      '&amp;': '&',
	      '&quot;': '"',
	      '&apos;': '\''
	    };
	    var nativeDecode = function (text) {
	      var elm;
	      elm = Element.fromTag('div').dom();
	      elm.innerHTML = text;
	      return elm.textContent || elm.innerText || text;
	    };
	    var buildEntitiesLookup = function (items, radix) {
	      var i, chr, entity;
	      var lookup = {};
	      if (items) {
	        items = items.split(',');
	        radix = radix || 10;
	        for (i = 0; i < items.length; i += 2) {
	          chr = String.fromCharCode(parseInt(items[i], radix));
	          if (!baseEntities[chr]) {
	            entity = '&' + items[i + 1] + ';';
	            lookup[chr] = entity;
	            lookup[entity] = chr;
	          }
	        }
	        return lookup;
	      }
	    };
	    namedEntities = buildEntitiesLookup('50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' + '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' + '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' + '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' + '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' + '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' + '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' + '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' + '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' + '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' + 'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' + 'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' + 't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' + 'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' + 'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' + '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' + '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' + '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' + '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' + '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' + 'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' + 'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' + 'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' + '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' + '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);
	    var encodeRaw = function (text, attr) {
	      return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function (chr) {
	        return baseEntities[chr] || chr;
	      });
	    };
	    var encodeAllRaw = function (text) {
	      return ('' + text).replace(rawCharsRegExp, function (chr) {
	        return baseEntities[chr] || chr;
	      });
	    };
	    var encodeNumeric = function (text, attr) {
	      return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function (chr) {
	        if (chr.length > 1) {
	          return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';
	        }
	        return baseEntities[chr] || '&#' + chr.charCodeAt(0) + ';';
	      });
	    };
	    var encodeNamed = function (text, attr, entities) {
	      entities = entities || namedEntities;
	      return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function (chr) {
	        return baseEntities[chr] || entities[chr] || chr;
	      });
	    };
	    var getEncodeFunc = function (name, entities) {
	      var entitiesMap = buildEntitiesLookup(entities) || namedEntities;
	      var encodeNamedAndNumeric = function (text, attr) {
	        return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function (chr) {
	          if (baseEntities[chr] !== undefined) {
	            return baseEntities[chr];
	          }
	          if (entitiesMap[chr] !== undefined) {
	            return entitiesMap[chr];
	          }
	          if (chr.length > 1) {
	            return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';
	          }
	          return '&#' + chr.charCodeAt(0) + ';';
	        });
	      };
	      var encodeCustomNamed = function (text, attr) {
	        return encodeNamed(text, attr, entitiesMap);
	      };
	      var nameMap = makeMap$1(name.replace(/\+/g, ','));
	      if (nameMap.named && nameMap.numeric) {
	        return encodeNamedAndNumeric;
	      }
	      if (nameMap.named) {
	        if (entities) {
	          return encodeCustomNamed;
	        }
	        return encodeNamed;
	      }
	      if (nameMap.numeric) {
	        return encodeNumeric;
	      }
	      return encodeRaw;
	    };
	    var decode = function (text) {
	      return text.replace(entityRegExp, function (all, numeric) {
	        if (numeric) {
	          if (numeric.charAt(0).toLowerCase() === 'x') {
	            numeric = parseInt(numeric.substr(1), 16);
	          } else {
	            numeric = parseInt(numeric, 10);
	          }
	          if (numeric > 65535) {
	            numeric -= 65536;
	            return String.fromCharCode(55296 + (numeric >> 10), 56320 + (numeric & 1023));
	          }
	          return asciiMap[numeric] || String.fromCharCode(numeric);
	        }
	        return reverseEntities[all] || namedEntities[all] || nativeDecode(all);
	      });
	    };
	    var Entities = {
	      encodeRaw: encodeRaw,
	      encodeAllRaw: encodeAllRaw,
	      encodeNumeric: encodeNumeric,
	      encodeNamed: encodeNamed,
	      getEncodeFunc: getEncodeFunc,
	      decode: decode
	    };
	
	    var mapCache = {}, dummyObj = {};
	    var makeMap$2 = Tools.makeMap, each$3 = Tools.each, extend$1 = Tools.extend, explode$1 = Tools.explode, inArray = Tools.inArray;
	    var split = function (items, delim) {
	      items = Tools.trim(items);
	      return items ? items.split(delim || ' ') : [];
	    };
	    var compileSchema = function (type) {
	      var schema = {};
	      var globalAttributes, blockContent;
	      var phrasingContent, flowContent, html4BlockContent, html4PhrasingContent;
	      var add = function (name, attributes, children) {
	        var ni, attributesOrder, element;
	        var arrayToMap = function (array, obj) {
	          var map = {};
	          var i, l;
	          for (i = 0, l = array.length; i < l; i++) {
	            map[array[i]] = obj || {};
	          }
	          return map;
	        };
	        children = children || [];
	        attributes = attributes || '';
	        if (typeof children === 'string') {
	          children = split(children);
	        }
	        name = split(name);
	        ni = name.length;
	        while (ni--) {
	          attributesOrder = split([
	            globalAttributes,
	            attributes
	          ].join(' '));
	          element = {
	            attributes: arrayToMap(attributesOrder),
	            attributesOrder: attributesOrder,
	            children: arrayToMap(children, dummyObj)
	          };
	          schema[name[ni]] = element;
	        }
	      };
	      var addAttrs = function (name, attributes) {
	        var ni, schemaItem, i, l;
	        name = split(name);
	        ni = name.length;
	        attributes = split(attributes);
	        while (ni--) {
	          schemaItem = schema[name[ni]];
	          for (i = 0, l = attributes.length; i < l; i++) {
	            schemaItem.attributes[attributes[i]] = {};
	            schemaItem.attributesOrder.push(attributes[i]);
	          }
	        }
	      };
	      if (mapCache[type]) {
	        return mapCache[type];
	      }
	      globalAttributes = 'id accesskey class dir lang style tabindex title role';
	      blockContent = 'address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul';
	      phrasingContent = 'a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd ' + 'label map noscript object q s samp script select small span strong sub sup ' + 'textarea u var #text #comment';
	      if (type !== 'html4') {
	        globalAttributes += ' contenteditable contextmenu draggable dropzone ' + 'hidden spellcheck translate';
	        blockContent += ' article aside details dialog figure main header footer hgroup section nav';
	        phrasingContent += ' audio canvas command datalist mark meter output picture ' + 'progress time wbr video ruby bdi keygen';
	      }
	      if (type !== 'html5-strict') {
	        globalAttributes += ' xml:lang';
	        html4PhrasingContent = 'acronym applet basefont big font strike tt';
	        phrasingContent = [
	          phrasingContent,
	          html4PhrasingContent
	        ].join(' ');
	        each$3(split(html4PhrasingContent), function (name) {
	          add(name, '', phrasingContent);
	        });
	        html4BlockContent = 'center dir isindex noframes';
	        blockContent = [
	          blockContent,
	          html4BlockContent
	        ].join(' ');
	        flowContent = [
	          blockContent,
	          phrasingContent
	        ].join(' ');
	        each$3(split(html4BlockContent), function (name) {
	          add(name, '', flowContent);
	        });
	      }
	      flowContent = flowContent || [
	        blockContent,
	        phrasingContent
	      ].join(' ');
	      add('html', 'manifest', 'head body');
	      add('head', '', 'base command link meta noscript script style title');
	      add('title hr noscript br');
	      add('base', 'href target');
	      add('link', 'href rel media hreflang type sizes hreflang');
	      add('meta', 'name http-equiv content charset');
	      add('style', 'media type scoped');
	      add('script', 'src async defer type charset');
	      add('body', 'onafterprint onbeforeprint onbeforeunload onblur onerror onfocus ' + 'onhashchange onload onmessage onoffline ononline onpagehide onpageshow ' + 'onpopstate onresize onscroll onstorage onunload', flowContent);
	      add('address dt dd div caption', '', flowContent);
	      add('h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn', '', phrasingContent);
	      add('blockquote', 'cite', flowContent);
	      add('ol', 'reversed start type', 'li');
	      add('ul', '', 'li');
	      add('li', 'value', flowContent);
	      add('dl', '', 'dt dd');
	      add('a', 'href target rel media hreflang type', phrasingContent);
	      add('q', 'cite', phrasingContent);
	      add('ins del', 'cite datetime', flowContent);
	      add('img', 'src sizes srcset alt usemap ismap width height');
	      add('iframe', 'src name width height', flowContent);
	      add('embed', 'src type width height');
	      add('object', 'data type typemustmatch name usemap form width height', [
	        flowContent,
	        'param'
	      ].join(' '));
	      add('param', 'name value');
	      add('map', 'name', [
	        flowContent,
	        'area'
	      ].join(' '));
	      add('area', 'alt coords shape href target rel media hreflang type');
	      add('table', 'border', 'caption colgroup thead tfoot tbody tr' + (type === 'html4' ? ' col' : ''));
	      add('colgroup', 'span', 'col');
	      add('col', 'span');
	      add('tbody thead tfoot', '', 'tr');
	      add('tr', '', 'td th');
	      add('td', 'colspan rowspan headers', flowContent);
	      add('th', 'colspan rowspan headers scope abbr', flowContent);
	      add('form', 'accept-charset action autocomplete enctype method name novalidate target', flowContent);
	      add('fieldset', 'disabled form name', [
	        flowContent,
	        'legend'
	      ].join(' '));
	      add('label', 'form for', phrasingContent);
	      add('input', 'accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate ' + 'formtarget height list max maxlength min multiple name pattern readonly required size src step type value width');
	      add('button', 'disabled form formaction formenctype formmethod formnovalidate formtarget name type value', type === 'html4' ? flowContent : phrasingContent);
	      add('select', 'disabled form multiple name required size', 'option optgroup');
	      add('optgroup', 'disabled label', 'option');
	      add('option', 'disabled label selected value');
	      add('textarea', 'cols dirname disabled form maxlength name readonly required rows wrap');
	      add('menu', 'type label', [
	        flowContent,
	        'li'
	      ].join(' '));
	      add('noscript', '', flowContent);
	      if (type !== 'html4') {
	        add('wbr');
	        add('ruby', '', [
	          phrasingContent,
	          'rt rp'
	        ].join(' '));
	        add('figcaption', '', flowContent);
	        add('mark rt rp summary bdi', '', phrasingContent);
	        add('canvas', 'width height', flowContent);
	        add('video', 'src crossorigin poster preload autoplay mediagroup loop ' + 'muted controls width height buffered', [
	          flowContent,
	          'track source'
	        ].join(' '));
	        add('audio', 'src crossorigin preload autoplay mediagroup loop muted controls ' + 'buffered volume', [
	          flowContent,
	          'track source'
	        ].join(' '));
	        add('picture', '', 'img source');
	        add('source', 'src srcset type media sizes');
	        add('track', 'kind src srclang label default');
	        add('datalist', '', [
	          phrasingContent,
	          'option'
	        ].join(' '));
	        add('article section nav aside main header footer', '', flowContent);
	        add('hgroup', '', 'h1 h2 h3 h4 h5 h6');
	        add('figure', '', [
	          flowContent,
	          'figcaption'
	        ].join(' '));
	        add('time', 'datetime', phrasingContent);
	        add('dialog', 'open', flowContent);
	        add('command', 'type label icon disabled checked radiogroup command');
	        add('output', 'for form name', phrasingContent);
	        add('progress', 'value max', phrasingContent);
	        add('meter', 'value min max low high optimum', phrasingContent);
	        add('details', 'open', [
	          flowContent,
	          'summary'
	        ].join(' '));
	        add('keygen', 'autofocus challenge disabled form keytype name');
	      }
	      if (type !== 'html5-strict') {
	        addAttrs('script', 'language xml:space');
	        addAttrs('style', 'xml:space');
	        addAttrs('object', 'declare classid code codebase codetype archive standby align border hspace vspace');
	        addAttrs('embed', 'align name hspace vspace');
	        addAttrs('param', 'valuetype type');
	        addAttrs('a', 'charset name rev shape coords');
	        addAttrs('br', 'clear');
	        addAttrs('applet', 'codebase archive code object alt name width height align hspace vspace');
	        addAttrs('img', 'name longdesc align border hspace vspace');
	        addAttrs('iframe', 'longdesc frameborder marginwidth marginheight scrolling align');
	        addAttrs('font basefont', 'size color face');
	        addAttrs('input', 'usemap align');
	        addAttrs('select');
	        addAttrs('textarea');
	        addAttrs('h1 h2 h3 h4 h5 h6 div p legend caption', 'align');
	        addAttrs('ul', 'type compact');
	        addAttrs('li', 'type');
	        addAttrs('ol dl menu dir', 'compact');
	        addAttrs('pre', 'width xml:space');
	        addAttrs('hr', 'align noshade size width');
	        addAttrs('isindex', 'prompt');
	        addAttrs('table', 'summary width frame rules cellspacing cellpadding align bgcolor');
	        addAttrs('col', 'width align char charoff valign');
	        addAttrs('colgroup', 'width align char charoff valign');
	        addAttrs('thead', 'align char charoff valign');
	        addAttrs('tr', 'align char charoff valign bgcolor');
	        addAttrs('th', 'axis align char charoff valign nowrap bgcolor width height');
	        addAttrs('form', 'accept');
	        addAttrs('td', 'abbr axis scope align char charoff valign nowrap bgcolor width height');
	        addAttrs('tfoot', 'align char charoff valign');
	        addAttrs('tbody', 'align char charoff valign');
	        addAttrs('area', 'nohref');
	        addAttrs('body', 'background bgcolor text link vlink alink');
	      }
	      if (type !== 'html4') {
	        addAttrs('input button select textarea', 'autofocus');
	        addAttrs('input textarea', 'placeholder');
	        addAttrs('a', 'download');
	        addAttrs('link script img', 'crossorigin');
	        addAttrs('img', 'loading');
	        addAttrs('iframe', 'sandbox seamless allowfullscreen loading');
	      }
	      each$3(split('a form meter progress dfn'), function (name) {
	        if (schema[name]) {
	          delete schema[name].children[name];
	        }
	      });
	      delete schema.caption.children.table;
	      delete schema.script;
	      mapCache[type] = schema;
	      return schema;
	    };
	    var compileElementMap = function (value, mode) {
	      var styles;
	      if (value) {
	        styles = {};
	        if (typeof value === 'string') {
	          value = { '*': value };
	        }
	        each$3(value, function (value, key) {
	          styles[key] = styles[key.toUpperCase()] = mode === 'map' ? makeMap$2(value, /[, ]/) : explode$1(value, /[, ]/);
	        });
	      }
	      return styles;
	    };
	    function Schema(settings) {
	      var elements = {};
	      var children = {};
	      var patternElements = [];
	      var validStyles;
	      var invalidStyles;
	      var schemaItems;
	      var whiteSpaceElementsMap, selfClosingElementsMap, shortEndedElementsMap, boolAttrMap, validClasses;
	      var blockElementsMap, nonEmptyElementsMap, moveCaretBeforeOnEnterElementsMap, textBlockElementsMap, textInlineElementsMap;
	      var customElementsMap = {}, specialElements = {};
	      var createLookupTable = function (option, defaultValue, extendWith) {
	        var value = settings[option];
	        if (!value) {
	          value = mapCache[option];
	          if (!value) {
	            value = makeMap$2(defaultValue, ' ', makeMap$2(defaultValue.toUpperCase(), ' '));
	            value = extend$1(value, extendWith);
	            mapCache[option] = value;
	          }
	        } else {
	          value = makeMap$2(value, /[, ]/, makeMap$2(value.toUpperCase(), /[, ]/));
	        }
	        return value;
	      };
	      settings = settings || {};
	      schemaItems = compileSchema(settings.schema);
	      if (settings.verify_html === false) {
	        settings.valid_elements = '*[*]';
	      }
	      validStyles = compileElementMap(settings.valid_styles);
	      invalidStyles = compileElementMap(settings.invalid_styles, 'map');
	      validClasses = compileElementMap(settings.valid_classes, 'map');
	      whiteSpaceElementsMap = createLookupTable('whitespace_elements', 'pre script noscript style textarea video audio iframe object code');
	      selfClosingElementsMap = createLookupTable('self_closing_elements', 'colgroup dd dt li option p td tfoot th thead tr');
	      shortEndedElementsMap = createLookupTable('short_ended_elements', 'area base basefont br col frame hr img input isindex link ' + 'meta param embed source wbr track');
	      boolAttrMap = createLookupTable('boolean_attributes', 'checked compact declare defer disabled ismap multiple nohref noresize ' + 'noshade nowrap readonly selected autoplay loop controls');
	      nonEmptyElementsMap = createLookupTable('non_empty_elements', 'td th iframe video audio object ' + 'script pre code', shortEndedElementsMap);
	      moveCaretBeforeOnEnterElementsMap = createLookupTable('move_caret_before_on_enter_elements', 'table', nonEmptyElementsMap);
	      textBlockElementsMap = createLookupTable('text_block_elements', 'h1 h2 h3 h4 h5 h6 p div address pre form ' + 'blockquote center dir fieldset header footer article section hgroup aside main nav figure');
	      blockElementsMap = createLookupTable('block_elements', 'hr table tbody thead tfoot ' + 'th tr td li ol ul caption dl dt dd noscript menu isindex option ' + 'datalist select optgroup figcaption details summary', textBlockElementsMap);
	      textInlineElementsMap = createLookupTable('text_inline_elements', 'span strong b em i font strike u var cite ' + 'dfn code mark q sup sub samp');
	      each$3((settings.special || 'script noscript noframes noembed title style textarea xmp').split(' '), function (name) {
	        specialElements[name] = new RegExp('</' + name + '[^>]*>', 'gi');
	      });
	      var patternToRegExp = function (str) {
	        return new RegExp('^' + str.replace(/([?+*])/g, '.$1') + '$');
	      };
	      var addValidElements = function (validElements) {
	        var ei, el, ai, al, matches, element, attr, attrData, elementName, attrName, attrType, attributes, attributesOrder, prefix, outputName, globalAttributes, globalAttributesOrder, key, value;
	        var elementRuleRegExp = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)\])?$/, attrRuleRegExp = /^([!\-])?(\w+[\\:]:\w+|[^=:<]+)?(?:([=:<])(.*))?$/, hasPatternsRegExp = /[*?+]/;
	        if (validElements) {
	          validElements = split(validElements, ',');
	          if (elements['@']) {
	            globalAttributes = elements['@'].attributes;
	            globalAttributesOrder = elements['@'].attributesOrder;
	          }
	          for (ei = 0, el = validElements.length; ei < el; ei++) {
	            matches = elementRuleRegExp.exec(validElements[ei]);
	            if (matches) {
	              prefix = matches[1];
	              elementName = matches[2];
	              outputName = matches[3];
	              attrData = matches[5];
	              attributes = {};
	              attributesOrder = [];
	              element = {
	                attributes: attributes,
	                attributesOrder: attributesOrder
	              };
	              if (prefix === '#') {
	                element.paddEmpty = true;
	              }
	              if (prefix === '-') {
	                element.removeEmpty = true;
	              }
	              if (matches[4] === '!') {
	                element.removeEmptyAttrs = true;
	              }
	              if (globalAttributes) {
	                for (key in globalAttributes) {
	                  attributes[key] = globalAttributes[key];
	                }
	                attributesOrder.push.apply(attributesOrder, globalAttributesOrder);
	              }
	              if (attrData) {
	                attrData = split(attrData, '|');
	                for (ai = 0, al = attrData.length; ai < al; ai++) {
	                  matches = attrRuleRegExp.exec(attrData[ai]);
	                  if (matches) {
	                    attr = {};
	                    attrType = matches[1];
	                    attrName = matches[2].replace(/[\\:]:/g, ':');
	                    prefix = matches[3];
	                    value = matches[4];
	                    if (attrType === '!') {
	                      element.attributesRequired = element.attributesRequired || [];
	                      element.attributesRequired.push(attrName);
	                      attr.required = true;
	                    }
	                    if (attrType === '-') {
	                      delete attributes[attrName];
	                      attributesOrder.splice(inArray(attributesOrder, attrName), 1);
	                      continue;
	                    }
	                    if (prefix) {
	                      if (prefix === '=') {
	                        element.attributesDefault = element.attributesDefault || [];
	                        element.attributesDefault.push({
	                          name: attrName,
	                          value: value
	                        });
	                        attr.defaultValue = value;
	                      }
	                      if (prefix === ':') {
	                        element.attributesForced = element.attributesForced || [];
	                        element.attributesForced.push({
	                          name: attrName,
	                          value: value
	                        });
	                        attr.forcedValue = value;
	                      }
	                      if (prefix === '<') {
	                        attr.validValues = makeMap$2(value, '?');
	                      }
	                    }
	                    if (hasPatternsRegExp.test(attrName)) {
	                      element.attributePatterns = element.attributePatterns || [];
	                      attr.pattern = patternToRegExp(attrName);
	                      element.attributePatterns.push(attr);
	                    } else {
	                      if (!attributes[attrName]) {
	                        attributesOrder.push(attrName);
	                      }
	                      attributes[attrName] = attr;
	                    }
	                  }
	                }
	              }
	              if (!globalAttributes && elementName === '@') {
	                globalAttributes = attributes;
	                globalAttributesOrder = attributesOrder;
	              }
	              if (outputName) {
	                element.outputName = elementName;
	                elements[outputName] = element;
	              }
	              if (hasPatternsRegExp.test(elementName)) {
	                element.pattern = patternToRegExp(elementName);
	                patternElements.push(element);
	              } else {
	                elements[elementName] = element;
	              }
	            }
	          }
	        }
	      };
	      var setValidElements = function (validElements) {
	        elements = {};
	        patternElements = [];
	        addValidElements(validElements);
	        each$3(schemaItems, function (element, name) {
	          children[name] = element.children;
	        });
	      };
	      var addCustomElements = function (customElements) {
	        var customElementRegExp = /^(~)?(.+)$/;
	        if (customElements) {
	          mapCache.text_block_elements = mapCache.block_elements = null;
	          each$3(split(customElements, ','), function (rule) {
	            var matches = customElementRegExp.exec(rule), inline = matches[1] === '~', cloneName = inline ? 'span' : 'div', name = matches[2];
	            children[name] = children[cloneName];
	            customElementsMap[name] = cloneName;
	            if (!inline) {
	              blockElementsMap[name.toUpperCase()] = {};
	              blockElementsMap[name] = {};
	            }
	            if (!elements[name]) {
	              var customRule = elements[cloneName];
	              customRule = extend$1({}, customRule);
	              delete customRule.removeEmptyAttrs;
	              delete customRule.removeEmpty;
	              elements[name] = customRule;
	            }
	            each$3(children, function (element, elmName) {
	              if (element[cloneName]) {
	                children[elmName] = element = extend$1({}, children[elmName]);
	                element[name] = element[cloneName];
	              }
	            });
	          });
	        }
	      };
	      var addValidChildren = function (validChildren) {
	        var childRuleRegExp = /^([+\-]?)(\w+)\[([^\]]+)\]$/;
	        mapCache[settings.schema] = null;
	        if (validChildren) {
	          each$3(split(validChildren, ','), function (rule) {
	            var matches = childRuleRegExp.exec(rule);
	            var parent, prefix;
	            if (matches) {
	              prefix = matches[1];
	              if (prefix) {
	                parent = children[matches[2]];
	              } else {
	                parent = children[matches[2]] = { '#comment': {} };
	              }
	              parent = children[matches[2]];
	              each$3(split(matches[3], '|'), function (child) {
	                if (prefix === '-') {
	                  delete parent[child];
	                } else {
	                  parent[child] = {};
	                }
	              });
	            }
	          });
	        }
	      };
	      var getElementRule = function (name) {
	        var element = elements[name], i;
	        if (element) {
	          return element;
	        }
	        i = patternElements.length;
	        while (i--) {
	          element = patternElements[i];
	          if (element.pattern.test(name)) {
	            return element;
	          }
	        }
	      };
	      if (!settings.valid_elements) {
	        each$3(schemaItems, function (element, name) {
	          elements[name] = {
	            attributes: element.attributes,
	            attributesOrder: element.attributesOrder
	          };
	          children[name] = element.children;
	        });
	        if (settings.schema !== 'html5') {
	          each$3(split('strong/b em/i'), function (item) {
	            item = split(item, '/');
	            elements[item[1]].outputName = item[0];
	          });
	        }
	        each$3(split('ol ul sub sup blockquote span font a table tbody tr strong em b i'), function (name) {
	          if (elements[name]) {
	            elements[name].removeEmpty = true;
	          }
	        });
	        each$3(split('p h1 h2 h3 h4 h5 h6 th td pre div address caption li'), function (name) {
	          elements[name].paddEmpty = true;
	        });
	        each$3(split('span'), function (name) {
	          elements[name].removeEmptyAttrs = true;
	        });
	      } else {
	        setValidElements(settings.valid_elements);
	      }
	      addCustomElements(settings.custom_elements);
	      addValidChildren(settings.valid_children);
	      addValidElements(settings.extended_valid_elements);
	      addValidChildren('+ol[ul|ol],+ul[ul|ol]');
	      each$3({
	        dd: 'dl',
	        dt: 'dl',
	        li: 'ul ol',
	        td: 'tr',
	        th: 'tr',
	        tr: 'tbody thead tfoot',
	        tbody: 'table',
	        thead: 'table',
	        tfoot: 'table',
	        legend: 'fieldset',
	        area: 'map',
	        param: 'video audio object'
	      }, function (parents, item) {
	        if (elements[item]) {
	          elements[item].parentsRequired = split(parents);
	        }
	      });
	      if (settings.invalid_elements) {
	        each$3(explode$1(settings.invalid_elements), function (item) {
	          if (elements[item]) {
	            delete elements[item];
	          }
	        });
	      }
	      if (!getElementRule('span')) {
	        addValidElements('span[!data-mce-type|*]');
	      }
	      var getValidStyles = function () {
	        return validStyles;
	      };
	      var getInvalidStyles = function () {
	        return invalidStyles;
	      };
	      var getValidClasses = function () {
	        return validClasses;
	      };
	      var getBoolAttrs = function () {
	        return boolAttrMap;
	      };
	      var getBlockElements = function () {
	        return blockElementsMap;
	      };
	      var getTextBlockElements = function () {
	        return textBlockElementsMap;
	      };
	      var getTextInlineElements = function () {
	        return textInlineElementsMap;
	      };
	      var getShortEndedElements = function () {
	        return shortEndedElementsMap;
	      };
	      var getSelfClosingElements = function () {
	        return selfClosingElementsMap;
	      };
	      var getNonEmptyElements = function () {
	        return nonEmptyElementsMap;
	      };
	      var getMoveCaretBeforeOnEnterElements = function () {
	        return moveCaretBeforeOnEnterElementsMap;
	      };
	      var getWhiteSpaceElements = function () {
	        return whiteSpaceElementsMap;
	      };
	      var getSpecialElements = function () {
	        return specialElements;
	      };
	      var isValidChild = function (name, child) {
	        var parent = children[name.toLowerCase()];
	        return !!(parent && parent[child.toLowerCase()]);
	      };
	      var isValid = function (name, attr) {
	        var attrPatterns, i;
	        var rule = getElementRule(name);
	        if (rule) {
	          if (attr) {
	            if (rule.attributes[attr]) {
	              return true;
	            }
	            attrPatterns = rule.attributePatterns;
	            if (attrPatterns) {
	              i = attrPatterns.length;
	              while (i--) {
	                if (attrPatterns[i].pattern.test(name)) {
	                  return true;
	                }
	              }
	            }
	          } else {
	            return true;
	          }
	        }
	        return false;
	      };
	      var getCustomElements = function () {
	        return customElementsMap;
	      };
	      return {
	        children: children,
	        elements: elements,
	        getValidStyles: getValidStyles,
	        getValidClasses: getValidClasses,
	        getBlockElements: getBlockElements,
	        getInvalidStyles: getInvalidStyles,
	        getShortEndedElements: getShortEndedElements,
	        getTextBlockElements: getTextBlockElements,
	        getTextInlineElements: getTextInlineElements,
	        getBoolAttrs: getBoolAttrs,
	        getElementRule: getElementRule,
	        getSelfClosingElements: getSelfClosingElements,
	        getNonEmptyElements: getNonEmptyElements,
	        getMoveCaretBeforeOnEnterElements: getMoveCaretBeforeOnEnterElements,
	        getWhiteSpaceElements: getWhiteSpaceElements,
	        getSpecialElements: getSpecialElements,
	        isValidChild: isValidChild,
	        isValid: isValid,
	        getCustomElements: getCustomElements,
	        addValidElements: addValidElements,
	        setValidElements: setValidElements,
	        addCustomElements: addCustomElements,
	        addValidChildren: addValidChildren
	      };
	    }
	
	    var zeroWidth = '\uFEFF';
	    var nbsp = '\xA0';
	
	    var toHex = function (match, r, g, b) {
	      var hex = function (val) {
	        val = parseInt(val, 10).toString(16);
	        return val.length > 1 ? val : '0' + val;
	      };
	      return '#' + hex(r) + hex(g) + hex(b);
	    };
	    var Styles = function (settings, schema) {
	      var rgbRegExp = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi;
	      var urlOrStrRegExp = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi;
	      var styleRegExp = /\s*([^:]+):\s*([^;]+);?/g;
	      var trimRightRegExp = /\s+$/;
	      var i;
	      var encodingLookup = {};
	      var encodingItems;
	      var validStyles;
	      var invalidStyles;
	      var invisibleChar = zeroWidth;
	      settings = settings || {};
	      if (schema) {
	        validStyles = schema.getValidStyles();
	        invalidStyles = schema.getInvalidStyles();
	      }
	      encodingItems = ('\\" \\\' \\; \\: ; : ' + invisibleChar).split(' ');
	      for (i = 0; i < encodingItems.length; i++) {
	        encodingLookup[encodingItems[i]] = invisibleChar + i;
	        encodingLookup[invisibleChar + i] = encodingItems[i];
	      }
	      return {
	        toHex: function (color) {
	          return color.replace(rgbRegExp, toHex);
	        },
	        parse: function (css) {
	          var styles = {};
	          var matches, name, value, isEncoded;
	          var urlConverter = settings.url_converter;
	          var urlConverterScope = settings.url_converter_scope || this;
	          var compress = function (prefix, suffix, noJoin) {
	            var top, right, bottom, left;
	            top = styles[prefix + '-top' + suffix];
	            if (!top) {
	              return;
	            }
	            right = styles[prefix + '-right' + suffix];
	            if (!right) {
	              return;
	            }
	            bottom = styles[prefix + '-bottom' + suffix];
	            if (!bottom) {
	              return;
	            }
	            left = styles[prefix + '-left' + suffix];
	            if (!left) {
	              return;
	            }
	            var box = [
	              top,
	              right,
	              bottom,
	              left
	            ];
	            i = box.length - 1;
	            while (i--) {
	              if (box[i] !== box[i + 1]) {
	                break;
	              }
	            }
	            if (i > -1 && noJoin) {
	              return;
	            }
	            styles[prefix + suffix] = i === -1 ? box[0] : box.join(' ');
	            delete styles[prefix + '-top' + suffix];
	            delete styles[prefix + '-right' + suffix];
	            delete styles[prefix + '-bottom' + suffix];
	            delete styles[prefix + '-left' + suffix];
	          };
	          var canCompress = function (key) {
	            var value = styles[key], i;
	            if (!value) {
	              return;
	            }
	            value = value.split(' ');
	            i = value.length;
	            while (i--) {
	              if (value[i] !== value[0]) {
	                return false;
	              }
	            }
	            styles[key] = value[0];
	            return true;
	          };
	          var compress2 = function (target, a, b, c) {
	            if (!canCompress(a)) {
	              return;
	            }
	            if (!canCompress(b)) {
	              return;
	            }
	            if (!canCompress(c)) {
	              return;
	            }
	            styles[target] = styles[a] + ' ' + styles[b] + ' ' + styles[c];
	            delete styles[a];
	            delete styles[b];
	            delete styles[c];
	          };
	          var encode = function (str) {
	            isEncoded = true;
	            return encodingLookup[str];
	          };
	          var decode = function (str, keepSlashes) {
	            if (isEncoded) {
	              str = str.replace(/\uFEFF[0-9]/g, function (str) {
	                return encodingLookup[str];
	              });
	            }
	            if (!keepSlashes) {
	              str = str.replace(/\\([\'\";:])/g, '$1');
	            }
	            return str;
	          };
	          var decodeSingleHexSequence = function (escSeq) {
	            return String.fromCharCode(parseInt(escSeq.slice(1), 16));
	          };
	          var decodeHexSequences = function (value) {
	            return value.replace(/\\[0-9a-f]+/gi, decodeSingleHexSequence);
	          };
	          var processUrl = function (match, url, url2, url3, str, str2) {
	            str = str || str2;
	            if (str) {
	              str = decode(str);
	              return '\'' + str.replace(/\'/g, '\\\'') + '\'';
	            }
	            url = decode(url || url2 || url3);
	            if (!settings.allow_script_urls) {
	              var scriptUrl = url.replace(/[\s\r\n]+/g, '');
	              if (/(java|vb)script:/i.test(scriptUrl)) {
	                return '';
	              }
	              if (!settings.allow_svg_data_urls && /^data:image\/svg/i.test(scriptUrl)) {
	                return '';
	              }
	            }
	            if (urlConverter) {
	              url = urlConverter.call(urlConverterScope, url, 'style');
	            }
	            return 'url(\'' + url.replace(/\'/g, '\\\'') + '\')';
	          };
	          if (css) {
	            css = css.replace(/[\u0000-\u001F]/g, '');
	            css = css.replace(/\\[\"\';:\uFEFF]/g, encode).replace(/\"[^\"]+\"|\'[^\']+\'/g, function (str) {
	              return str.replace(/[;:]/g, encode);
	            });
	            while (matches = styleRegExp.exec(css)) {
	              styleRegExp.lastIndex = matches.index + matches[0].length;
	              name = matches[1].replace(trimRightRegExp, '').toLowerCase();
	              value = matches[2].replace(trimRightRegExp, '');
	              if (name && value) {
	                name = decodeHexSequences(name);
	                value = decodeHexSequences(value);
	                if (name.indexOf(invisibleChar) !== -1 || name.indexOf('"') !== -1) {
	                  continue;
	                }
	                if (!settings.allow_script_urls && (name === 'behavior' || /expression\s*\(|\/\*|\*\//.test(value))) {
	                  continue;
	                }
	                if (name === 'font-weight' && value === '700') {
	                  value = 'bold';
	                } else if (name === 'color' || name === 'background-color') {
	                  value = value.toLowerCase();
	                }
	                value = value.replace(rgbRegExp, toHex);
	                value = value.replace(urlOrStrRegExp, processUrl);
	                styles[name] = isEncoded ? decode(value, true) : value;
	              }
	            }
	            compress('border', '', true);
	            compress('border', '-width');
	            compress('border', '-color');
	            compress('border', '-style');
	            compress('padding', '');
	            compress('margin', '');
	            compress2('border', 'border-width', 'border-style', 'border-color');
	            if (styles.border === 'medium none') {
	              delete styles.border;
	            }
	            if (styles['border-image'] === 'none') {
	              delete styles['border-image'];
	            }
	          }
	          return styles;
	        },
	        serialize: function (styles, elementName) {
	          var css = '', name, value;
	          var serializeStyles = function (name) {
	            var styleList, i, l, value;
	            styleList = validStyles[name];
	            if (styleList) {
	              for (i = 0, l = styleList.length; i < l; i++) {
	                name = styleList[i];
	                value = styles[name];
	                if (value) {
	                  css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';
	                }
	              }
	            }
	          };
	          var isValid = function (name, elementName) {
	            var styleMap;
	            styleMap = invalidStyles['*'];
	            if (styleMap && styleMap[name]) {
	              return false;
	            }
	            styleMap = invalidStyles[elementName];
	            if (styleMap && styleMap[name]) {
	              return false;
	            }
	            return true;
	          };
	          if (elementName && validStyles) {
	            serializeStyles('*');
	            serializeStyles(elementName);
	          } else {
	            for (name in styles) {
	              value = styles[name];
	              if (value && (!invalidStyles || isValid(name, elementName))) {
	                css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';
	              }
	            }
	          }
	          return css;
	        }
	      };
	    };
	
	    var eventExpandoPrefix = 'mce-data-';
	    var mouseEventRe = /^(?:mouse|contextmenu)|click/;
	    var deprecated = {
	      keyLocation: 1,
	      layerX: 1,
	      layerY: 1,
	      returnValue: 1,
	      webkitMovementX: 1,
	      webkitMovementY: 1,
	      keyIdentifier: 1,
	      mozPressure: 1
	    };
	    var hasIsDefaultPrevented = function (event) {
	      return event.isDefaultPrevented === returnTrue || event.isDefaultPrevented === returnFalse;
	    };
	    var returnFalse = function () {
	      return false;
	    };
	    var returnTrue = function () {
	      return true;
	    };
	    var addEvent = function (target, name, callback, capture) {
	      if (target.addEventListener) {
	        target.addEventListener(name, callback, capture || false);
	      } else if (target.attachEvent) {
	        target.attachEvent('on' + name, callback);
	      }
	    };
	    var removeEvent = function (target, name, callback, capture) {
	      if (target.removeEventListener) {
	        target.removeEventListener(name, callback, capture || false);
	      } else if (target.detachEvent) {
	        target.detachEvent('on' + name, callback);
	      }
	    };
	    var getTargetFromShadowDom = function (event, defaultTarget) {
	      if (event.composedPath) {
	        var composedPath = event.composedPath();
	        if (composedPath && composedPath.length > 0) {
	          return composedPath[0];
	        }
	      }
	      return defaultTarget;
	    };
	    var fix = function (originalEvent, data) {
	      var name;
	      var event = data || {};
	      for (name in originalEvent) {
	        if (!deprecated[name]) {
	          event[name] = originalEvent[name];
	        }
	      }
	      if (!event.target) {
	        event.target = event.srcElement || domGlobals.document;
	      }
	      if (Env.experimentalShadowDom) {
	        event.target = getTargetFromShadowDom(originalEvent, event.target);
	      }
	      if (originalEvent && mouseEventRe.test(originalEvent.type) && originalEvent.pageX === undefined && originalEvent.clientX !== undefined) {
	        var eventDoc = event.target.ownerDocument || domGlobals.document;
	        var doc = eventDoc.documentElement;
	        var body = eventDoc.body;
	        event.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
	        event.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
	      }
	      event.preventDefault = function () {
	        event.isDefaultPrevented = returnTrue;
	        if (originalEvent) {
	          if (originalEvent.preventDefault) {
	            originalEvent.preventDefault();
	          } else {
	            originalEvent.returnValue = false;
	          }
	        }
	      };
	      event.stopPropagation = function () {
	        event.isPropagationStopped = returnTrue;
	        if (originalEvent) {
	          if (originalEvent.stopPropagation) {
	            originalEvent.stopPropagation();
	          } else {
	            originalEvent.cancelBubble = true;
	          }
	        }
	      };
	      event.stopImmediatePropagation = function () {
	        event.isImmediatePropagationStopped = returnTrue;
	        event.stopPropagation();
	      };
	      if (hasIsDefaultPrevented(event) === false) {
	        event.isDefaultPrevented = returnFalse;
	        event.isPropagationStopped = returnFalse;
	        event.isImmediatePropagationStopped = returnFalse;
	      }
	      if (typeof event.metaKey === 'undefined') {
	        event.metaKey = false;
	      }
	      return event;
	    };
	    var bindOnReady = function (win, callback, eventUtils) {
	      var doc = win.document, event = { type: 'ready' };
	      if (eventUtils.domLoaded) {
	        callback(event);
	        return;
	      }
	      var isDocReady = function () {
	        return doc.readyState === 'complete' || doc.readyState === 'interactive' && doc.body;
	      };
	      var readyHandler = function () {
	        removeEvent(win, 'DOMContentLoaded', readyHandler);
	        removeEvent(win, 'load', readyHandler);
	        if (!eventUtils.domLoaded) {
	          eventUtils.domLoaded = true;
	          callback(event);
	        }
	      };
	      if (isDocReady()) {
	        readyHandler();
	      } else {
	        addEvent(win, 'DOMContentLoaded', readyHandler);
	      }
	      addEvent(win, 'load', readyHandler);
	    };
	    var EventUtils = function () {
	      function EventUtils() {
	        this.domLoaded = false;
	        this.events = {};
	        this.count = 1;
	        this.expando = eventExpandoPrefix + (+new Date()).toString(32);
	        this.hasMouseEnterLeave = 'onmouseenter' in domGlobals.document.documentElement;
	        this.hasFocusIn = 'onfocusin' in domGlobals.document.documentElement;
	        this.count = 1;
	      }
	      EventUtils.prototype.bind = function (target, names, callback, scope) {
	        var self = this;
	        var id, callbackList, i, name, fakeName, nativeHandler, capture;
	        var win = domGlobals.window;
	        var defaultNativeHandler = function (evt) {
	          self.executeHandlers(fix(evt || win.event), id);
	        };
	        if (!target || target.nodeType === 3 || target.nodeType === 8) {
	          return;
	        }
	        if (!target[self.expando]) {
	          id = self.count++;
	          target[self.expando] = id;
	          self.events[id] = {};
	        } else {
	          id = target[self.expando];
	        }
	        scope = scope || target;
	        var namesList = names.split(' ');
	        i = namesList.length;
	        while (i--) {
	          name = namesList[i];
	          nativeHandler = defaultNativeHandler;
	          fakeName = capture = false;
	          if (name === 'DOMContentLoaded') {
	            name = 'ready';
	          }
	          if (self.domLoaded && name === 'ready' && target.readyState === 'complete') {
	            callback.call(scope, fix({ type: name }));
	            continue;
	          }
	          if (!self.hasMouseEnterLeave) {
	            fakeName = self.mouseEnterLeave[name];
	            if (fakeName) {
	              nativeHandler = function (evt) {
	                var current, related;
	                current = evt.currentTarget;
	                related = evt.relatedTarget;
	                if (related && current.contains) {
	                  related = current.contains(related);
	                } else {
	                  while (related && related !== current) {
	                    related = related.parentNode;
	                  }
	                }
	                if (!related) {
	                  evt = fix(evt || win.event);
	                  evt.type = evt.type === 'mouseout' ? 'mouseleave' : 'mouseenter';
	                  evt.target = current;
	                  self.executeHandlers(evt, id);
	                }
	              };
	            }
	          }
	          if (!self.hasFocusIn && (name === 'focusin' || name === 'focusout')) {
	            capture = true;
	            fakeName = name === 'focusin' ? 'focus' : 'blur';
	            nativeHandler = function (evt) {
	              evt = fix(evt || win.event);
	              evt.type = evt.type === 'focus' ? 'focusin' : 'focusout';
	              self.executeHandlers(evt, id);
	            };
	          }
	          callbackList = self.events[id][name];
	          if (!callbackList) {
	            self.events[id][name] = callbackList = [{
	                func: callback,
	                scope: scope
	              }];
	            callbackList.fakeName = fakeName;
	            callbackList.capture = capture;
	            callbackList.nativeHandler = nativeHandler;
	            if (name === 'ready') {
	              bindOnReady(target, nativeHandler, self);
	            } else {
	              addEvent(target, fakeName || name, nativeHandler, capture);
	            }
	          } else {
	            if (name === 'ready' && self.domLoaded) {
	              callback(fix({ type: name }));
	            } else {
	              callbackList.push({
	                func: callback,
	                scope: scope
	              });
	            }
	          }
	        }
	        target = callbackList = 0;
	        return callback;
	      };
	      EventUtils.prototype.unbind = function (target, names, callback) {
	        var id, callbackList, i, ci, name, eventMap;
	        if (!target || target.nodeType === 3 || target.nodeType === 8) {
	          return this;
	        }
	        id = target[this.expando];
	        if (id) {
	          eventMap = this.events[id];
	          if (names) {
	            var namesList = names.split(' ');
	            i = namesList.length;
	            while (i--) {
	              name = namesList[i];
	              callbackList = eventMap[name];
	              if (callbackList) {
	                if (callback) {
	                  ci = callbackList.length;
	                  while (ci--) {
	                    if (callbackList[ci].func === callback) {
	                      var nativeHandler = callbackList.nativeHandler;
	                      var fakeName = callbackList.fakeName, capture = callbackList.capture;
	                      callbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));
	                      callbackList.nativeHandler = nativeHandler;
	                      callbackList.fakeName = fakeName;
	                      callbackList.capture = capture;
	                      eventMap[name] = callbackList;
	                    }
	                  }
	                }
	                if (!callback || callbackList.length === 0) {
	                  delete eventMap[name];
	                  removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);
	                }
	              }
	            }
	          } else {
	            for (name in eventMap) {
	              callbackList = eventMap[name];
	              removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);
	            }
	            eventMap = {};
	          }
	          for (name in eventMap) {
	            return this;
	          }
	          delete this.events[id];
	          try {
	            delete target[this.expando];
	          } catch (ex) {
	            target[this.expando] = null;
	          }
	        }
	        return this;
	      };
	      EventUtils.prototype.fire = function (target, name, args) {
	        var id;
	        if (!target || target.nodeType === 3 || target.nodeType === 8) {
	          return this;
	        }
	        var event = fix(null, args);
	        event.type = name;
	        event.target = target;
	        do {
	          id = target[this.expando];
	          if (id) {
	            this.executeHandlers(event, id);
	          }
	          target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;
	        } while (target && !event.isPropagationStopped());
	        return this;
	      };
	      EventUtils.prototype.clean = function (target) {
	        var i, children;
	        if (!target || target.nodeType === 3 || target.nodeType === 8) {
	          return this;
	        }
	        if (target[this.expando]) {
	          this.unbind(target);
	        }
	        if (!target.getElementsByTagName) {
	          target = target.document;
	        }
	        if (target && target.getElementsByTagName) {
	          this.unbind(target);
	          children = target.getElementsByTagName('*');
	          i = children.length;
	          while (i--) {
	            target = children[i];
	            if (target[this.expando]) {
	              this.unbind(target);
	            }
	          }
	        }
	        return this;
	      };
	      EventUtils.prototype.destroy = function () {
	        this.events = {};
	      };
	      EventUtils.prototype.cancel = function (e) {
	        if (e) {
	          e.preventDefault();
	          e.stopImmediatePropagation();
	        }
	        return false;
	      };
	      EventUtils.prototype.executeHandlers = function (evt, id) {
	        var callbackList, i, l, callback;
	        var container = this.events[id];
	        callbackList = container && container[evt.type];
	        if (callbackList) {
	          for (i = 0, l = callbackList.length; i < l; i++) {
	            callback = callbackList[i];
	            if (callback && callback.func.call(callback.scope, evt) === false) {
	              evt.preventDefault();
	            }
	            if (evt.isImmediatePropagationStopped()) {
	              return;
	            }
	          }
	        }
	      };
	      EventUtils.Event = new EventUtils();
	      return EventUtils;
	    }();
	
	    var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains$3, expando = 'sizzle' + -new Date(), preferredDoc = domGlobals.window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function (a, b) {
	        if (a === b) {
	          hasDuplicate = true;
	        }
	        return 0;
	      }, strundefined = typeof undefined, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf$2 = arr.indexOf || function (elem) {
	        var i = 0, len = this.length;
	        for (; i < len; i++) {
	          if (this[i] === elem) {
	            return i;
	          }
	        }
	        return -1;
	      }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped', whitespace = '[\\x20\\t\\r\\n\\f]', identifier = '(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+', attributes = '\\[' + whitespace + '*(' + identifier + ')(?:' + whitespace + '*([*^$|!~]?=)' + whitespace + '*(?:\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)"|(' + identifier + '))|)' + whitespace + '*\\]', pseudos = ':(' + identifier + ')(?:\\((' + '(\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)")|' + '((?:\\\\.|[^\\\\()[\\]]|' + attributes + ')*)|' + '.*' + ')\\)|)', rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rattributeQuotes = new RegExp('=' + whitespace + '*([^\\]\'"]*?)' + whitespace + '*\\]', 'g'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
	        ID: new RegExp('^#(' + identifier + ')'),
	        CLASS: new RegExp('^\\.(' + identifier + ')'),
	        TAG: new RegExp('^(' + identifier + '|[*])'),
	        ATTR: new RegExp('^' + attributes),
	        PSEUDO: new RegExp('^' + pseudos),
	        CHILD: new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
	        bool: new RegExp('^(?:' + booleans + ')$', 'i'),
	        needsContext: new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
	      }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function (_, escaped, escapedWhitespace) {
	        var high = '0x' + escaped - 65536;
	        return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
	      };
	    try {
	      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
	      arr[preferredDoc.childNodes.length].nodeType;
	    } catch (e) {
	      push = {
	        apply: arr.length ? function (target, els) {
	          push_native.apply(target, slice.call(els));
	        } : function (target, els) {
	          var j = target.length, i = 0;
	          while (target[j++] = els[i++]) {
	          }
	          target.length = j - 1;
	        }
	      };
	    }
	    var Sizzle = function (selector, context, results, seed) {
	      var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
	      if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
	        setDocument(context);
	      }
	      context = context || document;
	      results = results || [];
	      if (!selector || typeof selector !== 'string') {
	        return results;
	      }
	      if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
	        return [];
	      }
	      if (documentIsHTML && !seed) {
	        if (match = rquickExpr.exec(selector)) {
	          if (m = match[1]) {
	            if (nodeType === 9) {
	              elem = context.getElementById(m);
	              if (elem && elem.parentNode) {
	                if (elem.id === m) {
	                  results.push(elem);
	                  return results;
	                }
	              } else {
	                return results;
	              }
	            } else {
	              if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains$3(context, elem) && elem.id === m) {
	                results.push(elem);
	                return results;
	              }
	            }
	          } else if (match[2]) {
	            push.apply(results, context.getElementsByTagName(selector));
	            return results;
	          } else if ((m = match[3]) && support.getElementsByClassName) {
	            push.apply(results, context.getElementsByClassName(m));
	            return results;
	          }
	        }
	        if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
	          nid = old = expando;
	          newContext = context;
	          newSelector = nodeType === 9 && selector;
	          if (nodeType === 1 && context.nodeName.toLowerCase() !== 'object') {
	            groups = tokenize(selector);
	            if (old = context.getAttribute('id')) {
	              nid = old.replace(rescape, '\\$&');
	            } else {
	              context.setAttribute('id', nid);
	            }
	            nid = '[id=\'' + nid + '\'] ';
	            i = groups.length;
	            while (i--) {
	              groups[i] = nid + toSelector(groups[i]);
	            }
	            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
	            newSelector = groups.join(',');
	          }
	          if (newSelector) {
	            try {
	              push.apply(results, newContext.querySelectorAll(newSelector));
	              return results;
	            } catch (qsaError) {
	            } finally {
	              if (!old) {
	                context.removeAttribute('id');
	              }
	            }
	          }
	        }
	      }
	      return select(selector.replace(rtrim, '$1'), context, results, seed);
	    };
	    function createCache() {
	      var keys = [];
	      function cache(key, value) {
	        if (keys.push(key + ' ') > Expr.cacheLength) {
	          delete cache[keys.shift()];
	        }
	        return cache[key + ' '] = value;
	      }
	      return cache;
	    }
	    function markFunction(fn) {
	      fn[expando] = true;
	      return fn;
	    }
	    function siblingCheck(a, b) {
	      var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
	      if (diff) {
	        return diff;
	      }
	      if (cur) {
	        while (cur = cur.nextSibling) {
	          if (cur === b) {
	            return -1;
	          }
	        }
	      }
	      return a ? 1 : -1;
	    }
	    function createInputPseudo(type) {
	      return function (elem) {
	        var name = elem.nodeName.toLowerCase();
	        return name === 'input' && elem.type === type;
	      };
	    }
	    function createButtonPseudo(type) {
	      return function (elem) {
	        var name = elem.nodeName.toLowerCase();
	        return (name === 'input' || name === 'button') && elem.type === type;
	      };
	    }
	    function createPositionalPseudo(fn) {
	      return markFunction(function (argument) {
	        argument = +argument;
	        return markFunction(function (seed, matches) {
	          var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
	          while (i--) {
	            if (seed[j = matchIndexes[i]]) {
	              seed[j] = !(matches[j] = seed[j]);
	            }
	          }
	        });
	      });
	    }
	    function testContext(context) {
	      return context && typeof context.getElementsByTagName !== strundefined && context;
	    }
	    support = Sizzle.support = {};
	    isXML = Sizzle.isXML = function (elem) {
	      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	      return documentElement ? documentElement.nodeName !== 'HTML' : false;
	    };
	    setDocument = Sizzle.setDocument = function (node) {
	      var hasCompare, doc = node ? node.ownerDocument || node : preferredDoc, parent = doc.defaultView;
	      function getTop(win) {
	        try {
	          return win.top;
	        } catch (ex) {
	        }
	        return null;
	      }
	      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
	        return document;
	      }
	      document = doc;
	      docElem = doc.documentElement;
	      documentIsHTML = !isXML(doc);
	      if (parent && parent !== getTop(parent)) {
	        if (parent.addEventListener) {
	          parent.addEventListener('unload', function () {
	            setDocument();
	          }, false);
	        } else if (parent.attachEvent) {
	          parent.attachEvent('onunload', function () {
	            setDocument();
	          });
	        }
	      }
	      support.attributes = true;
	      support.getElementsByTagName = true;
	      support.getElementsByClassName = rnative.test(doc.getElementsByClassName);
	      support.getById = true;
	      Expr.find.ID = function (id, context) {
	        if (typeof context.getElementById !== strundefined && documentIsHTML) {
	          var m = context.getElementById(id);
	          return m && m.parentNode ? [m] : [];
	        }
	      };
	      Expr.filter.ID = function (id) {
	        var attrId = id.replace(runescape, funescape);
	        return function (elem) {
	          return elem.getAttribute('id') === attrId;
	        };
	      };
	      Expr.find.TAG = support.getElementsByTagName ? function (tag, context) {
	        if (typeof context.getElementsByTagName !== strundefined) {
	          return context.getElementsByTagName(tag);
	        }
	      } : function (tag, context) {
	        var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
	        if (tag === '*') {
	          while (elem = results[i++]) {
	            if (elem.nodeType === 1) {
	              tmp.push(elem);
	            }
	          }
	          return tmp;
	        }
	        return results;
	      };
	      Expr.find.CLASS = support.getElementsByClassName && function (className, context) {
	        if (documentIsHTML) {
	          return context.getElementsByClassName(className);
	        }
	      };
	      rbuggyMatches = [];
	      rbuggyQSA = [];
	      support.disconnectedMatch = true;
	      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
	      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
	      hasCompare = rnative.test(docElem.compareDocumentPosition);
	      contains$3 = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
	        var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
	        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
	      } : function (a, b) {
	        if (b) {
	          while (b = b.parentNode) {
	            if (b === a) {
	              return true;
	            }
	          }
	        }
	        return false;
	      };
	      sortOrder = hasCompare ? function (a, b) {
	        if (a === b) {
	          hasDuplicate = true;
	          return 0;
	        }
	        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
	        if (compare) {
	          return compare;
	        }
	        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
	        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
	          if (a === doc || a.ownerDocument === preferredDoc && contains$3(preferredDoc, a)) {
	            return -1;
	          }
	          if (b === doc || b.ownerDocument === preferredDoc && contains$3(preferredDoc, b)) {
	            return 1;
	          }
	          return sortInput ? indexOf$2.call(sortInput, a) - indexOf$2.call(sortInput, b) : 0;
	        }
	        return compare & 4 ? -1 : 1;
	      } : function (a, b) {
	        if (a === b) {
	          hasDuplicate = true;
	          return 0;
	        }
	        var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
	        if (!aup || !bup) {
	          return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf$2.call(sortInput, a) - indexOf$2.call(sortInput, b) : 0;
	        } else if (aup === bup) {
	          return siblingCheck(a, b);
	        }
	        cur = a;
	        while (cur = cur.parentNode) {
	          ap.unshift(cur);
	        }
	        cur = b;
	        while (cur = cur.parentNode) {
	          bp.unshift(cur);
	        }
	        while (ap[i] === bp[i]) {
	          i++;
	        }
	        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
	      };
	      return doc;
	    };
	    Sizzle.matches = function (expr, elements) {
	      return Sizzle(expr, null, null, elements);
	    };
	    Sizzle.matchesSelector = function (elem, expr) {
	      if ((elem.ownerDocument || elem) !== document) {
	        setDocument(elem);
	      }
	      expr = expr.replace(rattributeQuotes, '=\'$1\']');
	      if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
	        try {
	          var ret = matches.call(elem, expr);
	          if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
	            return ret;
	          }
	        } catch (e) {
	        }
	      }
	      return Sizzle(expr, document, null, [elem]).length > 0;
	    };
	    Sizzle.contains = function (context, elem) {
	      if ((context.ownerDocument || context) !== document) {
	        setDocument(context);
	      }
	      return contains$3(context, elem);
	    };
	    Sizzle.attr = function (elem, name) {
	      if ((elem.ownerDocument || elem) !== document) {
	        setDocument(elem);
	      }
	      var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
	      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
	    };
	    Sizzle.error = function (msg) {
	      throw new Error('Syntax error, unrecognized expression: ' + msg);
	    };
	    Sizzle.uniqueSort = function (results) {
	      var elem, duplicates = [], j = 0, i = 0;
	      hasDuplicate = !support.detectDuplicates;
	      sortInput = !support.sortStable && results.slice(0);
	      results.sort(sortOrder);
	      if (hasDuplicate) {
	        while (elem = results[i++]) {
	          if (elem === results[i]) {
	            j = duplicates.push(i);
	          }
	        }
	        while (j--) {
	          results.splice(duplicates[j], 1);
	        }
	      }
	      sortInput = null;
	      return results;
	    };
	    getText = Sizzle.getText = function (elem) {
	      var node, ret = '', i = 0, nodeType = elem.nodeType;
	      if (!nodeType) {
	        while (node = elem[i++]) {
	          ret += getText(node);
	        }
	      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
	        if (typeof elem.textContent === 'string') {
	          return elem.textContent;
	        } else {
	          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
	            ret += getText(elem);
	          }
	        }
	      } else if (nodeType === 3 || nodeType === 4) {
	        return elem.nodeValue;
	      }
	      return ret;
	    };
	    Expr = Sizzle.selectors = {
	      cacheLength: 50,
	      createPseudo: markFunction,
	      match: matchExpr,
	      attrHandle: {},
	      find: {},
	      relative: {
	        '>': {
	          dir: 'parentNode',
	          first: true
	        },
	        ' ': { dir: 'parentNode' },
	        '+': {
	          dir: 'previousSibling',
	          first: true
	        },
	        '~': { dir: 'previousSibling' }
	      },
	      preFilter: {
	        ATTR: function (match) {
	          match[1] = match[1].replace(runescape, funescape);
	          match[3] = (match[3] || match[4] || match[5] || '').replace(runescape, funescape);
	          if (match[2] === '~=') {
	            match[3] = ' ' + match[3] + ' ';
	          }
	          return match.slice(0, 4);
	        },
	        CHILD: function (match) {
	          match[1] = match[1].toLowerCase();
	          if (match[1].slice(0, 3) === 'nth') {
	            if (!match[3]) {
	              Sizzle.error(match[0]);
	            }
	            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
	            match[5] = +(match[7] + match[8] || match[3] === 'odd');
	          } else if (match[3]) {
	            Sizzle.error(match[0]);
	          }
	          return match;
	        },
	        PSEUDO: function (match) {
	          var excess, unquoted = !match[6] && match[2];
	          if (matchExpr.CHILD.test(match[0])) {
	            return null;
	          }
	          if (match[3]) {
	            match[2] = match[4] || match[5] || '';
	          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
	            match[0] = match[0].slice(0, excess);
	            match[2] = unquoted.slice(0, excess);
	          }
	          return match.slice(0, 3);
	        }
	      },
	      filter: {
	        TAG: function (nodeNameSelector) {
	          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
	          return nodeNameSelector === '*' ? function () {
	            return true;
	          } : function (elem) {
	            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
	          };
	        },
	        CLASS: function (className) {
	          var pattern = classCache[className + ' '];
	          return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
	            return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute('class') || '');
	          });
	        },
	        ATTR: function (name, operator, check) {
	          return function (elem) {
	            var result = Sizzle.attr(elem, name);
	            if (result == null) {
	              return operator === '!=';
	            }
	            if (!operator) {
	              return true;
	            }
	            result += '';
	            return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;
	          };
	        },
	        CHILD: function (type, what, argument, first, last) {
	          var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
	          return first === 1 && last === 0 ? function (elem) {
	            return !!elem.parentNode;
	          } : function (elem, context, xml) {
	            var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
	            if (parent) {
	              if (simple) {
	                while (dir) {
	                  node = elem;
	                  while (node = node[dir]) {
	                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
	                      return false;
	                    }
	                  }
	                  start = dir = type === 'only' && !start && 'nextSibling';
	                }
	                return true;
	              }
	              start = [forward ? parent.firstChild : parent.lastChild];
	              if (forward && useCache) {
	                outerCache = parent[expando] || (parent[expando] = {});
	                cache = outerCache[type] || [];
	                nodeIndex = cache[0] === dirruns && cache[1];
	                diff = cache[0] === dirruns && cache[2];
	                node = nodeIndex && parent.childNodes[nodeIndex];
	                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
	                  if (node.nodeType === 1 && ++diff && node === elem) {
	                    outerCache[type] = [
	                      dirruns,
	                      nodeIndex,
	                      diff
	                    ];
	                    break;
	                  }
	                }
	              } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
	                diff = cache[1];
	              } else {
	                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
	                  if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
	                    if (useCache) {
	                      (node[expando] || (node[expando] = {}))[type] = [
	                        dirruns,
	                        diff
	                      ];
	                    }
	                    if (node === elem) {
	                      break;
	                    }
	                  }
	                }
	              }
	              diff -= last;
	              return diff === first || diff % first === 0 && diff / first >= 0;
	            }
	          };
	        },
	        PSEUDO: function (pseudo, argument) {
	          var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
	          if (fn[expando]) {
	            return fn(argument);
	          }
	          if (fn.length > 1) {
	            args = [
	              pseudo,
	              pseudo,
	              '',
	              argument
	            ];
	            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
	              var idx, matched = fn(seed, argument), i = matched.length;
	              while (i--) {
	                idx = indexOf$2.call(seed, matched[i]);
	                seed[idx] = !(matches[idx] = matched[i]);
	              }
	            }) : function (elem) {
	              return fn(elem, 0, args);
	            };
	          }
	          return fn;
	        }
	      },
	      pseudos: {
	        not: markFunction(function (selector) {
	          var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
	          return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
	            var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
	            while (i--) {
	              if (elem = unmatched[i]) {
	                seed[i] = !(matches[i] = elem);
	              }
	            }
	          }) : function (elem, context, xml) {
	            input[0] = elem;
	            matcher(input, null, xml, results);
	            return !results.pop();
	          };
	        }),
	        has: markFunction(function (selector) {
	          return function (elem) {
	            return Sizzle(selector, elem).length > 0;
	          };
	        }),
	        contains: markFunction(function (text) {
	          text = text.replace(runescape, funescape);
	          return function (elem) {
	            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
	          };
	        }),
	        lang: markFunction(function (lang) {
	          if (!ridentifier.test(lang || '')) {
	            Sizzle.error('unsupported lang: ' + lang);
	          }
	          lang = lang.replace(runescape, funescape).toLowerCase();
	          return function (elem) {
	            var elemLang;
	            do {
	              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
	                elemLang = elemLang.toLowerCase();
	                return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
	              }
	            } while ((elem = elem.parentNode) && elem.nodeType === 1);
	            return false;
	          };
	        }),
	        target: function (elem) {
	          var hash = domGlobals.window.location && domGlobals.window.location.hash;
	          return hash && hash.slice(1) === elem.id;
	        },
	        root: function (elem) {
	          return elem === docElem;
	        },
	        focus: function (elem) {
	          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
	        },
	        enabled: function (elem) {
	          return elem.disabled === false;
	        },
	        disabled: function (elem) {
	          return elem.disabled === true;
	        },
	        checked: function (elem) {
	          var nodeName = elem.nodeName.toLowerCase();
	          return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
	        },
	        selected: function (elem) {
	          if (elem.parentNode) {
	            elem.parentNode.selectedIndex;
	          }
	          return elem.selected === true;
	        },
	        empty: function (elem) {
	          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
	            if (elem.nodeType < 6) {
	              return false;
	            }
	          }
	          return true;
	        },
	        parent: function (elem) {
	          return !Expr.pseudos.empty(elem);
	        },
	        header: function (elem) {
	          return rheader.test(elem.nodeName);
	        },
	        input: function (elem) {
	          return rinputs.test(elem.nodeName);
	        },
	        button: function (elem) {
	          var name = elem.nodeName.toLowerCase();
	          return name === 'input' && elem.type === 'button' || name === 'button';
	        },
	        text: function (elem) {
	          var attr;
	          return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text');
	        },
	        first: createPositionalPseudo(function () {
	          return [0];
	        }),
	        last: createPositionalPseudo(function (matchIndexes, length) {
	          return [length - 1];
	        }),
	        eq: createPositionalPseudo(function (matchIndexes, length, argument) {
	          return [argument < 0 ? argument + length : argument];
	        }),
	        even: createPositionalPseudo(function (matchIndexes, length) {
	          var i = 0;
	          for (; i < length; i += 2) {
	            matchIndexes.push(i);
	          }
	          return matchIndexes;
	        }),
	        odd: createPositionalPseudo(function (matchIndexes, length) {
	          var i = 1;
	          for (; i < length; i += 2) {
	            matchIndexes.push(i);
	          }
	          return matchIndexes;
	        }),
	        lt: createPositionalPseudo(function (matchIndexes, length, argument) {
	          var i = argument < 0 ? argument + length : argument;
	          for (; --i >= 0;) {
	            matchIndexes.push(i);
	          }
	          return matchIndexes;
	        }),
	        gt: createPositionalPseudo(function (matchIndexes, length, argument) {
	          var i = argument < 0 ? argument + length : argument;
	          for (; ++i < length;) {
	            matchIndexes.push(i);
	          }
	          return matchIndexes;
	        })
	      }
	    };
	    Expr.pseudos.nth = Expr.pseudos.eq;
	    for (i in {
	        radio: true,
	        checkbox: true,
	        file: true,
	        password: true,
	        image: true
	      }) {
	      Expr.pseudos[i] = createInputPseudo(i);
	    }
	    for (i in {
	        submit: true,
	        reset: true
	      }) {
	      Expr.pseudos[i] = createButtonPseudo(i);
	    }
	    function setFilters() {
	    }
	    setFilters.prototype = Expr.filters = Expr.pseudos;
	    Expr.setFilters = new setFilters();
	    tokenize = Sizzle.tokenize = function (selector, parseOnly) {
	      var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
	      if (cached) {
	        return parseOnly ? 0 : cached.slice(0);
	      }
	      soFar = selector;
	      groups = [];
	      preFilters = Expr.preFilter;
	      while (soFar) {
	        if (!matched || (match = rcomma.exec(soFar))) {
	          if (match) {
	            soFar = soFar.slice(match[0].length) || soFar;
	          }
	          groups.push(tokens = []);
	        }
	        matched = false;
	        if (match = rcombinators.exec(soFar)) {
	          matched = match.shift();
	          tokens.push({
	            value: matched,
	            type: match[0].replace(rtrim, ' ')
	          });
	          soFar = soFar.slice(matched.length);
	        }
	        for (type in Expr.filter) {
	          if (!Expr.filter.hasOwnProperty(type))
	            continue;
	          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
	            matched = match.shift();
	            tokens.push({
	              value: matched,
	              type: type,
	              matches: match
	            });
	            soFar = soFar.slice(matched.length);
	          }
	        }
	        if (!matched) {
	          break;
	        }
	      }
	      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
	    };
	    function toSelector(tokens) {
	      var i = 0, len = tokens.length, selector = '';
	      for (; i < len; i++) {
	        selector += tokens[i].value;
	      }
	      return selector;
	    }
	    function addCombinator(matcher, combinator, base) {
	      var dir = combinator.dir, checkNonElements = base && dir === 'parentNode', doneName = done++;
	      return combinator.first ? function (elem, context, xml) {
	        while (elem = elem[dir]) {
	          if (elem.nodeType === 1 || checkNonElements) {
	            return matcher(elem, context, xml);
	          }
	        }
	      } : function (elem, context, xml) {
	        var oldCache, outerCache, newCache = [
	            dirruns,
	            doneName
	          ];
	        if (xml) {
	          while (elem = elem[dir]) {
	            if (elem.nodeType === 1 || checkNonElements) {
	              if (matcher(elem, context, xml)) {
	                return true;
	              }
	            }
	          }
	        } else {
	          while (elem = elem[dir]) {
	            if (elem.nodeType === 1 || checkNonElements) {
	              outerCache = elem[expando] || (elem[expando] = {});
	              if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
	                return newCache[2] = oldCache[2];
	              } else {
	                outerCache[dir] = newCache;
	                if (newCache[2] = matcher(elem, context, xml)) {
	                  return true;
	                }
	              }
	            }
	          }
	        }
	      };
	    }
	    function elementMatcher(matchers) {
	      return matchers.length > 1 ? function (elem, context, xml) {
	        var i = matchers.length;
	        while (i--) {
	          if (!matchers[i](elem, context, xml)) {
	            return false;
	          }
	        }
	        return true;
	      } : matchers[0];
	    }
	    function multipleContexts(selector, contexts, results) {
	      var i = 0, len = contexts.length;
	      for (; i < len; i++) {
	        Sizzle(selector, contexts[i], results);
	      }
	      return results;
	    }
	    function condense(unmatched, map, filter, context, xml) {
	      var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
	      for (; i < len; i++) {
	        if (elem = unmatched[i]) {
	          if (!filter || filter(elem, context, xml)) {
	            newUnmatched.push(elem);
	            if (mapped) {
	              map.push(i);
	            }
	          }
	        }
	      }
	      return newUnmatched;
	    }
	    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
	      if (postFilter && !postFilter[expando]) {
	        postFilter = setMatcher(postFilter);
	      }
	      if (postFinder && !postFinder[expando]) {
	        postFinder = setMatcher(postFinder, postSelector);
	      }
	      return markFunction(function (seed, results, context, xml) {
	        var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
	        if (matcher) {
	          matcher(matcherIn, matcherOut, context, xml);
	        }
	        if (postFilter) {
	          temp = condense(matcherOut, postMap);
	          postFilter(temp, [], context, xml);
	          i = temp.length;
	          while (i--) {
	            if (elem = temp[i]) {
	              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
	            }
	          }
	        }
	        if (seed) {
	          if (postFinder || preFilter) {
	            if (postFinder) {
	              temp = [];
	              i = matcherOut.length;
	              while (i--) {
	                if (elem = matcherOut[i]) {
	                  temp.push(matcherIn[i] = elem);
	                }
	              }
	              postFinder(null, matcherOut = [], temp, xml);
	            }
	            i = matcherOut.length;
	            while (i--) {
	              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf$2.call(seed, elem) : preMap[i]) > -1) {
	                seed[temp] = !(results[temp] = elem);
	              }
	            }
	          }
	        } else {
	          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
	          if (postFinder) {
	            postFinder(null, results, matcherOut, xml);
	          } else {
	            push.apply(results, matcherOut);
	          }
	        }
	      });
	    }
	    function matcherFromTokens(tokens) {
	      var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
	          return elem === checkContext;
	        }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
	          return indexOf$2.call(checkContext, elem) > -1;
	        }, implicitRelative, true), matchers = [function (elem, context, xml) {
	            return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
	          }];
	      for (; i < len; i++) {
	        if (matcher = Expr.relative[tokens[i].type]) {
	          matchers = [addCombinator(elementMatcher(matchers), matcher)];
	        } else {
	          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
	          if (matcher[expando]) {
	            j = ++i;
	            for (; j < len; j++) {
	              if (Expr.relative[tokens[j].type]) {
	                break;
	              }
	            }
	            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
	          }
	          matchers.push(matcher);
	        }
	      }
	      return elementMatcher(matchers);
	    }
	    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
	      var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, outermost) {
	          var elem, j, matcher, matchedCount = 0, i = '0', unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG('*', outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
	          if (outermost) {
	            outermostContext = context !== document && context;
	          }
	          for (; i !== len && (elem = elems[i]) != null; i++) {
	            if (byElement && elem) {
	              j = 0;
	              while (matcher = elementMatchers[j++]) {
	                if (matcher(elem, context, xml)) {
	                  results.push(elem);
	                  break;
	                }
	              }
	              if (outermost) {
	                dirruns = dirrunsUnique;
	              }
	            }
	            if (bySet) {
	              if (elem = !matcher && elem) {
	                matchedCount--;
	              }
	              if (seed) {
	                unmatched.push(elem);
	              }
	            }
	          }
	          matchedCount += i;
	          if (bySet && i !== matchedCount) {
	            j = 0;
	            while (matcher = setMatchers[j++]) {
	              matcher(unmatched, setMatched, context, xml);
	            }
	            if (seed) {
	              if (matchedCount > 0) {
	                while (i--) {
	                  if (!(unmatched[i] || setMatched[i])) {
	                    setMatched[i] = pop.call(results);
	                  }
	                }
	              }
	              setMatched = condense(setMatched);
	            }
	            push.apply(results, setMatched);
	            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
	              Sizzle.uniqueSort(results);
	            }
	          }
	          if (outermost) {
	            dirruns = dirrunsUnique;
	            outermostContext = contextBackup;
	          }
	          return unmatched;
	        };
	      return bySet ? markFunction(superMatcher) : superMatcher;
	    }
	    compile = Sizzle.compile = function (selector, match) {
	      var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
	      if (!cached) {
	        if (!match) {
	          match = tokenize(selector);
	        }
	        i = match.length;
	        while (i--) {
	          cached = matcherFromTokens(match[i]);
	          if (cached[expando]) {
	            setMatchers.push(cached);
	          } else {
	            elementMatchers.push(cached);
	          }
	        }
	        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
	        cached.selector = selector;
	      }
	      return cached;
	    };
	    select = Sizzle.select = function (selector, context, results, seed) {
	      var i, tokens, token, type, find, compiled = typeof selector === 'function' && selector, match = !seed && tokenize(selector = compiled.selector || selector);
	      results = results || [];
	      if (match.length === 1) {
	        tokens = match[0] = match[0].slice(0);
	        if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
	          context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0];
	          if (!context) {
	            return results;
	          } else if (compiled) {
	            context = context.parentNode;
	          }
	          selector = selector.slice(tokens.shift().value.length);
	        }
	        i = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
	        while (i--) {
	          token = tokens[i];
	          if (Expr.relative[type = token.type]) {
	            break;
	          }
	          if (find = Expr.find[type]) {
	            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
	              tokens.splice(i, 1);
	              selector = seed.length && toSelector(tokens);
	              if (!selector) {
	                push.apply(results, seed);
	                return results;
	              }
	              break;
	            }
	          }
	        }
	      }
	      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
	      return results;
	    };
	    support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
	    support.detectDuplicates = !!hasDuplicate;
	    setDocument();
	    support.sortDetached = true;
	
	    var doc = domGlobals.document, push$1 = Array.prototype.push, slice$1 = Array.prototype.slice;
	    var rquickExpr$1 = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/;
	    var Event = EventUtils.Event;
	    var skipUniques = Tools.makeMap('children,contents,next,prev');
	    var isDefined = function (obj) {
	      return typeof obj !== 'undefined';
	    };
	    var isString$1 = function (obj) {
	      return typeof obj === 'string';
	    };
	    var isWindow = function (obj) {
	      return obj && obj === obj.window;
	    };
	    var createFragment = function (html, fragDoc) {
	      var frag, node, container;
	      fragDoc = fragDoc || doc;
	      container = fragDoc.createElement('div');
	      frag = fragDoc.createDocumentFragment();
	      container.innerHTML = html;
	      while (node = container.firstChild) {
	        frag.appendChild(node);
	      }
	      return frag;
	    };
	    var domManipulate = function (targetNodes, sourceItem, callback, reverse) {
	      var i;
	      if (isString$1(sourceItem)) {
	        sourceItem = createFragment(sourceItem, getElementDocument(targetNodes[0]));
	      } else if (sourceItem.length && !sourceItem.nodeType) {
	        sourceItem = DomQuery.makeArray(sourceItem);
	        if (reverse) {
	          for (i = sourceItem.length - 1; i >= 0; i--) {
	            domManipulate(targetNodes, sourceItem[i], callback, reverse);
	          }
	        } else {
	          for (i = 0; i < sourceItem.length; i++) {
	            domManipulate(targetNodes, sourceItem[i], callback, reverse);
	          }
	        }
	        return targetNodes;
	      }
	      if (sourceItem.nodeType) {
	        i = targetNodes.length;
	        while (i--) {
	          callback.call(targetNodes[i], sourceItem);
	        }
	      }
	      return targetNodes;
	    };
	    var hasClass = function (node, className) {
	      return node && className && (' ' + node.className + ' ').indexOf(' ' + className + ' ') !== -1;
	    };
	    var wrap$1 = function (elements, wrapper, all) {
	      var lastParent, newWrapper;
	      wrapper = DomQuery(wrapper)[0];
	      elements.each(function () {
	        var self = this;
	        if (!all || lastParent !== self.parentNode) {
	          lastParent = self.parentNode;
	          newWrapper = wrapper.cloneNode(false);
	          self.parentNode.insertBefore(newWrapper, self);
	          newWrapper.appendChild(self);
	        } else {
	          newWrapper.appendChild(self);
	        }
	      });
	      return elements;
	    };
	    var numericCssMap = Tools.makeMap('fillOpacity fontWeight lineHeight opacity orphans widows zIndex zoom', ' ');
	    var booleanMap = Tools.makeMap('checked compact declare defer disabled ismap multiple nohref noshade nowrap readonly selected', ' ');
	    var propFix = {
	      for: 'htmlFor',
	      class: 'className',
	      readonly: 'readOnly'
	    };
	    var cssFix = { float: 'cssFloat' };
	    var attrHooks = {}, cssHooks = {};
	    var DomQueryConstructor = function (selector, context) {
	      return new DomQuery.fn.init(selector, context);
	    };
	    var inArray$1 = function (item, array) {
	      var i;
	      if (array.indexOf) {
	        return array.indexOf(item);
	      }
	      i = array.length;
	      while (i--) {
	        if (array[i] === item) {
	          return i;
	        }
	      }
	      return -1;
	    };
	    var whiteSpaceRegExp$1 = /^\s*|\s*$/g;
	    var trim$2 = function (str) {
	      return str === null || str === undefined ? '' : ('' + str).replace(whiteSpaceRegExp$1, '');
	    };
	    var each$4 = function (obj, callback) {
	      var length, key, i, value;
	      if (obj) {
	        length = obj.length;
	        if (length === undefined) {
	          for (key in obj) {
	            if (obj.hasOwnProperty(key)) {
	              value = obj[key];
	              if (callback.call(value, key, value) === false) {
	                break;
	              }
	            }
	          }
	        } else {
	          for (i = 0; i < length; i++) {
	            value = obj[i];
	            if (callback.call(value, i, value) === false) {
	              break;
	            }
	          }
	        }
	      }
	      return obj;
	    };
	    var grep = function (array, callback) {
	      var out = [];
	      each$4(array, function (i, item) {
	        if (callback(item, i)) {
	          out.push(item);
	        }
	      });
	      return out;
	    };
	    var getElementDocument = function (element) {
	      if (!element) {
	        return doc;
	      }
	      if (element.nodeType === 9) {
	        return element;
	      }
	      return element.ownerDocument;
	    };
	    DomQueryConstructor.fn = DomQueryConstructor.prototype = {
	      constructor: DomQueryConstructor,
	      selector: '',
	      context: null,
	      length: 0,
	      init: function (selector, context) {
	        var self = this;
	        var match, node;
	        if (!selector) {
	          return self;
	        }
	        if (selector.nodeType) {
	          self.context = self[0] = selector;
	          self.length = 1;
	          return self;
	        }
	        if (context && context.nodeType) {
	          self.context = context;
	        } else {
	          if (context) {
	            return DomQuery(selector).attr(context);
	          }
	          self.context = context = domGlobals.document;
	        }
	        if (isString$1(selector)) {
	          self.selector = selector;
	          if (selector.charAt(0) === '<' && selector.charAt(selector.length - 1) === '>' && selector.length >= 3) {
	            match = [
	              null,
	              selector,
	              null
	            ];
	          } else {
	            match = rquickExpr$1.exec(selector);
	          }
	          if (match) {
	            if (match[1]) {
	              node = createFragment(selector, getElementDocument(context)).firstChild;
	              while (node) {
	                push$1.call(self, node);
	                node = node.nextSibling;
	              }
	            } else {
	              node = getElementDocument(context).getElementById(match[2]);
	              if (!node) {
	                return self;
	              }
	              if (node.id !== match[2]) {
	                return self.find(selector);
	              }
	              self.length = 1;
	              self[0] = node;
	            }
	          } else {
	            return DomQuery(context).find(selector);
	          }
	        } else {
	          this.add(selector, false);
	        }
	        return self;
	      },
	      toArray: function () {
	        return Tools.toArray(this);
	      },
	      add: function (items, sort) {
	        var self = this;
	        var nodes, i;
	        if (isString$1(items)) {
	          return self.add(DomQuery(items));
	        }
	        if (sort !== false) {
	          nodes = DomQuery.unique(self.toArray().concat(DomQuery.makeArray(items)));
	          self.length = nodes.length;
	          for (i = 0; i < nodes.length; i++) {
	            self[i] = nodes[i];
	          }
	        } else {
	          push$1.apply(self, DomQuery.makeArray(items));
	        }
	        return self;
	      },
	      attr: function (name, value) {
	        var self = this;
	        var hook;
	        if (typeof name === 'object') {
	          each$4(name, function (name, value) {
	            self.attr(name, value);
	          });
	        } else if (isDefined(value)) {
	          this.each(function () {
	            var hook;
	            if (this.nodeType === 1) {
	              hook = attrHooks[name];
	              if (hook && hook.set) {
	                hook.set(this, value);
	                return;
	              }
	              if (value === null) {
	                this.removeAttribute(name, 2);
	              } else {
	                this.setAttribute(name, value, 2);
	              }
	            }
	          });
	        } else {
	          if (self[0] && self[0].nodeType === 1) {
	            hook = attrHooks[name];
	            if (hook && hook.get) {
	              return hook.get(self[0], name);
	            }
	            if (booleanMap[name]) {
	              return self.prop(name) ? name : undefined;
	            }
	            value = self[0].getAttribute(name, 2);
	            if (value === null) {
	              value = undefined;
	            }
	          }
	          return value;
	        }
	        return self;
	      },
	      removeAttr: function (name) {
	        return this.attr(name, null);
	      },
	      prop: function (name, value) {
	        var self = this;
	        name = propFix[name] || name;
	        if (typeof name === 'object') {
	          each$4(name, function (name, value) {
	            self.prop(name, value);
	          });
	        } else if (isDefined(value)) {
	          this.each(function () {
	            if (this.nodeType === 1) {
	              this[name] = value;
	            }
	          });
	        } else {
	          if (self[0] && self[0].nodeType && name in self[0]) {
	            return self[0][name];
	          }
	          return value;
	        }
	        return self;
	      },
	      css: function (name, value) {
	        var self = this;
	        var elm, hook;
	        var camel = function (name) {
	          return name.replace(/-(\D)/g, function (a, b) {
	            return b.toUpperCase();
	          });
	        };
	        var dashed = function (name) {
	          return name.replace(/[A-Z]/g, function (a) {
	            return '-' + a;
	          });
	        };
	        if (typeof name === 'object') {
	          each$4(name, function (name, value) {
	            self.css(name, value);
	          });
	        } else {
	          if (isDefined(value)) {
	            name = camel(name);
	            if (typeof value === 'number' && !numericCssMap[name]) {
	              value = value.toString() + 'px';
	            }
	            self.each(function () {
	              var style = this.style;
	              hook = cssHooks[name];
	              if (hook && hook.set) {
	                hook.set(this, value);
	                return;
	              }
	              try {
	                this.style[cssFix[name] || name] = value;
	              } catch (ex) {
	              }
	              if (value === null || value === '') {
	                if (style.removeProperty) {
	                  style.removeProperty(dashed(name));
	                } else {
	                  style.removeAttribute(name);
	                }
	              }
	            });
	          } else {
	            elm = self[0];
	            hook = cssHooks[name];
	            if (hook && hook.get) {
	              return hook.get(elm);
	            }
	            if (elm.ownerDocument.defaultView) {
	              try {
	                return elm.ownerDocument.defaultView.getComputedStyle(elm, null).getPropertyValue(dashed(name));
	              } catch (ex) {
	                return undefined;
	              }
	            } else if (elm.currentStyle) {
	              return elm.currentStyle[camel(name)];
	            } else {
	              return '';
	            }
	          }
	        }
	        return self;
	      },
	      remove: function () {
	        var self = this;
	        var node, i = this.length;
	        while (i--) {
	          node = self[i];
	          Event.clean(node);
	          if (node.parentNode) {
	            node.parentNode.removeChild(node);
	          }
	        }
	        return this;
	      },
	      empty: function () {
	        var self = this;
	        var node, i = this.length;
	        while (i--) {
	          node = self[i];
	          while (node.firstChild) {
	            node.removeChild(node.firstChild);
	          }
	        }
	        return this;
	      },
	      html: function (value) {
	        var self = this;
	        var i;
	        if (isDefined(value)) {
	          i = self.length;
	          try {
	            while (i--) {
	              self[i].innerHTML = value;
	            }
	          } catch (ex) {
	            DomQuery(self[i]).empty().append(value);
	          }
	          return self;
	        }
	        return self[0] ? self[0].innerHTML : '';
	      },
	      text: function (value) {
	        var self = this;
	        var i;
	        if (isDefined(value)) {
	          i = self.length;
	          while (i--) {
	            if ('innerText' in self[i]) {
	              self[i].innerText = value;
	            } else {
	              self[0].textContent = value;
	            }
	          }
	          return self;
	        }
	        return self[0] ? self[0].innerText || self[0].textContent : '';
	      },
	      append: function () {
	        return domManipulate(this, arguments, function (node) {
	          if (this.nodeType === 1 || this.host && this.host.nodeType === 1) {
	            this.appendChild(node);
	          }
	        });
	      },
	      prepend: function () {
	        return domManipulate(this, arguments, function (node) {
	          if (this.nodeType === 1 || this.host && this.host.nodeType === 1) {
	            this.insertBefore(node, this.firstChild);
	          }
	        }, true);
	      },
	      before: function () {
	        var self = this;
	        if (self[0] && self[0].parentNode) {
	          return domManipulate(self, arguments, function (node) {
	            this.parentNode.insertBefore(node, this);
	          });
	        }
	        return self;
	      },
	      after: function () {
	        var self = this;
	        if (self[0] && self[0].parentNode) {
	          return domManipulate(self, arguments, function (node) {
	            this.parentNode.insertBefore(node, this.nextSibling);
	          }, true);
	        }
	        return self;
	      },
	      appendTo: function (val) {
	        DomQuery(val).append(this);
	        return this;
	      },
	      prependTo: function (val) {
	        DomQuery(val).prepend(this);
	        return this;
	      },
	      replaceWith: function (content) {
	        return this.before(content).remove();
	      },
	      wrap: function (content) {
	        return wrap$1(this, content);
	      },
	      wrapAll: function (content) {
	        return wrap$1(this, content, true);
	      },
	      wrapInner: function (content) {
	        this.each(function () {
	          DomQuery(this).contents().wrapAll(content);
	        });
	        return this;
	      },
	      unwrap: function () {
	        return this.parent().each(function () {
	          DomQuery(this).replaceWith(this.childNodes);
	        });
	      },
	      clone: function () {
	        var result = [];
	        this.each(function () {
	          result.push(this.cloneNode(true));
	        });
	        return DomQuery(result);
	      },
	      addClass: function (className) {
	        return this.toggleClass(className, true);
	      },
	      removeClass: function (className) {
	        return this.toggleClass(className, false);
	      },
	      toggleClass: function (className, state) {
	        var self = this;
	        if (typeof className !== 'string') {
	          return self;
	        }
	        if (className.indexOf(' ') !== -1) {
	          each$4(className.split(' '), function () {
	            self.toggleClass(this, state);
	          });
	        } else {
	          self.each(function (index, node) {
	            var existingClassName, classState;
	            classState = hasClass(node, className);
	            if (classState !== state) {
	              existingClassName = node.className;
	              if (classState) {
	                node.className = trim$2((' ' + existingClassName + ' ').replace(' ' + className + ' ', ' '));
	              } else {
	                node.className += existingClassName ? ' ' + className : className;
	              }
	            }
	          });
	        }
	        return self;
	      },
	      hasClass: function (className) {
	        return hasClass(this[0], className);
	      },
	      each: function (callback) {
	        return each$4(this, callback);
	      },
	      on: function (name, callback) {
	        return this.each(function () {
	          Event.bind(this, name, callback);
	        });
	      },
	      off: function (name, callback) {
	        return this.each(function () {
	          Event.unbind(this, name, callback);
	        });
	      },
	      trigger: function (name) {
	        return this.each(function () {
	          if (typeof name === 'object') {
	            Event.fire(this, name.type, name);
	          } else {
	            Event.fire(this, name);
	          }
	        });
	      },
	      show: function () {
	        return this.css('display', '');
	      },
	      hide: function () {
	        return this.css('display', 'none');
	      },
	      slice: function () {
	        return new DomQuery(slice$1.apply(this, arguments));
	      },
	      eq: function (index) {
	        return index === -1 ? this.slice(index) : this.slice(index, +index + 1);
	      },
	      first: function () {
	        return this.eq(0);
	      },
	      last: function () {
	        return this.eq(-1);
	      },
	      find: function (selector) {
	        var i, l;
	        var ret = [];
	        for (i = 0, l = this.length; i < l; i++) {
	          DomQuery.find(selector, this[i], ret);
	        }
	        return DomQuery(ret);
	      },
	      filter: function (selector) {
	        if (typeof selector === 'function') {
	          return DomQuery(grep(this.toArray(), function (item, i) {
	            return selector(i, item);
	          }));
	        }
	        return DomQuery(DomQuery.filter(selector, this.toArray()));
	      },
	      closest: function (selector) {
	        var result = [];
	        if (selector instanceof DomQuery) {
	          selector = selector[0];
	        }
	        this.each(function (i, node) {
	          while (node) {
	            if (typeof selector === 'string' && DomQuery(node).is(selector)) {
	              result.push(node);
	              break;
	            } else if (node === selector) {
	              result.push(node);
	              break;
	            }
	            node = node.parentNode;
	          }
	        });
	        return DomQuery(result);
	      },
	      offset: function (offset) {
	        var elm, doc, docElm;
	        var x = 0, y = 0, pos;
	        if (!offset) {
	          elm = this[0];
	          if (elm) {
	            doc = elm.ownerDocument;
	            docElm = doc.documentElement;
	            if (elm.getBoundingClientRect) {
	              pos = elm.getBoundingClientRect();
	              x = pos.left + (docElm.scrollLeft || doc.body.scrollLeft) - docElm.clientLeft;
	              y = pos.top + (docElm.scrollTop || doc.body.scrollTop) - docElm.clientTop;
	            }
	          }
	          return {
	            left: x,
	            top: y
	          };
	        }
	        return this.css(offset);
	      },
	      push: push$1,
	      sort: Array.prototype.sort,
	      splice: Array.prototype.splice
	    };
	    Tools.extend(DomQueryConstructor, {
	      extend: Tools.extend,
	      makeArray: function (object) {
	        if (isWindow(object) || object.nodeType) {
	          return [object];
	        }
	        return Tools.toArray(object);
	      },
	      inArray: inArray$1,
	      isArray: Tools.isArray,
	      each: each$4,
	      trim: trim$2,
	      grep: grep,
	      find: Sizzle,
	      expr: Sizzle.selectors,
	      unique: Sizzle.uniqueSort,
	      text: Sizzle.getText,
	      contains: Sizzle.contains,
	      filter: function (expr, elems, not) {
	        var i = elems.length;
	        if (not) {
	          expr = ':not(' + expr + ')';
	        }
	        while (i--) {
	          if (elems[i].nodeType !== 1) {
	            elems.splice(i, 1);
	          }
	        }
	        if (elems.length === 1) {
	          elems = DomQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [];
	        } else {
	          elems = DomQuery.find.matches(expr, elems);
	        }
	        return elems;
	      }
	    });
	    var dir = function (el, prop, until) {
	      var matched = [];
	      var cur = el[prop];
	      if (typeof until !== 'string' && until instanceof DomQuery) {
	        until = until[0];
	      }
	      while (cur && cur.nodeType !== 9) {
	        if (until !== undefined) {
	          if (cur === until) {
	            break;
	          }
	          if (typeof until === 'string' && DomQuery(cur).is(until)) {
	            break;
	          }
	        }
	        if (cur.nodeType === 1) {
	          matched.push(cur);
	        }
	        cur = cur[prop];
	      }
	      return matched;
	    };
	    var sibling = function (node, siblingName, nodeType, until) {
	      var result = [];
	      if (until instanceof DomQuery) {
	        until = until[0];
	      }
	      for (; node; node = node[siblingName]) {
	        if (nodeType && node.nodeType !== nodeType) {
	          continue;
	        }
	        if (until !== undefined) {
	          if (node === until) {
	            break;
	          }
	          if (typeof until === 'string' && DomQuery(node).is(until)) {
	            break;
	          }
	        }
	        result.push(node);
	      }
	      return result;
	    };
	    var firstSibling = function (node, siblingName, nodeType) {
	      for (node = node[siblingName]; node; node = node[siblingName]) {
	        if (node.nodeType === nodeType) {
	          return node;
	        }
	      }
	      return null;
	    };
	    each$4({
	      parent: function (node) {
	        var parent = node.parentNode;
	        return parent && parent.nodeType !== 11 ? parent : null;
	      },
	      parents: function (node) {
	        return dir(node, 'parentNode');
	      },
	      next: function (node) {
	        return firstSibling(node, 'nextSibling', 1);
	      },
	      prev: function (node) {
	        return firstSibling(node, 'previousSibling', 1);
	      },
	      children: function (node) {
	        return sibling(node.firstChild, 'nextSibling', 1);
	      },
	      contents: function (node) {
	        return Tools.toArray((node.nodeName === 'iframe' ? node.contentDocument || node.contentWindow.document : node).childNodes);
	      }
	    }, function (name, fn) {
	      DomQueryConstructor.fn[name] = function (selector) {
	        var self = this;
	        var result = [];
	        self.each(function () {
	          var nodes = fn.call(result, this, selector, result);
	          if (nodes) {
	            if (DomQuery.isArray(nodes)) {
	              result.push.apply(result, nodes);
	            } else {
	              result.push(nodes);
	            }
	          }
	        });
	        if (this.length > 1) {
	          if (!skipUniques[name]) {
	            result = DomQuery.unique(result);
	          }
	          if (name.indexOf('parents') === 0) {
	            result = result.reverse();
	          }
	        }
	        var wrappedResult = DomQuery(result);
	        if (selector) {
	          return wrappedResult.filter(selector);
	        }
	        return wrappedResult;
	      };
	    });
	    each$4({
	      parentsUntil: function (node, until) {
	        return dir(node, 'parentNode', until);
	      },
	      nextUntil: function (node, until) {
	        return sibling(node, 'nextSibling', 1, until).slice(1);
	      },
	      prevUntil: function (node, until) {
	        return sibling(node, 'previousSibling', 1, until).slice(1);
	      }
	    }, function (name, fn) {
	      DomQueryConstructor.fn[name] = function (selector, filter) {
	        var self = this;
	        var result = [];
	        self.each(function () {
	          var nodes = fn.call(result, this, selector, result);
	          if (nodes) {
	            if (DomQuery.isArray(nodes)) {
	              result.push.apply(result, nodes);
	            } else {
	              result.push(nodes);
	            }
	          }
	        });
	        if (this.length > 1) {
	          result = DomQuery.unique(result);
	          if (name.indexOf('parents') === 0 || name === 'prevUntil') {
	            result = result.reverse();
	          }
	        }
	        var wrappedResult = DomQuery(result);
	        if (filter) {
	          return wrappedResult.filter(filter);
	        }
	        return wrappedResult;
	      };
	    });
	    DomQueryConstructor.fn.is = function (selector) {
	      return !!selector && this.filter(selector).length > 0;
	    };
	    DomQueryConstructor.fn.init.prototype = DomQueryConstructor.fn;
	    DomQueryConstructor.overrideDefaults = function (callback) {
	      var defaults;
	      var sub = function (selector, context) {
	        defaults = defaults || callback();
	        if (arguments.length === 0) {
	          selector = defaults.element;
	        }
	        if (!context) {
	          context = defaults.context;
	        }
	        return new sub.fn.init(selector, context);
	      };
	      DomQuery.extend(sub, this);
	      return sub;
	    };
	    DomQueryConstructor.attrHooks = attrHooks;
	    DomQueryConstructor.cssHooks = cssHooks;
	    var DomQuery = DomQueryConstructor;
	
	    var TreeWalker = function () {
	      function TreeWalker(startNode, rootNode) {
	        this.node = startNode;
	        this.rootNode = rootNode;
	        this.current = this.current.bind(this);
	        this.next = this.next.bind(this);
	        this.prev = this.prev.bind(this);
	        this.prev2 = this.prev2.bind(this);
	      }
	      TreeWalker.prototype.current = function () {
	        return this.node;
	      };
	      TreeWalker.prototype.next = function (shallow) {
	        this.node = this.findSibling(this.node, 'firstChild', 'nextSibling', shallow);
	        return this.node;
	      };
	      TreeWalker.prototype.prev = function (shallow) {
	        this.node = this.findSibling(this.node, 'lastChild', 'previousSibling', shallow);
	        return this.node;
	      };
	      TreeWalker.prototype.prev2 = function (shallow) {
	        this.node = this.findPreviousNode(this.node, 'lastChild', 'previousSibling', shallow);
	        return this.node;
	      };
	      TreeWalker.prototype.findSibling = function (node, startName, siblingName, shallow) {
	        var sibling, parent;
	        if (node) {
	          if (!shallow && node[startName]) {
	            return node[startName];
	          }
	          if (node !== this.rootNode) {
	            sibling = node[siblingName];
	            if (sibling) {
	              return sibling;
	            }
	            for (parent = node.parentNode; parent && parent !== this.rootNode; parent = parent.parentNode) {
	              sibling = parent[siblingName];
	              if (sibling) {
	                return sibling;
	              }
	            }
	          }
	        }
	      };
	      TreeWalker.prototype.findPreviousNode = function (node, startName, siblingName, shallow) {
	        var sibling, parent, child;
	        if (node) {
	          sibling = node[siblingName];
	          if (this.rootNode && sibling === this.rootNode) {
	            return;
	          }
	          if (sibling) {
	            if (!shallow) {
	              for (child = sibling[startName]; child; child = child[startName]) {
	                if (!child[startName]) {
	                  return child;
	                }
	              }
	            }
	            return sibling;
	          }
	          parent = node.parentNode;
	          if (parent && parent !== this.rootNode) {
	            return parent;
	          }
	        }
	      };
	      return TreeWalker;
	    }();
	
	    var each$5 = Tools.each;
	    var grep$1 = Tools.grep;
	    var isIE = Env.ie;
	    var simpleSelectorRe = /^([a-z0-9],?)+$/i;
	    var whiteSpaceRegExp$2 = /^[ \t\r\n]*$/;
	    var setupAttrHooks = function (styles, settings, getContext) {
	      var keepValues = settings.keep_values;
	      var keepUrlHook = {
	        set: function ($elm, value, name) {
	          if (settings.url_converter) {
	            value = settings.url_converter.call(settings.url_converter_scope || getContext(), value, name, $elm[0]);
	          }
	          $elm.attr('data-mce-' + name, value).attr(name, value);
	        },
	        get: function ($elm, name) {
	          return $elm.attr('data-mce-' + name) || $elm.attr(name);
	        }
	      };
	      var attrHooks = {
	        style: {
	          set: function ($elm, value) {
	            if (value !== null && typeof value === 'object') {
	              $elm.css(value);
	              return;
	            }
	            if (keepValues) {
	              $elm.attr('data-mce-style', value);
	            }
	            if (value !== null && typeof value === 'string') {
	              $elm.removeAttr('style');
	              $elm.css(styles.parse(value));
	            } else {
	              $elm.attr('style', value);
	            }
	          },
	          get: function ($elm) {
	            var value = $elm.attr('data-mce-style') || $elm.attr('style');
	            value = styles.serialize(styles.parse(value), $elm[0].nodeName);
	            return value;
	          }
	        }
	      };
	      if (keepValues) {
	        attrHooks.href = attrHooks.src = keepUrlHook;
	      }
	      return attrHooks;
	    };
	    var updateInternalStyleAttr = function (styles, $elm) {
	      var rawValue = $elm.attr('style');
	      var value = styles.serialize(styles.parse(rawValue), $elm[0].nodeName);
	      if (!value) {
	        value = null;
	      }
	      $elm.attr('data-mce-style', value);
	    };
	    var findNodeIndex = function (node, normalized) {
	      var idx = 0, lastNodeType, nodeType;
	      if (node) {
	        for (lastNodeType = node.nodeType, node = node.previousSibling; node; node = node.previousSibling) {
	          nodeType = node.nodeType;
	          if (normalized && nodeType === 3) {
	            if (nodeType === lastNodeType || !node.nodeValue.length) {
	              continue;
	            }
	          }
	          idx++;
	          lastNodeType = nodeType;
	        }
	      }
	      return idx;
	    };
	    function DOMUtils(doc, settings) {
	      var _this = this;
	      if (settings === void 0) {
	        settings = {};
	      }
	      var attrHooks;
	      var addedStyles = {};
	      var win = domGlobals.window;
	      var files = {};
	      var counter = 0;
	      var stdMode = true;
	      var boxModel = true;
	      var styleSheetLoader = StyleSheetLoader(doc, {
	        contentCssCors: settings.contentCssCors,
	        referrerPolicy: settings.referrerPolicy
	      });
	      var boundEvents = [];
	      var schema = settings.schema ? settings.schema : Schema({});
	      var styles = Styles({
	        url_converter: settings.url_converter,
	        url_converter_scope: settings.url_converter_scope
	      }, settings.schema);
	      var events = settings.ownEvents ? new EventUtils() : EventUtils.Event;
	      var blockElementsMap = schema.getBlockElements();
	      var $ = DomQuery.overrideDefaults(function () {
	        return {
	          context: doc,
	          element: self.getRoot()
	        };
	      });
	      var isBlock = function (node) {
	        if (typeof node === 'string') {
	          return !!blockElementsMap[node];
	        } else if (node) {
	          var type = node.nodeType;
	          if (type) {
	            return !!(type === 1 && blockElementsMap[node.nodeName]);
	          }
	        }
	        return false;
	      };
	      var get = function (elm) {
	        if (elm && doc && typeof elm === 'string') {
	          var node = doc.getElementById(elm);
	          if (node && node.id !== elm) {
	            return doc.getElementsByName(elm)[1];
	          } else {
	            return node;
	          }
	        }
	        return elm;
	      };
	      var $$ = function (elm) {
	        if (typeof elm === 'string') {
	          elm = get(elm);
	        }
	        return $(elm);
	      };
	      var getAttrib = function (elm, name, defaultVal) {
	        var hook, value;
	        var $elm = $$(elm);
	        if ($elm.length) {
	          hook = attrHooks[name];
	          if (hook && hook.get) {
	            value = hook.get($elm, name);
	          } else {
	            value = $elm.attr(name);
	          }
	        }
	        if (typeof value === 'undefined') {
	          value = defaultVal || '';
	        }
	        return value;
	      };
	      var getAttribs = function (elm) {
	        var node = get(elm);
	        if (!node) {
	          return [];
	        }
	        return node.attributes;
	      };
	      var setAttrib = function (elm, name, value) {
	        var originalValue, hook;
	        if (value === '') {
	          value = null;
	        }
	        var $elm = $$(elm);
	        originalValue = $elm.attr(name);
	        if (!$elm.length) {
	          return;
	        }
	        hook = attrHooks[name];
	        if (hook && hook.set) {
	          hook.set($elm, value, name);
	        } else {
	          $elm.attr(name, value);
	        }
	        if (originalValue !== value && settings.onSetAttrib) {
	          settings.onSetAttrib({
	            attrElm: $elm,
	            attrName: name,
	            attrValue: value
	          });
	        }
	      };
	      var clone = function (node, deep) {
	        if (!isIE || node.nodeType !== 1 || deep) {
	          return node.cloneNode(deep);
	        }
	        if (!deep) {
	          var clone_1 = doc.createElement(node.nodeName);
	          each$5(getAttribs(node), function (attr) {
	            setAttrib(clone_1, attr.nodeName, getAttrib(node, attr.nodeName));
	          });
	          return clone_1;
	        }
	        return null;
	      };
	      var getRoot = function () {
	        return settings.root_element || doc.body;
	      };
	      var getViewPort = function (argWin) {
	        var vp = getBounds(argWin);
	        return {
	          x: vp.x(),
	          y: vp.y(),
	          w: vp.width(),
	          h: vp.height()
	        };
	      };
	      var getPos = function (elm, rootElm) {
	        return Position$1.getPos(doc.body, get(elm), rootElm);
	      };
	      var setStyle = function (elm, name, value) {
	        var $elm = isString(name) ? $$(elm).css(name, value) : $$(elm).css(name);
	        if (settings.update_styles) {
	          updateInternalStyleAttr(styles, $elm);
	        }
	      };
	      var setStyles = function (elm, stylesArg) {
	        var $elm = $$(elm).css(stylesArg);
	        if (settings.update_styles) {
	          updateInternalStyleAttr(styles, $elm);
	        }
	      };
	      var getStyle = function (elm, name, computed) {
	        var $elm = $$(elm);
	        if (computed) {
	          return $elm.css(name);
	        }
	        name = name.replace(/-(\D)/g, function (a, b) {
	          return b.toUpperCase();
	        });
	        if (name === 'float') {
	          name = Env.browser.isIE() ? 'styleFloat' : 'cssFloat';
	        }
	        return $elm[0] && $elm[0].style ? $elm[0].style[name] : undefined;
	      };
	      var getSize = function (elm) {
	        var w, h;
	        elm = get(elm);
	        w = getStyle(elm, 'width');
	        h = getStyle(elm, 'height');
	        if (w.indexOf('px') === -1) {
	          w = 0;
	        }
	        if (h.indexOf('px') === -1) {
	          h = 0;
	        }
	        return {
	          w: parseInt(w, 10) || elm.offsetWidth || elm.clientWidth,
	          h: parseInt(h, 10) || elm.offsetHeight || elm.clientHeight
	        };
	      };
	      var getRect = function (elm) {
	        var pos, size;
	        elm = get(elm);
	        pos = getPos(elm);
	        size = getSize(elm);
	        return {
	          x: pos.x,
	          y: pos.y,
	          w: size.w,
	          h: size.h
	        };
	      };
	      var is = function (elm, selector) {
	        var i;
	        if (!elm) {
	          return false;
	        }
	        if (!Array.isArray(elm)) {
	          if (selector === '*') {
	            return elm.nodeType === 1;
	          }
	          if (simpleSelectorRe.test(selector)) {
	            var selectors = selector.toLowerCase().split(/,/);
	            var elmName = elm.nodeName.toLowerCase();
	            for (i = selectors.length - 1; i >= 0; i--) {
	              if (selectors[i] === elmName) {
	                return true;
	              }
	            }
	            return false;
	          }
	          if (elm.nodeType && elm.nodeType !== 1) {
	            return false;
	          }
	        }
	        var elms = !Array.isArray(elm) ? [elm] : elm;
	        return Sizzle(selector, elms[0].ownerDocument || elms[0], null, elms).length > 0;
	      };
	      var getParents = function (elm, selector, root, collect) {
	        var result = [];
	        var selectorVal;
	        var node = get(elm);
	        collect = collect === undefined;
	        root = root || (getRoot().nodeName !== 'BODY' ? getRoot().parentNode : null);
	        if (Tools.is(selector, 'string')) {
	          selectorVal = selector;
	          if (selector === '*') {
	            selector = function (node) {
	              return node.nodeType === 1;
	            };
	          } else {
	            selector = function (node) {
	              return is(node, selectorVal);
	            };
	          }
	        }
	        while (node) {
	          if (node === root || !node.nodeType || node.nodeType === 9) {
	            break;
	          }
	          if (!selector || typeof selector === 'function' && selector(node)) {
	            if (collect) {
	              result.push(node);
	            } else {
	              return [node];
	            }
	          }
	          node = node.parentNode;
	        }
	        return collect ? result : null;
	      };
	      var getParent = function (node, selector, root) {
	        var parents = getParents(node, selector, root, false);
	        return parents && parents.length > 0 ? parents[0] : null;
	      };
	      var _findSib = function (node, selector, name) {
	        var func = selector;
	        if (node) {
	          if (typeof selector === 'string') {
	            func = function (node) {
	              return is(node, selector);
	            };
	          }
	          for (node = node[name]; node; node = node[name]) {
	            if (typeof func === 'function' && func(node)) {
	              return node;
	            }
	          }
	        }
	        return null;
	      };
	      var getNext = function (node, selector) {
	        return _findSib(node, selector, 'nextSibling');
	      };
	      var getPrev = function (node, selector) {
	        return _findSib(node, selector, 'previousSibling');
	      };
	      var select = function (selector, scope) {
	        return Sizzle(selector, get(scope) || settings.root_element || doc, []);
	      };
	      var run = function (elm, func, scope) {
	        var result;
	        var node = typeof elm === 'string' ? get(elm) : elm;
	        if (!node) {
	          return false;
	        }
	        if (Tools.isArray(node) && (node.length || node.length === 0)) {
	          result = [];
	          each$5(node, function (elm, i) {
	            if (elm) {
	              if (typeof elm === 'string') {
	                elm = get(elm);
	              }
	              result.push(func.call(scope, elm, i));
	            }
	          });
	          return result;
	        }
	        var context = scope ? scope : _this;
	        return func.call(context, node);
	      };
	      var setAttribs = function (elm, attrs) {
	        $$(elm).each(function (i, node) {
	          each$5(attrs, function (value, name) {
	            setAttrib(node, name, value);
	          });
	        });
	      };
	      var setHTML = function (elm, html) {
	        var $elm = $$(elm);
	        if (isIE) {
	          $elm.each(function (i, target) {
	            if (target.canHaveHTML === false) {
	              return;
	            }
	            while (target.firstChild) {
	              target.removeChild(target.firstChild);
	            }
	            try {
	              target.innerHTML = '<br>' + html;
	              target.removeChild(target.firstChild);
	            } catch (ex) {
	              DomQuery('<div></div>').html('<br>' + html).contents().slice(1).appendTo(target);
	            }
	            return html;
	          });
	        } else {
	          $elm.html(html);
	        }
	      };
	      var add = function (parentElm, name, attrs, html, create) {
	        return run(parentElm, function (parentElm) {
	          var newElm = typeof name === 'string' ? doc.createElement(name) : name;
	          setAttribs(newElm, attrs);
	          if (html) {
	            if (typeof html !== 'string' && html.nodeType) {
	              newElm.appendChild(html);
	            } else if (typeof html === 'string') {
	              setHTML(newElm, html);
	            }
	          }
	          return !create ? parentElm.appendChild(newElm) : newElm;
	        });
	      };
	      var create = function (name, attrs, html) {
	        return add(doc.createElement(name), name, attrs, html, true);
	      };
	      var decode = Entities.decode;
	      var encode = Entities.encodeAllRaw;
	      var createHTML = function (name, attrs, html) {
	        var outHtml = '', key;
	        outHtml += '<' + name;
	        for (key in attrs) {
	          if (attrs.hasOwnProperty(key) && attrs[key] !== null && typeof attrs[key] !== 'undefined') {
	            outHtml += ' ' + key + '="' + encode(attrs[key]) + '"';
	          }
	        }
	        if (typeof html !== 'undefined') {
	          return outHtml + '>' + html + '</' + name + '>';
	        }
	        return outHtml + ' />';
	      };
	      var createFragment = function (html) {
	        var node;
	        var container = doc.createElement('div');
	        var frag = doc.createDocumentFragment();
	        if (html) {
	          container.innerHTML = html;
	        }
	        while (node = container.firstChild) {
	          frag.appendChild(node);
	        }
	        return frag;
	      };
	      var remove = function (node, keepChildren) {
	        var $node = $$(node);
	        if (keepChildren) {
	          $node.each(function () {
	            var child;
	            while (child = this.firstChild) {
	              if (child.nodeType === 3 && child.data.length === 0) {
	                this.removeChild(child);
	              } else {
	                this.parentNode.insertBefore(child, this);
	              }
	            }
	          }).remove();
	        } else {
	          $node.remove();
	        }
	        return $node.length > 1 ? $node.toArray() : $node[0];
	      };
	      var removeAllAttribs = function (e) {
	        return run(e, function (e) {
	          var i;
	          var attrs = e.attributes;
	          for (i = attrs.length - 1; i >= 0; i--) {
	            e.removeAttributeNode(attrs.item(i));
	          }
	        });
	      };
	      var parseStyle = function (cssText) {
	        return styles.parse(cssText);
	      };
	      var serializeStyle = function (stylesArg, name) {
	        return styles.serialize(stylesArg, name);
	      };
	      var addStyle = function (cssText) {
	        var head, styleElm;
	        if (self !== DOMUtils.DOM && doc === domGlobals.document) {
	          if (addedStyles[cssText]) {
	            return;
	          }
	          addedStyles[cssText] = true;
	        }
	        styleElm = doc.getElementById('mceDefaultStyles');
	        if (!styleElm) {
	          styleElm = doc.createElement('style');
	          styleElm.id = 'mceDefaultStyles';
	          styleElm.type = 'text/css';
	          head = doc.getElementsByTagName('head')[0];
	          if (head.firstChild) {
	            head.insertBefore(styleElm, head.firstChild);
	          } else {
	            head.appendChild(styleElm);
	          }
	        }
	        if (styleElm.styleSheet) {
	          styleElm.styleSheet.cssText += cssText;
	        } else {
	          styleElm.appendChild(doc.createTextNode(cssText));
	        }
	      };
	      var loadCSS = function (url) {
	        var head;
	        if (self !== DOMUtils.DOM && doc === domGlobals.document) {
	          DOMUtils.DOM.loadCSS(url);
	          return;
	        }
	        if (!url) {
	          url = '';
	        }
	        head = doc.getElementsByTagName('head')[0];
	        each$5(url.split(','), function (url) {
	          var link;
	          url = Tools._addCacheSuffix(url);
	          if (files[url]) {
	            return;
	          }
	          files[url] = true;
	          link = create('link', __assign(__assign({
	            rel: 'stylesheet',
	            type: 'text/css',
	            href: url
	          }, settings.contentCssCors ? { crossOrigin: 'anonymous' } : {}), settings.referrerPolicy ? { referrerPolicy: settings.referrerPolicy } : {}));
	          head.appendChild(link);
	        });
	      };
	      var toggleClass = function (elm, cls, state) {
	        $$(elm).toggleClass(cls, state).each(function () {
	          if (this.className === '') {
	            DomQuery(this).attr('class', null);
	          }
	        });
	      };
	      var addClass = function (elm, cls) {
	        $$(elm).addClass(cls);
	      };
	      var removeClass = function (elm, cls) {
	        toggleClass(elm, cls, false);
	      };
	      var hasClass = function (elm, cls) {
	        return $$(elm).hasClass(cls);
	      };
	      var show = function (elm) {
	        $$(elm).show();
	      };
	      var hide = function (elm) {
	        $$(elm).hide();
	      };
	      var isHidden = function (elm) {
	        return $$(elm).css('display') === 'none';
	      };
	      var uniqueId = function (prefix) {
	        return (!prefix ? 'mce_' : prefix) + counter++;
	      };
	      var getOuterHTML = function (elm) {
	        var node = typeof elm === 'string' ? get(elm) : elm;
	        return NodeType.isElement(node) ? node.outerHTML : DomQuery('<div></div>').append(DomQuery(node).clone()).html();
	      };
	      var setOuterHTML = function (elm, html) {
	        $$(elm).each(function () {
	          try {
	            if ('outerHTML' in this) {
	              this.outerHTML = html;
	              return;
	            }
	          } catch (ex) {
	          }
	          remove(DomQuery(this).html(html), true);
	        });
	      };
	      var insertAfter = function (node, reference) {
	        var referenceNode = get(reference);
	        return run(node, function (node) {
	          var parent, nextSibling;
	          parent = referenceNode.parentNode;
	          nextSibling = referenceNode.nextSibling;
	          if (nextSibling) {
	            parent.insertBefore(node, nextSibling);
	          } else {
	            parent.appendChild(node);
	          }
	          return node;
	        });
	      };
	      var replace = function (newElm, oldElm, keepChildren) {
	        return run(oldElm, function (oldElm) {
	          if (Tools.is(oldElm, 'array')) {
	            newElm = newElm.cloneNode(true);
	          }
	          if (keepChildren) {
	            each$5(grep$1(oldElm.childNodes), function (node) {
	              newElm.appendChild(node);
	            });
	          }
	          return oldElm.parentNode.replaceChild(newElm, oldElm);
	        });
	      };
	      var rename = function (elm, name) {
	        var newElm;
	        if (elm.nodeName !== name.toUpperCase()) {
	          newElm = create(name);
	          each$5(getAttribs(elm), function (attrNode) {
	            setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));
	          });
	          replace(newElm, elm, true);
	        }
	        return newElm || elm;
	      };
	      var findCommonAncestor = function (a, b) {
	        var ps = a, pe;
	        while (ps) {
	          pe = b;
	          while (pe && ps !== pe) {
	            pe = pe.parentNode;
	          }
	          if (ps === pe) {
	            break;
	          }
	          ps = ps.parentNode;
	        }
	        if (!ps && a.ownerDocument) {
	          return a.ownerDocument.documentElement;
	        }
	        return ps;
	      };
	      var toHex = function (rgbVal) {
	        return styles.toHex(Tools.trim(rgbVal));
	      };
	      var isEmpty = function (node, elements) {
	        var i, attributes, type, name, brCount = 0;
	        node = node.firstChild;
	        if (node) {
	          var walker = new TreeWalker(node, node.parentNode);
	          var whitespace = schema ? schema.getWhiteSpaceElements() : {};
	          elements = elements || (schema ? schema.getNonEmptyElements() : null);
	          do {
	            type = node.nodeType;
	            if (NodeType.isElement(node)) {
	              var bogusVal = node.getAttribute('data-mce-bogus');
	              if (bogusVal) {
	                node = walker.next(bogusVal === 'all');
	                continue;
	              }
	              name = node.nodeName.toLowerCase();
	              if (elements && elements[name]) {
	                if (name === 'br') {
	                  brCount++;
	                  node = walker.next();
	                  continue;
	                }
	                return false;
	              }
	              attributes = getAttribs(node);
	              i = attributes.length;
	              while (i--) {
	                name = attributes[i].nodeName;
	                if (name === 'name' || name === 'data-mce-bookmark') {
	                  return false;
	                }
	              }
	            }
	            if (type === 8) {
	              return false;
	            }
	            if (type === 3 && !whiteSpaceRegExp$2.test(node.nodeValue)) {
	              return false;
	            }
	            if (type === 3 && node.parentNode && whitespace[node.parentNode.nodeName] && whiteSpaceRegExp$2.test(node.nodeValue)) {
	              return false;
	            }
	            node = walker.next();
	          } while (node);
	        }
	        return brCount <= 1;
	      };
	      var createRng = function () {
	        return doc.createRange();
	      };
	      var split = function (parentElm, splitElm, replacementElm) {
	        var r = createRng(), bef, aft, pa;
	        if (parentElm && splitElm) {
	          r.setStart(parentElm.parentNode, findNodeIndex(parentElm));
	          r.setEnd(splitElm.parentNode, findNodeIndex(splitElm));
	          bef = r.extractContents();
	          r = createRng();
	          r.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);
	          r.setEnd(parentElm.parentNode, findNodeIndex(parentElm) + 1);
	          aft = r.extractContents();
	          pa = parentElm.parentNode;
	          pa.insertBefore(TrimNode.trimNode(self, bef), parentElm);
	          if (replacementElm) {
	            pa.insertBefore(replacementElm, parentElm);
	          } else {
	            pa.insertBefore(splitElm, parentElm);
	          }
	          pa.insertBefore(TrimNode.trimNode(self, aft), parentElm);
	          remove(parentElm);
	          return replacementElm || splitElm;
	        }
	      };
	      var bind = function (target, name, func, scope) {
	        if (Tools.isArray(target)) {
	          var i = target.length;
	          var rv = [];
	          while (i--) {
	            rv[i] = bind(target[i], name, func, scope);
	          }
	          return rv;
	        }
	        if (settings.collect && (target === doc || target === win)) {
	          boundEvents.push([
	            target,
	            name,
	            func,
	            scope
	          ]);
	        }
	        return events.bind(target, name, func, scope || self);
	      };
	      var unbind = function (target, name, func) {
	        var i;
	        if (Tools.isArray(target)) {
	          i = target.length;
	          var rv = [];
	          while (i--) {
	            rv[i] = unbind(target[i], name, func);
	          }
	          return rv;
	        }
	        if (boundEvents && (target === doc || target === win)) {
	          i = boundEvents.length;
	          while (i--) {
	            var item = boundEvents[i];
	            if (target === item[0] && (!name || name === item[1]) && (!func || func === item[2])) {
	              events.unbind(item[0], item[1], item[2]);
	            }
	          }
	        }
	        return events.unbind(target, name, func);
	      };
	      var fire = function (target, name, evt) {
	        return events.fire(target, name, evt);
	      };
	      var getContentEditable = function (node) {
	        if (node && NodeType.isElement(node)) {
	          var contentEditable = node.getAttribute('data-mce-contenteditable');
	          if (contentEditable && contentEditable !== 'inherit') {
	            return contentEditable;
	          }
	          return node.contentEditable !== 'inherit' ? node.contentEditable : null;
	        } else {
	          return null;
	        }
	      };
	      var getContentEditableParent = function (node) {
	        var root = getRoot();
	        var state = null;
	        for (; node && node !== root; node = node.parentNode) {
	          state = getContentEditable(node);
	          if (state !== null) {
	            break;
	          }
	        }
	        return state;
	      };
	      var destroy = function () {
	        if (boundEvents) {
	          var i = boundEvents.length;
	          while (i--) {
	            var item = boundEvents[i];
	            events.unbind(item[0], item[1], item[2]);
	          }
	        }
	        if (Sizzle.setDocument) {
	          Sizzle.setDocument();
	        }
	      };
	      var isChildOf = function (node, parent) {
	        while (node) {
	          if (parent === node) {
	            return true;
	          }
	          node = node.parentNode;
	        }
	        return false;
	      };
	      var dumpRng = function (r) {
	        return 'startContainer: ' + r.startContainer.nodeName + ', startOffset: ' + r.startOffset + ', endContainer: ' + r.endContainer.nodeName + ', endOffset: ' + r.endOffset;
	      };
	      var self = {
	        doc: doc,
	        settings: settings,
	        win: win,
	        files: files,
	        stdMode: stdMode,
	        boxModel: boxModel,
	        styleSheetLoader: styleSheetLoader,
	        boundEvents: boundEvents,
	        styles: styles,
	        schema: schema,
	        events: events,
	        isBlock: isBlock,
	        $: $,
	        $$: $$,
	        root: null,
	        clone: clone,
	        getRoot: getRoot,
	        getViewPort: getViewPort,
	        getRect: getRect,
	        getSize: getSize,
	        getParent: getParent,
	        getParents: getParents,
	        get: get,
	        getNext: getNext,
	        getPrev: getPrev,
	        select: select,
	        is: is,
	        add: add,
	        create: create,
	        createHTML: createHTML,
	        createFragment: createFragment,
	        remove: remove,
	        setStyle: setStyle,
	        getStyle: getStyle,
	        setStyles: setStyles,
	        removeAllAttribs: removeAllAttribs,
	        setAttrib: setAttrib,
	        setAttribs: setAttribs,
	        getAttrib: getAttrib,
	        getPos: getPos,
	        parseStyle: parseStyle,
	        serializeStyle: serializeStyle,
	        addStyle: addStyle,
	        loadCSS: loadCSS,
	        addClass: addClass,
	        removeClass: removeClass,
	        hasClass: hasClass,
	        toggleClass: toggleClass,
	        show: show,
	        hide: hide,
	        isHidden: isHidden,
	        uniqueId: uniqueId,
	        setHTML: setHTML,
	        getOuterHTML: getOuterHTML,
	        setOuterHTML: setOuterHTML,
	        decode: decode,
	        encode: encode,
	        insertAfter: insertAfter,
	        replace: replace,
	        rename: rename,
	        findCommonAncestor: findCommonAncestor,
	        toHex: toHex,
	        run: run,
	        getAttribs: getAttribs,
	        isEmpty: isEmpty,
	        createRng: createRng,
	        nodeIndex: findNodeIndex,
	        split: split,
	        bind: bind,
	        unbind: unbind,
	        fire: fire,
	        getContentEditable: getContentEditable,
	        getContentEditableParent: getContentEditableParent,
	        destroy: destroy,
	        isChildOf: isChildOf,
	        dumpRng: dumpRng
	      };
	      attrHooks = setupAttrHooks(styles, settings, function () {
	        return self;
	      });
	      return self;
	    }
	    (function (DOMUtils) {
	      DOMUtils.DOM = DOMUtils(domGlobals.document);
	      DOMUtils.nodeIndex = findNodeIndex;
	    }(DOMUtils || (DOMUtils = {})));
	    var DOMUtils$1 = DOMUtils;
	
	    var DOM = DOMUtils$1.DOM;
	    var each$6 = Tools.each, grep$2 = Tools.grep;
	    var QUEUED = 0;
	    var LOADING = 1;
	    var LOADED = 2;
	    var FAILED = 3;
	    var ScriptLoader = function () {
	      function ScriptLoader(settings) {
	        if (settings === void 0) {
	          settings = {};
	        }
	        this.states = {};
	        this.queue = [];
	        this.scriptLoadedCallbacks = {};
	        this.queueLoadedCallbacks = [];
	        this.loading = 0;
	        this.settings = settings;
	      }
	      ScriptLoader.prototype._setReferrerPolicy = function (referrerPolicy) {
	        this.settings.referrerPolicy = referrerPolicy;
	      };
	      ScriptLoader.prototype.loadScript = function (url, success, failure) {
	        var dom = DOM;
	        var elm, id;
	        var done = function () {
	          dom.remove(id);
	          if (elm) {
	            elm.onreadystatechange = elm.onload = elm = null;
	          }
	          success();
	        };
	        var error = function () {
	          if (isFunction(failure)) {
	            failure();
	          } else {
	            if (typeof domGlobals.console !== 'undefined' && domGlobals.console.log) {
	              domGlobals.console.log('Failed to load script: ' + url);
	            }
	          }
	        };
	        id = dom.uniqueId();
	        elm = domGlobals.document.createElement('script');
	        elm.id = id;
	        elm.type = 'text/javascript';
	        elm.src = Tools._addCacheSuffix(url);
	        if (this.settings.referrerPolicy) {
	          dom.setAttrib(elm, 'referrerpolicy', this.settings.referrerPolicy);
	        }
	        elm.onload = done;
	        elm.onerror = error;
	        (domGlobals.document.getElementsByTagName('head')[0] || domGlobals.document.body).appendChild(elm);
	      };
	      ScriptLoader.prototype.isDone = function (url) {
	        return this.states[url] === LOADED;
	      };
	      ScriptLoader.prototype.markDone = function (url) {
	        this.states[url] = LOADED;
	      };
	      ScriptLoader.prototype.add = function (url, success, scope, failure) {
	        var state = this.states[url];
	        if (state === undefined) {
	          this.queue.push(url);
	          this.states[url] = QUEUED;
	        }
	        if (success) {
	          if (!this.scriptLoadedCallbacks[url]) {
	            this.scriptLoadedCallbacks[url] = [];
	          }
	          this.scriptLoadedCallbacks[url].push({
	            success: success,
	            failure: failure,
	            scope: scope || this
	          });
	        }
	      };
	      ScriptLoader.prototype.load = function (url, success, scope, failure) {
	        return this.add(url, success, scope, failure);
	      };
	      ScriptLoader.prototype.remove = function (url) {
	        delete this.states[url];
	        delete this.scriptLoadedCallbacks[url];
	      };
	      ScriptLoader.prototype.loadQueue = function (success, scope, failure) {
	        this.loadScripts(this.queue, success, scope, failure);
	      };
	      ScriptLoader.prototype.loadScripts = function (scripts, success, scope, failure) {
	        var self = this;
	        var loadScripts;
	        var failures = [];
	        var execCallbacks = function (name, url) {
	          each$6(self.scriptLoadedCallbacks[url], function (callback) {
	            if (isFunction(callback[name])) {
	              callback[name].call(callback.scope);
	            }
	          });
	          self.scriptLoadedCallbacks[url] = undefined;
	        };
	        self.queueLoadedCallbacks.push({
	          success: success,
	          failure: failure,
	          scope: scope || this
	        });
	        loadScripts = function () {
	          var loadingScripts = grep$2(scripts);
	          scripts.length = 0;
	          each$6(loadingScripts, function (url) {
	            if (self.states[url] === LOADED) {
	              execCallbacks('success', url);
	              return;
	            }
	            if (self.states[url] === FAILED) {
	              execCallbacks('failure', url);
	              return;
	            }
	            if (self.states[url] !== LOADING) {
	              self.states[url] = LOADING;
	              self.loading++;
	              self.loadScript(url, function () {
	                self.states[url] = LOADED;
	                self.loading--;
	                execCallbacks('success', url);
	                loadScripts();
	              }, function () {
	                self.states[url] = FAILED;
	                self.loading--;
	                failures.push(url);
	                execCallbacks('failure', url);
	                loadScripts();
	              });
	            }
	          });
	          if (!self.loading) {
	            var notifyCallbacks = self.queueLoadedCallbacks.slice(0);
	            self.queueLoadedCallbacks.length = 0;
	            each$6(notifyCallbacks, function (callback) {
	              if (failures.length === 0) {
	                if (isFunction(callback.success)) {
	                  callback.success.call(callback.scope);
	                }
	              } else {
	                if (isFunction(callback.failure)) {
	                  callback.failure.call(callback.scope, failures);
	                }
	              }
	            });
	          }
	        };
	        loadScripts();
	      };
	      ScriptLoader.ScriptLoader = new ScriptLoader();
	      return ScriptLoader;
	    }();
	
	    var isRaw = function (str) {
	      return isObject(str) && has(str, 'raw');
	    };
	    var isTokenised = function (str) {
	      return isArray(str) && str.length > 1;
	    };
	    var data = {};
	    var currentCode = Cell('en');
	    var getLanguageData = function () {
	      return get(data, currentCode.get());
	    };
	    var getData = function () {
	      return map$1(data, function (value) {
	        return __assign({}, value);
	      });
	    };
	    var setCode = function (newCode) {
	      if (newCode) {
	        currentCode.set(newCode);
	      }
	    };
	    var getCode = function () {
	      return currentCode.get();
	    };
	    var add = function (code, items) {
	      var langData = data[code];
	      if (!langData) {
	        data[code] = langData = {};
	      }
	      each$1(items, function (translation, name) {
	        langData[name.toLowerCase()] = translation;
	      });
	    };
	    var translate = function (text) {
	      var langData = getLanguageData().getOr({});
	      var toString = function (obj) {
	        if (isFunction(obj)) {
	          return Object.prototype.toString.call(obj);
	        }
	        return !isEmpty(obj) ? '' + obj : '';
	      };
	      var isEmpty = function (text) {
	        return text === '' || text === null || text === undefined;
	      };
	      var getLangData = function (text) {
	        var textstr = toString(text);
	        return get(langData, textstr.toLowerCase()).map(toString).getOr(textstr);
	      };
	      var removeContext = function (str) {
	        return str.replace(/{context:\w+}$/, '');
	      };
	      var translated = function (text) {
	        return text;
	      };
	      if (isEmpty(text)) {
	        return translated('');
	      }
	      if (isRaw(text)) {
	        return translated(toString(text.raw));
	      }
	      if (isTokenised(text)) {
	        var values_1 = text.slice(1);
	        var substitued = getLangData(text[0]).replace(/\{([0-9]+)\}/g, function ($1, $2) {
	          return has(values_1, $2) ? toString(values_1[$2]) : $1;
	        });
	        return translated(removeContext(substitued));
	      }
	      return translated(removeContext(getLangData(text)));
	    };
	    var isRtl = function () {
	      return getLanguageData().bind(function (items) {
	        return get(items, '_dir');
	      }).exists(function (dir) {
	        return dir === 'rtl';
	      });
	    };
	    var hasCode = function (code) {
	      return has(data, code);
	    };
	    var I18n = {
	      getData: getData,
	      setCode: setCode,
	      getCode: getCode,
	      add: add,
	      translate: translate,
	      isRtl: isRtl,
	      hasCode: hasCode
	    };
	
	    function AddOnManager() {
	      var _this = this;
	      var items = [];
	      var urls = {};
	      var lookup = {};
	      var _listeners = [];
	      var runListeners = function (name, state) {
	        var matchedListeners = filter(_listeners, function (listener) {
	          return listener.name === name && listener.state === state;
	        });
	        each(matchedListeners, function (listener) {
	          return listener.callback();
	        });
	      };
	      var get = function (name) {
	        if (lookup[name]) {
	          return lookup[name].instance;
	        }
	        return undefined;
	      };
	      var dependencies = function (name) {
	        var result;
	        if (lookup[name]) {
	          result = lookup[name].dependencies;
	        }
	        return result || [];
	      };
	      var requireLangPack = function (name, languages) {
	        if (AddOnManager.languageLoad !== false) {
	          waitFor(name, function () {
	            var language = I18n.getCode();
	            var wrappedLanguages = ',' + (languages || '') + ',';
	            if (!language || languages && wrappedLanguages.indexOf(',' + language + ',') === -1) {
	              return;
	            }
	            ScriptLoader.ScriptLoader.add(urls[name] + '/langs/' + language + '.js');
	          }, 'loaded');
	        }
	      };
	      var add = function (id, addOn, dependencies) {
	        var addOnConstructor = addOn;
	        items.push(addOnConstructor);
	        lookup[id] = {
	          instance: addOnConstructor,
	          dependencies: dependencies
	        };
	        runListeners(id, 'added');
	        return addOnConstructor;
	      };
	      var remove = function (name) {
	        delete urls[name];
	        delete lookup[name];
	      };
	      var createUrl = function (baseUrl, dep) {
	        if (typeof dep === 'object') {
	          return dep;
	        }
	        return typeof baseUrl === 'string' ? {
	          prefix: '',
	          resource: dep,
	          suffix: ''
	        } : {
	          prefix: baseUrl.prefix,
	          resource: dep,
	          suffix: baseUrl.suffix
	        };
	      };
	      var addComponents = function (pluginName, scripts) {
	        var pluginUrl = _this.urls[pluginName];
	        each(scripts, function (script) {
	          ScriptLoader.ScriptLoader.add(pluginUrl + '/' + script);
	        });
	      };
	      var loadDependencies = function (name, addOnUrl, success, scope) {
	        var deps = dependencies(name);
	        each(deps, function (dep) {
	          var newUrl = createUrl(addOnUrl, dep);
	          load(newUrl.resource, newUrl, undefined, undefined);
	        });
	        if (success) {
	          if (scope) {
	            success.call(scope);
	          } else {
	            success.call(ScriptLoader);
	          }
	        }
	      };
	      var load = function (name, addOnUrl, success, scope, failure) {
	        if (urls[name]) {
	          return;
	        }
	        var urlString = typeof addOnUrl === 'string' ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;
	        if (urlString.indexOf('/') !== 0 && urlString.indexOf('://') === -1) {
	          urlString = AddOnManager.baseURL + '/' + urlString;
	        }
	        urls[name] = urlString.substring(0, urlString.lastIndexOf('/'));
	        var done = function () {
	          runListeners(name, 'loaded');
	          loadDependencies(name, addOnUrl, success, scope);
	        };
	        if (lookup[name]) {
	          done();
	        } else {
	          ScriptLoader.ScriptLoader.add(urlString, done, scope, failure);
	        }
	      };
	      var waitFor = function (name, callback, state) {
	        if (state === void 0) {
	          state = 'added';
	        }
	        if (has(lookup, name) && state === 'added') {
	          callback();
	        } else if (has(urls, name) && state === 'loaded') {
	          callback();
	        } else {
	          _listeners.push({
	            name: name,
	            state: state,
	            callback: callback
	          });
	        }
	      };
	      return {
	        items: items,
	        urls: urls,
	        lookup: lookup,
	        _listeners: _listeners,
	        get: get,
	        dependencies: dependencies,
	        requireLangPack: requireLangPack,
	        add: add,
	        remove: remove,
	        createUrl: createUrl,
	        addComponents: addComponents,
	        load: load,
	        waitFor: waitFor
	      };
	    }
	    (function (AddOnManager) {
	      AddOnManager.PluginManager = AddOnManager();
	      AddOnManager.ThemeManager = AddOnManager();
	    }(AddOnManager || (AddOnManager = {})));
	    var AddOnManager$1 = AddOnManager;
	
	    var first = function (fn, rate) {
	      var timer = null;
	      var cancel = function () {
	        if (timer !== null) {
	          domGlobals.clearTimeout(timer);
	          timer = null;
	        }
	      };
	      var throttle = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	          args[_i] = arguments[_i];
	        }
	        if (timer === null) {
	          timer = domGlobals.setTimeout(function () {
	            fn.apply(null, args);
	            timer = null;
	          }, rate);
	        }
	      };
	      return {
	        cancel: cancel,
	        throttle: throttle
	      };
	    };
	    var last$2 = function (fn, rate) {
	      var timer = null;
	      var cancel = function () {
	        if (timer !== null) {
	          domGlobals.clearTimeout(timer);
	          timer = null;
	        }
	      };
	      var throttle = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	          args[_i] = arguments[_i];
	        }
	        if (timer !== null) {
	          domGlobals.clearTimeout(timer);
	        }
	        timer = domGlobals.setTimeout(function () {
	          fn.apply(null, args);
	          timer = null;
	        }, rate);
	      };
	      return {
	        cancel: cancel,
	        throttle: throttle
	      };
	    };
	
	    var read = function (element, attr) {
	      var value = get$3(element, attr);
	      return value === undefined || value === '' ? [] : value.split(' ');
	    };
	    var add$1 = function (element, attr, id) {
	      var old = read(element, attr);
	      var nu = old.concat([id]);
	      set(element, attr, nu.join(' '));
	      return true;
	    };
	    var remove$2 = function (element, attr, id) {
	      var nu = filter(read(element, attr), function (v) {
	        return v !== id;
	      });
	      if (nu.length > 0) {
	        set(element, attr, nu.join(' '));
	      } else {
	        remove$1(element, attr);
	      }
	      return false;
	    };
	
	    var supports = function (element) {
	      return element.dom().classList !== undefined;
	    };
	    var get$5 = function (element) {
	      return read(element, 'class');
	    };
	    var add$2 = function (element, clazz) {
	      return add$1(element, 'class', clazz);
	    };
	    var remove$3 = function (element, clazz) {
	      return remove$2(element, 'class', clazz);
	    };
	
	    var add$3 = function (element, clazz) {
	      if (supports(element)) {
	        element.dom().classList.add(clazz);
	      } else {
	        add$2(element, clazz);
	      }
	    };
	    var cleanClass = function (element) {
	      var classList = supports(element) ? element.dom().classList : get$5(element);
	      if (classList.length === 0) {
	        remove$1(element, 'class');
	      }
	    };
	    var remove$4 = function (element, clazz) {
	      if (supports(element)) {
	        var classList = element.dom().classList;
	        classList.remove(clazz);
	      } else {
	        remove$3(element, clazz);
	      }
	      cleanClass(element);
	    };
	    var has$2 = function (element, clazz) {
	      return supports(element) && element.dom().classList.contains(clazz);
	    };
	
	    var descendants = function (scope, predicate) {
	      var result = [];
	      each(children(scope), function (x) {
	        if (predicate(x)) {
	          result = result.concat([x]);
	        }
	        result = result.concat(descendants(x, predicate));
	      });
	      return result;
	    };
	
	    var descendants$1 = function (scope, selector) {
	      return all(selector, scope);
	    };
	
	    function ClosestOrAncestor (is, ancestor, scope, a, isRoot) {
	      return is(scope, a) ? Option.some(scope) : isFunction(isRoot) && isRoot(scope) ? Option.none() : ancestor(scope, a, isRoot);
	    }
	
	    var ancestor = function (scope, predicate, isRoot) {
	      var element = scope.dom();
	      var stop = isFunction(isRoot) ? isRoot : constant(false);
	      while (element.parentNode) {
	        element = element.parentNode;
	        var el = Element.fromDom(element);
	        if (predicate(el)) {
	          return Option.some(el);
	        } else if (stop(el)) {
	          break;
	        }
	      }
	      return Option.none();
	    };
	    var closest = function (scope, predicate, isRoot) {
	      var is = function (s, test) {
	        return test(s);
	      };
	      return ClosestOrAncestor(is, ancestor, scope, predicate, isRoot);
	    };
	
	    var ancestor$1 = function (scope, selector, isRoot) {
	      return ancestor(scope, function (e) {
	        return is(e, selector);
	      }, isRoot);
	    };
	    var descendant = function (scope, selector) {
	      return one(selector, scope);
	    };
	    var closest$1 = function (scope, selector, isRoot) {
	      return ClosestOrAncestor(is, ancestor$1, scope, selector, isRoot);
	    };
	
	    var annotation = constant('mce-annotation');
	    var dataAnnotation = constant('data-mce-annotation');
	    var dataAnnotationId = constant('data-mce-annotation-uid');
	
	    var identify = function (editor, annotationName) {
	      var rng = editor.selection.getRng();
	      var start = Element.fromDom(rng.startContainer);
	      var root = Element.fromDom(editor.getBody());
	      var selector = annotationName.fold(function () {
	        return '.' + annotation();
	      }, function (an) {
	        return '[' + dataAnnotation() + '="' + an + '"]';
	      });
	      var newStart = child(start, rng.startOffset).getOr(start);
	      var closest = closest$1(newStart, selector, function (n) {
	        return eq(n, root);
	      });
	      var getAttr = function (c, property) {
	        if (has$1(c, property)) {
	          return Option.some(get$3(c, property));
	        } else {
	          return Option.none();
	        }
	      };
	      return closest.bind(function (c) {
	        return getAttr(c, '' + dataAnnotationId()).bind(function (uid) {
	          return getAttr(c, '' + dataAnnotation()).map(function (name) {
	            var elements = findMarkers(editor, uid);
	            return {
	              uid: uid,
	              name: name,
	              elements: elements
	            };
	          });
	        });
	      });
	    };
	    var isAnnotation = function (elem) {
	      return isElement(elem) && has$2(elem, annotation());
	    };
	    var findMarkers = function (editor, uid) {
	      var body = Element.fromDom(editor.getBody());
	      return descendants$1(body, '[' + dataAnnotationId() + '="' + uid + '"]');
	    };
	    var findAll = function (editor, name) {
	      var body = Element.fromDom(editor.getBody());
	      var markers = descendants$1(body, '[' + dataAnnotation() + '="' + name + '"]');
	      var directory = {};
	      each(markers, function (m) {
	        var uid = get$3(m, dataAnnotationId());
	        var nodesAlready = directory.hasOwnProperty(uid) ? directory[uid] : [];
	        directory[uid] = nodesAlready.concat([m]);
	      });
	      return directory;
	    };
	
	    var setup = function (editor, registry) {
	      var changeCallbacks = Cell({});
	      var initData = function () {
	        return {
	          listeners: [],
	          previous: Cell(Option.none())
	        };
	      };
	      var withCallbacks = function (name, f) {
	        updateCallbacks(name, function (data) {
	          f(data);
	          return data;
	        });
	      };
	      var updateCallbacks = function (name, f) {
	        var callbackMap = changeCallbacks.get();
	        var data = callbackMap.hasOwnProperty(name) ? callbackMap[name] : initData();
	        var outputData = f(data);
	        callbackMap[name] = outputData;
	        changeCallbacks.set(callbackMap);
	      };
	      var fireCallbacks = function (name, uid, elements) {
	        withCallbacks(name, function (data) {
	          each(data.listeners, function (f) {
	            return f(true, name, {
	              uid: uid,
	              nodes: map(elements, function (elem) {
	                return elem.dom();
	              })
	            });
	          });
	        });
	      };
	      var fireNoAnnotation = function (name) {
	        withCallbacks(name, function (data) {
	          each(data.listeners, function (f) {
	            return f(false, name);
	          });
	        });
	      };
	      var onNodeChange = last$2(function () {
	        var callbackMap = changeCallbacks.get();
	        var annotations = sort(keys(callbackMap));
	        each(annotations, function (name) {
	          updateCallbacks(name, function (data) {
	            var prev = data.previous.get();
	            identify(editor, Option.some(name)).fold(function () {
	              if (prev.isSome()) {
	                fireNoAnnotation(name);
	                data.previous.set(Option.none());
	              }
	            }, function (_a) {
	              var uid = _a.uid, name = _a.name, elements = _a.elements;
	              if (!prev.is(uid)) {
	                fireCallbacks(name, uid, elements);
	                data.previous.set(Option.some(uid));
	              }
	            });
	            return {
	              previous: data.previous,
	              listeners: data.listeners
	            };
	          });
	        });
	      }, 30);
	      editor.on('remove', function () {
	        onNodeChange.cancel();
	      });
	      editor.on('NodeChange', function () {
	        onNodeChange.throttle();
	      });
	      var addListener = function (name, f) {
	        updateCallbacks(name, function (data) {
	          return {
	            previous: data.previous,
	            listeners: data.listeners.concat([f])
	          };
	        });
	      };
	      return { addListener: addListener };
	    };
	
	    var setup$1 = function (editor, registry) {
	      var identifyParserNode = function (span) {
	        return Option.from(span.attr(dataAnnotation())).bind(registry.lookup);
	      };
	      editor.on('init', function () {
	        editor.serializer.addNodeFilter('span', function (spans) {
	          each(spans, function (span) {
	            identifyParserNode(span).each(function (settings) {
	              if (settings.persistent === false) {
	                span.unwrap();
	              }
	            });
	          });
	        });
	      });
	    };
	
	    var create$1 = function () {
	      var annotations = {};
	      var register = function (name, settings) {
	        annotations[name] = {
	          name: name,
	          settings: settings
	        };
	      };
	      var lookup = function (name) {
	        return annotations.hasOwnProperty(name) ? Option.from(annotations[name]).map(function (a) {
	          return a.settings;
	        }) : Option.none();
	      };
	      return {
	        register: register,
	        lookup: lookup
	      };
	    };
	
	    var unique = 0;
	    var generate = function (prefix) {
	      var date = new Date();
	      var time = date.getTime();
	      var random = Math.floor(Math.random() * 1000000000);
	      unique++;
	      return prefix + '_' + random + unique + String(time);
	    };
	
	    var add$4 = function (element, classes) {
	      each(classes, function (x) {
	        add$3(element, x);
	      });
	    };
	
	    var fromHtml$1 = function (html, scope) {
	      var doc = scope || domGlobals.document;
	      var div = doc.createElement('div');
	      div.innerHTML = html;
	      return children(Element.fromDom(div));
	    };
	
	    var get$6 = function (element) {
	      return element.dom().innerHTML;
	    };
	    var set$1 = function (element, content) {
	      var owner$1 = owner(element);
	      var docDom = owner$1.dom();
	      var fragment = Element.fromDom(docDom.createDocumentFragment());
	      var contentElements = fromHtml$1(content, docDom);
	      append$1(fragment, contentElements);
	      empty(element);
	      append(element, fragment);
	    };
	
	    var clone = function (original, isDeep) {
	      return Element.fromDom(original.dom().cloneNode(isDeep));
	    };
	    var shallow = function (original) {
	      return clone(original, false);
	    };
	    var deep = function (original) {
	      return clone(original, true);
	    };
	
	    var ZWSP = zeroWidth;
	    var isZwsp = function (chr) {
	      return chr === ZWSP;
	    };
	    var trim$3 = function (text) {
	      return text.replace(new RegExp(ZWSP, 'g'), '');
	    };
	    var Zwsp = {
	      isZwsp: isZwsp,
	      ZWSP: ZWSP,
	      trim: trim$3
	    };
	
	    var isElement$2 = NodeType.isElement;
	    var isText$2 = NodeType.isText;
	    var isCaretContainerBlock = function (node) {
	      if (isText$2(node)) {
	        node = node.parentNode;
	      }
	      return isElement$2(node) && node.hasAttribute('data-mce-caret');
	    };
	    var isCaretContainerInline = function (node) {
	      return isText$2(node) && Zwsp.isZwsp(node.data);
	    };
	    var isCaretContainer = function (node) {
	      return isCaretContainerBlock(node) || isCaretContainerInline(node);
	    };
	    var hasContent = function (node) {
	      return node.firstChild !== node.lastChild || !NodeType.isBr(node.firstChild);
	    };
	    var insertInline = function (node, before) {
	      var doc, sibling, textNode, parentNode;
	      doc = node.ownerDocument;
	      textNode = doc.createTextNode(Zwsp.ZWSP);
	      parentNode = node.parentNode;
	      if (!before) {
	        sibling = node.nextSibling;
	        if (isText$2(sibling)) {
	          if (isCaretContainer(sibling)) {
	            return sibling;
	          }
	          if (startsWithCaretContainer(sibling)) {
	            sibling.splitText(1);
	            return sibling;
	          }
	        }
	        if (node.nextSibling) {
	          parentNode.insertBefore(textNode, node.nextSibling);
	        } else {
	          parentNode.appendChild(textNode);
	        }
	      } else {
	        sibling = node.previousSibling;
	        if (isText$2(sibling)) {
	          if (isCaretContainer(sibling)) {
	            return sibling;
	          }
	          if (endsWithCaretContainer(sibling)) {
	            return sibling.splitText(sibling.data.length - 1);
	          }
	        }
	        parentNode.insertBefore(textNode, node);
	      }
	      return textNode;
	    };
	    var isBeforeInline = function (pos) {
	      var container = pos.container();
	      if (!pos || !NodeType.isText(container)) {
	        return false;
	      }
	      return container.data.charAt(pos.offset()) === Zwsp.ZWSP || pos.isAtStart() && isCaretContainerInline(container.previousSibling);
	    };
	    var isAfterInline = function (pos) {
	      var container = pos.container();
	      if (!pos || !NodeType.isText(container)) {
	        return false;
	      }
	      return container.data.charAt(pos.offset() - 1) === Zwsp.ZWSP || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);
	    };
	    var createBogusBr = function () {
	      var br = domGlobals.document.createElement('br');
	      br.setAttribute('data-mce-bogus', '1');
	      return br;
	    };
	    var insertBlock = function (blockName, node, before) {
	      var doc, blockNode, parentNode;
	      doc = node.ownerDocument;
	      blockNode = doc.createElement(blockName);
	      blockNode.setAttribute('data-mce-caret', before ? 'before' : 'after');
	      blockNode.setAttribute('data-mce-bogus', 'all');
	      blockNode.appendChild(createBogusBr());
	      parentNode = node.parentNode;
	      if (!before) {
	        if (node.nextSibling) {
	          parentNode.insertBefore(blockNode, node.nextSibling);
	        } else {
	          parentNode.appendChild(blockNode);
	        }
	      } else {
	        parentNode.insertBefore(blockNode, node);
	      }
	      return blockNode;
	    };
	    var startsWithCaretContainer = function (node) {
	      return isText$2(node) && node.data[0] === Zwsp.ZWSP;
	    };
	    var endsWithCaretContainer = function (node) {
	      return isText$2(node) && node.data[node.data.length - 1] === Zwsp.ZWSP;
	    };
	    var trimBogusBr = function (elm) {
	      var brs = elm.getElementsByTagName('br');
	      var lastBr = brs[brs.length - 1];
	      if (NodeType.isBogus(lastBr)) {
	        lastBr.parentNode.removeChild(lastBr);
	      }
	    };
	    var showCaretContainerBlock = function (caretContainer) {
	      if (caretContainer && caretContainer.hasAttribute('data-mce-caret')) {
	        trimBogusBr(caretContainer);
	        caretContainer.removeAttribute('data-mce-caret');
	        caretContainer.removeAttribute('data-mce-bogus');
	        caretContainer.removeAttribute('style');
	        caretContainer.removeAttribute('_moz_abspos');
	        return caretContainer;
	      }
	      return null;
	    };
	    var isRangeInCaretContainerBlock = function (range) {
	      return isCaretContainerBlock(range.startContainer);
	    };
	
	    var isContentEditableTrue$1 = NodeType.isContentEditableTrue;
	    var isContentEditableFalse$1 = NodeType.isContentEditableFalse;
	    var isBr$2 = NodeType.isBr;
	    var isText$3 = NodeType.isText;
	    var isInvalidTextElement = NodeType.matchNodeNames([
	      'script',
	      'style',
	      'textarea'
	    ]);
	    var isAtomicInline = NodeType.matchNodeNames([
	      'img',
	      'input',
	      'textarea',
	      'hr',
	      'iframe',
	      'video',
	      'audio',
	      'object'
	    ]);
	    var isTable$2 = NodeType.matchNodeNames(['table']);
	    var isCaretContainer$1 = isCaretContainer;
	    var isCaretCandidate = function (node) {
	      if (isCaretContainer$1(node)) {
	        return false;
	      }
	      if (isText$3(node)) {
	        if (isInvalidTextElement(node.parentNode)) {
	          return false;
	        }
	        return true;
	      }
	      return isAtomicInline(node) || isBr$2(node) || isTable$2(node) || isNonUiContentEditableFalse(node);
	    };
	    var isUnselectable = function (node) {
	      return NodeType.isElement(node) && node.getAttribute('unselectable') === 'true';
	    };
	    var isNonUiContentEditableFalse = function (node) {
	      return isUnselectable(node) === false && isContentEditableFalse$1(node);
	    };
	    var isInEditable = function (node, root) {
	      for (node = node.parentNode; node && node !== root; node = node.parentNode) {
	        if (isNonUiContentEditableFalse(node)) {
	          return false;
	        }
	        if (isContentEditableTrue$1(node)) {
	          return true;
	        }
	      }
	      return true;
	    };
	    var isAtomicContentEditableFalse = function (node) {
	      if (!isNonUiContentEditableFalse(node)) {
	        return false;
	      }
	      return foldl(from$1(node.getElementsByTagName('*')), function (result, elm) {
	        return result || isContentEditableTrue$1(elm);
	      }, false) !== true;
	    };
	    var isAtomic = function (node) {
	      return isAtomicInline(node) || isAtomicContentEditableFalse(node);
	    };
	    var isEditableCaretCandidate = function (node, root) {
	      return isCaretCandidate(node) && isInEditable(node, root);
	    };
	
	    var round = Math.round;
	    var clone$1 = function (rect) {
	      if (!rect) {
	        return {
	          left: 0,
	          top: 0,
	          bottom: 0,
	          right: 0,
	          width: 0,
	          height: 0
	        };
	      }
	      return {
	        left: round(rect.left),
	        top: round(rect.top),
	        bottom: round(rect.bottom),
	        right: round(rect.right),
	        width: round(rect.width),
	        height: round(rect.height)
	      };
	    };
	    var collapse = function (rect, toStart) {
	      rect = clone$1(rect);
	      if (toStart) {
	        rect.right = rect.left;
	      } else {
	        rect.left = rect.left + rect.width;
	        rect.right = rect.left;
	      }
	      rect.width = 0;
	      return rect;
	    };
	    var isEqual = function (rect1, rect2) {
	      return rect1.left === rect2.left && rect1.top === rect2.top && rect1.bottom === rect2.bottom && rect1.right === rect2.right;
	    };
	    var isValidOverflow = function (overflowY, rect1, rect2) {
	      return overflowY >= 0 && overflowY <= Math.min(rect1.height, rect2.height) / 2;
	    };
	    var isAbove = function (rect1, rect2) {
	      if (rect1.bottom - rect1.height / 2 < rect2.top) {
	        return true;
	      }
	      if (rect1.top > rect2.bottom) {
	        return false;
	      }
	      return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);
	    };
	    var isBelow = function (rect1, rect2) {
	      if (rect1.top > rect2.bottom) {
	        return true;
	      }
	      if (rect1.bottom < rect2.top) {
	        return false;
	      }
	      return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);
	    };
	    var containsXY = function (rect, clientX, clientY) {
	      return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;
	    };
	
	    var getSelectedNode = function (range) {
	      var startContainer = range.startContainer, startOffset = range.startOffset;
	      if (startContainer.hasChildNodes() && range.endOffset === startOffset + 1) {
	        return startContainer.childNodes[startOffset];
	      }
	      return null;
	    };
	    var getNode = function (container, offset) {
	      if (container.nodeType === 1 && container.hasChildNodes()) {
	        if (offset >= container.childNodes.length) {
	          offset = container.childNodes.length - 1;
	        }
	        container = container.childNodes[offset];
	      }
	      return container;
	    };
	
	    var extendingChars = new RegExp('[\u0300-\u036f\u0483-\u0487\u0488-\u0489\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7\u0610-\u061a' + '\u064b-\u065f\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7-\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0' + '\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e3-\u0902\u093a\u093c' + '\u0941-\u0948\u094d\u0951-\u0957\u0962-\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2-\u09e3' + '\u0a01-\u0a02\u0a3c\u0a41-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51\u0a70-\u0a71\u0a75\u0a81-\u0a82\u0abc' + '\u0ac1-\u0ac5\u0ac7-\u0ac8\u0acd\u0ae2-\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57' + '\u0b62-\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c00\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56' + '\u0c62-\u0c63\u0c81\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc-\u0ccd\u0cd5-\u0cd6\u0ce2-\u0ce3\u0d01\u0d3e\u0d41-\u0d44' + '\u0d4d\u0d57\u0d62-\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9' + '\u0ebb-\u0ebc\u0ec8-\u0ecd\u0f18-\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86-\u0f87\u0f8d-\u0f97' + '\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039-\u103a\u103d-\u103e\u1058-\u1059\u105e-\u1060\u1071-\u1074' + '\u1082\u1085-\u1086\u108d\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17b4-\u17b5' + '\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927-\u1928\u1932\u1939-\u193b\u1a17-\u1a18' + '\u1a1b\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1ab0-\u1abd\u1ABE\u1b00-\u1b03\u1b34' + '\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80-\u1b81\u1ba2-\u1ba5\u1ba8-\u1ba9\u1bab-\u1bad\u1be6\u1be8-\u1be9' + '\u1bed\u1bef-\u1bf1\u1c2c-\u1c33\u1c36-\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1cf4\u1cf8-\u1cf9' + '\u1dc0-\u1df5\u1dfc-\u1dff\u200c-\u200d\u20d0-\u20dc\u20DD-\u20E0\u20e1\u20E2-\u20E4\u20e5-\u20f0\u2cef-\u2cf1' + '\u2d7f\u2de0-\u2dff\u302a-\u302d\u302e-\u302f\u3099-\u309a\ua66f\uA670-\uA672\ua674-\ua67d\ua69e-\ua69f\ua6f0-\ua6f1' + '\ua802\ua806\ua80b\ua825-\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc' + '\ua9e5\uaa29-\uaa2e\uaa31-\uaa32\uaa35-\uaa36\uaa43\uaa4c\uaa7c\uaab0\uaab2-\uaab4\uaab7-\uaab8\uaabe-\uaabf\uaac1' + '\uaaec-\uaaed\uaaf6\uabe5\uabe8\uabed\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\uff9e-\uff9f]');
	    var isExtendingChar = function (ch) {
	      return typeof ch === 'string' && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
	    };
	
	    var lift2 = function (oa, ob, f) {
	      return oa.isSome() && ob.isSome() ? Option.some(f(oa.getOrDie(), ob.getOrDie())) : Option.none();
	    };
	    var lift3 = function (oa, ob, oc, f) {
	      return oa.isSome() && ob.isSome() && oc.isSome() ? Option.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Option.none();
	    };
	    var someIf = function (b, a) {
	      return b ? Option.some(a) : Option.none();
	    };
	
	    var slice$2 = [].slice;
	    var or = function () {
	      var x = [];
	      for (var _i = 0; _i < arguments.length; _i++) {
	        x[_i] = arguments[_i];
	      }
	      var args = slice$2.call(arguments);
	      return function (x) {
	        for (var i = 0; i < args.length; i++) {
	          if (args[i](x)) {
	            return true;
	          }
	        }
	        return false;
	      };
	    };
	    var and = function () {
	      var x = [];
	      for (var _i = 0; _i < arguments.length; _i++) {
	        x[_i] = arguments[_i];
	      }
	      var args = slice$2.call(arguments);
	      return function (x) {
	        for (var i = 0; i < args.length; i++) {
	          if (!args[i](x)) {
	            return false;
	          }
	        }
	        return true;
	      };
	    };
	    var Predicate = {
	      and: and,
	      or: or
	    };
	
	    var isElement$3 = NodeType.isElement;
	    var isCaretCandidate$1 = isCaretCandidate;
	    var isBlock$1 = NodeType.matchStyleValues('display', 'block table');
	    var isFloated = NodeType.matchStyleValues('float', 'left right');
	    var isValidElementCaretCandidate = Predicate.and(isElement$3, isCaretCandidate$1, not(isFloated));
	    var isNotPre = not(NodeType.matchStyleValues('white-space', 'pre pre-line pre-wrap'));
	    var isText$4 = NodeType.isText;
	    var isBr$3 = NodeType.isBr;
	    var nodeIndex = DOMUtils$1.nodeIndex;
	    var resolveIndex = getNode;
	    var createRange = function (doc) {
	      return 'createRange' in doc ? doc.createRange() : DOMUtils$1.DOM.createRng();
	    };
	    var isWhiteSpace = function (chr) {
	      return chr && /[\r\n\t ]/.test(chr);
	    };
	    var isRange = function (rng) {
	      return !!rng.setStart && !!rng.setEnd;
	    };
	    var isHiddenWhiteSpaceRange = function (range) {
	      var container = range.startContainer;
	      var offset = range.startOffset;
	      var text;
	      if (isWhiteSpace(range.toString()) && isNotPre(container.parentNode) && NodeType.isText(container)) {
	        text = container.data;
	        if (isWhiteSpace(text[offset - 1]) || isWhiteSpace(text[offset + 1])) {
	          return true;
	        }
	      }
	      return false;
	    };
	    var getBrClientRect = function (brNode) {
	      var doc = brNode.ownerDocument;
	      var rng = createRange(doc);
	      var nbsp$1 = doc.createTextNode(nbsp);
	      var parentNode = brNode.parentNode;
	      var clientRect;
	      parentNode.insertBefore(nbsp$1, brNode);
	      rng.setStart(nbsp$1, 0);
	      rng.setEnd(nbsp$1, 1);
	      clientRect = clone$1(rng.getBoundingClientRect());
	      parentNode.removeChild(nbsp$1);
	      return clientRect;
	    };
	    var getBoundingClientRectWebKitText = function (rng) {
	      var sc = rng.startContainer;
	      var ec = rng.endContainer;
	      var so = rng.startOffset;
	      var eo = rng.endOffset;
	      if (sc === ec && NodeType.isText(ec) && so === 0 && eo === 1) {
	        var newRng = rng.cloneRange();
	        newRng.setEndAfter(ec);
	        return getBoundingClientRect(newRng);
	      } else {
	        return null;
	      }
	    };
	    var isZeroRect = function (r) {
	      return r.left === 0 && r.right === 0 && r.top === 0 && r.bottom === 0;
	    };
	    var getBoundingClientRect = function (item) {
	      var clientRect, clientRects;
	      clientRects = item.getClientRects();
	      if (clientRects.length > 0) {
	        clientRect = clone$1(clientRects[0]);
	      } else {
	        clientRect = clone$1(item.getBoundingClientRect());
	      }
	      if (!isRange(item) && isBr$3(item) && isZeroRect(clientRect)) {
	        return getBrClientRect(item);
	      }
	      if (isZeroRect(clientRect) && isRange(item)) {
	        return getBoundingClientRectWebKitText(item);
	      }
	      return clientRect;
	    };
	    var collapseAndInflateWidth = function (clientRect, toStart) {
	      var newClientRect = collapse(clientRect, toStart);
	      newClientRect.width = 1;
	      newClientRect.right = newClientRect.left + 1;
	      return newClientRect;
	    };
	    var getCaretPositionClientRects = function (caretPosition) {
	      var clientRects = [];
	      var beforeNode, node;
	      var addUniqueAndValidRect = function (clientRect) {
	        if (clientRect.height === 0) {
	          return;
	        }
	        if (clientRects.length > 0) {
	          if (isEqual(clientRect, clientRects[clientRects.length - 1])) {
	            return;
	          }
	        }
	        clientRects.push(clientRect);
	      };
	      var addCharacterOffset = function (container, offset) {
	        var range = createRange(container.ownerDocument);
	        if (offset < container.data.length) {
	          if (isExtendingChar(container.data[offset])) {
	            return clientRects;
	          }
	          if (isExtendingChar(container.data[offset - 1])) {
	            range.setStart(container, offset);
	            range.setEnd(container, offset + 1);
	            if (!isHiddenWhiteSpaceRange(range)) {
	              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range), false));
	              return clientRects;
	            }
	          }
	        }
	        if (offset > 0) {
	          range.setStart(container, offset - 1);
	          range.setEnd(container, offset);
	          if (!isHiddenWhiteSpaceRange(range)) {
	            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range), false));
	          }
	        }
	        if (offset < container.data.length) {
	          range.setStart(container, offset);
	          range.setEnd(container, offset + 1);
	          if (!isHiddenWhiteSpaceRange(range)) {
	            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range), true));
	          }
	        }
	      };
	      if (isText$4(caretPosition.container())) {
	        addCharacterOffset(caretPosition.container(), caretPosition.offset());
	        return clientRects;
	      }
	      if (isElement$3(caretPosition.container())) {
	        if (caretPosition.isAtEnd()) {
	          node = resolveIndex(caretPosition.container(), caretPosition.offset());
	          if (isText$4(node)) {
	            addCharacterOffset(node, node.data.length);
	          }
	          if (isValidElementCaretCandidate(node) && !isBr$3(node)) {
	            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node), false));
	          }
	        } else {
	          node = resolveIndex(caretPosition.container(), caretPosition.offset());
	          if (isText$4(node)) {
	            addCharacterOffset(node, 0);
	          }
	          if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {
	            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node), false));
	            return clientRects;
	          }
	          beforeNode = resolveIndex(caretPosition.container(), caretPosition.offset() - 1);
	          if (isValidElementCaretCandidate(beforeNode) && !isBr$3(beforeNode)) {
	            if (isBlock$1(beforeNode) || isBlock$1(node) || !isValidElementCaretCandidate(node)) {
	              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(beforeNode), false));
	            }
	          }
	          if (isValidElementCaretCandidate(node)) {
	            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node), true));
	          }
	        }
	      }
	      return clientRects;
	    };
	    function CaretPosition(container, offset, clientRects) {
	      var isAtStart = function () {
	        if (isText$4(container)) {
	          return offset === 0;
	        }
	        return offset === 0;
	      };
	      var isAtEnd = function () {
	        if (isText$4(container)) {
	          return offset >= container.data.length;
	        }
	        return offset >= container.childNodes.length;
	      };
	      var toRange = function () {
	        var range;
	        range = createRange(container.ownerDocument);
	        range.setStart(container, offset);
	        range.setEnd(container, offset);
	        return range;
	      };
	      var getClientRects = function () {
	        if (!clientRects) {
	          clientRects = getCaretPositionClientRects(CaretPosition(container, offset));
	        }
	        return clientRects;
	      };
	      var isVisible = function () {
	        return getClientRects().length > 0;
	      };
	      var isEqual = function (caretPosition) {
	        return caretPosition && container === caretPosition.container() && offset === caretPosition.offset();
	      };
	      var getNode = function (before) {
	        return resolveIndex(container, before ? offset - 1 : offset);
	      };
	      return {
	        container: constant(container),
	        offset: constant(offset),
	        toRange: toRange,
	        getClientRects: getClientRects,
	        isVisible: isVisible,
	        isAtStart: isAtStart,
	        isAtEnd: isAtEnd,
	        isEqual: isEqual,
	        getNode: getNode
	      };
	    }
	    (function (CaretPosition) {
	      CaretPosition.fromRangeStart = function (range) {
	        return CaretPosition(range.startContainer, range.startOffset);
	      };
	      CaretPosition.fromRangeEnd = function (range) {
	        return CaretPosition(range.endContainer, range.endOffset);
	      };
	      CaretPosition.after = function (node) {
	        return CaretPosition(node.parentNode, nodeIndex(node) + 1);
	      };
	      CaretPosition.before = function (node) {
	        return CaretPosition(node.parentNode, nodeIndex(node));
	      };
	      CaretPosition.isAbove = function (pos1, pos2) {
	        return lift2(head(pos2.getClientRects()), last(pos1.getClientRects()), isAbove).getOr(false);
	      };
	      CaretPosition.isBelow = function (pos1, pos2) {
	        return lift2(last(pos2.getClientRects()), head(pos1.getClientRects()), isBelow).getOr(false);
	      };
	      CaretPosition.isAtStart = function (pos) {
	        return pos ? pos.isAtStart() : false;
	      };
	      CaretPosition.isAtEnd = function (pos) {
	        return pos ? pos.isAtEnd() : false;
	      };
	      CaretPosition.isTextPosition = function (pos) {
	        return pos ? NodeType.isText(pos.container()) : false;
	      };
	      CaretPosition.isElementPosition = function (pos) {
	        return CaretPosition.isTextPosition(pos) === false;
	      };
	    }(CaretPosition || (CaretPosition = {})));
	    var CaretPosition$1 = CaretPosition;
	
	    var isText$5 = NodeType.isText;
	    var isBogus$1 = NodeType.isBogus;
	    var nodeIndex$1 = DOMUtils$1.nodeIndex;
	    var normalizedParent = function (node) {
	      var parentNode = node.parentNode;
	      if (isBogus$1(parentNode)) {
	        return normalizedParent(parentNode);
	      }
	      return parentNode;
	    };
	    var getChildNodes = function (node) {
	      if (!node) {
	        return [];
	      }
	      return ArrUtils.reduce(node.childNodes, function (result, node) {
	        if (isBogus$1(node) && node.nodeName !== 'BR') {
	          result = result.concat(getChildNodes(node));
	        } else {
	          result.push(node);
	        }
	        return result;
	      }, []);
	    };
	    var normalizedTextOffset = function (node, offset) {
	      while (node = node.previousSibling) {
	        if (!isText$5(node)) {
	          break;
	        }
	        offset += node.data.length;
	      }
	      return offset;
	    };
	    var equal = function (a) {
	      return function (b) {
	        return a === b;
	      };
	    };
	    var normalizedNodeIndex = function (node) {
	      var nodes, index, numTextFragments;
	      nodes = getChildNodes(normalizedParent(node));
	      index = ArrUtils.findIndex(nodes, equal(node), node);
	      nodes = nodes.slice(0, index + 1);
	      numTextFragments = ArrUtils.reduce(nodes, function (result, node, i) {
	        if (isText$5(node) && isText$5(nodes[i - 1])) {
	          result++;
	        }
	        return result;
	      }, 0);
	      nodes = ArrUtils.filter(nodes, NodeType.matchNodeNames([node.nodeName]));
	      index = ArrUtils.findIndex(nodes, equal(node), node);
	      return index - numTextFragments;
	    };
	    var createPathItem = function (node) {
	      var name;
	      if (isText$5(node)) {
	        name = 'text()';
	      } else {
	        name = node.nodeName.toLowerCase();
	      }
	      return name + '[' + normalizedNodeIndex(node) + ']';
	    };
	    var parentsUntil = function (root, node, predicate) {
	      var parents = [];
	      for (node = node.parentNode; node !== root; node = node.parentNode) {
	        if (predicate && predicate(node)) {
	          break;
	        }
	        parents.push(node);
	      }
	      return parents;
	    };
	    var create$2 = function (root, caretPosition) {
	      var container, offset, path = [], outputOffset, childNodes, parents;
	      container = caretPosition.container();
	      offset = caretPosition.offset();
	      if (isText$5(container)) {
	        outputOffset = normalizedTextOffset(container, offset);
	      } else {
	        childNodes = container.childNodes;
	        if (offset >= childNodes.length) {
	          outputOffset = 'after';
	          offset = childNodes.length - 1;
	        } else {
	          outputOffset = 'before';
	        }
	        container = childNodes[offset];
	      }
	      path.push(createPathItem(container));
	      parents = parentsUntil(root, container);
	      parents = ArrUtils.filter(parents, not(NodeType.isBogus));
	      path = path.concat(ArrUtils.map(parents, function (node) {
	        return createPathItem(node);
	      }));
	      return path.reverse().join('/') + ',' + outputOffset;
	    };
	    var resolvePathItem = function (node, name, index) {
	      var nodes = getChildNodes(node);
	      nodes = ArrUtils.filter(nodes, function (node, index) {
	        return !isText$5(node) || !isText$5(nodes[index - 1]);
	      });
	      nodes = ArrUtils.filter(nodes, NodeType.matchNodeNames([name]));
	      return nodes[index];
	    };
	    var findTextPosition = function (container, offset) {
	      var node = container, targetOffset = 0, dataLen;
	      while (isText$5(node)) {
	        dataLen = node.data.length;
	        if (offset >= targetOffset && offset <= targetOffset + dataLen) {
	          container = node;
	          offset = offset - targetOffset;
	          break;
	        }
	        if (!isText$5(node.nextSibling)) {
	          container = node;
	          offset = dataLen;
	          break;
	        }
	        targetOffset += dataLen;
	        node = node.nextSibling;
	      }
	      if (isText$5(container) && offset > container.data.length) {
	        offset = container.data.length;
	      }
	      return CaretPosition$1(container, offset);
	    };
	    var resolve$1 = function (root, path) {
	      var parts, container, offset;
	      if (!path) {
	        return null;
	      }
	      parts = path.split(',');
	      path = parts[0].split('/');
	      offset = parts.length > 1 ? parts[1] : 'before';
	      container = ArrUtils.reduce(path, function (result, value) {
	        value = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(value);
	        if (!value) {
	          return null;
	        }
	        if (value[1] === 'text()') {
	          value[1] = '#text';
	        }
	        return resolvePathItem(result, value[1], parseInt(value[2], 10));
	      }, root);
	      if (!container) {
	        return null;
	      }
	      if (!isText$5(container)) {
	        if (offset === 'after') {
	          offset = nodeIndex$1(container) + 1;
	        } else {
	          offset = nodeIndex$1(container);
	        }
	        return CaretPosition$1(container.parentNode, offset);
	      }
	      return findTextPosition(container, parseInt(offset, 10));
	    };
	
	    var trimEmptyTextNode = function (dom, node) {
	      if (NodeType.isText(node) && node.data.length === 0) {
	        dom.remove(node);
	      }
	    };
	    var insertNode = function (dom, rng, node) {
	      rng.insertNode(node);
	      trimEmptyTextNode(dom, node.previousSibling);
	      trimEmptyTextNode(dom, node.nextSibling);
	    };
	    var insertFragment = function (dom, rng, frag) {
	      var firstChild = Option.from(frag.firstChild);
	      var lastChild = Option.from(frag.lastChild);
	      rng.insertNode(frag);
	      firstChild.each(function (child) {
	        return trimEmptyTextNode(dom, child.previousSibling);
	      });
	      lastChild.each(function (child) {
	        return trimEmptyTextNode(dom, child.nextSibling);
	      });
	    };
	    var rangeInsertNode = function (dom, rng, node) {
	      if (NodeType.isDocumentFragment(node)) {
	        insertFragment(dom, rng, node);
	      } else {
	        insertNode(dom, rng, node);
	      }
	    };
	
	    var isContentEditableFalse$2 = NodeType.isContentEditableFalse;
	    var getNormalizedTextOffset = function (trim, container, offset) {
	      var node, trimmedOffset;
	      trimmedOffset = trim(container.data.slice(0, offset)).length;
	      for (node = container.previousSibling; node && NodeType.isText(node); node = node.previousSibling) {
	        trimmedOffset += trim(node.data).length;
	      }
	      return trimmedOffset;
	    };
	    var getPoint = function (dom, trim, normalized, rng, start) {
	      var container = rng[start ? 'startContainer' : 'endContainer'];
	      var offset = rng[start ? 'startOffset' : 'endOffset'];
	      var point = [];
	      var childNodes, after = 0;
	      var root = dom.getRoot();
	      if (NodeType.isText(container)) {
	        point.push(normalized ? getNormalizedTextOffset(trim, container, offset) : offset);
	      } else {
	        childNodes = container.childNodes;
	        if (offset >= childNodes.length && childNodes.length) {
	          after = 1;
	          offset = Math.max(0, childNodes.length - 1);
	        }
	        point.push(dom.nodeIndex(childNodes[offset], normalized) + after);
	      }
	      for (; container && container !== root; container = container.parentNode) {
	        point.push(dom.nodeIndex(container, normalized));
	      }
	      return point;
	    };
	    var getLocation = function (trim, selection, normalized, rng) {
	      var dom = selection.dom, bookmark = {};
	      bookmark.start = getPoint(dom, trim, normalized, rng, true);
	      if (!selection.isCollapsed()) {
	        bookmark.end = getPoint(dom, trim, normalized, rng, false);
	      }
	      return bookmark;
	    };
	    var findIndex$2 = function (dom, name, element) {
	      var count = 0;
	      Tools.each(dom.select(name), function (node) {
	        if (node.getAttribute('data-mce-bogus') === 'all') {
	          return;
	        }
	        if (node === element) {
	          return false;
	        }
	        count++;
	      });
	      return count;
	    };
	    var moveEndPoint = function (rng, start) {
	      var container, offset, childNodes;
	      var prefix = start ? 'start' : 'end';
	      container = rng[prefix + 'Container'];
	      offset = rng[prefix + 'Offset'];
	      if (NodeType.isElement(container) && container.nodeName === 'TR') {
	        childNodes = container.childNodes;
	        container = childNodes[Math.min(start ? offset : offset - 1, childNodes.length - 1)];
	        if (container) {
	          offset = start ? 0 : container.childNodes.length;
	          rng['set' + (start ? 'Start' : 'End')](container, offset);
	        }
	      }
	    };
	    var normalizeTableCellSelection = function (rng) {
	      moveEndPoint(rng, true);
	      moveEndPoint(rng, false);
	      return rng;
	    };
	    var findSibling = function (node, offset) {
	      var sibling;
	      if (NodeType.isElement(node)) {
	        node = getNode(node, offset);
	        if (isContentEditableFalse$2(node)) {
	          return node;
	        }
	      }
	      if (isCaretContainer(node)) {
	        if (NodeType.isText(node) && isCaretContainerBlock(node)) {
	          node = node.parentNode;
	        }
	        sibling = node.previousSibling;
	        if (isContentEditableFalse$2(sibling)) {
	          return sibling;
	        }
	        sibling = node.nextSibling;
	        if (isContentEditableFalse$2(sibling)) {
	          return sibling;
	        }
	      }
	    };
	    var findAdjacentContentEditableFalseElm = function (rng) {
	      return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);
	    };
	    var getOffsetBookmark = function (trim, normalized, selection) {
	      var element = selection.getNode();
	      var name = element ? element.nodeName : null;
	      var rng = selection.getRng();
	      if (isContentEditableFalse$2(element) || name === 'IMG') {
	        return {
	          name: name,
	          index: findIndex$2(selection.dom, name, element)
	        };
	      }
	      var sibling = findAdjacentContentEditableFalseElm(rng);
	      if (sibling) {
	        name = sibling.tagName;
	        return {
	          name: name,
	          index: findIndex$2(selection.dom, name, sibling)
	        };
	      }
	      return getLocation(trim, selection, normalized, rng);
	    };
	    var getCaretBookmark = function (selection) {
	      var rng = selection.getRng();
	      return {
	        start: create$2(selection.dom.getRoot(), CaretPosition$1.fromRangeStart(rng)),
	        end: create$2(selection.dom.getRoot(), CaretPosition$1.fromRangeEnd(rng))
	      };
	    };
	    var getRangeBookmark = function (selection) {
	      return { rng: selection.getRng() };
	    };
	    var createBookmarkSpan = function (dom, id, filled) {
	      var args = {
	        'data-mce-type': 'bookmark',
	        'id': id,
	        'style': 'overflow:hidden;line-height:0px'
	      };
	      return filled ? dom.create('span', args, '&#xFEFF;') : dom.create('span', args);
	    };
	    var getPersistentBookmark = function (selection, filled) {
	      var dom = selection.dom;
	      var rng = selection.getRng();
	      var id = dom.uniqueId();
	      var collapsed = selection.isCollapsed();
	      var element = selection.getNode();
	      var name = element.nodeName;
	      if (name === 'IMG') {
	        return {
	          name: name,
	          index: findIndex$2(dom, name, element)
	        };
	      }
	      var rng2 = normalizeTableCellSelection(rng.cloneRange());
	      if (!collapsed) {
	        rng2.collapse(false);
	        var endBookmarkNode = createBookmarkSpan(dom, id + '_end', filled);
	        rangeInsertNode(dom, rng2, endBookmarkNode);
	      }
	      rng = normalizeTableCellSelection(rng);
	      rng.collapse(true);
	      var startBookmarkNode = createBookmarkSpan(dom, id + '_start', filled);
	      rangeInsertNode(dom, rng, startBookmarkNode);
	      selection.moveToBookmark({
	        id: id,
	        keep: 1
	      });
	      return { id: id };
	    };
	    var getBookmark = function (selection, type, normalized) {
	      if (type === 2) {
	        return getOffsetBookmark(Zwsp.trim, normalized, selection);
	      } else if (type === 3) {
	        return getCaretBookmark(selection);
	      } else if (type) {
	        return getRangeBookmark(selection);
	      } else {
	        return getPersistentBookmark(selection, false);
	      }
	    };
	    var GetBookmark = {
	      getBookmark: getBookmark,
	      getUndoBookmark: curry(getOffsetBookmark, identity, true),
	      getPersistentBookmark: getPersistentBookmark
	    };
	
	    var TextWalker = function (startNode, rootNode, isBoundary) {
	      if (isBoundary === void 0) {
	        isBoundary = never;
	      }
	      var walker = new TreeWalker(startNode, rootNode);
	      var walk = function (direction) {
	        var next;
	        do {
	          next = walker[direction]();
	        } while (next && !NodeType.isText(next) && !isBoundary(next));
	        return Option.from(next).filter(NodeType.isText);
	      };
	      return {
	        current: function () {
	          return Option.from(walker.current()).filter(NodeType.isText);
	        },
	        next: function () {
	          return walk('next');
	        },
	        prev: function () {
	          return walk('prev');
	        },
	        prev2: function () {
	          return walk('prev2');
	        }
	      };
	    };
	
	    var TextSeeker = function (dom, isBoundary) {
	      var isBlockBoundary = isBoundary ? isBoundary : function (node) {
	        return dom.isBlock(node) || NodeType.isBr(node) || NodeType.isContentEditableFalse(node);
	      };
	      var walk = function (node, offset, walker, process) {
	        if (NodeType.isText(node)) {
	          var newOffset = process(node, offset, node.data);
	          if (newOffset !== -1) {
	            return Option.some({
	              container: node,
	              offset: newOffset
	            });
	          }
	        }
	        return walker().bind(function (next) {
	          return walk(next.container, next.offset, walker, process);
	        });
	      };
	      var backwards = function (node, offset, process, root) {
	        var walker = TextWalker(node, root, isBlockBoundary);
	        return walk(node, offset, function () {
	          return walker.prev().map(function (prev) {
	            return {
	              container: prev,
	              offset: prev.length
	            };
	          });
	        }, process).getOrNull();
	      };
	      var forwards = function (node, offset, process, root) {
	        var walker = TextWalker(node, root, isBlockBoundary);
	        return walk(node, offset, function () {
	          return walker.next().map(function (next) {
	            return {
	              container: next,
	              offset: 0
	            };
	          });
	        }, process).getOrNull();
	      };
	      return {
	        backwards: backwards,
	        forwards: forwards
	      };
	    };
	
	    var CARET_ID = '_mce_caret';
	    var isCaretNode = function (node) {
	      return NodeType.isElement(node) && node.id === CARET_ID;
	    };
	    var getParentCaretContainer = function (body, node) {
	      while (node && node !== body) {
	        if (node.id === CARET_ID) {
	          return node;
	        }
	        node = node.parentNode;
	      }
	      return null;
	    };
	
	    var isElement$4 = NodeType.isElement;
	    var isText$6 = NodeType.isText;
	    var removeNode = function (node) {
	      var parentNode = node.parentNode;
	      if (parentNode) {
	        parentNode.removeChild(node);
	      }
	    };
	    var getNodeValue = function (node) {
	      try {
	        return node.nodeValue;
	      } catch (ex) {
	        return '';
	      }
	    };
	    var setNodeValue = function (node, text) {
	      if (text.length === 0) {
	        removeNode(node);
	      } else {
	        node.nodeValue = text;
	      }
	    };
	    var trimCount = function (text) {
	      var trimmedText = Zwsp.trim(text);
	      return {
	        count: text.length - trimmedText.length,
	        text: trimmedText
	      };
	    };
	    var removeUnchanged = function (caretContainer, pos) {
	      remove$5(caretContainer);
	      return pos;
	    };
	    var removeTextAndReposition = function (caretContainer, pos) {
	      var before = trimCount(caretContainer.data.substr(0, pos.offset()));
	      var after = trimCount(caretContainer.data.substr(pos.offset()));
	      var text = before.text + after.text;
	      if (text.length > 0) {
	        setNodeValue(caretContainer, text);
	        return CaretPosition$1(caretContainer, pos.offset() - before.count);
	      } else {
	        return pos;
	      }
	    };
	    var removeElementAndReposition = function (caretContainer, pos) {
	      var parentNode = pos.container();
	      var newPosition = indexOf(from$1(parentNode.childNodes), caretContainer).map(function (index) {
	        return index < pos.offset() ? CaretPosition$1(parentNode, pos.offset() - 1) : pos;
	      }).getOr(pos);
	      remove$5(caretContainer);
	      return newPosition;
	    };
	    var removeTextCaretContainer = function (caretContainer, pos) {
	      return isText$6(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
	    };
	    var removeElementCaretContainer = function (caretContainer, pos) {
	      return pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
	    };
	    var removeAndReposition = function (container, pos) {
	      return CaretPosition$1.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);
	    };
	    var remove$5 = function (caretContainerNode) {
	      if (isElement$4(caretContainerNode) && isCaretContainer(caretContainerNode)) {
	        if (hasContent(caretContainerNode)) {
	          caretContainerNode.removeAttribute('data-mce-caret');
	        } else {
	          removeNode(caretContainerNode);
	        }
	      }
	      if (isText$6(caretContainerNode)) {
	        var text = Zwsp.trim(getNodeValue(caretContainerNode));
	        setNodeValue(caretContainerNode, text);
	      }
	    };
	    var CaretContainerRemove = {
	      removeAndReposition: removeAndReposition,
	      remove: remove$5
	    };
	
	    var DOM$1 = DOMUtils$1.DOM;
	    var getBodySetting = function (editor, name, defaultValue) {
	      var value = editor.getParam(name, defaultValue);
	      if (value.indexOf('=') !== -1) {
	        var bodyObj = editor.getParam(name, '', 'hash');
	        return bodyObj.hasOwnProperty(editor.id) ? bodyObj[editor.id] : defaultValue;
	      } else {
	        return value;
	      }
	    };
	    var getIframeAttrs = function (editor) {
	      return editor.getParam('iframe_attrs', {});
	    };
	    var getDocType = function (editor) {
	      return editor.getParam('doctype', '<!DOCTYPE html>');
	    };
	    var getDocumentBaseUrl = function (editor) {
	      return editor.getParam('document_base_url', '');
	    };
	    var getBodyId = function (editor) {
	      return getBodySetting(editor, 'body_id', 'tinymce');
	    };
	    var getBodyClass = function (editor) {
	      return getBodySetting(editor, 'body_class', '');
	    };
	    var getContentSecurityPolicy = function (editor) {
	      return editor.getParam('content_security_policy', '');
	    };
	    var shouldPutBrInPre = function (editor) {
	      return editor.getParam('br_in_pre', true);
	    };
	    var getForcedRootBlock = function (editor) {
	      if (editor.getParam('force_p_newlines', false)) {
	        return 'p';
	      }
	      var block = editor.getParam('forced_root_block', 'p');
	      if (block === false) {
	        return '';
	      } else if (block === true) {
	        return 'p';
	      } else {
	        return block;
	      }
	    };
	    var getForcedRootBlockAttrs = function (editor) {
	      return editor.getParam('forced_root_block_attrs', {});
	    };
	    var getBrNewLineSelector = function (editor) {
	      return editor.getParam('br_newline_selector', '.mce-toc h2,figcaption,caption');
	    };
	    var getNoNewLineSelector = function (editor) {
	      return editor.getParam('no_newline_selector', '');
	    };
	    var shouldKeepStyles = function (editor) {
	      return editor.getParam('keep_styles', true);
	    };
	    var shouldEndContainerOnEmptyBlock = function (editor) {
	      return editor.getParam('end_container_on_empty_block', false);
	    };
	    var getFontStyleValues = function (editor) {
	      return Tools.explode(editor.getParam('font_size_style_values', 'xx-small,x-small,small,medium,large,x-large,xx-large'));
	    };
	    var getFontSizeClasses = function (editor) {
	      return Tools.explode(editor.getParam('font_size_classes', ''));
	    };
	    var getImagesDataImgFilter = function (editor) {
	      return editor.getParam('images_dataimg_filter', constant(true), 'function');
	    };
	    var isAutomaticUploadsEnabled = function (editor) {
	      return editor.getParam('automatic_uploads', true, 'boolean');
	    };
	    var shouldReuseFileName = function (editor) {
	      return editor.getParam('images_reuse_filename', false, 'boolean');
	    };
	    var shouldReplaceBlobUris = function (editor) {
	      return editor.getParam('images_replace_blob_uris', true, 'boolean');
	    };
	    var getIconPackName = function (editor) {
	      return editor.getParam('icons', '', 'string');
	    };
	    var getIconsUrl = function (editor) {
	      return editor.getParam('icons_url', '', 'string');
	    };
	    var getImageUploadUrl = function (editor) {
	      return editor.getParam('images_upload_url', '', 'string');
	    };
	    var getImageUploadBasePath = function (editor) {
	      return editor.getParam('images_upload_base_path', '', 'string');
	    };
	    var getImagesUploadCredentials = function (editor) {
	      return editor.getParam('images_upload_credentials', false, 'boolean');
	    };
	    var getImagesUploadHandler = function (editor) {
	      return editor.getParam('images_upload_handler', null, 'function');
	    };
	    var shouldUseContentCssCors = function (editor) {
	      return editor.getParam('content_css_cors', false, 'boolean');
	    };
	    var getReferrerPolicy = function (editor) {
	      return editor.getParam('referrer_policy', '', 'string');
	    };
	    var getLanguageCode = function (editor) {
	      return editor.getParam('language', 'en', 'string');
	    };
	    var getLanguageUrl = function (editor) {
	      return editor.getParam('language_url', '', 'string');
	    };
	    var shouldIndentUseMargin = function (editor) {
	      return editor.getParam('indent_use_margin', false);
	    };
	    var getIndentation = function (editor) {
	      return editor.getParam('indentation', '40px', 'string');
	    };
	    var getContentCss = function (editor) {
	      var contentCss = editor.settings.content_css;
	      if (isString(contentCss)) {
	        return map(contentCss.split(','), trim);
	      } else if (isArray(contentCss)) {
	        return contentCss;
	      } else if (contentCss === false || editor.inline) {
	        return [];
	      } else {
	        return ['default'];
	      }
	    };
	    var getDirectionality = function (editor) {
	      return editor.getParam('directionality', I18n.isRtl() ? 'rtl' : undefined);
	    };
	    var getInlineBoundarySelector = function (editor) {
	      return editor.getParam('inline_boundaries_selector', 'a[href],code,.mce-annotation', 'string');
	    };
	    var getObjectResizing = function (editor) {
	      return editor.getParam('object_resizing');
	    };
	    var getResizeImgProportional = function (editor) {
	      return editor.getParam('resize_img_proportional', true, 'boolean');
	    };
	    var getPlaceholder = function (editor) {
	      return editor.getParam('placeholder', DOM$1.getAttrib(editor.getElement(), 'placeholder'), 'string');
	    };
	    var Settings = {
	      getIframeAttrs: getIframeAttrs,
	      getDocType: getDocType,
	      getDocumentBaseUrl: getDocumentBaseUrl,
	      getBodyId: getBodyId,
	      getBodyClass: getBodyClass,
	      getContentSecurityPolicy: getContentSecurityPolicy,
	      shouldPutBrInPre: shouldPutBrInPre,
	      getForcedRootBlock: getForcedRootBlock,
	      getForcedRootBlockAttrs: getForcedRootBlockAttrs,
	      getBrNewLineSelector: getBrNewLineSelector,
	      getNoNewLineSelector: getNoNewLineSelector,
	      shouldKeepStyles: shouldKeepStyles,
	      shouldEndContainerOnEmptyBlock: shouldEndContainerOnEmptyBlock,
	      getFontStyleValues: getFontStyleValues,
	      getFontSizeClasses: getFontSizeClasses,
	      getIconPackName: getIconPackName,
	      getIconsUrl: getIconsUrl,
	      getImagesDataImgFilter: getImagesDataImgFilter,
	      isAutomaticUploadsEnabled: isAutomaticUploadsEnabled,
	      shouldReuseFileName: shouldReuseFileName,
	      shouldReplaceBlobUris: shouldReplaceBlobUris,
	      getImageUploadUrl: getImageUploadUrl,
	      getImageUploadBasePath: getImageUploadBasePath,
	      getImagesUploadCredentials: getImagesUploadCredentials,
	      getImagesUploadHandler: getImagesUploadHandler,
	      shouldUseContentCssCors: shouldUseContentCssCors,
	      getReferrerPolicy: getReferrerPolicy,
	      getLanguageCode: getLanguageCode,
	      getLanguageUrl: getLanguageUrl,
	      shouldIndentUseMargin: shouldIndentUseMargin,
	      getIndentation: getIndentation,
	      getContentCss: getContentCss,
	      getDirectionality: getDirectionality,
	      getInlineBoundarySelector: getInlineBoundarySelector,
	      getObjectResizing: getObjectResizing,
	      getResizeImgProportional: getResizeImgProportional,
	      getPlaceholder: getPlaceholder
	    };
	
	    var browser$3 = detect$3().browser;
	    var isContentEditableFalse$3 = NodeType.isContentEditableFalse;
	    var isTableCell$1 = function (node) {
	      return NodeType.isElement(node) && /^(TD|TH)$/i.test(node.tagName);
	    };
	    var getAbsoluteClientRect = function (root, element, before) {
	      var clientRect = collapse(element.getBoundingClientRect(), before);
	      var docElm, scrollX, scrollY, margin, rootRect;
	      if (root.tagName === 'BODY') {
	        docElm = root.ownerDocument.documentElement;
	        scrollX = root.scrollLeft || docElm.scrollLeft;
	        scrollY = root.scrollTop || docElm.scrollTop;
	      } else {
	        rootRect = root.getBoundingClientRect();
	        scrollX = root.scrollLeft - rootRect.left;
	        scrollY = root.scrollTop - rootRect.top;
	      }
	      clientRect.left += scrollX;
	      clientRect.right += scrollX;
	      clientRect.top += scrollY;
	      clientRect.bottom += scrollY;
	      clientRect.width = 1;
	      margin = element.offsetWidth - element.clientWidth;
	      if (margin > 0) {
	        if (before) {
	          margin *= -1;
	        }
	        clientRect.left += margin;
	        clientRect.right += margin;
	      }
	      return clientRect;
	    };
	    var trimInlineCaretContainers = function (root) {
	      var contentEditableFalseNodes, node, sibling, i, data;
	      contentEditableFalseNodes = DomQuery('*[contentEditable=false]', root);
	      for (i = 0; i < contentEditableFalseNodes.length; i++) {
	        node = contentEditableFalseNodes[i];
	        sibling = node.previousSibling;
	        if (endsWithCaretContainer(sibling)) {
	          data = sibling.data;
	          if (data.length === 1) {
	            sibling.parentNode.removeChild(sibling);
	          } else {
	            sibling.deleteData(data.length - 1, 1);
	          }
	        }
	        sibling = node.nextSibling;
	        if (startsWithCaretContainer(sibling)) {
	          data = sibling.data;
	          if (data.length === 1) {
	            sibling.parentNode.removeChild(sibling);
	          } else {
	            sibling.deleteData(0, 1);
	          }
	        }
	      }
	    };
	    var FakeCaret = function (editor, root, isBlock, hasFocus) {
	      var lastVisualCaret = Cell(Option.none());
	      var cursorInterval, caretContainerNode;
	      var rootBlock = Settings.getForcedRootBlock(editor);
	      var caretBlock = rootBlock.length > 0 ? rootBlock : 'p';
	      var show = function (before, element) {
	        var clientRect, rng;
	        hide();
	        if (isTableCell$1(element)) {
	          return null;
	        }
	        if (isBlock(element)) {
	          caretContainerNode = insertBlock(caretBlock, element, before);
	          clientRect = getAbsoluteClientRect(root, element, before);
	          DomQuery(caretContainerNode).css('top', clientRect.top);
	          var caret = DomQuery('<div class="mce-visual-caret" data-mce-bogus="all"></div>').css(clientRect).appendTo(root)[0];
	          lastVisualCaret.set(Option.some({
	            caret: caret,
	            element: element,
	            before: before
	          }));
	          lastVisualCaret.get().each(function (caretState) {
	            if (before) {
	              DomQuery(caretState.caret).addClass('mce-visual-caret-before');
	            }
	          });
	          startBlink();
	          rng = element.ownerDocument.createRange();
	          rng.setStart(caretContainerNode, 0);
	          rng.setEnd(caretContainerNode, 0);
	        } else {
	          caretContainerNode = insertInline(element, before);
	          rng = element.ownerDocument.createRange();
	          if (isContentEditableFalse$3(caretContainerNode.nextSibling)) {
	            rng.setStart(caretContainerNode, 0);
	            rng.setEnd(caretContainerNode, 0);
	          } else {
	            rng.setStart(caretContainerNode, 1);
	            rng.setEnd(caretContainerNode, 1);
	          }
	          return rng;
	        }
	        return rng;
	      };
	      var hide = function () {
	        trimInlineCaretContainers(root);
	        if (caretContainerNode) {
	          CaretContainerRemove.remove(caretContainerNode);
	          caretContainerNode = null;
	        }
	        lastVisualCaret.get().each(function (caretState) {
	          DomQuery(caretState.caret).remove();
	          lastVisualCaret.set(Option.none());
	        });
	        Delay.clearInterval(cursorInterval);
	      };
	      var startBlink = function () {
	        cursorInterval = Delay.setInterval(function () {
	          if (hasFocus()) {
	            DomQuery('div.mce-visual-caret', root).toggleClass('mce-visual-caret-hidden');
	          } else {
	            DomQuery('div.mce-visual-caret', root).addClass('mce-visual-caret-hidden');
	          }
	        }, 500);
	      };
	      var reposition = function () {
	        lastVisualCaret.get().each(function (caretState) {
	          var clientRect = getAbsoluteClientRect(root, caretState.element, caretState.before);
	          DomQuery(caretState.caret).css(__assign({}, clientRect));
	        });
	      };
	      var destroy = function () {
	        return Delay.clearInterval(cursorInterval);
	      };
	      var getCss = function () {
	        return '.mce-visual-caret {' + 'position: absolute;' + 'background-color: black;' + 'background-color: currentcolor;' + '}' + '.mce-visual-caret-hidden {' + 'display: none;' + '}' + '*[data-mce-caret] {' + 'position: absolute;' + 'left: -1000px;' + 'right: auto;' + 'top: 0;' + 'margin: 0;' + 'padding: 0;' + '}';
	      };
	      return {
	        show: show,
	        hide: hide,
	        getCss: getCss,
	        reposition: reposition,
	        destroy: destroy
	      };
	    };
	    var isFakeCaretTableBrowser = function () {
	      return browser$3.isIE() || browser$3.isEdge() || browser$3.isFirefox();
	    };
	    var isFakeCaretTarget = function (node) {
	      return isContentEditableFalse$3(node) || NodeType.isTable(node) && isFakeCaretTableBrowser();
	    };
	
	    var isContentEditableFalse$4 = NodeType.isContentEditableFalse;
	    var isBlockLike = NodeType.matchStyleValues('display', 'block table table-cell table-caption list-item');
	    var isCaretContainer$2 = isCaretContainer;
	    var isCaretContainerBlock$1 = isCaretContainerBlock;
	    var isElement$5 = NodeType.isElement;
	    var isCaretCandidate$2 = isCaretCandidate;
	    var isForwards = function (direction) {
	      return direction > 0;
	    };
	    var isBackwards = function (direction) {
	      return direction < 0;
	    };
	    var skipCaretContainers = function (walk, shallow) {
	      var node;
	      while (node = walk(shallow)) {
	        if (!isCaretContainerBlock$1(node)) {
	          return node;
	        }
	      }
	      return null;
	    };
	    var findNode = function (node, direction, predicateFn, rootNode, shallow) {
	      var walker = new TreeWalker(node, rootNode);
	      if (isBackwards(direction)) {
	        if (isContentEditableFalse$4(node) || isCaretContainerBlock$1(node)) {
	          node = skipCaretContainers(walker.prev, true);
	          if (predicateFn(node)) {
	            return node;
	          }
	        }
	        while (node = skipCaretContainers(walker.prev, shallow)) {
	          if (predicateFn(node)) {
	            return node;
	          }
	        }
	      }
	      if (isForwards(direction)) {
	        if (isContentEditableFalse$4(node) || isCaretContainerBlock$1(node)) {
	          node = skipCaretContainers(walker.next, true);
	          if (predicateFn(node)) {
	            return node;
	          }
	        }
	        while (node = skipCaretContainers(walker.next, shallow)) {
	          if (predicateFn(node)) {
	            return node;
	          }
	        }
	      }
	      return null;
	    };
	    var getParentBlock = function (node, rootNode) {
	      while (node && node !== rootNode) {
	        if (isBlockLike(node)) {
	          return node;
	        }
	        node = node.parentNode;
	      }
	      return null;
	    };
	    var isInSameBlock = function (caretPosition1, caretPosition2, rootNode) {
	      return getParentBlock(caretPosition1.container(), rootNode) === getParentBlock(caretPosition2.container(), rootNode);
	    };
	    var getChildNodeAtRelativeOffset = function (relativeOffset, caretPosition) {
	      var container, offset;
	      if (!caretPosition) {
	        return null;
	      }
	      container = caretPosition.container();
	      offset = caretPosition.offset();
	      if (!isElement$5(container)) {
	        return null;
	      }
	      return container.childNodes[offset + relativeOffset];
	    };
	    var beforeAfter = function (before, node) {
	      var range = node.ownerDocument.createRange();
	      if (before) {
	        range.setStartBefore(node);
	        range.setEndBefore(node);
	      } else {
	        range.setStartAfter(node);
	        range.setEndAfter(node);
	      }
	      return range;
	    };
	    var isNodesInSameBlock = function (root, node1, node2) {
	      return getParentBlock(node1, root) === getParentBlock(node2, root);
	    };
	    var lean = function (left, root, node) {
	      var sibling, siblingName;
	      if (left) {
	        siblingName = 'previousSibling';
	      } else {
	        siblingName = 'nextSibling';
	      }
	      while (node && node !== root) {
	        sibling = node[siblingName];
	        if (isCaretContainer$2(sibling)) {
	          sibling = sibling[siblingName];
	        }
	        if (isContentEditableFalse$4(sibling)) {
	          if (isNodesInSameBlock(root, sibling, node)) {
	            return sibling;
	          }
	          break;
	        }
	        if (isCaretCandidate$2(sibling)) {
	          break;
	        }
	        node = node.parentNode;
	      }
	      return null;
	    };
	    var before$2 = curry(beforeAfter, true);
	    var after$1 = curry(beforeAfter, false);
	    var normalizeRange = function (direction, root, range) {
	      var node, container, offset, location;
	      var leanLeft = curry(lean, true, root);
	      var leanRight = curry(lean, false, root);
	      container = range.startContainer;
	      offset = range.startOffset;
	      if (isCaretContainerBlock(container)) {
	        if (!isElement$5(container)) {
	          container = container.parentNode;
	        }
	        location = container.getAttribute('data-mce-caret');
	        if (location === 'before') {
	          node = container.nextSibling;
	          if (isFakeCaretTarget(node)) {
	            return before$2(node);
	          }
	        }
	        if (location === 'after') {
	          node = container.previousSibling;
	          if (isFakeCaretTarget(node)) {
	            return after$1(node);
	          }
	        }
	      }
	      if (!range.collapsed) {
	        return range;
	      }
	      if (NodeType.isText(container)) {
	        if (isCaretContainer$2(container)) {
	          if (direction === 1) {
	            node = leanRight(container);
	            if (node) {
	              return before$2(node);
	            }
	            node = leanLeft(container);
	            if (node) {
	              return after$1(node);
	            }
	          }
	          if (direction === -1) {
	            node = leanLeft(container);
	            if (node) {
	              return after$1(node);
	            }
	            node = leanRight(container);
	            if (node) {
	              return before$2(node);
	            }
	          }
	          return range;
	        }
	        if (endsWithCaretContainer(container) && offset >= container.data.length - 1) {
	          if (direction === 1) {
	            node = leanRight(container);
	            if (node) {
	              return before$2(node);
	            }
	          }
	          return range;
	        }
	        if (startsWithCaretContainer(container) && offset <= 1) {
	          if (direction === -1) {
	            node = leanLeft(container);
	            if (node) {
	              return after$1(node);
	            }
	          }
	          return range;
	        }
	        if (offset === container.data.length) {
	          node = leanRight(container);
	          if (node) {
	            return before$2(node);
	          }
	          return range;
	        }
	        if (offset === 0) {
	          node = leanLeft(container);
	          if (node) {
	            return after$1(node);
	          }
	          return range;
	        }
	      }
	      return range;
	    };
	    var getRelativeCefElm = function (forward, caretPosition) {
	      return Option.from(getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition)).filter(isContentEditableFalse$4);
	    };
	    var getNormalizedRangeEndPoint = function (direction, root, range) {
	      var normalizedRange = normalizeRange(direction, root, range);
	      if (direction === -1) {
	        return CaretPosition.fromRangeStart(normalizedRange);
	      }
	      return CaretPosition.fromRangeEnd(normalizedRange);
	    };
	    var getElementFromPosition = function (pos) {
	      return Option.from(pos.getNode()).map(Element.fromDom);
	    };
	    var getElementFromPrevPosition = function (pos) {
	      return Option.from(pos.getNode(true)).map(Element.fromDom);
	    };
	    var getVisualCaretPosition = function (walkFn, caretPosition) {
	      while (caretPosition = walkFn(caretPosition)) {
	        if (caretPosition.isVisible()) {
	          return caretPosition;
	        }
	      }
	      return caretPosition;
	    };
	    var isMoveInsideSameBlock = function (from, to) {
	      var inSameBlock = isInSameBlock(from, to);
	      if (!inSameBlock && NodeType.isBr(from.getNode())) {
	        return true;
	      }
	      return inSameBlock;
	    };
	
	    var HDirection;
	    (function (HDirection) {
	      HDirection[HDirection['Backwards'] = -1] = 'Backwards';
	      HDirection[HDirection['Forwards'] = 1] = 'Forwards';
	    }(HDirection || (HDirection = {})));
	    var isContentEditableFalse$5 = NodeType.isContentEditableFalse;
	    var isText$7 = NodeType.isText;
	    var isElement$6 = NodeType.isElement;
	    var isBr$4 = NodeType.isBr;
	    var isCaretCandidate$3 = isCaretCandidate;
	    var isAtomic$1 = isAtomic;
	    var isEditableCaretCandidate$1 = isEditableCaretCandidate;
	    var getParents = function (node, root) {
	      var parents = [];
	      while (node && node !== root) {
	        parents.push(node);
	        node = node.parentNode;
	      }
	      return parents;
	    };
	    var nodeAtIndex = function (container, offset) {
	      if (container.hasChildNodes() && offset < container.childNodes.length) {
	        return container.childNodes[offset];
	      }
	      return null;
	    };
	    var getCaretCandidatePosition = function (direction, node) {
	      if (isForwards(direction)) {
	        if (isCaretCandidate$3(node.previousSibling) && !isText$7(node.previousSibling)) {
	          return CaretPosition$1.before(node);
	        }
	        if (isText$7(node)) {
	          return CaretPosition$1(node, 0);
	        }
	      }
	      if (isBackwards(direction)) {
	        if (isCaretCandidate$3(node.nextSibling) && !isText$7(node.nextSibling)) {
	          return CaretPosition$1.after(node);
	        }
	        if (isText$7(node)) {
	          return CaretPosition$1(node, node.data.length);
	        }
	      }
	      if (isBackwards(direction)) {
	        if (isBr$4(node)) {
	          return CaretPosition$1.before(node);
	        }
	        return CaretPosition$1.after(node);
	      }
	      return CaretPosition$1.before(node);
	    };
	    var moveForwardFromBr = function (root, nextNode) {
	      var nextSibling = nextNode.nextSibling;
	      if (nextSibling && isCaretCandidate$3(nextSibling)) {
	        if (isText$7(nextSibling)) {
	          return CaretPosition$1(nextSibling, 0);
	        } else {
	          return CaretPosition$1.before(nextSibling);
	        }
	      } else {
	        return findCaretPosition(HDirection.Forwards, CaretPosition$1.after(nextNode), root);
	      }
	    };
	    var findCaretPosition = function (direction, startPos, root) {
	      var node, nextNode, innerNode;
	      var rootContentEditableFalseElm, caretPosition;
	      if (!isElement$6(root) || !startPos) {
	        return null;
	      }
	      if (startPos.isEqual(CaretPosition$1.after(root)) && root.lastChild) {
	        caretPosition = CaretPosition$1.after(root.lastChild);
	        if (isBackwards(direction) && isCaretCandidate$3(root.lastChild) && isElement$6(root.lastChild)) {
	          return isBr$4(root.lastChild) ? CaretPosition$1.before(root.lastChild) : caretPosition;
	        }
	      } else {
	        caretPosition = startPos;
	      }
	      var container = caretPosition.container();
	      var offset = caretPosition.offset();
	      if (isText$7(container)) {
	        if (isBackwards(direction) && offset > 0) {
	          return CaretPosition$1(container, --offset);
	        }
	        if (isForwards(direction) && offset < container.length) {
	          return CaretPosition$1(container, ++offset);
	        }
	        node = container;
	      } else {
	        if (isBackwards(direction) && offset > 0) {
	          nextNode = nodeAtIndex(container, offset - 1);
	          if (isCaretCandidate$3(nextNode)) {
	            if (!isAtomic$1(nextNode)) {
	              innerNode = findNode(nextNode, direction, isEditableCaretCandidate$1, nextNode);
	              if (innerNode) {
	                if (isText$7(innerNode)) {
	                  return CaretPosition$1(innerNode, innerNode.data.length);
	                }
	                return CaretPosition$1.after(innerNode);
	              }
	            }
	            if (isText$7(nextNode)) {
	              return CaretPosition$1(nextNode, nextNode.data.length);
	            }
	            return CaretPosition$1.before(nextNode);
	          }
	        }
	        if (isForwards(direction) && offset < container.childNodes.length) {
	          nextNode = nodeAtIndex(container, offset);
	          if (isCaretCandidate$3(nextNode)) {
	            if (isBr$4(nextNode)) {
	              return moveForwardFromBr(root, nextNode);
	            }
	            if (!isAtomic$1(nextNode)) {
	              innerNode = findNode(nextNode, direction, isEditableCaretCandidate$1, nextNode);
	              if (innerNode) {
	                if (isText$7(innerNode)) {
	                  return CaretPosition$1(innerNode, 0);
	                }
	                return CaretPosition$1.before(innerNode);
	              }
	            }
	            if (isText$7(nextNode)) {
	              return CaretPosition$1(nextNode, 0);
	            }
	            return CaretPosition$1.after(nextNode);
	          }
	        }
	        node = nextNode ? nextNode : caretPosition.getNode();
	      }
	      if (isForwards(direction) && caretPosition.isAtEnd() || isBackwards(direction) && caretPosition.isAtStart()) {
	        node = findNode(node, direction, constant(true), root, true);
	        if (isEditableCaretCandidate$1(node, root)) {
	          return getCaretCandidatePosition(direction, node);
	        }
	      }
	      nextNode = findNode(node, direction, isEditableCaretCandidate$1, root);
	      rootContentEditableFalseElm = ArrUtils.last(filter(getParents(container, root), isContentEditableFalse$5));
	      if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {
	        if (isForwards(direction)) {
	          caretPosition = CaretPosition$1.after(rootContentEditableFalseElm);
	        } else {
	          caretPosition = CaretPosition$1.before(rootContentEditableFalseElm);
	        }
	        return caretPosition;
	      }
	      if (nextNode) {
	        return getCaretCandidatePosition(direction, nextNode);
	      }
	      return null;
	    };
	    var CaretWalker = function (root) {
	      return {
	        next: function (caretPosition) {
	          return findCaretPosition(HDirection.Forwards, caretPosition, root);
	        },
	        prev: function (caretPosition) {
	          return findCaretPosition(HDirection.Backwards, caretPosition, root);
	        }
	      };
	    };
	
	    var walkToPositionIn = function (forward, root, start) {
	      var position = forward ? CaretPosition$1.before(start) : CaretPosition$1.after(start);
	      return fromPosition(forward, root, position);
	    };
	    var afterElement = function (node) {
	      return NodeType.isBr(node) ? CaretPosition$1.before(node) : CaretPosition$1.after(node);
	    };
	    var isBeforeOrStart = function (position) {
	      if (CaretPosition$1.isTextPosition(position)) {
	        return position.offset() === 0;
	      } else {
	        return isCaretCandidate(position.getNode());
	      }
	    };
	    var isAfterOrEnd = function (position) {
	      if (CaretPosition$1.isTextPosition(position)) {
	        var container = position.container();
	        return position.offset() === container.data.length;
	      } else {
	        return isCaretCandidate(position.getNode(true));
	      }
	    };
	    var isBeforeAfterSameElement = function (from, to) {
	      return !CaretPosition$1.isTextPosition(from) && !CaretPosition$1.isTextPosition(to) && from.getNode() === to.getNode(true);
	    };
	    var isAtBr = function (position) {
	      return !CaretPosition$1.isTextPosition(position) && NodeType.isBr(position.getNode());
	    };
	    var shouldSkipPosition = function (forward, from, to) {
	      if (forward) {
	        return !isBeforeAfterSameElement(from, to) && !isAtBr(from) && isAfterOrEnd(from) && isBeforeOrStart(to);
	      } else {
	        return !isBeforeAfterSameElement(to, from) && isBeforeOrStart(from) && isAfterOrEnd(to);
	      }
	    };
	    var fromPosition = function (forward, root, pos) {
	      var walker = CaretWalker(root);
	      return Option.from(forward ? walker.next(pos) : walker.prev(pos));
	    };
	    var navigate = function (forward, root, from) {
	      return fromPosition(forward, root, from).bind(function (to) {
	        if (isInSameBlock(from, to, root) && shouldSkipPosition(forward, from, to)) {
	          return fromPosition(forward, root, to);
	        } else {
	          return Option.some(to);
	        }
	      });
	    };
	    var navigateIgnore = function (forward, root, from, ignoreFilter) {
	      return navigate(forward, root, from).bind(function (pos) {
	        return ignoreFilter(pos) ? navigateIgnore(forward, root, pos, ignoreFilter) : Option.some(pos);
	      });
	    };
	    var positionIn = function (forward, element) {
	      var startNode = forward ? element.firstChild : element.lastChild;
	      if (NodeType.isText(startNode)) {
	        return Option.some(CaretPosition$1(startNode, forward ? 0 : startNode.data.length));
	      } else if (startNode) {
	        if (isCaretCandidate(startNode)) {
	          return Option.some(forward ? CaretPosition$1.before(startNode) : afterElement(startNode));
	        } else {
	          return walkToPositionIn(forward, element, startNode);
	        }
	      } else {
	        return Option.none();
	      }
	    };
	    var nextPosition = curry(fromPosition, true);
	    var prevPosition = curry(fromPosition, false);
	    var CaretFinder = {
	      fromPosition: fromPosition,
	      nextPosition: nextPosition,
	      prevPosition: prevPosition,
	      navigate: navigate,
	      navigateIgnore: navigateIgnore,
	      positionIn: positionIn,
	      firstPositionIn: curry(positionIn, true),
	      lastPositionIn: curry(positionIn, false)
	    };
	
	    var isStringPathBookmark = function (bookmark) {
	      return typeof bookmark.start === 'string';
	    };
	    var isRangeBookmark = function (bookmark) {
	      return bookmark.hasOwnProperty('rng');
	    };
	    var isIdBookmark = function (bookmark) {
	      return bookmark.hasOwnProperty('id');
	    };
	    var isIndexBookmark = function (bookmark) {
	      return bookmark.hasOwnProperty('name');
	    };
	    var isPathBookmark = function (bookmark) {
	      return Tools.isArray(bookmark.start);
	    };
	
	    var addBogus = function (dom, node) {
	      if (NodeType.isElement(node) && dom.isBlock(node) && !node.innerHTML && !Env.ie) {
	        node.innerHTML = '<br data-mce-bogus="1" />';
	      }
	      return node;
	    };
	    var resolveCaretPositionBookmark = function (dom, bookmark) {
	      var rng, pos;
	      rng = dom.createRng();
	      pos = resolve$1(dom.getRoot(), bookmark.start);
	      rng.setStart(pos.container(), pos.offset());
	      pos = resolve$1(dom.getRoot(), bookmark.end);
	      rng.setEnd(pos.container(), pos.offset());
	      return rng;
	    };
	    var insertZwsp = function (node, rng) {
	      var textNode = node.ownerDocument.createTextNode(Zwsp.ZWSP);
	      node.appendChild(textNode);
	      rng.setStart(textNode, 0);
	      rng.setEnd(textNode, 0);
	    };
	    var isEmpty = function (node) {
	      return node.hasChildNodes() === false;
	    };
	    var tryFindRangePosition = function (node, rng) {
	      return CaretFinder.lastPositionIn(node).fold(function () {
	        return false;
	      }, function (pos) {
	        rng.setStart(pos.container(), pos.offset());
	        rng.setEnd(pos.container(), pos.offset());
	        return true;
	      });
	    };
	    var padEmptyCaretContainer = function (root, node, rng) {
	      if (isEmpty(node) && getParentCaretContainer(root, node)) {
	        insertZwsp(node, rng);
	        return true;
	      } else {
	        return false;
	      }
	    };
	    var setEndPoint = function (dom, start, bookmark, rng) {
	      var point = bookmark[start ? 'start' : 'end'];
	      var i, node, offset, children;
	      var root = dom.getRoot();
	      if (point) {
	        offset = point[0];
	        for (node = root, i = point.length - 1; i >= 1; i--) {
	          children = node.childNodes;
	          if (padEmptyCaretContainer(root, node, rng)) {
	            return true;
	          }
	          if (point[i] > children.length - 1) {
	            if (padEmptyCaretContainer(root, node, rng)) {
	              return true;
	            }
	            return tryFindRangePosition(node, rng);
	          }
	          node = children[point[i]];
	        }
	        if (node.nodeType === 3) {
	          offset = Math.min(point[0], node.nodeValue.length);
	        }
	        if (node.nodeType === 1) {
	          offset = Math.min(point[0], node.childNodes.length);
	        }
	        if (start) {
	          rng.setStart(node, offset);
	        } else {
	          rng.setEnd(node, offset);
	        }
	      }
	      return true;
	    };
	    var isValidTextNode = function (node) {
	      return NodeType.isText(node) && node.data.length > 0;
	    };
	    var restoreEndPoint = function (dom, suffix, bookmark) {
	      var marker = dom.get(bookmark.id + '_' + suffix), node, idx, next, prev;
	      var keep = bookmark.keep;
	      var container, offset;
	      if (marker) {
	        node = marker.parentNode;
	        if (suffix === 'start') {
	          if (!keep) {
	            idx = dom.nodeIndex(marker);
	          } else {
	            if (marker.hasChildNodes()) {
	              node = marker.firstChild;
	              idx = 1;
	            } else if (isValidTextNode(marker.nextSibling)) {
	              node = marker.nextSibling;
	              idx = 0;
	            } else if (isValidTextNode(marker.previousSibling)) {
	              node = marker.previousSibling;
	              idx = marker.previousSibling.data.length;
	            } else {
	              node = marker.parentNode;
	              idx = dom.nodeIndex(marker) + 1;
	            }
	          }
	          container = node;
	          offset = idx;
	        } else {
	          if (!keep) {
	            idx = dom.nodeIndex(marker);
	          } else {
	            if (marker.hasChildNodes()) {
	              node = marker.firstChild;
	              idx = 1;
	            } else if (isValidTextNode(marker.previousSibling)) {
	              node = marker.previousSibling;
	              idx = marker.previousSibling.data.length;
	            } else {
	              node = marker.parentNode;
	              idx = dom.nodeIndex(marker);
	            }
	          }
	          container = node;
	          offset = idx;
	        }
	        if (!keep) {
	          prev = marker.previousSibling;
	          next = marker.nextSibling;
	          Tools.each(Tools.grep(marker.childNodes), function (node) {
	            if (NodeType.isText(node)) {
	              node.nodeValue = node.nodeValue.replace(/\uFEFF/g, '');
	            }
	          });
	          while (marker = dom.get(bookmark.id + '_' + suffix)) {
	            dom.remove(marker, true);
	          }
	          if (prev && next && prev.nodeType === next.nodeType && NodeType.isText(prev) && !Env.opera) {
	            idx = prev.nodeValue.length;
	            prev.appendData(next.nodeValue);
	            dom.remove(next);
	            if (suffix === 'start') {
	              container = prev;
	              offset = idx;
	            } else {
	              container = prev;
	              offset = idx;
	            }
	          }
	        }
	        return Option.some(CaretPosition$1(container, offset));
	      } else {
	        return Option.none();
	      }
	    };
	    var resolvePaths = function (dom, bookmark) {
	      var rng = dom.createRng();
	      if (setEndPoint(dom, true, bookmark, rng) && setEndPoint(dom, false, bookmark, rng)) {
	        return Option.some(rng);
	      } else {
	        return Option.none();
	      }
	    };
	    var resolveId = function (dom, bookmark) {
	      var startPos = restoreEndPoint(dom, 'start', bookmark);
	      var endPos = restoreEndPoint(dom, 'end', bookmark);
	      return lift2(startPos, endPos.or(startPos), function (spos, epos) {
	        var rng = dom.createRng();
	        rng.setStart(addBogus(dom, spos.container()), spos.offset());
	        rng.setEnd(addBogus(dom, epos.container()), epos.offset());
	        return rng;
	      });
	    };
	    var resolveIndex$1 = function (dom, bookmark) {
	      return Option.from(dom.select(bookmark.name)[bookmark.index]).map(function (elm) {
	        var rng = dom.createRng();
	        rng.selectNode(elm);
	        return rng;
	      });
	    };
	    var resolve$2 = function (selection, bookmark) {
	      var dom = selection.dom;
	      if (bookmark) {
	        if (isPathBookmark(bookmark)) {
	          return resolvePaths(dom, bookmark);
	        } else if (isStringPathBookmark(bookmark)) {
	          return Option.some(resolveCaretPositionBookmark(dom, bookmark));
	        } else if (isIdBookmark(bookmark)) {
	          return resolveId(dom, bookmark);
	        } else if (isIndexBookmark(bookmark)) {
	          return resolveIndex$1(dom, bookmark);
	        } else if (isRangeBookmark(bookmark)) {
	          return Option.some(bookmark.rng);
	        }
	      }
	      return Option.none();
	    };
	    var ResolveBookmark = { resolve: resolve$2 };
	
	    var getBookmark$1 = function (selection, type, normalized) {
	      return GetBookmark.getBookmark(selection, type, normalized);
	    };
	    var moveToBookmark = function (selection, bookmark) {
	      ResolveBookmark.resolve(selection, bookmark).each(function (rng) {
	        selection.setRng(rng);
	      });
	    };
	    var isBookmarkNode$1 = function (node) {
	      return NodeType.isElement(node) && node.tagName === 'SPAN' && node.getAttribute('data-mce-type') === 'bookmark';
	    };
	    var Bookmarks = {
	      getBookmark: getBookmark$1,
	      moveToBookmark: moveToBookmark,
	      isBookmarkNode: isBookmarkNode$1
	    };
	
	    var is$2 = function (expected) {
	      return function (actual) {
	        return expected === actual;
	      };
	    };
	    var isNbsp = is$2(nbsp);
	    var isWhiteSpace$1 = function (chr) {
	      return chr !== '' && ' \f\n\r\t\x0B'.indexOf(chr) !== -1;
	    };
	    var isContent = function (chr) {
	      return !isWhiteSpace$1(chr) && !isNbsp(chr);
	    };
	
	    var isNode = function (node) {
	      return !!node.nodeType;
	    };
	    var isInlineBlock = function (node) {
	      return node && /^(IMG)$/.test(node.nodeName);
	    };
	    var moveStart = function (dom, selection, rng) {
	      var offset = rng.startOffset;
	      var container = rng.startContainer, walker, node, nodes;
	      if (rng.startContainer === rng.endContainer) {
	        if (isInlineBlock(rng.startContainer.childNodes[rng.startOffset])) {
	          return;
	        }
	      }
	      if (container.nodeType === 1) {
	        nodes = container.childNodes;
	        if (offset < nodes.length) {
	          container = nodes[offset];
	          walker = new TreeWalker(container, dom.getParent(container, dom.isBlock));
	        } else {
	          container = nodes[nodes.length - 1];
	          walker = new TreeWalker(container, dom.getParent(container, dom.isBlock));
	          walker.next(true);
	        }
	        for (node = walker.current(); node; node = walker.next()) {
	          if (node.nodeType === 3 && !isWhiteSpaceNode(node)) {
	            rng.setStart(node, 0);
	            selection.setRng(rng);
	            return;
	          }
	        }
	      }
	    };
	    var getNonWhiteSpaceSibling = function (node, next, inc) {
	      if (node) {
	        var nextName = next ? 'nextSibling' : 'previousSibling';
	        for (node = inc ? node : node[nextName]; node; node = node[nextName]) {
	          if (node.nodeType === 1 || !isWhiteSpaceNode(node)) {
	            return node;
	          }
	        }
	      }
	    };
	    var isTextBlock$1 = function (editor, name) {
	      if (isNode(name)) {
	        name = name.nodeName;
	      }
	      return !!editor.schema.getTextBlockElements()[name.toLowerCase()];
	    };
	    var isValid = function (ed, parent, child) {
	      return ed.schema.isValidChild(parent, child);
	    };
	    var isWhiteSpaceNode = function (node) {
	      return node && NodeType.isText(node) && /^([\t \r\n]+|)$/.test(node.nodeValue);
	    };
	    var isEmptyTextNode = function (node) {
	      return node && NodeType.isText(node) && node.length === 0;
	    };
	    var replaceVars = function (value, vars) {
	      if (typeof value !== 'string') {
	        value = value(vars);
	      } else if (vars) {
	        value = value.replace(/%(\w+)/g, function (str, name) {
	          return vars[name] || str;
	        });
	      }
	      return value;
	    };
	    var isEq = function (str1, str2) {
	      str1 = str1 || '';
	      str2 = str2 || '';
	      str1 = '' + (str1.nodeName || str1);
	      str2 = '' + (str2.nodeName || str2);
	      return str1.toLowerCase() === str2.toLowerCase();
	    };
	    var normalizeStyleValue = function (dom, value, name) {
	      if (name === 'color' || name === 'backgroundColor') {
	        value = dom.toHex(value);
	      }
	      if (name === 'fontWeight' && value === 700) {
	        value = 'bold';
	      }
	      if (name === 'fontFamily') {
	        value = value.replace(/[\'\"]/g, '').replace(/,\s+/g, ',');
	      }
	      return '' + value;
	    };
	    var getStyle = function (dom, node, name) {
	      return normalizeStyleValue(dom, dom.getStyle(node, name), name);
	    };
	    var getTextDecoration = function (dom, node) {
	      var decoration;
	      dom.getParent(node, function (n) {
	        decoration = dom.getStyle(n, 'text-decoration');
	        return decoration && decoration !== 'none';
	      });
	      return decoration;
	    };
	    var getParents$1 = function (dom, node, selector) {
	      return dom.getParents(node, selector, dom.getRoot());
	    };
	
	    var isBookmarkNode$2 = Bookmarks.isBookmarkNode;
	    var getParents$2 = getParents$1, isWhiteSpaceNode$1 = isWhiteSpaceNode, isTextBlock$2 = isTextBlock$1;
	    var isBogusBr = function (node) {
	      return node.nodeName === 'BR' && node.getAttribute('data-mce-bogus') && !node.nextSibling;
	    };
	    var findParentContentEditable = function (dom, node) {
	      var parent = node;
	      while (parent) {
	        if (NodeType.isElement(parent) && dom.getContentEditable(parent)) {
	          return dom.getContentEditable(parent) === 'false' ? parent : node;
	        }
	        parent = parent.parentNode;
	      }
	      return node;
	    };
	    var walkText = function (start, node, offset, predicate) {
	      var str = node.data;
	      for (var i = offset; start ? i >= 0 : i < str.length; start ? i-- : i++) {
	        if (predicate(str.charAt(i))) {
	          return start ? i + 1 : i;
	        }
	      }
	      return -1;
	    };
	    var findSpace = function (start, node, offset) {
	      return walkText(start, node, offset, function (c) {
	        return isNbsp(c) || isWhiteSpace$1(c);
	      });
	    };
	    var findContent = function (start, node, offset) {
	      return walkText(start, node, offset, isContent);
	    };
	    var findWordEndPoint = function (dom, body, container, offset, start, includeTrailingSpaces) {
	      var lastTextNode;
	      var rootNode = dom.getParent(container, dom.isBlock) || body;
	      var walk = function (container, offset, pred) {
	        var textSeeker = TextSeeker(dom);
	        var walker = start ? textSeeker.backwards : textSeeker.forwards;
	        return Option.from(walker(container, offset, function (text, textOffset) {
	          if (isBookmarkNode$2(text.parentNode)) {
	            return -1;
	          } else {
	            lastTextNode = text;
	            return pred(start, text, textOffset);
	          }
	        }, rootNode));
	      };
	      var spaceResult = walk(container, offset, findSpace);
	      return spaceResult.bind(function (result) {
	        return includeTrailingSpaces ? walk(result.container, result.offset + (start ? -1 : 0), findContent) : Option.some(result);
	      }).orThunk(function () {
	        return lastTextNode ? Option.some({
	          container: lastTextNode,
	          offset: start ? 0 : lastTextNode.length
	        }) : Option.none();
	      });
	    };
	    var findSelectorEndPoint = function (dom, format, rng, container, siblingName) {
	      if (NodeType.isText(container) && container.nodeValue.length === 0 && container[siblingName]) {
	        container = container[siblingName];
	      }
	      var parents = getParents$2(dom, container);
	      for (var i = 0; i < parents.length; i++) {
	        for (var y = 0; y < format.length; y++) {
	          var curFormat = format[y];
	          if ('collapsed' in curFormat && curFormat.collapsed !== rng.collapsed) {
	            continue;
	          }
	          if (dom.is(parents[i], curFormat.selector)) {
	            return parents[i];
	          }
	        }
	      }
	      return container;
	    };
	    var findBlockEndPoint = function (editor, format, container, siblingName) {
	      var node;
	      var dom = editor.dom;
	      var root = dom.getRoot();
	      if (!format[0].wrapper) {
	        node = dom.getParent(container, format[0].block, root);
	      }
	      if (!node) {
	        var scopeRoot = dom.getParent(container, 'LI,TD,TH');
	        node = dom.getParent(NodeType.isText(container) ? container.parentNode : container, function (node) {
	          return node !== root && isTextBlock$2(editor, node);
	        }, scopeRoot);
	      }
	      if (node && format[0].wrapper) {
	        node = getParents$2(dom, node, 'ul,ol').reverse()[0] || node;
	      }
	      if (!node) {
	        node = container;
	        while (node[siblingName] && !dom.isBlock(node[siblingName])) {
	          node = node[siblingName];
	          if (isEq(node, 'br')) {
	            break;
	          }
	        }
	      }
	      return node || container;
	    };
	    var findParentContainer = function (dom, format, startContainer, startOffset, endContainer, endOffset, start) {
	      var container, parent, sibling, siblingName, root;
	      container = parent = start ? startContainer : endContainer;
	      siblingName = start ? 'previousSibling' : 'nextSibling';
	      root = dom.getRoot();
	      if (NodeType.isText(container) && !isWhiteSpaceNode$1(container)) {
	        if (start ? startOffset > 0 : endOffset < container.nodeValue.length) {
	          return container;
	        }
	      }
	      while (true) {
	        if (!format[0].block_expand && dom.isBlock(parent)) {
	          return parent;
	        }
	        for (sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {
	          if (!isBookmarkNode$2(sibling) && !isWhiteSpaceNode$1(sibling) && !isBogusBr(sibling)) {
	            return parent;
	          }
	        }
	        if (parent === root || parent.parentNode === root) {
	          container = parent;
	          break;
	        }
	        parent = parent.parentNode;
	      }
	      return container;
	    };
	    var expandRng = function (editor, rng, format, includeTrailingSpace) {
	      if (includeTrailingSpace === void 0) {
	        includeTrailingSpace = false;
	      }
	      var startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;
	      var dom = editor.dom;
	      if (NodeType.isElement(startContainer) && startContainer.hasChildNodes()) {
	        startContainer = getNode(startContainer, startOffset);
	        if (NodeType.isText(startContainer)) {
	          startOffset = 0;
	        }
	      }
	      if (NodeType.isElement(endContainer) && endContainer.hasChildNodes()) {
	        endContainer = getNode(endContainer, rng.collapsed ? endOffset : endOffset - 1);
	        if (NodeType.isText(endContainer)) {
	          endOffset = endContainer.nodeValue.length;
	        }
	      }
	      startContainer = findParentContentEditable(dom, startContainer);
	      endContainer = findParentContentEditable(dom, endContainer);
	      if (isBookmarkNode$2(startContainer.parentNode) || isBookmarkNode$2(startContainer)) {
	        startContainer = isBookmarkNode$2(startContainer) ? startContainer : startContainer.parentNode;
	        if (rng.collapsed) {
	          startContainer = startContainer.previousSibling || startContainer;
	        } else {
	          startContainer = startContainer.nextSibling || startContainer;
	        }
	        if (NodeType.isText(startContainer)) {
	          startOffset = rng.collapsed ? startContainer.length : 0;
	        }
	      }
	      if (isBookmarkNode$2(endContainer.parentNode) || isBookmarkNode$2(endContainer)) {
	        endContainer = isBookmarkNode$2(endContainer) ? endContainer : endContainer.parentNode;
	        if (rng.collapsed) {
	          endContainer = endContainer.nextSibling || endContainer;
	        } else {
	          endContainer = endContainer.previousSibling || endContainer;
	        }
	        if (NodeType.isText(endContainer)) {
	          endOffset = rng.collapsed ? 0 : endContainer.length;
	        }
	      }
	      if (rng.collapsed) {
	        var startPoint = findWordEndPoint(dom, editor.getBody(), startContainer, startOffset, true, includeTrailingSpace);
	        startPoint.each(function (_a) {
	          var container = _a.container, offset = _a.offset;
	          startContainer = container;
	          startOffset = offset;
	        });
	        var endPoint = findWordEndPoint(dom, editor.getBody(), endContainer, endOffset, false, includeTrailingSpace);
	        endPoint.each(function (_a) {
	          var container = _a.container, offset = _a.offset;
	          endContainer = container;
	          endOffset = offset;
	        });
	      }
	      if (format[0].inline || format[0].block_expand) {
	        if (!format[0].inline || (!NodeType.isText(startContainer) || startOffset === 0)) {
	          startContainer = findParentContainer(dom, format, startContainer, startOffset, endContainer, endOffset, true);
	        }
	        if (!format[0].inline || (!NodeType.isText(endContainer) || endOffset === endContainer.nodeValue.length)) {
	          endContainer = findParentContainer(dom, format, startContainer, startOffset, endContainer, endOffset, false);
	        }
	      }
	      if (format[0].selector && format[0].expand !== false && !format[0].inline) {
	        startContainer = findSelectorEndPoint(dom, format, rng, startContainer, 'previousSibling');
	        endContainer = findSelectorEndPoint(dom, format, rng, endContainer, 'nextSibling');
	      }
	      if (format[0].block || format[0].selector) {
	        startContainer = findBlockEndPoint(editor, format, startContainer, 'previousSibling');
	        endContainer = findBlockEndPoint(editor, format, endContainer, 'nextSibling');
	        if (format[0].block) {
	          if (!dom.isBlock(startContainer)) {
	            startContainer = findParentContainer(dom, format, startContainer, startOffset, endContainer, endOffset, true);
	          }
	          if (!dom.isBlock(endContainer)) {
	            endContainer = findParentContainer(dom, format, startContainer, startOffset, endContainer, endOffset, false);
	          }
	        }
	      }
	      if (NodeType.isElement(startContainer)) {
	        startOffset = dom.nodeIndex(startContainer);
	        startContainer = startContainer.parentNode;
	      }
	      if (NodeType.isElement(endContainer)) {
	        endOffset = dom.nodeIndex(endContainer) + 1;
	        endContainer = endContainer.parentNode;
	      }
	      return {
	        startContainer: startContainer,
	        startOffset: startOffset,
	        endContainer: endContainer,
	        endOffset: endOffset
	      };
	    };
	
	    var each$7 = Tools.each;
	    var clampToExistingChildren = function (container, index) {
	      var childNodes = container.childNodes;
	      if (index >= childNodes.length) {
	        index = childNodes.length - 1;
	      } else if (index < 0) {
	        index = 0;
	      }
	      return childNodes[index] || container;
	    };
	    var getEndChild = function (container, index) {
	      return clampToExistingChildren(container, index - 1);
	    };
	    var walk$1 = function (dom, rng, callback) {
	      var startContainer = rng.startContainer;
	      var startOffset = rng.startOffset;
	      var endContainer = rng.endContainer;
	      var endOffset = rng.endOffset;
	      var nodes = dom.select('td[data-mce-selected],th[data-mce-selected]');
	      if (nodes.length > 0) {
	        each$7(nodes, function (node) {
	          callback([node]);
	        });
	        return;
	      }
	      var exclude = function (nodes) {
	        var node;
	        node = nodes[0];
	        if (node.nodeType === 3 && node === startContainer && startOffset >= node.nodeValue.length) {
	          nodes.splice(0, 1);
	        }
	        node = nodes[nodes.length - 1];
	        if (endOffset === 0 && nodes.length > 0 && node === endContainer && node.nodeType === 3) {
	          nodes.splice(nodes.length - 1, 1);
	        }
	        return nodes;
	      };
	      var collectSiblings = function (node, name, endNode) {
	        var siblings = [];
	        for (; node && node !== endNode; node = node[name]) {
	          siblings.push(node);
	        }
	        return siblings;
	      };
	      var findEndPoint = function (node, root) {
	        do {
	          if (node.parentNode === root) {
	            return node;
	          }
	          node = node.parentNode;
	        } while (node);
	      };
	      var walkBoundary = function (startNode, endNode, next) {
	        var siblingName = next ? 'nextSibling' : 'previousSibling';
	        for (var node = startNode, parent_1 = node.parentNode; node && node !== endNode; node = parent_1) {
	          parent_1 = node.parentNode;
	          var siblings_1 = collectSiblings(node === startNode ? node : node[siblingName], siblingName);
	          if (siblings_1.length) {
	            if (!next) {
	              siblings_1.reverse();
	            }
	            callback(exclude(siblings_1));
	          }
	        }
	      };
	      if (startContainer.nodeType === 1 && startContainer.hasChildNodes()) {
	        startContainer = clampToExistingChildren(startContainer, startOffset);
	      }
	      if (endContainer.nodeType === 1 && endContainer.hasChildNodes()) {
	        endContainer = getEndChild(endContainer, endOffset);
	      }
	      if (startContainer === endContainer) {
	        return callback(exclude([startContainer]));
	      }
	      var ancestor = dom.findCommonAncestor(startContainer, endContainer);
	      for (var node = startContainer; node; node = node.parentNode) {
	        if (node === endContainer) {
	          return walkBoundary(startContainer, ancestor, true);
	        }
	        if (node === ancestor) {
	          break;
	        }
	      }
	      for (var node = endContainer; node; node = node.parentNode) {
	        if (node === startContainer) {
	          return walkBoundary(endContainer, ancestor);
	        }
	        if (node === ancestor) {
	          break;
	        }
	      }
	      var startPoint = findEndPoint(startContainer, ancestor) || startContainer;
	      var endPoint = findEndPoint(endContainer, ancestor) || endContainer;
	      walkBoundary(startContainer, startPoint, true);
	      var siblings = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, 'nextSibling', endPoint === endContainer ? endPoint.nextSibling : endPoint);
	      if (siblings.length) {
	        callback(exclude(siblings));
	      }
	      walkBoundary(endContainer, endPoint);
	    };
	    var RangeWalk = { walk: walk$1 };
	
	    function NodeValue (is, name) {
	      var get = function (element) {
	        if (!is(element)) {
	          throw new Error('Can only get ' + name + ' value of a ' + name + ' node');
	        }
	        return getOption(element).getOr('');
	      };
	      var getOption = function (element) {
	        return is(element) ? Option.from(element.dom().nodeValue) : Option.none();
	      };
	      var set = function (element, value) {
	        if (!is(element)) {
	          throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');
	        }
	        element.dom().nodeValue = value;
	      };
	      return {
	        get: get,
	        getOption: getOption,
	        set: set
	      };
	    }
	
	    var api = NodeValue(isText, 'text');
	    var get$7 = function (element) {
	      return api.get(element);
	    };
	
	    var isZeroWidth = function (elem) {
	      return isText(elem) && get$7(elem) === zeroWidth;
	    };
	    var context = function (editor, elem, wrapName, nodeName) {
	      return parent(elem).fold(function () {
	        return 'skipping';
	      }, function (parent) {
	        if (nodeName === 'br' || isZeroWidth(elem)) {
	          return 'valid';
	        } else if (isAnnotation(elem)) {
	          return 'existing';
	        } else if (isCaretNode(elem)) {
	          return 'caret';
	        } else if (!isValid(editor, wrapName, nodeName) || !isValid(editor, name(parent), wrapName)) {
	          return 'invalid-child';
	        } else {
	          return 'valid';
	        }
	      });
	    };
	
	    var applyWordGrab = function (editor, rng) {
	      var r = expandRng(editor, rng, [{ inline: true }]);
	      rng.setStart(r.startContainer, r.startOffset);
	      rng.setEnd(r.endContainer, r.endOffset);
	      editor.selection.setRng(rng);
	    };
	    var makeAnnotation = function (eDoc, _a, annotationName, decorate) {
	      var _b = _a.uid, uid = _b === void 0 ? generate('mce-annotation') : _b, data = __rest(_a, ['uid']);
	      var master = Element.fromTag('span', eDoc);
	      add$3(master, annotation());
	      set(master, '' + dataAnnotationId(), uid);
	      set(master, '' + dataAnnotation(), annotationName);
	      var _c = decorate(uid, data), _d = _c.attributes, attributes = _d === void 0 ? {} : _d, _e = _c.classes, classes = _e === void 0 ? [] : _e;
	      setAll(master, attributes);
	      add$4(master, classes);
	      return master;
	    };
	    var annotate = function (editor, rng, annotationName, decorate, data) {
	      var newWrappers = [];
	      var master = makeAnnotation(editor.getDoc(), data, annotationName, decorate);
	      var wrapper = Cell(Option.none());
	      var finishWrapper = function () {
	        wrapper.set(Option.none());
	      };
	      var getOrOpenWrapper = function () {
	        return wrapper.get().getOrThunk(function () {
	          var nu = shallow(master);
	          newWrappers.push(nu);
	          wrapper.set(Option.some(nu));
	          return nu;
	        });
	      };
	      var processElements = function (elems) {
	        each(elems, processElement);
	      };
	      var processElement = function (elem) {
	        var ctx = context(editor, elem, 'span', name(elem));
	        switch (ctx) {
	        case 'invalid-child': {
	            finishWrapper();
	            var children$1 = children(elem);
	            processElements(children$1);
	            finishWrapper();
	            break;
	          }
	        case 'valid': {
	            var w = getOrOpenWrapper();
	            wrap(elem, w);
	            break;
	          }
	        }
	      };
	      var processNodes = function (nodes) {
	        var elems = map(nodes, Element.fromDom);
	        processElements(elems);
	      };
	      RangeWalk.walk(editor.dom, rng, function (nodes) {
	        finishWrapper();
	        processNodes(nodes);
	      });
	      return newWrappers;
	    };
	    var annotateWithBookmark = function (editor, name, settings, data) {
	      editor.undoManager.transact(function () {
	        var initialRng = editor.selection.getRng();
	        if (initialRng.collapsed) {
	          applyWordGrab(editor, initialRng);
	        }
	        if (editor.selection.getRng().collapsed) {
	          var wrapper = makeAnnotation(editor.getDoc(), data, name, settings.decorate);
	          set$1(wrapper, nbsp);
	          editor.selection.getRng().insertNode(wrapper.dom());
	          editor.selection.select(wrapper.dom());
	        } else {
	          var bookmark = GetBookmark.getPersistentBookmark(editor.selection, false);
	          var rng = editor.selection.getRng();
	          annotate(editor, rng, name, settings.decorate, data);
	          editor.selection.moveToBookmark(bookmark);
	        }
	      });
	    };
	
	    var Annotator = function (editor) {
	      var registry = create$1();
	      setup$1(editor, registry);
	      var changes = setup(editor);
	      return {
	        register: function (name, settings) {
	          registry.register(name, settings);
	        },
	        annotate: function (name, data) {
	          registry.lookup(name).each(function (settings) {
	            annotateWithBookmark(editor, name, settings, data);
	          });
	        },
	        annotationChanged: function (name, callback) {
	          changes.addListener(name, callback);
	        },
	        remove: function (name) {
	          identify(editor, Option.some(name)).each(function (_a) {
	            var elements = _a.elements;
	            each(elements, unwrap);
	          });
	        },
	        getAll: function (name) {
	          var directory = findAll(editor, name);
	          return map$1(directory, function (elems) {
	            return map(elems, function (elem) {
	              return elem.dom();
	            });
	          });
	        }
	      };
	    };
	
	    var whiteSpaceRegExp$3 = /^[ \t\r\n]*$/;
	    var typeLookup = {
	      '#text': 3,
	      '#comment': 8,
	      '#cdata': 4,
	      '#pi': 7,
	      '#doctype': 10,
	      '#document-fragment': 11
	    };
	    var walk$2 = function (node, root, prev) {
	      var startName = prev ? 'lastChild' : 'firstChild';
	      var siblingName = prev ? 'prev' : 'next';
	      if (node[startName]) {
	        return node[startName];
	      }
	      if (node !== root) {
	        var sibling = node[siblingName];
	        if (sibling) {
	          return sibling;
	        }
	        for (var parent_1 = node.parent; parent_1 && parent_1 !== root; parent_1 = parent_1.parent) {
	          sibling = parent_1[siblingName];
	          if (sibling) {
	            return sibling;
	          }
	        }
	      }
	    };
	    var isEmptyTextNode$1 = function (node) {
	      if (!whiteSpaceRegExp$3.test(node.value)) {
	        return false;
	      }
	      var parentNode = node.parent;
	      if (parentNode && (parentNode.name !== 'span' || parentNode.attr('style')) && /^[ ]+$/.test(node.value)) {
	        return false;
	      }
	      return true;
	    };
	    var Node$1 = function () {
	      function Node(name, type) {
	        this.name = name;
	        this.type = type;
	        if (type === 1) {
	          this.attributes = [];
	          this.attributes.map = {};
	        }
	      }
	      Node.create = function (name, attrs) {
	        var node = new Node(name, typeLookup[name] || 1);
	        if (attrs) {
	          for (var attrName in attrs) {
	            node.attr(attrName, attrs[attrName]);
	          }
	        }
	        return node;
	      };
	      Node.prototype.replace = function (node) {
	        var self = this;
	        if (node.parent) {
	          node.remove();
	        }
	        self.insert(node, self);
	        self.remove();
	        return self;
	      };
	      Node.prototype.attr = function (name, value) {
	        var self = this;
	        var attrs;
	        if (typeof name !== 'string') {
	          for (var key in name) {
	            self.attr(key, name[key]);
	          }
	          return self;
	        }
	        if (attrs = self.attributes) {
	          if (value !== undefined) {
	            if (value === null) {
	              if (name in attrs.map) {
	                delete attrs.map[name];
	                var i = attrs.length;
	                while (i--) {
	                  if (attrs[i].name === name) {
	                    attrs.splice(i, 1);
	                    return self;
	                  }
	                }
	              }
	              return self;
	            }
	            if (name in attrs.map) {
	              var i = attrs.length;
	              while (i--) {
	                if (attrs[i].name === name) {
	                  attrs[i].value = value;
	                  break;
	                }
	              }
	            } else {
	              attrs.push({
	                name: name,
	                value: value
	              });
	            }
	            attrs.map[name] = value;
	            return self;
	          }
	          return attrs.map[name];
	        }
	      };
	      Node.prototype.clone = function () {
	        var self = this;
	        var clone = new Node(self.name, self.type);
	        var selfAttrs;
	        if (selfAttrs = self.attributes) {
	          var cloneAttrs = [];
	          cloneAttrs.map = {};
	          for (var i = 0, l = selfAttrs.length; i < l; i++) {
	            var selfAttr = selfAttrs[i];
	            if (selfAttr.name !== 'id') {
	              cloneAttrs[cloneAttrs.length] = {
	                name: selfAttr.name,
	                value: selfAttr.value
	              };
	              cloneAttrs.map[selfAttr.name] = selfAttr.value;
	            }
	          }
	          clone.attributes = cloneAttrs;
	        }
	        clone.value = self.value;
	        clone.shortEnded = self.shortEnded;
	        return clone;
	      };
	      Node.prototype.wrap = function (wrapper) {
	        var self = this;
	        self.parent.insert(wrapper, self);
	        wrapper.append(self);
	        return self;
	      };
	      Node.prototype.unwrap = function () {
	        var self = this;
	        for (var node = self.firstChild; node;) {
	          var next = node.next;
	          self.insert(node, self, true);
	          node = next;
	        }
	        self.remove();
	      };
	      Node.prototype.remove = function () {
	        var self = this, parent = self.parent, next = self.next, prev = self.prev;
	        if (parent) {
	          if (parent.firstChild === self) {
	            parent.firstChild = next;
	            if (next) {
	              next.prev = null;
	            }
	          } else {
	            prev.next = next;
	          }
	          if (parent.lastChild === self) {
	            parent.lastChild = prev;
	            if (prev) {
	              prev.next = null;
	            }
	          } else {
	            next.prev = prev;
	          }
	          self.parent = self.next = self.prev = null;
	        }
	        return self;
	      };
	      Node.prototype.append = function (node) {
	        var self = this;
	        if (node.parent) {
	          node.remove();
	        }
	        var last = self.lastChild;
	        if (last) {
	          last.next = node;
	          node.prev = last;
	          self.lastChild = node;
	        } else {
	          self.lastChild = self.firstChild = node;
	        }
	        node.parent = self;
	        return node;
	      };
	      Node.prototype.insert = function (node, refNode, before) {
	        if (node.parent) {
	          node.remove();
	        }
	        var parent = refNode.parent || this;
	        if (before) {
	          if (refNode === parent.firstChild) {
	            parent.firstChild = node;
	          } else {
	            refNode.prev.next = node;
	          }
	          node.prev = refNode.prev;
	          node.next = refNode;
	          refNode.prev = node;
	        } else {
	          if (refNode === parent.lastChild) {
	            parent.lastChild = node;
	          } else {
	            refNode.next.prev = node;
	          }
	          node.next = refNode.next;
	          node.prev = refNode;
	          refNode.next = node;
	        }
	        node.parent = parent;
	        return node;
	      };
	      Node.prototype.getAll = function (name) {
	        var self = this;
	        var collection = [];
	        for (var node = self.firstChild; node; node = walk$2(node, self)) {
	          if (node.name === name) {
	            collection.push(node);
	          }
	        }
	        return collection;
	      };
	      Node.prototype.empty = function () {
	        var self = this;
	        if (self.firstChild) {
	          var nodes = [];
	          for (var node = self.firstChild; node; node = walk$2(node, self)) {
	            nodes.push(node);
	          }
	          var i = nodes.length;
	          while (i--) {
	            var node = nodes[i];
	            node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;
	          }
	        }
	        self.firstChild = self.lastChild = null;
	        return self;
	      };
	      Node.prototype.isEmpty = function (elements, whitespace, predicate) {
	        if (whitespace === void 0) {
	          whitespace = {};
	        }
	        var self = this;
	        var node = self.firstChild;
	        if (node) {
	          do {
	            if (node.type === 1) {
	              if (node.attr('data-mce-bogus')) {
	                continue;
	              }
	              if (elements[node.name]) {
	                return false;
	              }
	              var i = node.attributes.length;
	              while (i--) {
	                var name_1 = node.attributes[i].name;
	                if (name_1 === 'name' || name_1.indexOf('data-mce-bookmark') === 0) {
	                  return false;
	                }
	              }
	            }
	            if (node.type === 8) {
	              return false;
	            }
	            if (node.type === 3 && !isEmptyTextNode$1(node)) {
	              return false;
	            }
	            if (node.type === 3 && node.parent && whitespace[node.parent.name] && whiteSpaceRegExp$3.test(node.value)) {
	              return false;
	            }
	            if (predicate && predicate(node)) {
	              return false;
	            }
	          } while (node = walk$2(node, self));
	        }
	        return true;
	      };
	      Node.prototype.walk = function (prev) {
	        return walk$2(this, null, prev);
	      };
	      return Node;
	    }();
	
	    var isValidPrefixAttrName = function (name) {
	      return name.indexOf('data-') === 0 || name.indexOf('aria-') === 0;
	    };
	    var isInvalidUri = function (settings, uri) {
	      if (settings.allow_html_data_urls) {
	        return false;
	      } else if (/^data:image\//i.test(uri)) {
	        return settings.allow_svg_data_urls === false && /^data:image\/svg\+xml/i.test(uri);
	      } else {
	        return /^data:/i.test(uri);
	      }
	    };
	    var findEndTagIndex = function (schema, html, startIndex) {
	      var count = 1, index, matches, tokenRegExp, shortEndedElements;
	      shortEndedElements = schema.getShortEndedElements();
	      tokenRegExp = /<([!?\/])?([A-Za-z0-9\-_\:\.]+)((?:\s+[^"\'>]+(?:(?:"[^"]*")|(?:\'[^\']*\')|[^>]*))*|\/|\s+)>/g;
	      tokenRegExp.lastIndex = index = startIndex;
	      while (matches = tokenRegExp.exec(html)) {
	        index = tokenRegExp.lastIndex;
	        if (matches[1] === '/') {
	          count--;
	        } else if (!matches[1]) {
	          if (matches[2] in shortEndedElements) {
	            continue;
	          }
	          count++;
	        }
	        if (count === 0) {
	          break;
	        }
	      }
	      return index;
	    };
	    var isConditionalComment = function (html, startIndex) {
	      return /^\s*\[if [\w\W]+\]>.*<!\[endif\](--!?)?>/.test(html.substr(startIndex));
	    };
	    var findCommentEndIndex = function (html, isBogus, startIndex) {
	      if (startIndex === void 0) {
	        startIndex = 0;
	      }
	      var lcHtml = html.toLowerCase();
	      if (lcHtml.indexOf('[if ', startIndex) !== -1 && isConditionalComment(lcHtml, startIndex)) {
	        var endIfIndex = lcHtml.indexOf('[endif]', startIndex);
	        return lcHtml.indexOf('>', endIfIndex);
	      } else {
	        if (isBogus) {
	          var endIndex = lcHtml.indexOf('>', startIndex);
	          return endIndex !== -1 ? endIndex : lcHtml.length;
	        } else {
	          var endCommentRegexp = /--!?>/;
	          endCommentRegexp.lastIndex = startIndex;
	          var match = endCommentRegexp.exec(html);
	          return match ? match.index + match[0].length : lcHtml.length;
	        }
	      }
	    };
	    var checkBogusAttribute = function (regExp, attrString) {
	      var matches = regExp.exec(attrString);
	      if (matches) {
	        var name_1 = matches[1];
	        var value = matches[2];
	        return typeof name_1 === 'string' && name_1.toLowerCase() === 'data-mce-bogus' ? value : null;
	      } else {
	        return null;
	      }
	    };
	    function SaxParser(settings, schema) {
	      if (schema === void 0) {
	        schema = Schema();
	      }
	      var noop = function () {
	      };
	      settings = settings || {};
	      if (settings.fix_self_closing !== false) {
	        settings.fix_self_closing = true;
	      }
	      var comment = settings.comment ? settings.comment : noop;
	      var cdata = settings.cdata ? settings.cdata : noop;
	      var text = settings.text ? settings.text : noop;
	      var start = settings.start ? settings.start : noop;
	      var end = settings.end ? settings.end : noop;
	      var pi = settings.pi ? settings.pi : noop;
	      var doctype = settings.doctype ? settings.doctype : noop;
	      var parse = function (html, format) {
	        if (format === void 0) {
	          format = 'html';
	        }
	        var matches, index = 0, value, endRegExp;
	        var stack = [];
	        var attrList, i, textData, name;
	        var isInternalElement, removeInternalElements, shortEndedElements, fillAttrsMap, isShortEnded;
	        var validate, elementRule, isValidElement, attr, attribsValue, validAttributesMap, validAttributePatterns;
	        var attributesRequired, attributesDefault, attributesForced, processHtml;
	        var anyAttributesRequired, selfClosing, tokenRegExp, attrRegExp, specialElements, attrValue, idCount = 0;
	        var decode = Entities.decode;
	        var fixSelfClosing;
	        var filteredUrlAttrs = Tools.makeMap('src,href,data,background,formaction,poster,xlink:href');
	        var scriptUriRegExp = /((java|vb)script|mhtml):/i;
	        var parsingMode = format === 'html' ? 0 : 1;
	        var processEndTag = function (name) {
	          var pos, i;
	          pos = stack.length;
	          while (pos--) {
	            if (stack[pos].name === name) {
	              break;
	            }
	          }
	          if (pos >= 0) {
	            for (i = stack.length - 1; i >= pos; i--) {
	              name = stack[i];
	              if (name.valid) {
	                end(name.name);
	              }
	            }
	            stack.length = pos;
	          }
	        };
	        var processComment = function (value) {
	          if (value === '') {
	            return;
	          }
	          if (value.charAt(0) === '>') {
	            value = ' ' + value;
	          }
	          if (!settings.allow_conditional_comments && value.substr(0, 3).toLowerCase() === '[if') {
	            value = ' ' + value;
	          }
	          comment(value);
	        };
	        var processMalformedComment = function (value, startIndex) {
	          var startTag = value || '';
	          var isBogus = !startsWith(startTag, '--');
	          var endIndex = findCommentEndIndex(html, isBogus, startIndex);
	          value = html.substr(startIndex, endIndex - startIndex);
	          processComment(isBogus ? startTag + value : value);
	          return endIndex + 1;
	        };
	        var parseAttribute = function (match, name, value, val2, val3) {
	          var attrRule, i;
	          var trimRegExp = /[\s\u0000-\u001F]+/g;
	          name = name.toLowerCase();
	          value = name in fillAttrsMap ? name : decode(value || val2 || val3 || '');
	          if (validate && !isInternalElement && isValidPrefixAttrName(name) === false) {
	            attrRule = validAttributesMap[name];
	            if (!attrRule && validAttributePatterns) {
	              i = validAttributePatterns.length;
	              while (i--) {
	                attrRule = validAttributePatterns[i];
	                if (attrRule.pattern.test(name)) {
	                  break;
	                }
	              }
	              if (i === -1) {
	                attrRule = null;
	              }
	            }
	            if (!attrRule) {
	              return;
	            }
	            if (attrRule.validValues && !(value in attrRule.validValues)) {
	              return;
	            }
	          }
	          if (filteredUrlAttrs[name] && !settings.allow_script_urls) {
	            var uri = value.replace(trimRegExp, '');
	            try {
	              uri = decodeURIComponent(uri);
	            } catch (ex) {
	              uri = unescape(uri);
	            }
	            if (scriptUriRegExp.test(uri)) {
	              return;
	            }
	            if (isInvalidUri(settings, uri)) {
	              return;
	            }
	          }
	          if (isInternalElement && (name in filteredUrlAttrs || name.indexOf('on') === 0)) {
	            return;
	          }
	          attrList.map[name] = value;
	          attrList.push({
	            name: name,
	            value: value
	          });
	        };
	        tokenRegExp = new RegExp('<(?:' + '(?:!--([\\w\\W]*?)--!?>)|' + '(?:!\\[CDATA\\[([\\w\\W]*?)\\]\\]>)|' + '(?:![Dd][Oo][Cc][Tt][Yy][Pp][Ee]([\\w\\W]*?)>)|' + '(?:!(--)?)|' + '(?:\\?([^\\s\\/<>]+) ?([\\w\\W]*?)[?/]>)|' + '(?:\\/([A-Za-z][A-Za-z0-9\\-_\\:\\.]*)>)|' + '(?:([A-Za-z][A-Za-z0-9\\-_\\:\\.]*)((?:\\s+[^"\'>]+(?:(?:"[^"]*")|(?:\'[^\']*\')|[^>]*))*|\\/|\\s+)>)' + ')', 'g');
	        attrRegExp = /([\w:\-]+)(?:\s*=\s*(?:(?:\"((?:[^\"])*)\")|(?:\'((?:[^\'])*)\')|([^>\s]+)))?/g;
	        shortEndedElements = schema.getShortEndedElements();
	        selfClosing = settings.self_closing_elements || schema.getSelfClosingElements();
	        fillAttrsMap = schema.getBoolAttrs();
	        validate = settings.validate;
	        removeInternalElements = settings.remove_internals;
	        fixSelfClosing = settings.fix_self_closing;
	        specialElements = schema.getSpecialElements();
	        processHtml = html + '>';
	        while (matches = tokenRegExp.exec(processHtml)) {
	          var matchText = matches[0];
	          if (index < matches.index) {
	            text(decode(html.substr(index, matches.index - index)));
	          }
	          if (value = matches[7]) {
	            value = value.toLowerCase();
	            if (value.charAt(0) === ':') {
	              value = value.substr(1);
	            }
	            processEndTag(value);
	          } else if (value = matches[8]) {
	            if (matches.index + matchText.length > html.length) {
	              text(decode(html.substr(matches.index)));
	              index = matches.index + matchText.length;
	              continue;
	            }
	            value = value.toLowerCase();
	            if (value.charAt(0) === ':') {
	              value = value.substr(1);
	            }
	            isShortEnded = value in shortEndedElements;
	            if (fixSelfClosing && selfClosing[value] && stack.length > 0 && stack[stack.length - 1].name === value) {
	              processEndTag(value);
	            }
	            var bogusValue = checkBogusAttribute(attrRegExp, matches[9]);
	            if (bogusValue !== null) {
	              if (bogusValue === 'all') {
	                index = findEndTagIndex(schema, html, tokenRegExp.lastIndex);
	                tokenRegExp.lastIndex = index;
	                continue;
	              }
	              isValidElement = false;
	            }
	            if (!validate || (elementRule = schema.getElementRule(value))) {
	              isValidElement = true;
	              if (validate) {
	                validAttributesMap = elementRule.attributes;
	                validAttributePatterns = elementRule.attributePatterns;
	              }
	              if (attribsValue = matches[9]) {
	                isInternalElement = attribsValue.indexOf('data-mce-type') !== -1;
	                if (isInternalElement && removeInternalElements) {
	                  isValidElement = false;
	                }
	                attrList = [];
	                attrList.map = {};
	                attribsValue.replace(attrRegExp, parseAttribute);
	              } else {
	                attrList = [];
	                attrList.map = {};
	              }
	              if (validate && !isInternalElement) {
	                attributesRequired = elementRule.attributesRequired;
	                attributesDefault = elementRule.attributesDefault;
	                attributesForced = elementRule.attributesForced;
	                anyAttributesRequired = elementRule.removeEmptyAttrs;
	                if (anyAttributesRequired && !attrList.length) {
	                  isValidElement = false;
	                }
	                if (attributesForced) {
	                  i = attributesForced.length;
	                  while (i--) {
	                    attr = attributesForced[i];
	                    name = attr.name;
	                    attrValue = attr.value;
	                    if (attrValue === '{$uid}') {
	                      attrValue = 'mce_' + idCount++;
	                    }
	                    attrList.map[name] = attrValue;
	                    attrList.push({
	                      name: name,
	                      value: attrValue
	                    });
	                  }
	                }
	                if (attributesDefault) {
	                  i = attributesDefault.length;
	                  while (i--) {
	                    attr = attributesDefault[i];
	                    name = attr.name;
	                    if (!(name in attrList.map)) {
	                      attrValue = attr.value;
	                      if (attrValue === '{$uid}') {
	                        attrValue = 'mce_' + idCount++;
	                      }
	                      attrList.map[name] = attrValue;
	                      attrList.push({
	                        name: name,
	                        value: attrValue
	                      });
	                    }
	                  }
	                }
	                if (attributesRequired) {
	                  i = attributesRequired.length;
	                  while (i--) {
	                    if (attributesRequired[i] in attrList.map) {
	                      break;
	                    }
	                  }
	                  if (i === -1) {
	                    isValidElement = false;
	                  }
	                }
	                if (attr = attrList.map['data-mce-bogus']) {
	                  if (attr === 'all') {
	                    index = findEndTagIndex(schema, html, tokenRegExp.lastIndex);
	                    tokenRegExp.lastIndex = index;
	                    continue;
	                  }
	                  isValidElement = false;
	                }
	              }
	              if (isValidElement) {
	                start(value, attrList, isShortEnded);
	              }
	            } else {
	              isValidElement = false;
	            }
	            if (endRegExp = specialElements[value]) {
	              endRegExp.lastIndex = index = matches.index + matchText.length;
	              if (matches = endRegExp.exec(html)) {
	                if (isValidElement) {
	                  textData = html.substr(index, matches.index - index);
	                }
	                index = matches.index + matches[0].length;
	              } else {
	                textData = html.substr(index);
	                index = html.length;
	              }
	              if (isValidElement) {
	                if (textData.length > 0) {
	                  text(textData, true);
	                }
	                end(value);
	              }
	              tokenRegExp.lastIndex = index;
	              continue;
	            }
	            if (!isShortEnded) {
	              if (!attribsValue || attribsValue.indexOf('/') !== attribsValue.length - 1) {
	                stack.push({
	                  name: value,
	                  valid: isValidElement
	                });
	              } else if (isValidElement) {
	                end(value);
	              }
	            }
	          } else if (value = matches[1]) {
	            processComment(value);
	          } else if (value = matches[2]) {
	            var isValidCdataSection = parsingMode === 1 || settings.preserve_cdata || stack.length > 0 && schema.isValidChild(stack[stack.length - 1].name, '#cdata');
	            if (isValidCdataSection) {
	              cdata(value);
	            } else {
	              index = processMalformedComment('', matches.index + 2);
	              tokenRegExp.lastIndex = index;
	              continue;
	            }
	          } else if (value = matches[3]) {
	            doctype(value);
	          } else if ((value = matches[4]) || matchText === '<!') {
	            index = processMalformedComment(value, matches.index + matchText.length);
	            tokenRegExp.lastIndex = index;
	            continue;
	          } else if (value = matches[5]) {
	            if (parsingMode === 1) {
	              pi(value, matches[6]);
	            } else {
	              index = processMalformedComment('?', matches.index + 2);
	              tokenRegExp.lastIndex = index;
	              continue;
	            }
	          }
	          index = matches.index + matchText.length;
	        }
	        if (index < html.length) {
	          text(decode(html.substr(index)));
	        }
	        for (i = stack.length - 1; i >= 0; i--) {
	          value = stack[i];
	          if (value.valid) {
	            end(value.name);
	          }
	        }
	      };
	      return { parse: parse };
	    }
	    (function (SaxParser) {
	      SaxParser.findEndTag = findEndTagIndex;
	    }(SaxParser || (SaxParser = {})));
	    var SaxParser$1 = SaxParser;
	
	    var trimHtml = function (tempAttrs, html) {
	      var trimContentRegExp = new RegExp(['\\s?(' + tempAttrs.join('|') + ')="[^"]+"'].join('|'), 'gi');
	      return html.replace(trimContentRegExp, '');
	    };
	    var trimInternal = function (serializer, html) {
	      var content = html;
	      var bogusAllRegExp = /<(\w+) [^>]*data-mce-bogus="all"[^>]*>/g;
	      var endTagIndex, index, matchLength, matches, shortEndedElements;
	      var schema = serializer.schema;
	      content = trimHtml(serializer.getTempAttrs(), content);
	      shortEndedElements = schema.getShortEndedElements();
	      while (matches = bogusAllRegExp.exec(content)) {
	        index = bogusAllRegExp.lastIndex;
	        matchLength = matches[0].length;
	        if (shortEndedElements[matches[1]]) {
	          endTagIndex = index;
	        } else {
	          endTagIndex = SaxParser$1.findEndTag(schema, content, index);
	        }
	        content = content.substring(0, index - matchLength) + content.substring(endTagIndex);
	        bogusAllRegExp.lastIndex = index - matchLength;
	      }
	      return Zwsp.trim(content);
	    };
	    var trimExternal = trimInternal;
	    var TrimHtml = {
	      trimExternal: trimExternal,
	      trimInternal: trimInternal
	    };
	
	    var defaultFormat = 'html';
	    var trimEmptyContents = function (editor, html) {
	      var blockName = Settings.getForcedRootBlock(editor);
	      var emptyRegExp = new RegExp('^(<' + blockName + '[^>]*>(&nbsp;|&#160;|\\s|\xA0|<br \\/>|)<\\/' + blockName + '>[\r\n]*|<br \\/>[\r\n]*)$');
	      return html.replace(emptyRegExp, '');
	    };
	    var getContentFromBody = function (editor, args, body) {
	      var content;
	      args.format = args.format ? args.format : defaultFormat;
	      args.get = true;
	      args.getInner = true;
	      if (!args.no_events) {
	        editor.fire('BeforeGetContent', args);
	      }
	      if (args.format === 'raw') {
	        content = Tools.trim(TrimHtml.trimExternal(editor.serializer, body.innerHTML));
	      } else if (args.format === 'text') {
	        content = Zwsp.trim(body.innerText || body.textContent);
	      } else if (args.format === 'tree') {
	        return editor.serializer.serialize(body, args);
	      } else {
	        content = trimEmptyContents(editor, editor.serializer.serialize(body, args));
	      }
	      if (args.format !== 'text' && !isWsPreserveElement(Element.fromDom(body))) {
	        args.content = Tools.trim(content);
	      } else {
	        args.content = content;
	      }
	      if (!args.no_events) {
	        editor.fire('GetContent', args);
	      }
	      return args.content;
	    };
	    var getContent = function (editor, args) {
	      if (args === void 0) {
	        args = {};
	      }
	      return Option.from(editor.getBody()).fold(constant(args.format === 'tree' ? new Node$1('body', 11) : ''), function (body) {
	        return getContentFromBody(editor, args, body);
	      });
	    };
	
	    var makeMap$3 = Tools.makeMap;
	    var Writer = function (settings) {
	      var html = [];
	      var indent, indentBefore, indentAfter, encode, htmlOutput;
	      settings = settings || {};
	      indent = settings.indent;
	      indentBefore = makeMap$3(settings.indent_before || '');
	      indentAfter = makeMap$3(settings.indent_after || '');
	      encode = Entities.getEncodeFunc(settings.entity_encoding || 'raw', settings.entities);
	      htmlOutput = settings.element_format === 'html';
	      return {
	        start: function (name, attrs, empty) {
	          var i, l, attr, value;
	          if (indent && indentBefore[name] && html.length > 0) {
	            value = html[html.length - 1];
	            if (value.length > 0 && value !== '\n') {
	              html.push('\n');
	            }
	          }
	          html.push('<', name);
	          if (attrs) {
	            for (i = 0, l = attrs.length; i < l; i++) {
	              attr = attrs[i];
	              html.push(' ', attr.name, '="', encode(attr.value, true), '"');
	            }
	          }
	          if (!empty || htmlOutput) {
	            html[html.length] = '>';
	          } else {
	            html[html.length] = ' />';
	          }
	          if (empty && indent && indentAfter[name] && html.length > 0) {
	            value = html[html.length - 1];
	            if (value.length > 0 && value !== '\n') {
	              html.push('\n');
	            }
	          }
	        },
	        end: function (name) {
	          var value;
	          html.push('</', name, '>');
	          if (indent && indentAfter[name] && html.length > 0) {
	            value = html[html.length - 1];
	            if (value.length > 0 && value !== '\n') {
	              html.push('\n');
	            }
	          }
	        },
	        text: function (text, raw) {
	          if (text.length > 0) {
	            html[html.length] = raw ? text : encode(text);
	          }
	        },
	        cdata: function (text) {
	          html.push('<![CDATA[', text, ']]>');
	        },
	        comment: function (text) {
	          html.push('<!--', text, '-->');
	        },
	        pi: function (name, text) {
	          if (text) {
	            html.push('<?', name, ' ', encode(text), '?>');
	          } else {
	            html.push('<?', name, '?>');
	          }
	          if (indent) {
	            html.push('\n');
	          }
	        },
	        doctype: function (text) {
	          html.push('<!DOCTYPE', text, '>', indent ? '\n' : '');
	        },
	        reset: function () {
	          html.length = 0;
	        },
	        getContent: function () {
	          return html.join('').replace(/\n$/, '');
	        }
	      };
	    };
	
	    var Serializer = function (settings, schema) {
	      if (schema === void 0) {
	        schema = Schema();
	      }
	      var writer = Writer(settings);
	      settings = settings || {};
	      settings.validate = 'validate' in settings ? settings.validate : true;
	      var serialize = function (node) {
	        var handlers, validate;
	        validate = settings.validate;
	        handlers = {
	          3: function (node) {
	            writer.text(node.value, node.raw);
	          },
	          8: function (node) {
	            writer.comment(node.value);
	          },
	          7: function (node) {
	            writer.pi(node.name, node.value);
	          },
	          10: function (node) {
	            writer.doctype(node.value);
	          },
	          4: function (node) {
	            writer.cdata(node.value);
	          },
	          11: function (node) {
	            if (node = node.firstChild) {
	              do {
	                walk(node);
	              } while (node = node.next);
	            }
	          }
	        };
	        writer.reset();
	        var walk = function (node) {
	          var handler = handlers[node.type];
	          var name, isEmpty, attrs, attrName, attrValue, sortedAttrs, i, l, elementRule;
	          if (!handler) {
	            name = node.name;
	            isEmpty = node.shortEnded;
	            attrs = node.attributes;
	            if (validate && attrs && attrs.length > 1) {
	              sortedAttrs = [];
	              sortedAttrs.map = {};
	              elementRule = schema.getElementRule(node.name);
	              if (elementRule) {
	                for (i = 0, l = elementRule.attributesOrder.length; i < l; i++) {
	                  attrName = elementRule.attributesOrder[i];
	                  if (attrName in attrs.map) {
	                    attrValue = attrs.map[attrName];
	                    sortedAttrs.map[attrName] = attrValue;
	                    sortedAttrs.push({
	                      name: attrName,
	                      value: attrValue
	                    });
	                  }
	                }
	                for (i = 0, l = attrs.length; i < l; i++) {
	                  attrName = attrs[i].name;
	                  if (!(attrName in sortedAttrs.map)) {
	                    attrValue = attrs.map[attrName];
	                    sortedAttrs.map[attrName] = attrValue;
	                    sortedAttrs.push({
	                      name: attrName,
	                      value: attrValue
	                    });
	                  }
	                }
	                attrs = sortedAttrs;
	              }
	            }
	            writer.start(node.name, attrs, isEmpty);
	            if (!isEmpty) {
	              if (node = node.firstChild) {
	                do {
	                  walk(node);
	                } while (node = node.next);
	              }
	              writer.end(name);
	            }
	          } else {
	            handler(node);
	          }
	        };
	        if (node.type === 1 && !settings.inner) {
	          walk(node);
	        } else {
	          handlers[11](node);
	        }
	        return writer.getContent();
	      };
	      return { serialize: serialize };
	    };
	
	    var traverse = function (node, fn) {
	      fn(node);
	      if (node.firstChild) {
	        traverse(node.firstChild, fn);
	      }
	      if (node.next) {
	        traverse(node.next, fn);
	      }
	    };
	    var findMatchingNodes = function (nodeFilters, attributeFilters, node) {
	      var nodeMatches = {};
	      var attrMatches = {};
	      var matches = [];
	      if (node.firstChild) {
	        traverse(node.firstChild, function (node) {
	          each(nodeFilters, function (filter) {
	            if (filter.name === node.name) {
	              if (nodeMatches[filter.name]) {
	                nodeMatches[filter.name].nodes.push(node);
	              } else {
	                nodeMatches[filter.name] = {
	                  filter: filter,
	                  nodes: [node]
	                };
	              }
	            }
	          });
	          each(attributeFilters, function (filter) {
	            if (typeof node.attr(filter.name) === 'string') {
	              if (attrMatches[filter.name]) {
	                attrMatches[filter.name].nodes.push(node);
	              } else {
	                attrMatches[filter.name] = {
	                  filter: filter,
	                  nodes: [node]
	                };
	              }
	            }
	          });
	        });
	      }
	      for (var name_1 in nodeMatches) {
	        if (nodeMatches.hasOwnProperty(name_1)) {
	          matches.push(nodeMatches[name_1]);
	        }
	      }
	      for (var name_2 in attrMatches) {
	        if (attrMatches.hasOwnProperty(name_2)) {
	          matches.push(attrMatches[name_2]);
	        }
	      }
	      return matches;
	    };
	    var filter$3 = function (nodeFilters, attributeFilters, node) {
	      var matches = findMatchingNodes(nodeFilters, attributeFilters, node);
	      each(matches, function (match) {
	        each(match.filter.callbacks, function (callback) {
	          callback(match.nodes, match.filter.name, {});
	        });
	      });
	    };
	
	    var hasFocus = function (element) {
	      var doc = owner(element).dom();
	      return element.dom() === doc.activeElement;
	    };
	    var active = function (_doc) {
	      var doc = _doc !== undefined ? _doc.dom() : domGlobals.document;
	      return Option.from(doc.activeElement).map(Element.fromDom);
	    };
	    var search = function (element) {
	      return active(owner(element)).filter(function (e) {
	        return element.dom().contains(e.dom());
	      });
	    };
	
	    var generate$1 = function (cases) {
	      if (!isArray(cases)) {
	        throw new Error('cases must be an array');
	      }
	      if (cases.length === 0) {
	        throw new Error('there must be at least one case');
	      }
	      var constructors = [];
	      var adt = {};
	      each(cases, function (acase, count) {
	        var keys$1 = keys(acase);
	        if (keys$1.length !== 1) {
	          throw new Error('one and only one name per case');
	        }
	        var key = keys$1[0];
	        var value = acase[key];
	        if (adt[key] !== undefined) {
	          throw new Error('duplicate key detected:' + key);
	        } else if (key === 'cata') {
	          throw new Error('cannot have a case named cata (sorry)');
	        } else if (!isArray(value)) {
	          throw new Error('case arguments must be an array');
	        }
	        constructors.push(key);
	        adt[key] = function () {
	          var argLength = arguments.length;
	          if (argLength !== value.length) {
	            throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);
	          }
	          var args = new Array(argLength);
	          for (var i = 0; i < args.length; i++) {
	            args[i] = arguments[i];
	          }
	          var match = function (branches) {
	            var branchKeys = keys(branches);
	            if (constructors.length !== branchKeys.length) {
	              throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\nActual: ' + branchKeys.join(','));
	            }
	            var allReqd = forall(constructors, function (reqKey) {
	              return contains(branchKeys, reqKey);
	            });
	            if (!allReqd) {
	              throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\nRequired: ' + constructors.join(', '));
	            }
	            return branches[key].apply(null, args);
	          };
	          return {
	            fold: function () {
	              if (arguments.length !== cases.length) {
	                throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + arguments.length);
	              }
	              var target = arguments[count];
	              return target.apply(null, args);
	            },
	            match: match,
	            log: function (label) {
	              domGlobals.console.log(label, {
	                constructors: constructors,
	                constructor: key,
	                params: args
	              });
	            }
	          };
	        };
	      });
	      return adt;
	    };
	    var Adt = { generate: generate$1 };
	
	    var create$3 = Immutable('start', 'soffset', 'finish', 'foffset');
	    var SimRange = { create: create$3 };
	
	    var adt = Adt.generate([
	      { before: ['element'] },
	      {
	        on: [
	          'element',
	          'offset'
	        ]
	      },
	      { after: ['element'] }
	    ]);
	    var cata = function (subject, onBefore, onOn, onAfter) {
	      return subject.fold(onBefore, onOn, onAfter);
	    };
	    var getStart = function (situ) {
	      return situ.fold(identity, identity, identity);
	    };
	    var before$3 = adt.before;
	    var on = adt.on;
	    var after$2 = adt.after;
	    var Situ = {
	      before: before$3,
	      on: on,
	      after: after$2,
	      cata: cata,
	      getStart: getStart
	    };
	
	    var adt$1 = Adt.generate([
	      { domRange: ['rng'] },
	      {
	        relative: [
	          'startSitu',
	          'finishSitu'
	        ]
	      },
	      {
	        exact: [
	          'start',
	          'soffset',
	          'finish',
	          'foffset'
	        ]
	      }
	    ]);
	    var exactFromRange = function (simRange) {
	      return adt$1.exact(simRange.start(), simRange.soffset(), simRange.finish(), simRange.foffset());
	    };
	    var getStart$1 = function (selection) {
	      return selection.match({
	        domRange: function (rng) {
	          return Element.fromDom(rng.startContainer);
	        },
	        relative: function (startSitu, finishSitu) {
	          return Situ.getStart(startSitu);
	        },
	        exact: function (start, soffset, finish, foffset) {
	          return start;
	        }
	      });
	    };
	    var domRange = adt$1.domRange;
	    var relative = adt$1.relative;
	    var exact = adt$1.exact;
	    var getWin = function (selection) {
	      var start = getStart$1(selection);
	      return defaultView(start);
	    };
	    var range = SimRange.create;
	    var Selection = {
	      domRange: domRange,
	      relative: relative,
	      exact: exact,
	      exactFromRange: exactFromRange,
	      getWin: getWin,
	      range: range
	    };
	
	    var browser$4 = detect$3().browser;
	    var clamp = function (offset, element) {
	      var max = isText(element) ? get$7(element).length : children(element).length + 1;
	      if (offset > max) {
	        return max;
	      } else if (offset < 0) {
	        return 0;
	      }
	      return offset;
	    };
	    var normalizeRng = function (rng) {
	      return Selection.range(rng.start(), clamp(rng.soffset(), rng.start()), rng.finish(), clamp(rng.foffset(), rng.finish()));
	    };
	    var isOrContains = function (root, elm) {
	      return !NodeType.isRestrictedNode(elm.dom()) && (contains$2(root, elm) || eq(root, elm));
	    };
	    var isRngInRoot = function (root) {
	      return function (rng) {
	        return isOrContains(root, rng.start()) && isOrContains(root, rng.finish());
	      };
	    };
	    var shouldStore = function (editor) {
	      return editor.inline === true || browser$4.isIE();
	    };
	    var nativeRangeToSelectionRange = function (r) {
	      return Selection.range(Element.fromDom(r.startContainer), r.startOffset, Element.fromDom(r.endContainer), r.endOffset);
	    };
	    var readRange = function (win) {
	      var selection = win.getSelection();
	      var rng = !selection || selection.rangeCount === 0 ? Option.none() : Option.from(selection.getRangeAt(0));
	      return rng.map(nativeRangeToSelectionRange);
	    };
	    var getBookmark$2 = function (root) {
	      var win = defaultView(root);
	      return readRange(win.dom()).filter(isRngInRoot(root));
	    };
	    var validate = function (root, bookmark) {
	      return Option.from(bookmark).filter(isRngInRoot(root)).map(normalizeRng);
	    };
	    var bookmarkToNativeRng = function (bookmark) {
	      var rng = domGlobals.document.createRange();
	      try {
	        rng.setStart(bookmark.start().dom(), bookmark.soffset());
	        rng.setEnd(bookmark.finish().dom(), bookmark.foffset());
	        return Option.some(rng);
	      } catch (_) {
	        return Option.none();
	      }
	    };
	    var store = function (editor) {
	      var newBookmark = shouldStore(editor) ? getBookmark$2(Element.fromDom(editor.getBody())) : Option.none();
	      editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;
	    };
	    var storeNative = function (editor, rng) {
	      var root = Element.fromDom(editor.getBody());
	      var range = shouldStore(editor) ? Option.from(rng) : Option.none();
	      var newBookmark = range.map(nativeRangeToSelectionRange).filter(isRngInRoot(root));
	      editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;
	    };
	    var getRng = function (editor) {
	      var bookmark = editor.bookmark ? editor.bookmark : Option.none();
	      return bookmark.bind(function (x) {
	        return validate(Element.fromDom(editor.getBody()), x);
	      }).bind(bookmarkToNativeRng);
	    };
	    var restore = function (editor) {
	      getRng(editor).each(function (rng) {
	        editor.selection.setRng(rng);
	      });
	    };
	    var SelectionBookmark = {
	      store: store,
	      storeNative: storeNative,
	      readRange: readRange,
	      restore: restore,
	      getRng: getRng,
	      getBookmark: getBookmark$2,
	      validate: validate
	    };
	
	    var isEditorUIElement = function (elm) {
	      var className = elm.className.toString();
	      return className.indexOf('tox-') !== -1 || className.indexOf('mce-') !== -1;
	    };
	    var FocusManager = { isEditorUIElement: isEditorUIElement };
	
	    var isManualNodeChange = function (e) {
	      return e.type === 'nodechange' && e.selectionChange;
	    };
	    var registerPageMouseUp = function (editor, throttledStore) {
	      var mouseUpPage = function () {
	        throttledStore.throttle();
	      };
	      DOMUtils$1.DOM.bind(domGlobals.document, 'mouseup', mouseUpPage);
	      editor.on('remove', function () {
	        DOMUtils$1.DOM.unbind(domGlobals.document, 'mouseup', mouseUpPage);
	      });
	    };
	    var registerFocusOut = function (editor) {
	      editor.on('focusout', function () {
	        SelectionBookmark.store(editor);
	      });
	    };
	    var registerMouseUp = function (editor, throttledStore) {
	      editor.on('mouseup touchend', function (e) {
	        throttledStore.throttle();
	      });
	    };
	    var registerEditorEvents = function (editor, throttledStore) {
	      var browser = detect$3().browser;
	      if (browser.isIE()) {
	        registerFocusOut(editor);
	      } else {
	        registerMouseUp(editor, throttledStore);
	      }
	      editor.on('keyup NodeChange', function (e) {
	        if (!isManualNodeChange(e)) {
	          SelectionBookmark.store(editor);
	        }
	      });
	    };
	    var register = function (editor) {
	      var throttledStore = first(function () {
	        SelectionBookmark.store(editor);
	      }, 0);
	      editor.on('init', function () {
	        if (editor.inline) {
	          registerPageMouseUp(editor, throttledStore);
	        }
	        registerEditorEvents(editor, throttledStore);
	      });
	      editor.on('remove', function () {
	        throttledStore.cancel();
	      });
	    };
	    var SelectionRestore = { register: register };
	
	    var documentFocusInHandler;
	    var DOM$2 = DOMUtils$1.DOM;
	    var isEditorUIElement$1 = function (elm) {
	      return FocusManager.isEditorUIElement(elm);
	    };
	    var isEditorContentAreaElement = function (elm) {
	      var classList = elm.classList;
	      if (classList !== undefined) {
	        return classList.contains('tox-edit-area') || classList.contains('tox-edit-area__iframe') || classList.contains('mce-content-body');
	      } else {
	        return false;
	      }
	    };
	    var isUIElement = function (editor, elm) {
	      var customSelector = editor ? editor.settings.custom_ui_selector : '';
	      var parent = DOM$2.getParent(elm, function (elm) {
	        return isEditorUIElement$1(elm) || (customSelector ? editor.dom.is(elm, customSelector) : false);
	      });
	      return parent !== null;
	    };
	    var getActiveElement = function () {
	      try {
	        return domGlobals.document.activeElement;
	      } catch (ex) {
	        return domGlobals.document.body;
	      }
	    };
	    var registerEvents = function (editorManager, e) {
	      var editor = e.editor;
	      SelectionRestore.register(editor);
	      editor.on('focusin', function () {
	        var self = this;
	        var focusedEditor = editorManager.focusedEditor;
	        if (focusedEditor !== self) {
	          if (focusedEditor) {
	            focusedEditor.fire('blur', { focusedEditor: self });
	          }
	          editorManager.setActive(self);
	          editorManager.focusedEditor = self;
	          self.fire('focus', { blurredEditor: focusedEditor });
	          self.focus(true);
	        }
	      });
	      editor.on('focusout', function () {
	        var self = this;
	        Delay.setEditorTimeout(self, function () {
	          var focusedEditor = editorManager.focusedEditor;
	          if (!isUIElement(self, getActiveElement()) && focusedEditor === self) {
	            self.fire('blur', { focusedEditor: null });
	            editorManager.focusedEditor = null;
	          }
	        });
	      });
	      if (!documentFocusInHandler) {
	        documentFocusInHandler = function (e) {
	          var activeEditor = editorManager.activeEditor;
	          var target;
	          target = e.target;
	          if (activeEditor && target.ownerDocument === domGlobals.document) {
	            if (target !== domGlobals.document.body && !isUIElement(activeEditor, target) && editorManager.focusedEditor === activeEditor) {
	              activeEditor.fire('blur', { focusedEditor: null });
	              editorManager.focusedEditor = null;
	            }
	          }
	        };
	        DOM$2.bind(domGlobals.document, 'focusin', documentFocusInHandler);
	      }
	    };
	    var unregisterDocumentEvents = function (editorManager, e) {
	      if (editorManager.focusedEditor === e.editor) {
	        editorManager.focusedEditor = null;
	      }
	      if (!editorManager.activeEditor) {
	        DOM$2.unbind(domGlobals.document, 'focusin', documentFocusInHandler);
	        documentFocusInHandler = null;
	      }
	    };
	    var setup$2 = function (editorManager) {
	      editorManager.on('AddEditor', curry(registerEvents, editorManager));
	      editorManager.on('RemoveEditor', curry(unregisterDocumentEvents, editorManager));
	    };
	    var FocusController = {
	      setup: setup$2,
	      isEditorUIElement: isEditorUIElement$1,
	      isEditorContentAreaElement: isEditorContentAreaElement,
	      isUIElement: isUIElement
	    };
	
	    var getContentEditableHost = function (editor, node) {
	      return editor.dom.getParent(node, function (node) {
	        return editor.dom.getContentEditable(node) === 'true';
	      });
	    };
	    var getCollapsedNode = function (rng) {
	      return rng.collapsed ? Option.from(getNode(rng.startContainer, rng.startOffset)).map(Element.fromDom) : Option.none();
	    };
	    var getFocusInElement = function (root, rng) {
	      return getCollapsedNode(rng).bind(function (node) {
	        if (isTableSection(node)) {
	          return Option.some(node);
	        } else if (contains$2(root, node) === false) {
	          return Option.some(root);
	        } else {
	          return Option.none();
	        }
	      });
	    };
	    var normalizeSelection = function (editor, rng) {
	      getFocusInElement(Element.fromDom(editor.getBody()), rng).bind(function (elm) {
	        return CaretFinder.firstPositionIn(elm.dom());
	      }).fold(function () {
	        editor.selection.normalize();
	        return;
	      }, function (caretPos) {
	        return editor.selection.setRng(caretPos.toRange());
	      });
	    };
	    var focusBody = function (body) {
	      if (body.setActive) {
	        try {
	          body.setActive();
	        } catch (ex) {
	          body.focus();
	        }
	      } else {
	        body.focus();
	      }
	    };
	    var hasElementFocus = function (elm) {
	      return hasFocus(elm) || search(elm).isSome();
	    };
	    var hasIframeFocus = function (editor) {
	      return editor.iframeElement && hasFocus(Element.fromDom(editor.iframeElement));
	    };
	    var hasInlineFocus = function (editor) {
	      var rawBody = editor.getBody();
	      return rawBody && hasElementFocus(Element.fromDom(rawBody));
	    };
	    var hasUiFocus = function (editor) {
	      return active().filter(function (elem) {
	        return !FocusController.isEditorContentAreaElement(elem.dom()) && FocusController.isUIElement(editor, elem.dom());
	      }).isSome();
	    };
	    var hasFocus$1 = function (editor) {
	      return editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);
	    };
	    var hasEditorOrUiFocus = function (editor) {
	      return hasFocus$1(editor) || hasUiFocus(editor);
	    };
	    var focusEditor = function (editor) {
	      var selection = editor.selection;
	      var body = editor.getBody();
	      var rng = selection.getRng();
	      editor.quirks.refreshContentEditable();
	      if (editor.bookmark !== undefined && hasFocus$1(editor) === false) {
	        SelectionBookmark.getRng(editor).each(function (bookmarkRng) {
	          editor.selection.setRng(bookmarkRng);
	          rng = bookmarkRng;
	        });
	      }
	      var contentEditableHost = getContentEditableHost(editor, selection.getNode());
	      if (editor.$.contains(body, contentEditableHost)) {
	        focusBody(contentEditableHost);
	        normalizeSelection(editor, rng);
	        activateEditor(editor);
	        return;
	      }
	      if (!editor.inline) {
	        if (!Env.opera) {
	          focusBody(body);
	        }
	        editor.getWin().focus();
	      }
	      if (Env.gecko || editor.inline) {
	        focusBody(body);
	        normalizeSelection(editor, rng);
	      }
	      activateEditor(editor);
	    };
	    var activateEditor = function (editor) {
	      return editor.editorManager.setActive(editor);
	    };
	    var focus = function (editor, skipFocus) {
	      if (editor.removed) {
	        return;
	      }
	      skipFocus ? activateEditor(editor) : focusEditor(editor);
	    };
	    var EditorFocus = {
	      focus: focus,
	      hasFocus: hasFocus$1,
	      hasEditorOrUiFocus: hasEditorOrUiFocus
	    };
	
	    var defaultFormat$1 = 'html';
	    var isTreeNode = function (content) {
	      return content instanceof Node$1;
	    };
	    var moveSelection = function (editor) {
	      if (EditorFocus.hasFocus(editor)) {
	        CaretFinder.firstPositionIn(editor.getBody()).each(function (pos) {
	          var node = pos.getNode();
	          var caretPos = NodeType.isTable(node) ? CaretFinder.firstPositionIn(node).getOr(pos) : pos;
	          editor.selection.setRng(caretPos.toRange());
	        });
	      }
	    };
	    var setEditorHtml = function (editor, html) {
	      editor.dom.setHTML(editor.getBody(), html);
	      moveSelection(editor);
	    };
	    var setContentString = function (editor, body, content, args) {
	      var forcedRootBlockName, padd;
	      if (content.length === 0 || /^\s+$/.test(content)) {
	        padd = '<br data-mce-bogus="1">';
	        if (body.nodeName === 'TABLE') {
	          content = '<tr><td>' + padd + '</td></tr>';
	        } else if (/^(UL|OL)$/.test(body.nodeName)) {
	          content = '<li>' + padd + '</li>';
	        }
	        forcedRootBlockName = Settings.getForcedRootBlock(editor);
	        if (forcedRootBlockName && editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {
	          content = padd;
	          content = editor.dom.createHTML(forcedRootBlockName, editor.settings.forced_root_block_attrs, content);
	        } else if (!content) {
	          content = '<br data-mce-bogus="1">';
	        }
	        setEditorHtml(editor, content);
	        editor.fire('SetContent', args);
	      } else {
	        if (args.format !== 'raw') {
	          content = Serializer({ validate: editor.validate }, editor.schema).serialize(editor.parser.parse(content, {
	            isRootContent: true,
	            insert: true
	          }));
	        }
	        args.content = isWsPreserveElement(Element.fromDom(body)) ? content : Tools.trim(content);
	        setEditorHtml(editor, args.content);
	        if (!args.no_events) {
	          editor.fire('SetContent', args);
	        }
	      }
	      return args.content;
	    };
	    var setContentTree = function (editor, body, content, args) {
	      filter$3(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);
	      var html = Serializer({ validate: editor.validate }, editor.schema).serialize(content);
	      args.content = isWsPreserveElement(Element.fromDom(body)) ? html : Tools.trim(html);
	      setEditorHtml(editor, args.content);
	      if (!args.no_events) {
	        editor.fire('SetContent', args);
	      }
	      return content;
	    };
	    var setContent = function (editor, content, args) {
	      if (args === void 0) {
	        args = {};
	      }
	      args.format = args.format ? args.format : defaultFormat$1;
	      args.set = true;
	      args.content = isTreeNode(content) ? '' : content;
	      if (!isTreeNode(content) && !args.no_events) {
	        editor.fire('BeforeSetContent', args);
	        content = args.content;
	      }
	      return Option.from(editor.getBody()).fold(constant(content), function (body) {
	        return isTreeNode(content) ? setContentTree(editor, body, content, args) : setContentString(editor, body, content, args);
	      });
	    };
	
	    var firePreProcess = function (editor, args) {
	      return editor.fire('PreProcess', args);
	    };
	    var firePostProcess = function (editor, args) {
	      return editor.fire('PostProcess', args);
	    };
	    var fireRemove = function (editor) {
	      return editor.fire('remove');
	    };
	    var fireDetach = function (editor) {
	      return editor.fire('detach');
	    };
	    var fireSwitchMode = function (editor, mode) {
	      return editor.fire('SwitchMode', { mode: mode });
	    };
	    var fireObjectResizeStart = function (editor, target, width, height) {
	      editor.fire('ObjectResizeStart', {
	        target: target,
	        width: width,
	        height: height
	      });
	    };
	    var fireObjectResized = function (editor, target, width, height) {
	      editor.fire('ObjectResized', {
	        target: target,
	        width: width,
	        height: height
	      });
	    };
	    var firePreInit = function (editor) {
	      return editor.fire('PreInit');
	    };
	    var firePostRender = function (editor) {
	      return editor.fire('PostRender');
	    };
	    var fireInit = function (editor) {
	      return editor.fire('Init');
	    };
	    var firePlaceholderToggle = function (editor, state) {
	      return editor.fire('PlaceholderToggle', { state: state });
	    };
	    var fireError = function (editor, errorType, error) {
	      return editor.fire(errorType, error);
	    };
	
	    var DOM$3 = DOMUtils$1.DOM;
	    var restoreOriginalStyles = function (editor) {
	      DOM$3.setStyle(editor.id, 'display', editor.orgDisplay);
	    };
	    var safeDestroy = function (x) {
	      return Option.from(x).each(function (x) {
	        return x.destroy();
	      });
	    };
	    var clearDomReferences = function (editor) {
	      editor.contentAreaContainer = editor.formElement = editor.container = editor.editorContainer = null;
	      editor.bodyElement = editor.contentDocument = editor.contentWindow = null;
	      editor.iframeElement = editor.targetElm = null;
	      if (editor.selection) {
	        editor.selection = editor.selection.win = editor.selection.dom = editor.selection.dom.doc = null;
	      }
	    };
	    var restoreForm = function (editor) {
	      var form = editor.formElement;
	      if (form) {
	        if (form._mceOldSubmit) {
	          form.submit = form._mceOldSubmit;
	          form._mceOldSubmit = null;
	        }
	        DOM$3.unbind(form, 'submit reset', editor.formEventDelegate);
	      }
	    };
	    var remove$6 = function (editor) {
	      if (!editor.removed) {
	        var _selectionOverrides = editor._selectionOverrides, editorUpload = editor.editorUpload;
	        var body = editor.getBody();
	        var element = editor.getElement();
	        if (body) {
	          editor.save({ is_removing: true });
	        }
	        editor.removed = true;
	        editor.unbindAllNativeEvents();
	        if (editor.hasHiddenInput && element) {
	          DOM$3.remove(element.nextSibling);
	        }
	        fireRemove(editor);
	        editor.editorManager.remove(editor);
	        if (!editor.inline && body) {
	          restoreOriginalStyles(editor);
	        }
	        fireDetach(editor);
	        DOM$3.remove(editor.getContainer());
	        safeDestroy(_selectionOverrides);
	        safeDestroy(editorUpload);
	        editor.destroy();
	      }
	    };
	    var destroy = function (editor, automatic) {
	      var selection = editor.selection, dom = editor.dom;
	      if (editor.destroyed) {
	        return;
	      }
	      if (!automatic && !editor.removed) {
	        editor.remove();
	        return;
	      }
	      if (!automatic) {
	        editor.editorManager.off('beforeunload', editor._beforeUnload);
	        if (editor.theme && editor.theme.destroy) {
	          editor.theme.destroy();
	        }
	        safeDestroy(selection);
	        safeDestroy(dom);
	      }
	      restoreForm(editor);
	      clearDomReferences(editor);
	      editor.destroyed = true;
	    };
	
	    var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
	    var deep$1 = function (old, nu) {
	      var bothObjects = isObject(old) && isObject(nu);
	      return bothObjects ? deepMerge(old, nu) : nu;
	    };
	    var baseMerge = function (merger) {
	      return function () {
	        var objects = new Array(arguments.length);
	        for (var i = 0; i < objects.length; i++) {
	          objects[i] = arguments[i];
	        }
	        if (objects.length === 0) {
	          throw new Error('Can\'t merge zero objects');
	        }
	        var ret = {};
	        for (var j = 0; j < objects.length; j++) {
	          var curObject = objects[j];
	          for (var key in curObject) {
	            if (hasOwnProperty$2.call(curObject, key)) {
	              ret[key] = merger(ret[key], curObject[key]);
	            }
	          }
	        }
	        return ret;
	      };
	    };
	    var deepMerge = baseMerge(deep$1);
	
	    var sectionResult = Immutable('sections', 'settings');
	    var deviceDetection = detect$3().deviceType;
	    var isTouch = deviceDetection.isTouch();
	    var isPhone = deviceDetection.isPhone();
	    var isTablet = deviceDetection.isTablet();
	    var legacyMobilePlugins = [
	      'lists',
	      'autolink',
	      'autosave'
	    ];
	    var defaultTouchSettings = {
	      table_grid: false,
	      object_resizing: false,
	      resize: false
	    };
	    var normalizePlugins = function (plugins) {
	      var pluginNames = isArray(plugins) ? plugins.join(' ') : plugins;
	      var trimmedPlugins = map(isString(pluginNames) ? pluginNames.split(' ') : [], trim);
	      return filter(trimmedPlugins, function (item) {
	        return item.length > 0;
	      });
	    };
	    var filterLegacyMobilePlugins = function (plugins) {
	      return filter(plugins, curry(contains, legacyMobilePlugins));
	    };
	    var extractSections = function (keys, settings) {
	      var result = bifilter(settings, function (value, key) {
	        return contains(keys, key);
	      });
	      return sectionResult(result.t, result.f);
	    };
	    var getSection = function (sectionResult, name, defaults) {
	      if (defaults === void 0) {
	        defaults = {};
	      }
	      var sections = sectionResult.sections();
	      var sectionSettings = sections.hasOwnProperty(name) ? sections[name] : {};
	      return Tools.extend({}, defaults, sectionSettings);
	    };
	    var hasSection = function (sectionResult, name) {
	      return sectionResult.sections().hasOwnProperty(name);
	    };
	    var isSectionTheme = function (sectionResult, name, theme) {
	      var section = sectionResult.sections();
	      return hasSection(sectionResult, name) && section[name].theme === theme;
	    };
	    var getSectionConfig = function (sectionResult, name) {
	      return hasSection(sectionResult, name) ? sectionResult.sections()[name] : {};
	    };
	    var getToolbarMode = function (settings, defaultVal) {
	      return get(settings, 'toolbar_mode').orThunk(function () {
	        return get(settings, 'toolbar_drawer').map(function (val) {
	          return val === false ? 'wrap' : val;
	        });
	      }).getOr(defaultVal);
	    };
	    var getDefaultSettings = function (settings, id, documentBaseUrl, isTouch, editor) {
	      var baseDefaults = {
	        id: id,
	        theme: 'silver',
	        toolbar_mode: getToolbarMode(settings, 'floating'),
	        plugins: '',
	        document_base_url: documentBaseUrl,
	        add_form_submit_trigger: true,
	        submit_patch: true,
	        add_unload_trigger: true,
	        convert_urls: true,
	        relative_urls: true,
	        remove_script_host: true,
	        object_resizing: true,
	        doctype: '<!DOCTYPE html>',
	        visual: true,
	        font_size_legacy_values: 'xx-small,small,medium,large,x-large,xx-large,300%',
	        forced_root_block: 'p',
	        hidden_input: true,
	        inline_styles: true,
	        convert_fonts_to_spans: true,
	        indent: true,
	        indent_before: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist',
	        indent_after: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist',
	        entity_encoding: 'named',
	        url_converter: editor.convertURL,
	        url_converter_scope: editor
	      };
	      return __assign(__assign({}, baseDefaults), isTouch ? defaultTouchSettings : {});
	    };
	    var getDefaultMobileSettings = function (settings, isPhone) {
	      var defaultMobileSettings = {
	        resize: false,
	        toolbar_mode: getToolbarMode(settings, 'scrolling'),
	        toolbar_sticky: false
	      };
	      var defaultPhoneSettings = { menubar: false };
	      return __assign(__assign(__assign({}, defaultTouchSettings), defaultMobileSettings), isPhone ? defaultPhoneSettings : {});
	    };
	    var getExternalPlugins = function (overrideSettings, settings) {
	      var userDefinedExternalPlugins = settings.external_plugins ? settings.external_plugins : {};
	      if (overrideSettings && overrideSettings.external_plugins) {
	        return Tools.extend({}, overrideSettings.external_plugins, userDefinedExternalPlugins);
	      } else {
	        return userDefinedExternalPlugins;
	      }
	    };
	    var combinePlugins = function (forcedPlugins, plugins) {
	      return [].concat(normalizePlugins(forcedPlugins)).concat(normalizePlugins(plugins));
	    };
	    var processPlugins = function (isMobileDevice, sectionResult, defaultOverrideSettings, settings) {
	      var forcedPlugins = normalizePlugins(defaultOverrideSettings.forced_plugins);
	      var desktopPlugins = normalizePlugins(settings.plugins);
	      var mobileConfig = getSectionConfig(sectionResult, 'mobile');
	      var mobilePlugins = mobileConfig.plugins ? normalizePlugins(mobileConfig.plugins) : desktopPlugins;
	      var platformPlugins = isMobileDevice && isSectionTheme(sectionResult, 'mobile', 'mobile') ? filterLegacyMobilePlugins(mobilePlugins) : isMobileDevice && hasSection(sectionResult, 'mobile') ? mobilePlugins : desktopPlugins;
	      var combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);
	      return Tools.extend(settings, { plugins: combinedPlugins.join(' ') });
	    };
	    var isOnMobile = function (isMobileDevice, sectionResult) {
	      return isMobileDevice && hasSection(sectionResult, 'mobile');
	    };
	    var combineSettings = function (isMobileDevice, isPhone, defaultSettings, defaultOverrideSettings, settings) {
	      var defaultDeviceSettings = isMobileDevice ? { mobile: getDefaultMobileSettings(settings, isPhone) } : {};
	      var sectionResult = extractSections(['mobile'], deepMerge(defaultDeviceSettings, settings));
	      var extendedSettings = Tools.extend(defaultSettings, defaultOverrideSettings, sectionResult.settings(), isOnMobile(isMobileDevice, sectionResult) ? getSection(sectionResult, 'mobile') : {}, {
	        validate: true,
	        external_plugins: getExternalPlugins(defaultOverrideSettings, sectionResult.settings())
	      });
	      return processPlugins(isMobileDevice, sectionResult, defaultOverrideSettings, extendedSettings);
	    };
	    var getEditorSettings = function (editor, id, documentBaseUrl, defaultOverrideSettings, settings) {
	      var defaultSettings = getDefaultSettings(settings, id, documentBaseUrl, isTouch, editor);
	      return combineSettings(isPhone || isTablet, isPhone, defaultSettings, defaultOverrideSettings, settings);
	    };
	    var getFiltered = function (predicate, editor, name) {
	      return Option.from(editor.settings[name]).filter(predicate);
	    };
	    var getParamObject = function (value) {
	      var output = {};
	      if (typeof value === 'string') {
	        each(value.indexOf('=') > 0 ? value.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value.split(','), function (val) {
	          var arr = val.split('=');
	          if (arr.length > 1) {
	            output[Tools.trim(arr[0])] = Tools.trim(arr[1]);
	          } else {
	            output[Tools.trim(arr[0])] = Tools.trim(arr[0]);
	          }
	        });
	      } else {
	        output = value;
	      }
	      return output;
	    };
	    var isArrayOf = function (p) {
	      return function (a) {
	        return isArray(a) && forall(a, p);
	      };
	    };
	    var getParam = function (editor, name, defaultVal, type) {
	      var value = name in editor.settings ? editor.settings[name] : defaultVal;
	      if (type === 'hash') {
	        return getParamObject(value);
	      } else if (type === 'string') {
	        return getFiltered(isString, editor, name).getOr(defaultVal);
	      } else if (type === 'number') {
	        return getFiltered(isNumber, editor, name).getOr(defaultVal);
	      } else if (type === 'boolean') {
	        return getFiltered(isBoolean, editor, name).getOr(defaultVal);
	      } else if (type === 'object') {
	        return getFiltered(isObject, editor, name).getOr(defaultVal);
	      } else if (type === 'array') {
	        return getFiltered(isArray, editor, name).getOr(defaultVal);
	      } else if (type === 'string[]') {
	        return getFiltered(isArrayOf(isString), editor, name).getOr(defaultVal);
	      } else if (type === 'function') {
	        return getFiltered(isFunction, editor, name).getOr(defaultVal);
	      } else {
	        return value;
	      }
	    };
	
	    var CreateIconManager = function () {
	      var lookup = {};
	      var add = function (id, iconPack) {
	        lookup[id] = iconPack;
	      };
	      var get = function (id) {
	        if (lookup[id]) {
	          return lookup[id];
	        }
	        return { icons: {} };
	      };
	      var has$1 = function (id) {
	        return has(lookup, id);
	      };
	      return {
	        add: add,
	        get: get,
	        has: has$1
	      };
	    };
	    var IconManager = CreateIconManager();
	
	    var getProp = function (propName, elm) {
	      var rawElm = elm.dom();
	      return rawElm[propName];
	    };
	    var getComputedSizeProp = function (propName, elm) {
	      return parseInt(get$4(elm, propName), 10);
	    };
	    var getClientWidth = curry(getProp, 'clientWidth');
	    var getClientHeight = curry(getProp, 'clientHeight');
	    var getMarginTop = curry(getComputedSizeProp, 'margin-top');
	    var getMarginLeft = curry(getComputedSizeProp, 'margin-left');
	    var getBoundingClientRect$1 = function (elm) {
	      return elm.dom().getBoundingClientRect();
	    };
	    var isInsideElementContentArea = function (bodyElm, clientX, clientY) {
	      var clientWidth = getClientWidth(bodyElm);
	      var clientHeight = getClientHeight(bodyElm);
	      return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;
	    };
	    var transpose = function (inline, elm, clientX, clientY) {
	      var clientRect = getBoundingClientRect$1(elm);
	      var deltaX = inline ? clientRect.left + elm.dom().clientLeft + getMarginLeft(elm) : 0;
	      var deltaY = inline ? clientRect.top + elm.dom().clientTop + getMarginTop(elm) : 0;
	      var x = clientX - deltaX;
	      var y = clientY - deltaY;
	      return {
	        x: x,
	        y: y
	      };
	    };
	    var isXYInContentArea = function (editor, clientX, clientY) {
	      var bodyElm = Element.fromDom(editor.getBody());
	      var targetElm = editor.inline ? bodyElm : documentElement(bodyElm);
	      var transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);
	      return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);
	    };
	    var fromDomSafe = function (node) {
	      return Option.from(node).map(Element.fromDom);
	    };
	    var isEditorAttachedToDom = function (editor) {
	      var rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();
	      return fromDomSafe(rawContainer).map(function (container) {
	        return contains$2(owner(container), container);
	      }).getOr(false);
	    };
	    var EditorView = {
	      isXYInContentArea: isXYInContentArea,
	      isEditorAttachedToDom: isEditorAttachedToDom
	    };
	
	    function NotificationManagerImpl() {
	      var unimplemented = function () {
	        throw new Error('Theme did not provide a NotificationManager implementation.');
	      };
	      return {
	        open: unimplemented,
	        close: unimplemented,
	        reposition: unimplemented,
	        getArgs: unimplemented
	      };
	    }
	
	    function NotificationManager(editor) {
	      var notifications = [];
	      var getImplementation = function () {
	        var theme = editor.theme;
	        return theme && theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();
	      };
	      var getTopNotification = function () {
	        return Option.from(notifications[0]);
	      };
	      var isEqual = function (a, b) {
	        return a.type === b.type && a.text === b.text && !a.progressBar && !a.timeout && !b.progressBar && !b.timeout;
	      };
	      var reposition = function () {
	        if (notifications.length > 0) {
	          getImplementation().reposition(notifications);
	        }
	      };
	      var addNotification = function (notification) {
	        notifications.push(notification);
	      };
	      var closeNotification = function (notification) {
	        findIndex(notifications, function (otherNotification) {
	          return otherNotification === notification;
	        }).each(function (index) {
	          notifications.splice(index, 1);
	        });
	      };
	      var open = function (spec) {
	        if (editor.removed || !EditorView.isEditorAttachedToDom(editor)) {
	          return;
	        }
	        return find(notifications, function (notification) {
	          return isEqual(getImplementation().getArgs(notification), spec);
	        }).getOrThunk(function () {
	          editor.editorManager.setActive(editor);
	          var notification = getImplementation().open(spec, function () {
	            closeNotification(notification);
	            reposition();
	          });
	          addNotification(notification);
	          reposition();
	          return notification;
	        });
	      };
	      var close = function () {
	        getTopNotification().each(function (notification) {
	          getImplementation().close(notification);
	          closeNotification(notification);
	          reposition();
	        });
	      };
	      var getNotifications = function () {
	        return notifications;
	      };
	      var registerEvents = function (editor) {
	        editor.on('SkinLoaded', function () {
	          var serviceMessage = editor.settings.service_message;
	          if (serviceMessage) {
	            open({
	              text: serviceMessage,
	              type: 'warning',
	              timeout: 0
	            });
	          }
	        });
	        editor.on('ResizeEditor ResizeWindow NodeChange', function () {
	          Delay.requestAnimationFrame(reposition);
	        });
	        editor.on('remove', function () {
	          each(notifications.slice(), function (notification) {
	            getImplementation().close(notification);
	          });
	        });
	      };
	      registerEvents(editor);
	      return {
	        open: open,
	        close: close,
	        getNotifications: getNotifications
	      };
	    }
	
	    var PluginManager = AddOnManager$1.PluginManager;
	
	    var ThemeManager = AddOnManager$1.ThemeManager;
	
	    function WindowManagerImpl () {
	      var unimplemented = function () {
	        throw new Error('Theme did not provide a WindowManager implementation.');
	      };
	      return {
	        open: unimplemented,
	        openUrl: unimplemented,
	        alert: unimplemented,
	        confirm: unimplemented,
	        close: unimplemented,
	        getParams: unimplemented,
	        setParams: unimplemented
	      };
	    }
	
	    var WindowManager = function (editor) {
	      var dialogs = [];
	      var getImplementation = function () {
	        var theme = editor.theme;
	        return theme && theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();
	      };
	      var funcBind = function (scope, f) {
	        return function () {
	          return f ? f.apply(scope, arguments) : undefined;
	        };
	      };
	      var fireOpenEvent = function (dialog) {
	        editor.fire('OpenWindow', { dialog: dialog });
	      };
	      var fireCloseEvent = function (dialog) {
	        editor.fire('CloseWindow', { dialog: dialog });
	      };
	      var addDialog = function (dialog) {
	        dialogs.push(dialog);
	        fireOpenEvent(dialog);
	      };
	      var closeDialog = function (dialog) {
	        fireCloseEvent(dialog);
	        dialogs = filter(dialogs, function (otherDialog) {
	          return otherDialog !== dialog;
	        });
	        if (dialogs.length === 0) {
	          editor.focus();
	        }
	      };
	      var getTopDialog = function () {
	        return Option.from(dialogs[dialogs.length - 1]);
	      };
	      var storeSelectionAndOpenDialog = function (openDialog) {
	        editor.editorManager.setActive(editor);
	        SelectionBookmark.store(editor);
	        var dialog = openDialog();
	        addDialog(dialog);
	        return dialog;
	      };
	      var open = function (args, params) {
	        return storeSelectionAndOpenDialog(function () {
	          return getImplementation().open(args, params, closeDialog);
	        });
	      };
	      var openUrl = function (args) {
	        return storeSelectionAndOpenDialog(function () {
	          return getImplementation().openUrl(args, closeDialog);
	        });
	      };
	      var alert = function (message, callback, scope) {
	        getImplementation().alert(message, funcBind(scope ? scope : this, callback));
	      };
	      var confirm = function (message, callback, scope) {
	        getImplementation().confirm(message, funcBind(scope ? scope : this, callback));
	      };
	      var close = function () {
	        getTopDialog().each(function (dialog) {
	          getImplementation().close(dialog);
	          closeDialog(dialog);
	        });
	      };
	      editor.on('remove', function () {
	        each(dialogs, function (dialog) {
	          getImplementation().close(dialog);
	        });
	      });
	      return {
	        open: open,
	        openUrl: openUrl,
	        alert: alert,
	        confirm: confirm,
	        close: close
	      };
	    };
	
	    var displayNotification = function (editor, message) {
	      editor.notificationManager.open({
	        type: 'error',
	        text: message
	      });
	    };
	    var displayError = function (editor, message) {
	      if (editor._skinLoaded) {
	        displayNotification(editor, message);
	      } else {
	        editor.on('SkinLoaded', function () {
	          displayNotification(editor, message);
	        });
	      }
	    };
	    var uploadError = function (editor, message) {
	      displayError(editor, I18n.translate([
	        'Failed to upload image: {0}',
	        message
	      ]));
	    };
	    var logError = function (editor, errorType, msg) {
	      fireError(editor, errorType, { message: msg });
	      domGlobals.console.error(msg);
	    };
	    var createLoadError = function (type, url, name) {
	      return name ? 'Failed to load ' + type + ': ' + name + ' from url ' + url : 'Failed to load ' + type + ' url: ' + url;
	    };
	    var pluginLoadError = function (editor, url, name) {
	      logError(editor, 'PluginLoadError', createLoadError('plugin', url, name));
	    };
	    var iconsLoadError = function (editor, url, name) {
	      logError(editor, 'IconsLoadError', createLoadError('icons', url, name));
	    };
	    var languageLoadError = function (editor, url, name) {
	      logError(editor, 'LanguageLoadError', createLoadError('language', url, name));
	    };
	    var pluginInitError = function (editor, name, err) {
	      var message = I18n.translate([
	        'Failed to initialize plugin: {0}',
	        name
	      ]);
	      initError(message, err);
	      displayError(editor, message);
	    };
	    var initError = function (message) {
	      var x = [];
	      for (var _i = 1; _i < arguments.length; _i++) {
	        x[_i - 1] = arguments[_i];
	      }
	      var console = domGlobals.window.console;
	      if (console) {
	        if (console.error) {
	          console.error.apply(console, arguments);
	        } else {
	          console.log.apply(console, arguments);
	        }
	      }
	    };
	    var ErrorReporter = {
	      pluginLoadError: pluginLoadError,
	      iconsLoadError: iconsLoadError,
	      languageLoadError: languageLoadError,
	      pluginInitError: pluginInitError,
	      uploadError: uploadError,
	      displayError: displayError,
	      initError: initError
	    };
	
	    var getAll = function () {
	      return {
	        'accessibility-check': '<svg width="24" height="24"><path d="M12 2a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2c0-1.1.9-2 2-2zm8 7h-5v12c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5c0-.6-.4-1-1-1a1 1 0 0 0-1 1v5c0 .6-.4 1-1 1a1 1 0 0 1-1-1V9H4a1 1 0 1 1 0-2h16c.6 0 1 .4 1 1s-.4 1-1 1z" fill-rule="nonzero"/></svg>',
	        'action-next': '<svg width="24" height="24"><path fill-rule="nonzero" d="M5.7 7.3a1 1 0 0 0-1.4 1.4l7.7 7.7 7.7-7.7a1 1 0 1 0-1.4-1.4L12 13.6 5.7 7.3z"/></svg>',
	        'action-prev': '<svg width="24" height="24"><path fill-rule="nonzero" d="M18.3 15.7a1 1 0 0 0 1.4-1.4L12 6.6l-7.7 7.7a1 1 0 0 0 1.4 1.4L12 9.4l6.3 6.3z"/></svg>',
	        'align-center': '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm3 4h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2zm-3-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2z" fill-rule="evenodd"/></svg>',
	        'align-justify': '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2z" fill-rule="evenodd"/></svg>',
	        'align-left': '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm0 4h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2z" fill-rule="evenodd"/></svg>',
	        'align-none': '<svg width="24" height="24"><path d="M14.2 5L13 7H5a1 1 0 1 1 0-2h9.2zm4 0h.8a1 1 0 0 1 0 2h-2l1.2-2zm-6.4 4l-1.2 2H5a1 1 0 0 1 0-2h6.8zm4 0H19a1 1 0 0 1 0 2h-4.4l1.2-2zm-6.4 4l-1.2 2H5a1 1 0 0 1 0-2h4.4zm4 0H19a1 1 0 0 1 0 2h-6.8l1.2-2zM7 17l-1.2 2H5a1 1 0 0 1 0-2h2zm4 0h8a1 1 0 0 1 0 2H9.8l1.2-2zm5.2-13.5l1.3.7-9.7 16.3-1.3-.7 9.7-16.3z" fill-rule="evenodd"/></svg>',
	        'align-right': '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm6 4h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm-6-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2z" fill-rule="evenodd"/></svg>',
	        'arrow-left': '<svg width="24" height="24"><path d="M5.6 13l12 6a1 1 0 0 0 1.4-1V6a1 1 0 0 0-1.4-.9l-12 6a1 1 0 0 0 0 1.8z" fill-rule="evenodd"/></svg>',
	        'arrow-right': '<svg width="24" height="24"><path d="M18.5 13l-12 6A1 1 0 0 1 5 18V6a1 1 0 0 1 1.4-.9l12 6a1 1 0 0 1 0 1.8z" fill-rule="evenodd"/></svg>',
	        'bold': '<svg width="24" height="24"><path d="M7.8 19c-.3 0-.5 0-.6-.2l-.2-.5V5.7c0-.2 0-.4.2-.5l.6-.2h5c1.5 0 2.7.3 3.5 1 .7.6 1.1 1.4 1.1 2.5a3 3 0 0 1-.6 1.9c-.4.6-1 1-1.6 1.2.4.1.9.3 1.3.6s.8.7 1 1.2c.4.4.5 1 .5 1.6 0 1.3-.4 2.3-1.3 3-.8.7-2.1 1-3.8 1H7.8zm5-8.3c.6 0 1.2-.1 1.6-.5.4-.3.6-.7.6-1.3 0-1.1-.8-1.7-2.3-1.7H9.3v3.5h3.4zm.5 6c.7 0 1.3-.1 1.7-.4.4-.4.6-.9.6-1.5s-.2-1-.7-1.4c-.4-.3-1-.4-2-.4H9.4v3.8h4z" fill-rule="evenodd"/></svg>',
	        'bookmark': '<svg width="24" height="24"><path d="M6 4v17l6-4 6 4V4c0-.6-.4-1-1-1H7a1 1 0 0 0-1 1z" fill-rule="nonzero"/></svg>',
	        'border-width': '<svg width="24" height="24"><path d="M5 14.8h14a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2zm-.5 3.7h15c.3 0 .5.2.5.5s-.2.5-.5.5h-15a.5.5 0 1 1 0-1zm.5-8.3h14c.6 0 1 .4 1 1v1c0 .5-.4 1-1 1H5a1 1 0 0 1-1-1v-1c0-.6.4-1 1-1zm0-5.7h14c.6 0 1 .4 1 1v2c0 .6-.4 1-1 1H5a1 1 0 0 1-1-1v-2c0-.6.4-1 1-1z" fill-rule="evenodd"/></svg>',
	        'brightness': '<svg width="24" height="24"><path d="M12 17c.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7v-1c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3zm0-10a1 1 0 0 1-.7-.3A1 1 0 0 1 11 6V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3zm7 4c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-1a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1zM7 12c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H5a1 1 0 0 1-.7-.3A1 1 0 0 1 4 12c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1c.3 0 .5.1.7.3.2.2.3.4.3.7zm10 3.5l.7.8c.2.1.3.4.3.6 0 .3-.1.6-.3.8a1 1 0 0 1-.8.3 1 1 0 0 1-.6-.3l-.8-.7a1 1 0 0 1-.3-.8c0-.2.1-.5.3-.7a1 1 0 0 1 1.4 0zm-10-7l-.7-.8a1 1 0 0 1-.3-.6c0-.3.1-.6.3-.8.2-.2.5-.3.8-.3.2 0 .5.1.7.3l.7.7c.2.2.3.5.3.8 0 .2-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.8-.3zm10 0a1 1 0 0 1-.8.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.6.3-.8l.8-.7c.1-.2.4-.3.6-.3.3 0 .6.1.8.3.2.2.3.5.3.8 0 .2-.1.5-.3.7l-.7.7zm-10 7c.2-.2.5-.3.8-.3.2 0 .5.1.7.3a1 1 0 0 1 0 1.4l-.8.8a1 1 0 0 1-.6.3 1 1 0 0 1-.8-.3 1 1 0 0 1-.3-.8c0-.2.1-.5.3-.6l.7-.8zM12 8a4 4 0 0 1 3.7 2.4 4 4 0 0 1 0 3.2A4 4 0 0 1 12 16a4 4 0 0 1-3.7-2.4 4 4 0 0 1 0-3.2A4 4 0 0 1 12 8zm0 6.5c.7 0 1.3-.2 1.8-.7.5-.5.7-1.1.7-1.8s-.2-1.3-.7-1.8c-.5-.5-1.1-.7-1.8-.7s-1.3.2-1.8.7c-.5.5-.7 1.1-.7 1.8s.2 1.3.7 1.8c.5.5 1.1.7 1.8.7z" fill-rule="evenodd"/></svg>',
	        'browse': '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-4v-2h4V8H5v10h4v2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zm-8 9.4l-2.3 2.3a1 1 0 1 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1-1.4 1.4L13 13.4V20a1 1 0 0 1-2 0v-6.6z" fill-rule="nonzero"/></svg>',
	        'cancel': '<svg width="24" height="24"><path d="M12 4.6a7.4 7.4 0 1 1 0 14.8 7.4 7.4 0 0 1 0-14.8zM12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18zm0 8L14.8 8l1 1.1-2.7 2.8 2.7 2.7-1.1 1.1-2.7-2.7-2.7 2.7-1-1.1 2.6-2.7-2.7-2.7 1-1.1 2.8 2.7z" fill-rule="nonzero"/></svg>',
	        'change-case': '<svg width="24" height="24"><path d="M18.4 18.2v-.6c-.5.8-1.3 1.2-2.4 1.2-2.2 0-3.3-1.6-3.3-4.8 0-3.1 1-4.7 3.3-4.7 1.1 0 1.8.3 2.4 1.1v-.6c0-.5.4-.8.8-.8s.8.3.8.8v8.4c0 .5-.4.8-.8.8a.8.8 0 0 1-.8-.8zm-2-7.4c-1.3 0-1.8.9-1.8 3.2 0 2.4.5 3.3 1.7 3.3 1.3 0 1.8-.9 1.8-3.2 0-2.4-.5-3.3-1.7-3.3zM10 15.7H5.5l-.8 2.6a1 1 0 0 1-1 .7h-.2a.7.7 0 0 1-.7-1l4-12a1 1 0 1 1 2 0l4 12a.7.7 0 0 1-.8 1h-.2a1 1 0 0 1-1-.7l-.8-2.6zm-.3-1.5l-2-6.5-1.9 6.5h3.9z" fill-rule="evenodd"/></svg>',
	        'character-count': '<svg width="24" height="24"><path d="M4 11.5h16v1H4v-1zm4.8-6.8V10H7.7V5.8h-1v-1h2zM11 8.3V9h2v1h-3V7.7l2-1v-.9h-2v-1h3v2.4l-2 1zm6.3-3.4V10h-3.1V9h2.1V8h-2.1V6.8h2.1v-1h-2.1v-1h3.1zM5.8 16.4c0-.5.2-.8.5-1 .2-.2.6-.3 1.2-.3l.8.1c.2 0 .4.2.5.3l.4.4v2.8l.2.3H8.2v-.1-.2l-.6.3H7c-.4 0-.7 0-1-.2a1 1 0 0 1-.3-.9c0-.3 0-.6.3-.8.3-.2.7-.4 1.2-.4l.6-.2h.3v-.2l-.1-.2a.8.8 0 0 0-.5-.1 1 1 0 0 0-.4 0l-.3.4h-1zm2.3.8h-.2l-.2.1-.4.1a1 1 0 0 0-.4.2l-.2.2.1.3.5.1h.4l.4-.4v-.6zm2-3.4h1.2v1.7l.5-.3h.5c.5 0 .9.1 1.2.5.3.4.5.8.5 1.4 0 .6-.2 1.1-.5 1.5-.3.4-.7.6-1.3.6l-.6-.1-.4-.4v.4h-1.1v-5.4zm1.1 3.3c0 .3 0 .6.2.8a.7.7 0 0 0 1.2 0l.2-.8c0-.4 0-.6-.2-.8a.7.7 0 0 0-.6-.3l-.6.3-.2.8zm6.1-.5c0-.2 0-.3-.2-.4a.8.8 0 0 0-.5-.2c-.3 0-.5.1-.6.3l-.2.9c0 .3 0 .6.2.8.1.2.3.3.6.3.2 0 .4 0 .5-.2l.2-.4h1.1c0 .5-.3.8-.6 1.1a2 2 0 0 1-1.3.4c-.5 0-1-.2-1.3-.6a2 2 0 0 1-.5-1.4c0-.6.1-1.1.5-1.5.3-.4.8-.5 1.4-.5.5 0 1 0 1.2.3.4.3.5.7.5 1.2h-1v-.1z" fill-rule="evenodd"/></svg>',
	        'checklist-rtl': '<svg width="24" height="24"><path d="M5 17h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm14.2 11c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 8c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z" fill-rule="evenodd"/></svg>',
	        'checklist': '<svg width="24" height="24"><path d="M11 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm0-6h8a1 1 0 0 1 0 2h-8a1 1 0 0 1 0-2zM7.2 16c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 8c-.2.3-.7.4-1 0L3.8 6.9a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z" fill-rule="evenodd"/></svg>',
	        'checkmark': '<svg width="24" height="24"><path d="M18.2 5.4a1 1 0 0 1 1.6 1.2l-8 12a1 1 0 0 1-1.5.1l-5-5a1 1 0 1 1 1.4-1.4l4.1 4.1 7.4-11z" fill-rule="nonzero"/></svg>',
	        'chevron-down': '<svg width="10" height="10"><path d="M8.7 2.2c.3-.3.8-.3 1 0 .4.4.4.9 0 1.2L5.7 7.8c-.3.3-.9.3-1.2 0L.2 3.4a.8.8 0 0 1 0-1.2c.3-.3.8-.3 1.1 0L5 6l3.7-3.8z" fill-rule="nonzero"/></svg>',
	        'chevron-left': '<svg width="10" height="10"><path d="M7.8 1.3L4 5l3.8 3.7c.3.3.3.8 0 1-.4.4-.9.4-1.2 0L2.2 5.7a.8.8 0 0 1 0-1.2L6.6.2C7 0 7.4 0 7.8.2c.3.3.3.8 0 1.1z" fill-rule="nonzero"/></svg>',
	        'chevron-right': '<svg width="10" height="10"><path d="M2.2 1.3a.8.8 0 0 1 0-1c.4-.4.9-.4 1.2 0l4.4 4.1c.3.4.3.9 0 1.2L3.4 9.8c-.3.3-.8.3-1.2 0a.8.8 0 0 1 0-1.1L6 5 2.2 1.3z" fill-rule="nonzero"/></svg>',
	        'chevron-up': '<svg width="10" height="10"><path d="M8.7 7.8L5 4 1.3 7.8c-.3.3-.8.3-1 0a.8.8 0 0 1 0-1.2l4.1-4.4c.3-.3.9-.3 1.2 0l4.2 4.4c.3.3.3.9 0 1.2-.3.3-.8.3-1.1 0z" fill-rule="nonzero"/></svg>',
	        'close': '<svg width="24" height="24"><path d="M17.3 8.2L13.4 12l3.9 3.8a1 1 0 0 1-1.5 1.5L12 13.4l-3.8 3.9a1 1 0 0 1-1.5-1.5l3.9-3.8-3.9-3.8a1 1 0 0 1 1.5-1.5l3.8 3.9 3.8-3.9a1 1 0 0 1 1.5 1.5z" fill-rule="evenodd"/></svg>',
	        'code-sample': '<svg width="24" height="26"><path d="M7.1 11a2.8 2.8 0 0 1-.8 2 2.8 2.8 0 0 1 .8 2v1.7c0 .3.1.6.4.8.2.3.5.4.8.4.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.7 0-1.4-.3-2-.8-.5-.6-.8-1.3-.8-2V15c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4v-.8c0-.2.2-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V9.3c0-.7.3-1.4.8-2 .6-.5 1.3-.8 2-.8.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8V11zm9.8 0V9.3c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4V7c0-.2.1-.4.4-.4.7 0 1.4.3 2 .8.5.6.8 1.3.8 2V11c0 .3.1.6.4.8.2.3.5.4.8.4.2 0 .4.2.4.4v.8c0 .2-.2.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8v1.7c0 .7-.3 1.4-.8 2-.6.5-1.3.8-2 .8a.4.4 0 0 1-.4-.4v-.8c0-.2.1-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V15a2.8 2.8 0 0 1 .8-2 2.8 2.8 0 0 1-.8-2zm-3.3-.4c0 .4-.1.8-.5 1.1-.3.3-.7.5-1.1.5-.4 0-.8-.2-1.1-.5-.4-.3-.5-.7-.5-1.1 0-.5.1-.9.5-1.2.3-.3.7-.4 1.1-.4.4 0 .8.1 1.1.4.4.3.5.7.5 1.2zM12 13c.4 0 .8.1 1.1.5.4.3.5.7.5 1.1 0 1-.1 1.6-.5 2a3 3 0 0 1-1.1 1c-.4.3-.8.4-1.1.4a.5.5 0 0 1-.5-.5V17a3 3 0 0 0 1-.2l.6-.6c-.6 0-1-.2-1.3-.5-.2-.3-.3-.7-.3-1 0-.5.1-1 .5-1.2.3-.4.7-.5 1.1-.5z" fill-rule="evenodd"/></svg>',
	        'color-levels': '<svg width="24" height="24"><path d="M17.5 11.4A9 9 0 0 1 18 14c0 .5 0 1-.2 1.4 0 .4-.3.9-.5 1.3a6.2 6.2 0 0 1-3.7 3 5.7 5.7 0 0 1-3.2 0A5.9 5.9 0 0 1 7.6 18a6.2 6.2 0 0 1-1.4-2.6 6.7 6.7 0 0 1 0-2.8c0-.4.1-.9.3-1.3a13.6 13.6 0 0 1 2.3-4A20 20 0 0 1 12 4a26.4 26.4 0 0 1 3.2 3.4 18.2 18.2 0 0 1 2.3 4zm-2 4.5c.4-.7.5-1.4.5-2a7.3 7.3 0 0 0-1-3.2c.2.6.2 1.2.2 1.9a4.5 4.5 0 0 1-1.3 3 5.3 5.3 0 0 1-2.3 1.5 4.9 4.9 0 0 1-2 .1 4.3 4.3 0 0 0 2.4.8 4 4 0 0 0 2-.6 4 4 0 0 0 1.5-1.5z" fill-rule="evenodd"/></svg>',
	        'color-picker': '<svg width="24" height="24"><path d="M12 3a9 9 0 0 0 0 18 1.5 1.5 0 0 0 1.1-2.5c-.2-.3-.4-.6-.4-1 0-.8.7-1.5 1.5-1.5H16a5 5 0 0 0 5-5c0-4.4-4-8-9-8zm-5.5 9a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm3-4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm3 4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3z" fill-rule="nonzero"/></svg>',
	        'color-swatch-remove-color': '<svg width="24" height="24"><path stroke="#000" stroke-width="2" d="M21 3L3 21" fill-rule="evenodd"/></svg>',
	        'color-swatch': '<svg width="24" height="24"><rect x="3" y="3" width="18" height="18" rx="1" fill-rule="evenodd"/></svg>',
	        'comment-add': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M9 19l3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23z"/><path d="M13 10h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 0v-2H9a1 1 0 0 1 0-2h2V8a1 1 0 0 1 2 0v2z"/></g></svg>',
	        'comment': '<svg width="24" height="24"><path fill-rule="nonzero" d="M9 19l3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23z"/></svg>',
	        'contrast': '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4zm-6 8a6 6 0 0 0 6 6V6a6 6 0 0 0-6 6z" fill-rule="evenodd"/></svg>',
	        'copy': '<svg width="24" height="24"><path d="M16 3H6a2 2 0 0 0-2 2v11h2V5h10V3zm1 4a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7zm0 12V9h-7v10h7z" fill-rule="nonzero"/></svg>',
	        'crop': '<svg width="24" height="24"><path d="M17 8v7h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v2c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-2H7V9H5a1 1 0 1 1 0-2h2V5c0-.6.4-1 1-1s1 .4 1 1v2h7l3-3 1 1-3 3zM9 9v5l5-5H9zm1 6h5v-5l-5 5z" fill-rule="evenodd"/></svg>',
	        'cut': '<svg width="24" height="24"><path d="M18 15c.6.7 1 1.4 1 2.3 0 .8-.2 1.5-.7 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l6 6 6-6 .5 1a3.3 3.3 0 0 1 0 2c0 .4-.3.7-.5 1l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8zm-8.5 2.2l.1-.4v-.3-.4a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2 1.6 1.6 0 0 0-.8 0 2.6 2.6 0 0 0-.8.3 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3 2.8 2.8 0 0 0 1-1zm2.5-2.8c.4 0 .7-.1 1-.4.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4s-.7.1-1 .4c-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4zm5.4 4l.2-.5v-.4-.3a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3 1.5 1.5 0 0 0-.8 0 1 1 0 0 0-.4.2 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4l.3.4.3.4a2.8 2.8 0 0 0 .8.5l.4.1h.7l.5-.2z" fill-rule="evenodd"/></svg>',
	        'document-properties': '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3zM17 19H7V5h6v4h4v10z" fill-rule="nonzero"/></svg>',
	        'drag': '<svg width="24" height="24"><path d="M13 5h2v2h-2V5zm0 4h2v2h-2V9zM9 9h2v2H9V9zm4 4h2v2h-2v-2zm-4 0h2v2H9v-2zm0 4h2v2H9v-2zm4 0h2v2h-2v-2zM9 5h2v2H9V5z" fill-rule="evenodd"/></svg>',
	        'duplicate': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M16 3v2H6v11H4V5c0-1.1.9-2 2-2h10zm3 8h-2V9h-7v10h9a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7a2 2 0 0 1 2 2v2z"/><path d="M17 14h1a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1h-1a1 1 0 0 1 0-2h1v-1a1 1 0 0 1 2 0v1z"/></g></svg>',
	        'edit-block': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19.8 8.8l-9.4 9.4c-.2.2-.5.4-.9.4l-5.4 1.2 1.2-5.4.5-.8 9.4-9.4c.7-.7 1.8-.7 2.5 0l2.1 2.1c.7.7.7 1.8 0 2.5zm-2-.2l1-.9v-.3l-2.2-2.2a.3.3 0 0 0-.3 0l-1 1L18 8.5zm-1 1l-2.5-2.4-6 6 2.5 2.5 6-6zm-7 7.1l-2.6-2.4-.3.3-.1.2-.7 3 3.1-.6h.1l.4-.5z"/></svg>',
	        'edit-image': '<svg width="24" height="24"><path d="M18 16h2V7a2 2 0 0 0-2-2H7v2h11v9zM6 17h15a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1H6a2 2 0 0 1-2-2V7H3a1 1 0 1 1 0-2h1V4a1 1 0 1 1 2 0v13zm3-5.3l1.3 2 3-4.7 3.7 6H7l2-3.3z" fill-rule="nonzero"/></svg>',
	        'embed-page': '<svg width="24" height="24"><path d="M19 6V5H5v14h2A13 13 0 0 1 19 6zm0 1.4c-.8.8-1.6 2.4-2.2 4.6H19V7.4zm0 5.6h-2.4c-.4 1.8-.6 3.8-.6 6h3v-6zm-4 6c0-2.2.2-4.2.6-6H13c-.7 1.8-1.1 3.8-1.1 6h3zm-4 0c0-2.2.4-4.2 1-6H9.6A12 12 0 0 0 8 19h3zM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1zm11.8 9c.4-1.9 1-3.4 1.8-4.5a9.2 9.2 0 0 0-4 4.5h2.2zm-3.4 0a12 12 0 0 1 2.8-4 12 12 0 0 0-5 4h2.2z" fill-rule="nonzero"/></svg>',
	        'embed': '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1zm1 2v14h14V5H5zm4.8 2.6l5.6 4a.5.5 0 0 1 0 .8l-5.6 4A.5.5 0 0 1 9 16V8a.5.5 0 0 1 .8-.4z" fill-rule="nonzero"/></svg>',
	        'emoji': '<svg width="24" height="24"><path d="M9 11c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1zm6 0c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1zm-3 5.5c2.1 0 4-1.5 4.4-3.5H7.6c.5 2 2.3 3.5 4.4 3.5zM12 4a8 8 0 1 0 0 16 8 8 0 0 0 0-16zm0 14.5a6.5 6.5 0 1 1 0-13 6.5 6.5 0 0 1 0 13z" fill-rule="nonzero"/></svg>',
	        'fill': '<svg width="24" height="26"><path d="M16.6 12l-9-9-1.4 1.4 2.4 2.4-5.2 5.1c-.5.6-.5 1.6 0 2.2L9 19.6a1.5 1.5 0 0 0 2.2 0l5.5-5.5c.5-.6.5-1.6 0-2.2zM5.2 13L10 8.2l4.8 4.8H5.2zM19 14.5s-2 2.2-2 3.5c0 1.1.9 2 2 2a2 2 0 0 0 2-2c0-1.3-2-3.5-2-3.5z" fill-rule="nonzero"/></svg>',
	        'flip-horizontally': '<svg width="24" height="24"><path d="M14 19h2v-2h-2v2zm4-8h2V9h-2v2zM4 7v10c0 1.1.9 2 2 2h3v-2H6V7h3V5H6a2 2 0 0 0-2 2zm14-2v2h2a2 2 0 0 0-2-2zm-7 16h2V3h-2v18zm7-6h2v-2h-2v2zm-4-8h2V5h-2v2zm4 12a2 2 0 0 0 2-2h-2v2z" fill-rule="nonzero"/></svg>',
	        'flip-vertically': '<svg width="24" height="24"><path d="M5 14v2h2v-2H5zm8 4v2h2v-2h-2zm4-14H7a2 2 0 0 0-2 2v3h2V6h10v3h2V6a2 2 0 0 0-2-2zm2 14h-2v2a2 2 0 0 0 2-2zM3 11v2h18v-2H3zm6 7v2h2v-2H9zm8-4v2h2v-2h-2zM5 18c0 1.1.9 2 2 2v-2H5z" fill-rule="nonzero"/></svg>',
	        'format-painter': '<svg width="24" height="24"><path d="M18 5V4c0-.5-.4-1-1-1H5a1 1 0 0 0-1 1v4c0 .6.5 1 1 1h12c.6 0 1-.4 1-1V7h1v4H9v9c0 .6.4 1 1 1h2c.6 0 1-.4 1-1v-7h8V5h-3z" fill-rule="nonzero"/></svg>',
	        'format': '<svg width="24" height="24"><path fill-rule="evenodd" d="M17 5a1 1 0 0 1 0 2h-4v11a1 1 0 0 1-2 0V7H7a1 1 0 1 1 0-2h10z"/></svg>',
	        'fullscreen': '<svg width="24" height="24"><path d="M15.3 10l-1.2-1.3 2.9-3h-2.3a.9.9 0 1 1 0-1.7H19c.5 0 .9.4.9.9v4.4a.9.9 0 1 1-1.8 0V7l-2.9 3zm0 4l3 3v-2.3a.9.9 0 1 1 1.7 0V19c0 .5-.4.9-.9.9h-4.4a.9.9 0 1 1 0-1.8H17l-3-2.9 1.3-1.2zM10 15.4l-2.9 3h2.3a.9.9 0 1 1 0 1.7H5a.9.9 0 0 1-.9-.9v-4.4a.9.9 0 1 1 1.8 0V17l2.9-3 1.2 1.3zM8.7 10L5.7 7v2.3a.9.9 0 0 1-1.7 0V5c0-.5.4-.9.9-.9h4.4a.9.9 0 0 1 0 1.8H7l3 2.9-1.3 1.2z" fill-rule="nonzero"/></svg>',
	        'gallery': '<svg width="24" height="24"><path fill-rule="nonzero" d="M5 15.7l2.3-2.2c.3-.3.7-.3 1 0L11 16l5.1-5c.3-.4.8-.4 1 0l2 1.9V8H5v7.7zM5 18V19h3l1.8-1.9-2-2L5 17.9zm14-3l-2.5-2.4-6.4 6.5H19v-4zM4 6h16c.6 0 1 .4 1 1v13c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V7c0-.6.4-1 1-1zm6 7a2 2 0 1 1 0-4 2 2 0 0 1 0 4zM4.5 4h15a.5.5 0 1 1 0 1h-15a.5.5 0 0 1 0-1zm2-2h11a.5.5 0 1 1 0 1h-11a.5.5 0 0 1 0-1z"/></svg>',
	        'gamma': '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1zm1 2v14h14V5H5zm6.5 11.8V14L9.2 8.7a5.1 5.1 0 0 0-.4-.8l-.1-.2H8 8v-1l.3-.1.3-.1h.7a1 1 0 0 1 .6.5l.1.3a8.5 8.5 0 0 1 .3.6l1.9 4.6 2-5.2a1 1 0 0 1 1-.6.5.5 0 0 1 .5.6L13 14v2.8a.7.7 0 0 1-1.4 0z" fill-rule="nonzero"/></svg>',
	        'help': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M12 5.5a6.5 6.5 0 0 0-6 9 6.3 6.3 0 0 0 1.4 2l1 1a6.3 6.3 0 0 0 3.6 1 6.5 6.5 0 0 0 6-9 6.3 6.3 0 0 0-1.4-2l-1-1a6.3 6.3 0 0 0-3.6-1zM12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4z"/><path d="M9.6 9.7a.7.7 0 0 1-.7-.8c0-1.1 1.5-1.8 3.2-1.8 1.8 0 3.2.8 3.2 2.4 0 1.4-.4 2.1-1.5 2.8-.2 0-.3.1-.3.2a2 2 0 0 0-.8.8.8.8 0 0 1-1.4-.6c.3-.7.8-1 1.3-1.5l.4-.2c.7-.4.8-.6.8-1.5 0-.5-.6-.9-1.7-.9-.5 0-1 .1-1.4.3-.2 0-.3.1-.3.2v-.2c0 .4-.4.8-.8.8z" fill-rule="nonzero"/><circle cx="12" cy="16" r="1"/></g></svg>',
	        'highlight-bg-color': '<svg width="24" height="24"><g fill-rule="evenodd"><path id="tox-icon-highlight-bg-color__color" d="M3 18h18v3H3z"/><path fill-rule="nonzero" d="M7.7 16.7H3l3.3-3.3-.7-.8L10.2 8l4 4.1-4 4.2c-.2.2-.6.2-.8 0l-.6-.7-1.1 1.1zm5-7.5L11 7.4l3-2.9a2 2 0 0 1 2.6 0L18 6c.7.7.7 2 0 2.7l-2.9 2.9-1.8-1.8-.5-.6"/></g></svg>',
	        'home': '<svg width="24" height="24"><path fill-rule="nonzero" d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>',
	        'horizontal-rule': '<svg width="24" height="24"><path d="M4 11h16v2H4z" fill-rule="evenodd"/></svg>',
	        'image-options': '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2z" fill-rule="nonzero"/></svg>',
	        'image': '<svg width="24" height="24"><path d="M5 15.7l3.3-3.2c.3-.3.7-.3 1 0L12 15l4.1-4c.3-.4.8-.4 1 0l2 1.9V5H5v10.7zM5 18V19h3l2.8-2.9-2-2L5 17.9zm14-3l-2.5-2.4-6.4 6.5H19v-4zM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1zm6 8a2 2 0 1 0 0-4 2 2 0 0 0 0 4z" fill-rule="nonzero"/></svg>',
	        'indent': '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2zm-2.6-3.8L6.2 12l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6z" fill-rule="evenodd"/></svg>',
	        'info': '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4zm-1 3v2h2V7h-2zm3 10v-1h-1v-5h-3v1h1v4h-1v1h4z" fill-rule="evenodd"/></svg>',
	        'insert-character': '<svg width="24" height="24"><path d="M15 18h4l1-2v4h-6v-3.3l1.4-1a6 6 0 0 0 1.8-2.9 6.3 6.3 0 0 0-.1-4.1 5.8 5.8 0 0 0-3-3.2c-.6-.3-1.3-.5-2.1-.5a5.1 5.1 0 0 0-3.9 1.8 6.3 6.3 0 0 0-1.3 6 6.2 6.2 0 0 0 1.8 3l1.4.9V20H4v-4l1 2h4v-.5l-2-1L5.4 15A6.5 6.5 0 0 1 4 11c0-1 .2-1.9.6-2.7A7 7 0 0 1 6.3 6C7.1 5.4 8 5 9 4.5c1-.3 2-.5 3.1-.5a8.8 8.8 0 0 1 5.7 2 7 7 0 0 1 1.7 2.3 6 6 0 0 1 .2 4.8c-.2.7-.6 1.3-1 1.9a7.6 7.6 0 0 1-3.6 2.5v.5z" fill-rule="evenodd"/></svg>',
	        'insert-time': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M12 19a7 7 0 1 0 0-14 7 7 0 0 0 0 14zm0 2a9 9 0 1 1 0-18 9 9 0 0 1 0 18z"/><path d="M16 12h-3V7c0-.6-.4-1-1-1a1 1 0 0 0-1 1v7h5c.6 0 1-.4 1-1s-.4-1-1-1z"/></g></svg>',
	        'invert': '<svg width="24" height="24"><path d="M18 19.3L16.5 18a5.8 5.8 0 0 1-3.1 1.9 6.1 6.1 0 0 1-5.5-1.6A5.8 5.8 0 0 1 6 14v-.3l.1-1.2A13.9 13.9 0 0 1 7.7 9l-3-3 .7-.8 2.8 2.9 9 8.9 1.5 1.6-.7.6zm0-5.5v.3l-.1 1.1-.4 1-1.2-1.2a4.3 4.3 0 0 0 .2-1v-.2c0-.4 0-.8-.2-1.3l-.5-1.4a14.8 14.8 0 0 0-3-4.2L12 6a26.1 26.1 0 0 0-2.2 2.5l-1-1a20.9 20.9 0 0 1 2.9-3.3L12 4l1 .8a22.2 22.2 0 0 1 4 5.4c.6 1.2 1 2.4 1 3.6z" fill-rule="evenodd"/></svg>',
	        'italic': '<svg width="24" height="24"><path d="M16.7 4.7l-.1.9h-.3c-.6 0-1 0-1.4.3-.3.3-.4.6-.5 1.1l-2.1 9.8v.6c0 .5.4.8 1.4.8h.2l-.2.8H8l.2-.8h.2c1.1 0 1.8-.5 2-1.5l2-9.8.1-.5c0-.6-.4-.8-1.4-.8h-.3l.2-.9h5.8z" fill-rule="evenodd"/></svg>',
	        'line': '<svg width="24" height="24"><path d="M15 9l-8 8H4v-3l8-8 3 3zm1-1l-3-3 1-1h1c-.2 0 0 0 0 0l2 2s0 .2 0 0v1l-1 1zM4 18h16v2H4v-2z" fill-rule="evenodd"/></svg>',
	        'link': '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2.1 2a2 2 0 1 0 2.7 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2zm11.6-.6a1 1 0 0 1-1.4-1.4l2-2a2 2 0 1 0-2.6-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2z" fill-rule="nonzero"/></svg>',
	        'list-bull-circle': '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M11 16a2 2 0 1 0 0-4 2 2 0 0 0 0 4zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6zM11 26a2 2 0 1 0 0-4 2 2 0 0 0 0 4zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6zM11 36a2 2 0 1 0 0-4 2 2 0 0 0 0 4zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6z" fill-rule="nonzero"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
	        'list-bull-default': '<svg width="48" height="48"><g fill-rule="evenodd"><circle cx="11" cy="14" r="3"/><circle cx="11" cy="24" r="3"/><circle cx="11" cy="34" r="3"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
	        'list-bull-square': '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M8 11h6v6H8zM8 21h6v6H8zM8 31h6v6H8z"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
	        'list-num-default-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 17v-4.8l-1.6 1v-1.1l1.6-1h1.2V17zM33.3 17.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm1.7 5.7c0-1.2 1-2 2.2-2 1.3 0 2.1.8 2.1 1.8 0 .7-.3 1.2-1.3 2.2l-1.2 1v.2h2.6v1h-4.3v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H35zm-1.7 4.3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm3.2 7.3v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H35c0-1.1 1-1.8 2.2-1.8 1.2 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.7.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .6 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm-3.3 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z"/></g></svg>',
	        'list-num-default': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10 17v-4.8l-1.5 1v-1.1l1.6-1h1.2V17h-1.2zm3.6.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zm-5 5.7c0-1.2.8-2 2.1-2s2.1.8 2.1 1.8c0 .7-.3 1.2-1.4 2.2l-1.1 1v.2h2.6v1H8.6v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H8.5zm6.3 4.3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zM10 34.4v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H8.6c0-1.1 1-1.8 2.2-1.8 1.3 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.8.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .7 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm4.7 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z"/></g></svg>',
	        'list-num-lower-alpha-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M36.5 16c-.9 0-1.5-.5-1.5-1.3s.6-1.3 1.8-1.4h1v-.4c0-.4-.2-.6-.7-.6-.4 0-.7.1-.8.4h-1.1c0-.8.8-1.4 2-1.4S39 12 39 13V16h-1.2v-.6c-.3.4-.8.7-1.4.7zm.4-.8c.6 0 1-.4 1-.9V14h-1c-.5.1-.7.3-.7.6 0 .4.3.6.7.6zM33.1 16.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zM37.7 26c-.7 0-1.2-.2-1.5-.7v.7H35v-6.3h1.2v2.5c.3-.5.8-.9 1.5-.9 1.1 0 1.8 1 1.8 2.4 0 1.5-.7 2.4-1.8 2.4zm-.5-3.6c-.6 0-1 .5-1 1.3s.4 1.4 1 1.4c.7 0 1-.6 1-1.4 0-.8-.3-1.3-1-1.3zM33.2 26.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm6 7h-1c-.1-.5-.4-.8-1-.8s-1 .5-1 1.4c0 1 .4 1.4 1 1.4.5 0 .9-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm-6.1 3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
	        'list-num-lower-alpha': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.3 15.2c.5 0 1-.4 1-.9V14h-1c-.5.1-.8.3-.8.6 0 .4.3.6.8.6zm-.4.9c-1 0-1.5-.6-1.5-1.4 0-.8.6-1.3 1.7-1.4h1.1v-.4c0-.4-.2-.6-.7-.6-.5 0-.8.1-.9.4h-1c0-.8.8-1.4 2-1.4 1.1 0 1.8.6 1.8 1.6V16h-1.1v-.6h-.1c-.2.4-.7.7-1.3.7zm4.6 0c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm-3.2 10c-.6 0-1.2-.3-1.4-.8v.7H8.5v-6.3H10v2.5c.3-.5.8-.9 1.4-.9 1.2 0 1.9 1 1.9 2.4 0 1.5-.7 2.4-1.9 2.4zm-.4-3.7c-.7 0-1 .5-1 1.3s.3 1.4 1 1.4c.6 0 1-.6 1-1.4 0-.8-.4-1.3-1-1.3zm4 3.7c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm-2.2 7h-1.2c0-.5-.4-.8-.9-.8-.6 0-1 .5-1 1.4 0 1 .4 1.4 1 1.4.5 0 .8-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm1.8 3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
	        'list-num-lower-greek-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 16c-1.2 0-2-.8-2-2.3 0-1.5.8-2.4 2-2.4.6 0 1 .4 1.3 1v-.9H40v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1-.7h-.2c-.2.4-.7.8-1.3.8zm.3-1c.6 0 1-.5 1-1.3s-.4-1.3-1-1.3-1 .5-1 1.3.4 1.4 1 1.4zM33.3 16.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zM36 21.9c0-1.5.8-2.3 2.1-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.9 1.3.9.3 1.3.8 1.3 1.7 0 1.2-.7 1.9-1.8 1.9-.6 0-1.1-.3-1.4-.8v2.2H36V22zm1.8 1.2v-1h.3c.5 0 .9-.2.9-.7 0-.5-.3-.8-.9-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1 1.3s1-.4 1-1-.4-1-1.2-1h-.3zM33.3 26.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zM37.1 34.6L34.8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.2.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1zM33.3 36.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
	        'list-num-lower-greek': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.5 15c.7 0 1-.5 1-1.3s-.3-1.3-1-1.3c-.5 0-.9.5-.9 1.3s.4 1.4 1 1.4zm-.3 1c-1.1 0-1.8-.8-1.8-2.3 0-1.5.7-2.4 1.8-2.4.7 0 1.1.4 1.3 1h.1v-.9h1.2v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1.1-.7h-.1c-.2.4-.7.8-1.4.8zm5 .1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm-4.9 7v-1h.3c.6 0 1-.2 1-.7 0-.5-.4-.8-1-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1.1 1.3.6 0 1-.4 1-1s-.5-1-1.3-1h-.3zM8.6 22c0-1.5.7-2.3 2-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.8 1.3.8.3 1.3.8 1.3 1.7 0 1.2-.8 1.9-1.9 1.9-.6 0-1.1-.3-1.3-.8v2.2H8.5V22zm6.2 4.2c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zm-4.5 8.5L8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.1.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1zm4.5.5c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
	        'list-num-lower-roman-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M32.9 16v-1.2h-1.3V16H33zm0 10v-1.2h-1.3V26H33zm0 10v-1.2h-1.3V36H33z"/><path fill-rule="nonzero" d="M36 21h-1.5v5H36zM36 31h-1.5v5H36zM39 21h-1.5v5H39zM39 31h-1.5v5H39zM42 31h-1.5v5H42zM36 11h-1.5v5H36zM36 19h-1.5v1H36zM36 29h-1.5v1H36zM39 19h-1.5v1H39zM39 29h-1.5v1H39zM42 29h-1.5v1H42zM36 9h-1.5v1H36z"/></g></svg>',
	        'list-num-lower-roman': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 16v-1.2h1.3V16H15zm0 10v-1.2h1.3V26H15zm0 10v-1.2h1.3V36H15z"/><path fill-rule="nonzero" d="M12 21h1.5v5H12zM12 31h1.5v5H12zM9 21h1.5v5H9zM9 31h1.5v5H9zM6 31h1.5v5H6zM12 11h1.5v5H12zM12 19h1.5v1H12zM12 29h1.5v1H12zM9 19h1.5v1H9zM9 29h1.5v1H9zM6 29h1.5v1H6zM12 9h1.5v1H12z"/></g></svg>',
	        'list-num-upper-alpha-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M39.3 17l-.5-1.4h-2l-.5 1.4H35l2-6h1.6l2 6h-1.3zm-1.6-4.7l-.7 2.3h1.6l-.8-2.3zM33.4 17c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zm4.7 9.9h-2.7v-6H38c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7zm-1.4-5v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1zm0 4h1.1c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9h-1.1V26zM33 27.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm4.9 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2zm-4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
	        'list-num-upper-alpha': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M12.6 17l-.5-1.4h-2L9.5 17H8.3l2-6H12l2 6h-1.3zM11 12.3l-.7 2.3h1.6l-.8-2.3zm4.7 4.8c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7zM11.4 27H8.7v-6h2.6c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7zM10 22v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1zm0 4H11c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9H10V26zm5.4 1.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm-4.1 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2zm4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
	        'list-num-upper-roman-rtl': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M31.6 17v-1.2H33V17h-1.3zm0 10v-1.2H33V27h-1.3zm0 10v-1.2H33V37h-1.3z"/><path fill-rule="nonzero" d="M34.5 20H36v7h-1.5zM34.5 30H36v7h-1.5zM37.5 20H39v7h-1.5zM37.5 30H39v7h-1.5zM40.5 30H42v7h-1.5zM34.5 10H36v7h-1.5z"/></g></svg>',
	        'list-num-upper-roman': '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 17v-1.2h1.3V17H15zm0 10v-1.2h1.3V27H15zm0 10v-1.2h1.3V37H15z"/><path fill-rule="nonzero" d="M12 20h1.5v7H12zM12 30h1.5v7H12zM9 20h1.5v7H9zM9 30h1.5v7H9zM6 30h1.5v7H6zM12 10h1.5v7H12z"/></g></svg>',
	        'lock': '<svg width="24" height="24"><path d="M16.3 11c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H8V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h.3zM10 8v3h4V8a1 1 0 0 0-.3-.7A1 1 0 0 0 13 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7z" fill-rule="evenodd"/></svg>',
	        'ltr': '<svg width="24" height="24"><path d="M11 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 7.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L11 5zM4.4 16.2L6.2 15l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6z" fill-rule="evenodd"/></svg>',
	        'more-drawer': '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2z" fill-rule="nonzero"/></svg>',
	        'new-document': '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3zM17 19H7V5h6v4h4v10z" fill-rule="nonzero"/></svg>',
	        'new-tab': '<svg width="24" height="24"><path d="M15 13l2-2v8H5V7h8l-2 2H7v8h8v-4zm4-8v5.5l-2-2-5.6 5.5H10v-1.4L15.5 7l-2-2H19z" fill-rule="evenodd"/></svg>',
	        'non-breaking': '<svg width="24" height="24"><path d="M11 11H8a1 1 0 1 1 0-2h3V6c0-.6.4-1 1-1s1 .4 1 1v3h3c.6 0 1 .4 1 1s-.4 1-1 1h-3v3c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-3zm10 4v5H3v-5c0-.6.4-1 1-1s1 .4 1 1v3h14v-3c0-.6.4-1 1-1s1 .4 1 1z" fill-rule="evenodd"/></svg>',
	        'notice': '<svg width="24" height="24"><path d="M17.8 9.8L15.4 4 20 8.5v7L15.5 20h-7L4 15.5v-7L8.5 4h7l2.3 5.8zm0 0l2.2 5.7-2.3-5.8zM13 17v-2h-2v2h2zm0-4V7h-2v6h2z" fill-rule="evenodd"/></svg>',
	        'ordered-list-rtl': '<svg width="24" height="24"><path d="M6 17h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 1 1 0-2zm13-1v3.5a.5.5 0 1 1-1 0V5h-.5a.5.5 0 1 1 0-1H19zm-1 8.8l.2.2h1.3a.5.5 0 1 1 0 1h-1.6a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2h-1.3a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3zm2 4.2v2c0 .6-.4 1-1 1h-1.5a.5.5 0 0 1 0-1h1.2a.3.3 0 1 0 0-.6h-1.3a.4.4 0 1 1 0-.8h1.3a.3.3 0 0 0 0-.6h-1.2a.5.5 0 1 1 0-1H19c.6 0 1 .4 1 1z" fill-rule="evenodd"/></svg>',
	        'ordered-list': '<svg width="24" height="24"><path d="M10 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 1 1 0-2zM6 4v3.5c0 .3-.2.5-.5.5a.5.5 0 0 1-.5-.5V5h-.5a.5.5 0 0 1 0-1H6zm-1 8.8l.2.2h1.3c.3 0 .5.2.5.5s-.2.5-.5.5H4.9a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2H4.5a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3zM7 17v2c0 .6-.4 1-1 1H4.5a.5.5 0 0 1 0-1h1.2c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.4a.4.4 0 1 1 0-.8h1.3c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.5a.5.5 0 1 1 0-1H6c.6 0 1 .4 1 1z" fill-rule="evenodd"/></svg>',
	        'orientation': '<svg width="24" height="24"><path d="M7.3 6.4L1 13l6.4 6.5 6.5-6.5-6.5-6.5zM3.7 13l3.6-3.7L11 13l-3.7 3.7-3.6-3.7zM12 6l2.8 2.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0L9.2 5.7a.8.8 0 0 1 0-1.2L13.6.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L12 4h1a9 9 0 1 1-4.3 16.9l1.5-1.5A7 7 0 1 0 13 6h-1z" fill-rule="nonzero"/></svg>',
	        'outdent': '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2zm1.6-3.8a1 1 0 0 1-1.2 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 0 1 1.2 1.6L6.8 12l1.8 1.2z" fill-rule="evenodd"/></svg>',
	        'page-break': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M5 11c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1h-1a1 1 0 0 1 0-2zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2zM7 3v5h10V3c0-.6.4-1 1-1s1 .4 1 1v7H5V3c0-.6.4-1 1-1s1 .4 1 1zM6 22a1 1 0 0 1-1-1v-7h14v7c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5H7v5c0 .6-.4 1-1 1z"/></g></svg>',
	        'paragraph': '<svg width="24" height="24"><path fill-rule="evenodd" d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5z"/></svg>',
	        'paste-text': '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9zM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1zm1.5-9.5v9h9v-9h-9zM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1zm0 9h6v2h-.5l-.5-1h-1v4h.8v1h-3.6v-1h.8v-4h-1l-.5 1H12v-2z" fill-rule="nonzero"/></svg>',
	        'paste': '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9zM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1zm1.5-9.5v9h9v-9h-9zM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1z" fill-rule="nonzero"/></svg>',
	        'permanent-pen': '<svg width="24" height="24"><path d="M10.5 17.5L8 20H3v-3l3.5-3.5a2 2 0 0 1 0-3L14 3l1 1-7.3 7.3a1 1 0 0 0 0 1.4l3.6 3.6c.4.4 1 .4 1.4 0L20 9l1 1-7.6 7.6a2 2 0 0 1-2.8 0l-.1-.1z" fill-rule="nonzero"/></svg>',
	        'plus': '<svg width="24" height="24"><path d="M12 4c.5 0 1 .4 1 .9V11h6a1 1 0 0 1 .1 2H13v6a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H11V5c0-.6.4-1 1-1z"/></svg>',
	        'preferences': '<svg width="24" height="24"><path d="M20.1 13.5l-1.9.2a5.8 5.8 0 0 1-.6 1.5l1.2 1.5c.4.4.3 1 0 1.4l-.7.7a1 1 0 0 1-1.4 0l-1.5-1.2a6.2 6.2 0 0 1-1.5.6l-.2 1.9c0 .5-.5.9-1 .9h-1a1 1 0 0 1-1-.9l-.2-1.9a5.8 5.8 0 0 1-1.5-.6l-1.5 1.2a1 1 0 0 1-1.4 0l-.7-.7a1 1 0 0 1 0-1.4l1.2-1.5a6.2 6.2 0 0 1-.6-1.5l-1.9-.2a1 1 0 0 1-.9-1v-1c0-.5.4-1 .9-1l1.9-.2a5.8 5.8 0 0 1 .6-1.5L5.2 7.3a1 1 0 0 1 0-1.4l.7-.7a1 1 0 0 1 1.4 0l1.5 1.2a6.2 6.2 0 0 1 1.5-.6l.2-1.9c0-.5.5-.9 1-.9h1c.5 0 1 .4 1 .9l.2 1.9a5.8 5.8 0 0 1 1.5.6l1.5-1.2a1 1 0 0 1 1.4 0l.7.7c.3.4.4 1 0 1.4l-1.2 1.5a6.2 6.2 0 0 1 .6 1.5l1.9.2c.5 0 .9.5.9 1v1c0 .5-.4 1-.9 1zM12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6z" fill-rule="evenodd"/></svg>',
	        'preview': '<svg width="24" height="24"><path d="M3.5 12.5c.5.8 1.1 1.6 1.8 2.3 2 2 4.2 3.2 6.7 3.2s4.7-1.2 6.7-3.2a16.2 16.2 0 0 0 2.1-2.8 15.7 15.7 0 0 0-2.1-2.8c-2-2-4.2-3.2-6.7-3.2a9.3 9.3 0 0 0-6.7 3.2A16.2 16.2 0 0 0 3.2 12c0 .2.2.3.3.5zm-2.4-1l.7-1.2L4 7.8C6.2 5.4 8.9 4 12 4c3 0 5.8 1.4 8.1 3.8a18.2 18.2 0 0 1 2.8 3.7v1l-.7 1.2-2.1 2.5c-2.3 2.4-5 3.8-8.1 3.8-3 0-5.8-1.4-8.1-3.8a18.2 18.2 0 0 1-2.8-3.7 1 1 0 0 1 0-1zm12-3.3a2 2 0 1 0 2.7 2.6 4 4 0 1 1-2.6-2.6z" fill-rule="nonzero"/></svg>',
	        'print': '<svg width="24" height="24"><path d="M18 8H6a3 3 0 0 0-3 3v6h2v3h14v-3h2v-6a3 3 0 0 0-3-3zm-1 10H7v-4h10v4zm.5-5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5 1.5.7 1.5 1.5-.7 1.5-1.5 1.5zm.5-8H6v2h12V5z" fill-rule="nonzero"/></svg>',
	        'quote': '<svg width="24" height="24"><path d="M7.5 17h.9c.4 0 .7-.2.9-.6L11 13V8c0-.6-.4-1-1-1H6a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3zm8 0h.9c.4 0 .7-.2.9-.6L19 13V8c0-.6-.4-1-1-1h-4a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3z" fill-rule="nonzero"/></svg>',
	        'redo': '<svg width="24" height="24"><path d="M17.6 10H12c-2.8 0-4.4 1.4-4.9 3.5-.4 2 .3 4 1.4 4.6a1 1 0 1 1-1 1.8c-2-1.2-2.9-4.1-2.3-6.8.6-3 3-5.1 6.8-5.1h5.6l-3.3-3.3a1 1 0 1 1 1.4-1.4l5 5a1 1 0 0 1 0 1.4l-5 5a1 1 0 0 1-1.4-1.4l3.3-3.3z" fill-rule="nonzero"/></svg>',
	        'reload': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M5 22.1l-1.2-4.7v-.2a1 1 0 0 1 1-1l5 .4a1 1 0 1 1-.2 2l-2.2-.2a7.8 7.8 0 0 0 8.4.2 7.5 7.5 0 0 0 3.5-6.4 1 1 0 1 1 2 0 9.5 9.5 0 0 1-4.5 8 9.9 9.9 0 0 1-10.2 0l.4 1.4a1 1 0 1 1-2 .5zM13.6 7.4c0-.5.5-1 1-.9l2.8.2a8 8 0 0 0-9.5-1 7.5 7.5 0 0 0-3.6 7 1 1 0 0 1-2 0 9.5 9.5 0 0 1 4.5-8.6 10 10 0 0 1 10.9.3l-.3-1a1 1 0 0 1 2-.5l1.1 4.8a1 1 0 0 1-1 1.2l-5-.4a1 1 0 0 1-.9-1z"/></g></svg>',
	        'remove-formatting': '<svg width="24" height="24"><path d="M13.2 6a1 1 0 0 1 0 .2l-2.6 10a1 1 0 0 1-1 .8h-.2a.8.8 0 0 1-.8-1l2.6-10H8a1 1 0 1 1 0-2h9a1 1 0 0 1 0 2h-3.8zM5 18h7a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2zm13 1.5L16.5 18 15 19.5a.7.7 0 0 1-1-1l1.5-1.5-1.5-1.5a.7.7 0 0 1 1-1l1.5 1.5 1.5-1.5a.7.7 0 0 1 1 1L17.5 17l1.5 1.5a.7.7 0 0 1-1 1z" fill-rule="evenodd"/></svg>',
	        'remove': '<svg width="24" height="24"><path d="M16 7h3a1 1 0 0 1 0 2h-1v9a3 3 0 0 1-3 3H9a3 3 0 0 1-3-3V9H5a1 1 0 1 1 0-2h3V6a3 3 0 0 1 3-3h2a3 3 0 0 1 3 3v1zm-2 0V6c0-.6-.4-1-1-1h-2a1 1 0 0 0-1 1v1h4zm2 2H8v9c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V9zm-7 3a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4zm4 0a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4z" fill-rule="nonzero"/></svg>',
	        'resize-handle': '<svg width="10" height="10"><g fill-rule="nonzero"><path d="M8.1 1.1A.5.5 0 1 1 9 2l-7 7A.5.5 0 1 1 1 8l7-7zM8.1 5.1A.5.5 0 1 1 9 6l-3 3A.5.5 0 1 1 5 8l3-3z"/></g></svg>',
	        'resize': '<svg width="24" height="24"><path d="M4 5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h6c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H7.4L18 16.6V13c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v6c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-6a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3.6L6 7.4V11c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3A1 1 0 0 1 4 11V5z" fill-rule="evenodd"/></svg>',
	        'restore-draft': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M17 13c0 .6-.4 1-1 1h-4V8c0-.6.4-1 1-1s1 .4 1 1v4h2c.6 0 1 .4 1 1z"/><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10z" fill-rule="nonzero"/></g></svg>',
	        'rotate-left': '<svg width="24" height="24"><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10z" fill-rule="nonzero"/></svg>',
	        'rotate-right': '<svg width="24" height="24"><path d="M20 8V5a1 1 0 0 1 2 0v6c0 .6-.4 1-1 1h-6a1 1 0 0 1 0-2h4.3L16 7A7.2 7.2 0 0 0 7.7 6a7 7 0 0 0 3 13.1c1.9.1 3.7-.5 5-1.7a1 1 0 0 1 1.4 1.5A9.2 9.2 0 0 1 2.2 14c-.9-3.9 1-8 4.5-9.9 3.5-1.9 8-1.3 10.8 1.5L20 8z" fill-rule="nonzero"/></svg>',
	        'rtl': '<svg width="24" height="24"><path d="M8 5h8v2h-2v12h-2V7h-2v12H8v-7c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 4.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L8 5zm12 11.2a1 1 0 1 1-1 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 1 1 1 1.6L18.4 15l1.8 1.2z" fill-rule="evenodd"/></svg>',
	        'save': '<svg width="24" height="24"><path d="M5 16h14a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-2c0-1.1.9-2 2-2zm0 2v2h14v-2H5zm10 0h2v2h-2v-2zm-4-6.4L8.7 9.3a1 1 0 1 0-1.4 1.4l4 4c.4.4 1 .4 1.4 0l4-4a1 1 0 1 0-1.4-1.4L13 11.6V4a1 1 0 0 0-2 0v7.6z" fill-rule="nonzero"/></svg>',
	        'search': '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12z" fill-rule="nonzero"/></svg>',
	        'select-all': '<svg width="24" height="24"><path d="M3 5h2V3a2 2 0 0 0-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2a2 2 0 0 0-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8a2 2 0 0 0 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2zM7 17h10V7H7v10zm2-8h6v6H9V9z" fill-rule="nonzero"/></svg>',
	        'selected': '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2zm3.6 10.9L7 12.3a.7.7 0 0 0-1 1L9.6 17 18 8.6a.7.7 0 0 0 0-1 .7.7 0 0 0-1 0l-7.4 7.3z"/></svg>',
	        'settings': '<svg width="24" height="24"><path d="M11 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V8H5a1 1 0 1 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.5V6zM8 8h2V6H8v2zm9 2.8v.2h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v.3c0 .2 0 .3-.2.5l-.6.2h-2.4c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V13H5a1 1 0 0 1 0-2h8v-.3c0-.2 0-.3.2-.5l.6-.2h2.4c.3 0 .4 0 .6.2l.2.6zM14 13h2v-2h-2v2zm-3 2.8v.2h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V18H5a1 1 0 0 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.6zM8 18h2v-2H8v2z" fill-rule="evenodd"/></svg>',
	        'sharpen': '<svg width="24" height="24"><path d="M16 6l4 4-8 9-8-9 4-4h8zm-4 10.2l5.5-6.2-.1-.1H12v-.3h5.1l-.2-.2H12V9h4.6l-.2-.2H12v-.3h4.1l-.2-.2H12V8h3.6l-.2-.2H8.7L6.5 10l.1.1H12v.3H6.9l.2.2H12v.3H7.3l.2.2H12v.3H7.7l.3.2h4v.3H8.2l.2.2H12v.3H8.6l.3.2H12v.3H9l.3.2H12v.3H9.5l.2.2H12v.3h-2l.2.2H12v.3h-1.6l.2.2H12v.3h-1.1l.2.2h.9v.3h-.7l.2.2h.5v.3h-.3l.3.2z" fill-rule="evenodd"/></svg>',
	        'sort-asc': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M4 8h5a1 1 0 1 1 0 2H4a1 1 0 1 1 0-2zm0 8h8a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2zm0-4h7a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2z"/><path fill-rule="nonzero" d="M16 8.4l-2.3 2.3a1 1 0 0 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 1 1-1.4 1.4L18 8.4V18a1 1 0 0 1-2 0V8.4z"/></g></svg>',
	        'sort-dsc': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M4 16h5a1 1 0 0 0 0-2H4a1 1 0 0 0 0 2zm0-8h8a1 1 0 0 0 0-2H4a1 1 0 1 0 0 2zm0 4h7a1 1 0 0 0 0-2H4a1 1 0 0 0 0 2z"/><path fill-rule="nonzero" d="M16 15.6l-2.3-2.3a1 1 0 0 0-1.4 1.4l4 4c.4.4 1 .4 1.4 0l4-4a1 1 0 0 0-1.4-1.4L18 15.6V6a1 1 0 0 0-2 0v9.6z"/></g></svg>',
	        'sourcecode': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M9.8 15.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0l-4.4-4.1a.8.8 0 0 1 0-1.2l4.4-4.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L6 12l3.8 3.7zM14.2 15.7c-.3.3-.3.8 0 1 .4.4.9.4 1.2 0l4.4-4.1c.3-.3.3-.9 0-1.2l-4.4-4.2a.8.8 0 0 0-1.2 0c-.3.3-.3.8 0 1.1L18 12l-3.8 3.7z"/></g></svg>',
	        'spell-check': '<svg width="24" height="24"><path d="M6 8v3H5V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h2c.3 0 .5.1.7.3.2.2.3.4.3.7v6H8V8H6zm0-3v2h2V5H6zm13 0h-3v5h3v1h-3a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3v1zm-5 1.5l-.1.7c-.1.2-.3.3-.6.3.3 0 .5.1.6.3l.1.7V10c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-3V4h3c.3 0 .5.1.7.3.2.2.3.4.3.7v1.5zM13 10V8h-2v2h2zm0-3V5h-2v2h2zm3 5l1 1-6.5 7L7 15.5l1.3-1 2.2 2.2L16 12z" fill-rule="evenodd"/></svg>',
	        'strike-through': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M15.6 8.5c-.5-.7-1-1.1-1.3-1.3-.6-.4-1.3-.6-2-.6-2.7 0-2.8 1.7-2.8 2.1 0 1.6 1.8 2 3.2 2.3 4.4.9 4.6 2.8 4.6 3.9 0 1.4-.7 4.1-5 4.1A6.2 6.2 0 0 1 7 16.4l1.5-1.1c.4.6 1.6 2 3.7 2 1.6 0 2.5-.4 3-1.2.4-.8.3-2-.8-2.6-.7-.4-1.6-.7-2.9-1-1-.2-3.9-.8-3.9-3.6C7.6 6 10.3 5 12.4 5c2.9 0 4.2 1.6 4.7 2.4l-1.5 1.1z"/><path d="M5 11h14a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2z" fill-rule="nonzero"/></g></svg>',
	        'subscript': '<svg width="24" height="24"><path d="M10.4 10l4.6 4.6-1.4 1.4L9 11.4 4.4 16 3 14.6 7.6 10 3 5.4 4.4 4 9 8.6 13.6 4 15 5.4 10.4 10zM21 19h-5v-1l1-.8 1.7-1.6c.3-.4.5-.8.5-1.2 0-.3 0-.6-.2-.7-.2-.2-.5-.3-.9-.3a2 2 0 0 0-.8.2l-.7.3-.4-1.1 1-.6 1.2-.2c.8 0 1.4.3 1.8.7.4.4.6.9.6 1.5s-.2 1.1-.5 1.6a8 8 0 0 1-1.3 1.3l-.6.6h2.6V19z" fill-rule="nonzero"/></svg>',
	        'superscript': '<svg width="24" height="24"><path d="M15 9.4L10.4 14l4.6 4.6-1.4 1.4L9 15.4 4.4 20 3 18.6 7.6 14 3 9.4 4.4 8 9 12.6 13.6 8 15 9.4zm5.9 1.6h-5v-1l1-.8 1.7-1.6c.3-.5.5-.9.5-1.3 0-.3 0-.5-.2-.7-.2-.2-.5-.3-.9-.3l-.8.2-.7.4-.4-1.2c.2-.2.5-.4 1-.5.3-.2.8-.2 1.2-.2.8 0 1.4.2 1.8.6.4.4.6 1 .6 1.6 0 .5-.2 1-.5 1.5l-1.3 1.4-.6.5h2.6V11z" fill-rule="nonzero"/></svg>',
	        'table-cell-properties': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zm-8 9H5v5h6v-5zm8 0h-6v5h6v-5zm-8-7H5v5h6V6z"/></svg>',
	        'table-cell-select-all': '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zm0 2H5v12h14V6z"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2z" opacity=".2"/></g></svg>',
	        'table-cell-select-inner': '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zm0 2H5v12h14V6z" opacity=".2"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2z"/></g></svg>',
	        'table-delete-column': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zm-4 4h-2V6h-2v2H9V6H5v12h4v-2h2v2h2v-2h2v2h4V6h-4v2zm.3.5l1 1.2-3 2.3 3 2.3-1 1.2L12 13l-3.3 2.6-1-1.2 3-2.3-3-2.3 1-1.2L12 11l3.3-2.5z"/></svg>',
	        'table-delete-row': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zm0 2H5v3h2.5v2H5v2h2.5v2H5v3h14v-3h-2.5v-2H19v-2h-2.5V9H19V6zm-4.7 1.8l1.2 1L13 12l2.6 3.3-1.2 1-2.3-3-2.3 3-1.2-1L11 12 8.5 8.7l1.2-1 2.3 3 2.3-3z"/></svg>',
	        'table-delete-table': '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zM5 6v12h14V6H5z"/><path d="M14.4 8.6l1 1-2.3 2.4 2.3 2.4-1 1-2.4-2.3-2.4 2.3-1-1 2.3-2.4-2.3-2.4 1-1 2.4 2.3z"/></g></svg>',
	        'table-insert-column-after': '<svg width="24" height="24"><path fill-rule="nonzero" d="M20 4c.6 0 1 .4 1 1v2a1 1 0 0 1-2 0V6h-8v12h8v-1a1 1 0 0 1 2 0v2c0 .5-.4 1-.9 1H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h15zM9 13H5v5h4v-5zm7-5c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H17v2a1 1 0 0 1-2 .1V13h-2a1 1 0 0 1-.1-2H15V9c0-.6.4-1 1-1zM9 6H5v5h4V6z"/></svg>',
	        'table-insert-column-before': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a1 1 0 0 1-1-1v-2a1 1 0 0 1 2 0v1h8V6H5v1a1 1 0 1 1-2 0V5c0-.6.4-1 1-1h15zm0 9h-4v5h4v-5zM8 8c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H9v2a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H7V9c0-.6.4-1 1-1zm11-2h-4v5h4V6z"/></svg>',
	        'table-insert-row-above': '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4a1 1 0 1 1 0 2H5v6h14V6h-1a1 1 0 0 1 0-2h2c.6 0 1 .4 1 1v13a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5c0-.6.4-1 1-1h2zm5 10H5v4h6v-4zm8 0h-6v4h6v-4zM12 3c.5 0 1 .4 1 .9V6h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 .1V8H9a1 1 0 0 1 0-2h2V4c0-.6.4-1 1-1z"/></svg>',
	        'table-insert-row-after': '<svg width="24" height="24"><path fill-rule="nonzero" d="M12 13c.5 0 1 .4 1 .9V16h2a1 1 0 0 1 .1 2H13v2a1 1 0 0 1-2 .1V18H9a1 1 0 0 1-.1-2H11v-2c0-.6.4-1 1-1zm6 7a1 1 0 0 1 0-2h1v-6H5v6h1a1 1 0 0 1 0 2H4a1 1 0 0 1-1-1V6c0-1.1.9-2 2-2h14a2 2 0 0 1 2 2v13c0 .5-.4 1-.9 1H18zM11 6H5v4h6V6zm8 0h-6v4h6V6z"/></svg>',
	        'table-left-header': '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zm0 9h-4v5h4v-5zm-6 0H9v5h4v-5zm0-7H9v5h4V6zm6 0h-4v5h4V6z"/></svg>',
	        'table-merge-cells': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zM5 15.5V18h3v-2.5H5zm14-5h-9V18h9v-7.5zM19 6h-4v2.5h4V6zM8 6H5v2.5h3V6zm5 0h-3v2.5h3V6zm-8 7.5h3v-3H5v3z"/></svg>',
	        'table-row-properties': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zM5 15v3h6v-3H5zm14 0h-6v3h6v-3zm0-9h-6v3h6V6zM5 9h6V6H5v3z"/></svg>',
	        'table-split-cells': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zM8 15.5H5V18h3v-2.5zm11-5h-9V18h9v-7.5zm-2.5 1l1 1-2 2 2 2-1 1-2-2-2 2-1-1 2-2-2-2 1-1 2 2 2-2zm-8.5-1H5v3h3v-3zM19 6h-4v2.5h4V6zM8 6H5v2.5h3V6zm5 0h-3v2.5h3V6z"/></svg>',
	        'table-top-header': '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zm-8 11H5v3h6v-3zm8 0h-6v3h6v-3zm0-5h-6v3h6v-3zM5 13h6v-3H5v3z"/></svg>',
	        'table': '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14zM5 14v4h6v-4H5zm14 0h-6v4h6v-4zm0-6h-6v4h6V8zM5 12h6V8H5v4z"/></svg>',
	        'template': '<svg width="24" height="24"><path d="M19 19v-1H5v1h14zM9 16v-4a5 5 0 1 1 6 0v4h4a2 2 0 0 1 2 2v3H3v-3c0-1.1.9-2 2-2h4zm4 0v-5l.8-.6a3 3 0 1 0-3.6 0l.8.6v5h2z" fill-rule="nonzero"/></svg>',
	        'temporary-placeholder': '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M9 7.6V6h2.5V4.5a.5.5 0 1 1 1 0V6H15v1.6a8 8 0 1 1-6 0zm-2.6 5.3a.5.5 0 0 0 .3.6c.3 0 .6 0 .6-.3l.1-.2a5 5 0 0 1 3.3-2.8c.3-.1.4-.4.4-.6-.1-.3-.4-.5-.6-.4a6 6 0 0 0-4.1 3.7z"/><circle cx="14" cy="4" r="1"/><circle cx="12" cy="2" r="1"/><circle cx="10" cy="4" r="1"/></g></svg>',
	        'text-color': '<svg width="24" height="24"><g fill-rule="evenodd"><path id="tox-icon-text-color__color" d="M3 18h18v3H3z"/><path d="M8.7 16h-.8a.5.5 0 0 1-.5-.6l2.7-9c.1-.3.3-.4.5-.4h2.8c.2 0 .4.1.5.4l2.7 9a.5.5 0 0 1-.5.6h-.8a.5.5 0 0 1-.4-.4l-.7-2.2c0-.3-.3-.4-.5-.4h-3.4c-.2 0-.4.1-.5.4l-.7 2.2c0 .3-.2.4-.4.4zm2.6-7.6l-.6 2a.5.5 0 0 0 .5.6h1.6a.5.5 0 0 0 .5-.6l-.6-2c0-.3-.3-.4-.5-.4h-.4c-.2 0-.4.1-.5.4z"/></g></svg>',
	        'toc': '<svg width="24" height="24"><path d="M5 5c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2zm0-4c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2z" fill-rule="evenodd"/></svg>',
	        'translate': '<svg width="24" height="24"><path d="M12.7 14.3l-.3.7-.4.7-2.2-2.2-3.1 3c-.3.4-.8.4-1 0a.7.7 0 0 1 0-1l3.1-3A12.4 12.4 0 0 1 6.7 9H8a10.1 10.1 0 0 0 1.7 2.4c.5-.5 1-1.1 1.4-1.8l.9-2H4.7a.7.7 0 1 1 0-1.5h4.4v-.7c0-.4.3-.8.7-.8.4 0 .7.4.7.8v.7H15c.4 0 .8.3.8.7 0 .4-.4.8-.8.8h-1.4a12.3 12.3 0 0 1-1 2.4 13.5 13.5 0 0 1-1.7 2.3l1.9 1.8zm4.3-3l2.7 7.3a.5.5 0 0 1-.4.7 1 1 0 0 1-1-.7l-.6-1.5h-3.4l-.6 1.5a1 1 0 0 1-1 .7.5.5 0 0 1-.4-.7l2.7-7.4a1 1 0 1 1 2 0zm-2.2 4.4h2.4L16 12.5l-1.2 3.2z" fill-rule="evenodd"/></svg>',
	        'underline': '<svg width="24" height="24"><path d="M16 5c.6 0 1 .4 1 1v5.5a4 4 0 0 1-.4 1.8l-1 1.4a5.3 5.3 0 0 1-5.5 1 5 5 0 0 1-1.6-1c-.5-.4-.8-.9-1.1-1.4a4 4 0 0 1-.4-1.8V6c0-.6.4-1 1-1s1 .4 1 1v5.5c0 .3 0 .6.2 1l.6.7a3.3 3.3 0 0 0 2.2.8 3.4 3.4 0 0 0 2.2-.8c.3-.2.4-.5.6-.8l.2-.9V6c0-.6.4-1 1-1zM8 17h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2z" fill-rule="evenodd"/></svg>',
	        'undo': '<svg width="24" height="24"><path d="M6.4 8H12c3.7 0 6.2 2 6.8 5.1.6 2.7-.4 5.6-2.3 6.8a1 1 0 0 1-1-1.8c1.1-.6 1.8-2.7 1.4-4.6-.5-2.1-2.1-3.5-4.9-3.5H6.4l3.3 3.3a1 1 0 1 1-1.4 1.4l-5-5a1 1 0 0 1 0-1.4l5-5a1 1 0 0 1 1.4 1.4L6.4 8z" fill-rule="nonzero"/></svg>',
	        'unlink': '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2zm11.6-.6a1 1 0 0 1-1.4-1.4l2.1-2a2 2 0 1 0-2.7-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2zM7.6 6.3a.8.8 0 0 1-1 1.1L3.3 4.2a.7.7 0 1 1 1-1l3.2 3.1zM5.1 8.6a.8.8 0 0 1 0 1.5H3a.8.8 0 0 1 0-1.5H5zm5-3.5a.8.8 0 0 1-1.5 0V3a.8.8 0 0 1 1.5 0V5zm6 11.8a.8.8 0 0 1 1-1l3.2 3.2a.8.8 0 0 1-1 1L16 17zm-2.2 2a.8.8 0 0 1 1.5 0V21a.8.8 0 0 1-1.5 0V19zm5-3.5a.7.7 0 1 1 0-1.5H21a.8.8 0 0 1 0 1.5H19z" fill-rule="nonzero"/></svg>',
	        'unlock': '<svg width="24" height="24"><path d="M16 5c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h-2V8a1 1 0 0 0-.3-.7A1 1 0 0 0 16 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7v3h.3c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H4.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H11V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2z" fill-rule="evenodd"/></svg>',
	        'unordered-list': '<svg width="24" height="24"><path d="M11 5h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2zM4.5 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1z" fill-rule="evenodd"/></svg>',
	        'unselected': '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2zm0 1a1 1 0 0 0-1 1v12c0 .6.4 1 1 1h12c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H6z"/></svg>',
	        'upload': '<svg width="24" height="24"><path d="M18 19v-2a1 1 0 0 1 2 0v3c0 .6-.4 1-1 1H5a1 1 0 0 1-1-1v-3a1 1 0 0 1 2 0v2h12zM11 6.4L8.7 8.7a1 1 0 0 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 1 1-1.4 1.4L13 6.4V16a1 1 0 0 1-2 0V6.4z" fill-rule="nonzero"/></svg>',
	        'user': '<svg width="24" height="24"><path d="M12 24a12 12 0 1 1 0-24 12 12 0 0 1 0 24zm-8.7-5.3a11 11 0 0 0 17.4 0C19.4 16.3 14.6 15 12 15c-2.6 0-7.4 1.3-8.7 3.7zM12 13c2.2 0 4-2 4-4.5S14.2 4 12 4 8 6 8 8.5 9.8 13 12 13z" fill-rule="nonzero"/></svg>',
	        'visualblocks': '<svg width="24" height="24"><path d="M9 19v2H7v-2h2zm-4 0v2a2 2 0 0 1-2-2h2zm8 0v2h-2v-2h2zm8 0a2 2 0 0 1-2 2v-2h2zm-4 0v2h-2v-2h2zM15 7a1 1 0 0 1 0 2v7a1 1 0 0 1-2 0V9h-1v7a1 1 0 0 1-2 0v-4a2.5 2.5 0 0 1-.2-5H15zM5 15v2H3v-2h2zm16 0v2h-2v-2h2zM5 11v2H3v-2h2zm16 0v2h-2v-2h2zM5 7v2H3V7h2zm16 0v2h-2V7h2zM5 3v2H3c0-1.1.9-2 2-2zm8 0v2h-2V3h2zm6 0a2 2 0 0 1 2 2h-2V3zM9 3v2H7V3h2zm8 0v2h-2V3h2z" fill-rule="evenodd"/></svg>',
	        'visualchars': '<svg width="24" height="24"><path d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5z" fill-rule="evenodd"/></svg>',
	        'warning': '<svg width="24" height="24"><path d="M19.8 18.3c.2.5.3.9 0 1.2-.1.3-.5.5-1 .5H5.2c-.5 0-.9-.2-1-.5-.3-.3-.2-.7 0-1.2L11 4.7l.5-.5.5-.2c.2 0 .3 0 .5.2.2 0 .3.3.5.5l6.8 13.6zM12 18c.3 0 .5-.1.7-.3.2-.2.3-.4.3-.7a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3zm.7-3l.3-4a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7l.3 4h1.4z" fill-rule="evenodd"/></svg>',
	        'zoom-in': '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12zm-1-9a1 1 0 0 1 2 0v6a1 1 0 0 1-2 0V8zm-2 4a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8z" fill-rule="nonzero"/></svg>',
	        'zoom-out': '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12zm-3-5a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8z" fill-rule="nonzero"/></svg>'
	      };
	    };
	
	    var isContentCssSkinName = function (url) {
	      return /^[a-z0-9\-]+$/i.test(url);
	    };
	    var getContentCssUrls = function (editor) {
	      var contentCss = Settings.getContentCss(editor);
	      var skinUrl = editor.editorManager.baseURL + '/skins/content';
	      var suffix = editor.editorManager.suffix;
	      var contentCssFile = 'content' + suffix + '.css';
	      var inline = editor.inline === true;
	      return map(contentCss, function (url) {
	        if (isContentCssSkinName(url) && !inline) {
	          return skinUrl + '/' + url + '/' + contentCssFile;
	        } else {
	          return editor.documentBaseURI.toAbsolute(url);
	        }
	      });
	    };
	    var appendContentCssFromSettings = function (editor) {
	      editor.contentCSS = editor.contentCSS.concat(getContentCssUrls(editor));
	    };
	
	    function BookmarkManager(selection) {
	      return {
	        getBookmark: curry(Bookmarks.getBookmark, selection),
	        moveToBookmark: curry(Bookmarks.moveToBookmark, selection)
	      };
	    }
	    (function (BookmarkManager) {
	      BookmarkManager.isBookmarkNode = Bookmarks.isBookmarkNode;
	    }(BookmarkManager || (BookmarkManager = {})));
	    var BookmarkManager$1 = BookmarkManager;
	
	    var isXYWithinRange = function (clientX, clientY, range) {
	      if (range.collapsed) {
	        return false;
	      }
	      if (Env.browser.isIE() && range.startOffset === range.endOffset - 1 && range.startContainer === range.endContainer) {
	        var elm = range.startContainer.childNodes[range.startOffset];
	        if (NodeType.isElement(elm)) {
	          return exists(elm.getClientRects(), function (rect) {
	            return containsXY(rect, clientX, clientY);
	          });
	        }
	      }
	      return exists(range.getClientRects(), function (rect) {
	        return containsXY(rect, clientX, clientY);
	      });
	    };
	    var RangePoint = { isXYWithinRange: isXYWithinRange };
	
	    var VK = {
	      BACKSPACE: 8,
	      DELETE: 46,
	      DOWN: 40,
	      ENTER: 13,
	      LEFT: 37,
	      RIGHT: 39,
	      SPACEBAR: 32,
	      TAB: 9,
	      UP: 38,
	      END: 35,
	      HOME: 36,
	      modifierPressed: function (e) {
	        return e.shiftKey || e.ctrlKey || e.altKey || this.metaKeyPressed(e);
	      },
	      metaKeyPressed: function (e) {
	        return Env.mac ? e.metaKey : e.ctrlKey && !e.altKey;
	      }
	    };
	
	    var isContentEditableFalse$6 = NodeType.isContentEditableFalse;
	    var isContentEditableTrue$2 = NodeType.isContentEditableTrue;
	    var getContentEditableRoot = function (root, node) {
	      while (node && node !== root) {
	        if (isContentEditableTrue$2(node) || isContentEditableFalse$6(node)) {
	          return node;
	        }
	        node = node.parentNode;
	      }
	      return null;
	    };
	    var ControlSelection = function (selection, editor) {
	      var dom = editor.dom, each = Tools.each;
	      var selectedElm, selectedElmGhost, resizeHelper, resizeHandles, selectedHandle;
	      var startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;
	      var width, height;
	      var editableDoc = editor.getDoc(), rootDocument = domGlobals.document;
	      var abs = Math.abs, round = Math.round, rootElement = editor.getBody();
	      var startScrollWidth, startScrollHeight;
	      resizeHandles = {
	        nw: [
	          0,
	          0,
	          -1,
	          -1
	        ],
	        ne: [
	          1,
	          0,
	          1,
	          -1
	        ],
	        se: [
	          1,
	          1,
	          1,
	          1
	        ],
	        sw: [
	          0,
	          1,
	          -1,
	          1
	        ]
	      };
	      var isImage = function (elm) {
	        return elm && (elm.nodeName === 'IMG' || editor.dom.is(elm, 'figure.image'));
	      };
	      var isEventOnImageOutsideRange = function (evt, range) {
	        if (evt.type === 'longpress' || evt.type.indexOf('touch') === 0) {
	          var touch = evt.touches[0];
	          return isImage(evt.target) && !RangePoint.isXYWithinRange(touch.clientX, touch.clientY, range);
	        } else {
	          return isImage(evt.target) && !RangePoint.isXYWithinRange(evt.clientX, evt.clientY, range);
	        }
	      };
	      var contextMenuSelectImage = function (evt) {
	        var target = evt.target;
	        if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) {
	          editor.selection.select(target);
	        }
	      };
	      var getResizeTarget = function (elm) {
	        return editor.dom.is(elm, 'figure.image') ? elm.querySelector('img') : elm;
	      };
	      var isResizable = function (elm) {
	        var selector = Settings.getObjectResizing(editor);
	        if (selector === false || Env.iOS) {
	          return false;
	        }
	        if (typeof selector !== 'string') {
	          selector = 'table,img,figure.image,div';
	        }
	        if (elm.getAttribute('data-mce-resize') === 'false') {
	          return false;
	        }
	        if (elm === editor.getBody()) {
	          return false;
	        }
	        return is(Element.fromDom(elm), selector);
	      };
	      var resizeGhostElement = function (e) {
	        var deltaX, deltaY, proportional;
	        var resizeHelperX, resizeHelperY;
	        deltaX = e.screenX - startX;
	        deltaY = e.screenY - startY;
	        width = deltaX * selectedHandle[2] + startW;
	        height = deltaY * selectedHandle[3] + startH;
	        width = width < 5 ? 5 : width;
	        height = height < 5 ? 5 : height;
	        if (isImage(selectedElm) && Settings.getResizeImgProportional(editor) !== false) {
	          proportional = !VK.modifierPressed(e);
	        } else {
	          proportional = VK.modifierPressed(e);
	        }
	        if (proportional) {
	          if (abs(deltaX) > abs(deltaY)) {
	            height = round(width * ratio);
	            width = round(height / ratio);
	          } else {
	            width = round(height / ratio);
	            height = round(width * ratio);
	          }
	        }
	        dom.setStyles(getResizeTarget(selectedElmGhost), {
	          width: width,
	          height: height
	        });
	        resizeHelperX = selectedHandle.startPos.x + deltaX;
	        resizeHelperY = selectedHandle.startPos.y + deltaY;
	        resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;
	        resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;
	        dom.setStyles(resizeHelper, {
	          left: resizeHelperX,
	          top: resizeHelperY,
	          display: 'block'
	        });
	        resizeHelper.innerHTML = width + ' &times; ' + height;
	        if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {
	          dom.setStyle(selectedElmGhost, 'left', selectedElmX + (startW - width));
	        }
	        if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {
	          dom.setStyle(selectedElmGhost, 'top', selectedElmY + (startH - height));
	        }
	        deltaX = rootElement.scrollWidth - startScrollWidth;
	        deltaY = rootElement.scrollHeight - startScrollHeight;
	        if (deltaX + deltaY !== 0) {
	          dom.setStyles(resizeHelper, {
	            left: resizeHelperX - deltaX,
	            top: resizeHelperY - deltaY
	          });
	        }
	        if (!resizeStarted) {
	          fireObjectResizeStart(editor, selectedElm, startW, startH);
	          resizeStarted = true;
	        }
	      };
	      var endGhostResize = function () {
	        resizeStarted = false;
	        var setSizeProp = function (name, value) {
	          if (value) {
	            if (selectedElm.style[name] || !editor.schema.isValid(selectedElm.nodeName.toLowerCase(), name)) {
	              dom.setStyle(getResizeTarget(selectedElm), name, value);
	            } else {
	              dom.setAttrib(getResizeTarget(selectedElm), name, value);
	            }
	          }
	        };
	        setSizeProp('width', width);
	        setSizeProp('height', height);
	        dom.unbind(editableDoc, 'mousemove', resizeGhostElement);
	        dom.unbind(editableDoc, 'mouseup', endGhostResize);
	        if (rootDocument !== editableDoc) {
	          dom.unbind(rootDocument, 'mousemove', resizeGhostElement);
	          dom.unbind(rootDocument, 'mouseup', endGhostResize);
	        }
	        dom.remove(selectedElmGhost);
	        dom.remove(resizeHelper);
	        showResizeRect(selectedElm);
	        fireObjectResized(editor, selectedElm, width, height);
	        dom.setAttrib(selectedElm, 'style', dom.getAttrib(selectedElm, 'style'));
	        editor.nodeChanged();
	      };
	      var showResizeRect = function (targetElm) {
	        var position, targetWidth, targetHeight, e, rect;
	        hideResizeRect();
	        unbindResizeHandleEvents();
	        position = dom.getPos(targetElm, rootElement);
	        selectedElmX = position.x;
	        selectedElmY = position.y;
	        rect = targetElm.getBoundingClientRect();
	        targetWidth = rect.width || rect.right - rect.left;
	        targetHeight = rect.height || rect.bottom - rect.top;
	        if (selectedElm !== targetElm) {
	          selectedElm = targetElm;
	          width = height = 0;
	        }
	        e = editor.fire('ObjectSelected', { target: targetElm });
	        if (isResizable(targetElm) && !e.isDefaultPrevented()) {
	          each(resizeHandles, function (handle, name) {
	            var handleElm;
	            var startDrag = function (e) {
	              startX = e.screenX;
	              startY = e.screenY;
	              startW = getResizeTarget(selectedElm).clientWidth;
	              startH = getResizeTarget(selectedElm).clientHeight;
	              ratio = startH / startW;
	              selectedHandle = handle;
	              handle.startPos = {
	                x: targetWidth * handle[0] + selectedElmX,
	                y: targetHeight * handle[1] + selectedElmY
	              };
	              startScrollWidth = rootElement.scrollWidth;
	              startScrollHeight = rootElement.scrollHeight;
	              selectedElmGhost = selectedElm.cloneNode(true);
	              dom.addClass(selectedElmGhost, 'mce-clonedresizable');
	              dom.setAttrib(selectedElmGhost, 'data-mce-bogus', 'all');
	              selectedElmGhost.contentEditable = false;
	              selectedElmGhost.unSelectabe = true;
	              dom.setStyles(selectedElmGhost, {
	                left: selectedElmX,
	                top: selectedElmY,
	                margin: 0
	              });
	              selectedElmGhost.removeAttribute('data-mce-selected');
	              rootElement.appendChild(selectedElmGhost);
	              dom.bind(editableDoc, 'mousemove', resizeGhostElement);
	              dom.bind(editableDoc, 'mouseup', endGhostResize);
	              if (rootDocument !== editableDoc) {
	                dom.bind(rootDocument, 'mousemove', resizeGhostElement);
	                dom.bind(rootDocument, 'mouseup', endGhostResize);
	              }
	              resizeHelper = dom.add(rootElement, 'div', {
	                'class': 'mce-resize-helper',
	                'data-mce-bogus': 'all'
	              }, startW + ' &times; ' + startH);
	            };
	            handleElm = dom.get('mceResizeHandle' + name);
	            if (handleElm) {
	              dom.remove(handleElm);
	            }
	            handleElm = dom.add(rootElement, 'div', {
	              'id': 'mceResizeHandle' + name,
	              'data-mce-bogus': 'all',
	              'class': 'mce-resizehandle',
	              'unselectable': true,
	              'style': 'cursor:' + name + '-resize; margin:0; padding:0'
	            });
	            if (Env.ie === 11) {
	              handleElm.contentEditable = false;
	            }
	            dom.bind(handleElm, 'mousedown', function (e) {
	              e.stopImmediatePropagation();
	              e.preventDefault();
	              startDrag(e);
	            });
	            handle.elm = handleElm;
	            dom.setStyles(handleElm, {
	              left: targetWidth * handle[0] + selectedElmX - handleElm.offsetWidth / 2,
	              top: targetHeight * handle[1] + selectedElmY - handleElm.offsetHeight / 2
	            });
	          });
	        } else {
	          hideResizeRect();
	        }
	        selectedElm.setAttribute('data-mce-selected', '1');
	      };
	      var hideResizeRect = function () {
	        var name, handleElm;
	        unbindResizeHandleEvents();
	        if (selectedElm) {
	          selectedElm.removeAttribute('data-mce-selected');
	        }
	        for (name in resizeHandles) {
	          handleElm = dom.get('mceResizeHandle' + name);
	          if (handleElm) {
	            dom.unbind(handleElm);
	            dom.remove(handleElm);
	          }
	        }
	      };
	      var updateResizeRect = function (e) {
	        var startElm, controlElm;
	        var isChildOrEqual = function (node, parent) {
	          if (node) {
	            do {
	              if (node === parent) {
	                return true;
	              }
	            } while (node = node.parentNode);
	          }
	        };
	        if (resizeStarted || editor.removed) {
	          return;
	        }
	        each(dom.select('img[data-mce-selected],hr[data-mce-selected]'), function (img) {
	          img.removeAttribute('data-mce-selected');
	        });
	        controlElm = e.type === 'mousedown' ? e.target : selection.getNode();
	        controlElm = dom.$(controlElm).closest('table,img,figure.image,hr')[0];
	        if (isChildOrEqual(controlElm, rootElement)) {
	          disableGeckoResize();
	          startElm = selection.getStart(true);
	          if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {
	            showResizeRect(controlElm);
	            return;
	          }
	        }
	        hideResizeRect();
	      };
	      var isWithinContentEditableFalse = function (elm) {
	        return isContentEditableFalse$6(getContentEditableRoot(editor.getBody(), elm));
	      };
	      var unbindResizeHandleEvents = function () {
	        for (var name_1 in resizeHandles) {
	          var handle = resizeHandles[name_1];
	          if (handle.elm) {
	            dom.unbind(handle.elm);
	            delete handle.elm;
	          }
	        }
	      };
	      var disableGeckoResize = function () {
	        try {
	          editor.getDoc().execCommand('enableObjectResizing', false, false);
	        } catch (ex) {
	        }
	      };
	      editor.on('init', function () {
	        disableGeckoResize();
	        if (Env.browser.isIE() || Env.browser.isEdge()) {
	          editor.on('mousedown click', function (e) {
	            var target = e.target, nodeName = target.nodeName;
	            if (!resizeStarted && /^(TABLE|IMG|HR)$/.test(nodeName) && !isWithinContentEditableFalse(target)) {
	              if (e.button !== 2) {
	                editor.selection.select(target, nodeName === 'TABLE');
	              }
	              if (e.type === 'mousedown') {
	                editor.nodeChanged();
	              }
	            }
	          });
	          var handleMSControlSelect_1 = function (e) {
	            var delayedSelect = function (node) {
	              Delay.setEditorTimeout(editor, function () {
	                return editor.selection.select(node);
	              });
	            };
	            if (isWithinContentEditableFalse(e.target)) {
	              e.preventDefault();
	              delayedSelect(e.target);
	              return;
	            }
	            if (/^(TABLE|IMG|HR)$/.test(e.target.nodeName)) {
	              e.preventDefault();
	              if (e.target.tagName === 'IMG') {
	                delayedSelect(e.target);
	              }
	            }
	          };
	          dom.bind(rootElement, 'mscontrolselect', handleMSControlSelect_1);
	          editor.on('remove', function () {
	            return dom.unbind(rootElement, 'mscontrolselect', handleMSControlSelect_1);
	          });
	        }
	        var throttledUpdateResizeRect = Delay.throttle(function (e) {
	          if (!editor.composing) {
	            updateResizeRect(e);
	          }
	        });
	        editor.on('nodechange ResizeEditor ResizeWindow drop FullscreenStateChanged', throttledUpdateResizeRect);
	        editor.on('keyup compositionend', function (e) {
	          if (selectedElm && selectedElm.nodeName === 'TABLE') {
	            throttledUpdateResizeRect(e);
	          }
	        });
	        editor.on('hide blur', hideResizeRect);
	        editor.on('contextmenu longpress', contextMenuSelectImage, true);
	      });
	      editor.on('remove', unbindResizeHandleEvents);
	      var destroy = function () {
	        selectedElm = selectedElmGhost = null;
	      };
	      return {
	        isResizable: isResizable,
	        showResizeRect: showResizeRect,
	        hideResizeRect: hideResizeRect,
	        updateResizeRect: updateResizeRect,
	        destroy: destroy
	      };
	    };
	
	    function Dimension (name, getOffset) {
	      var set = function (element, h) {
	        if (!isNumber(h) && !h.match(/^[0-9]+$/)) {
	          throw new Error(name + '.set accepts only positive integer values. Value was ' + h);
	        }
	        var dom = element.dom();
	        if (isSupported(dom)) {
	          dom.style[name] = h + 'px';
	        }
	      };
	      var get = function (element) {
	        var r = getOffset(element);
	        if (r <= 0 || r === null) {
	          var css = get$4(element, name);
	          return parseFloat(css) || 0;
	        }
	        return r;
	      };
	      var getOuter = get;
	      var aggregate = function (element, properties) {
	        return foldl(properties, function (acc, property) {
	          var val = get$4(element, property);
	          var value = val === undefined ? 0 : parseInt(val, 10);
	          return isNaN(value) ? acc : acc + value;
	        }, 0);
	      };
	      var max = function (element, value, properties) {
	        var cumulativeInclusions = aggregate(element, properties);
	        var absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;
	        return absoluteMax;
	      };
	      return {
	        set: set,
	        get: get,
	        getOuter: getOuter,
	        aggregate: aggregate,
	        max: max
	      };
	    }
	
	    var api$1 = Dimension('height', function (element) {
	      var dom = element.dom();
	      return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;
	    });
	    var get$8 = function (element) {
	      return api$1.get(element);
	    };
	
	    var walkUp = function (navigation, doc) {
	      var frame = navigation.view(doc);
	      return frame.fold(constant([]), function (f) {
	        var parent = navigation.owner(f);
	        var rest = walkUp(navigation, parent);
	        return [f].concat(rest);
	      });
	    };
	    var pathTo = function (element, navigation) {
	      var d = navigation.owner(element);
	      return walkUp(navigation, d);
	    };
	
	    var view = function (doc) {
	      var element = doc.dom() === domGlobals.document ? Option.none() : Option.from(doc.dom().defaultView.frameElement);
	      return element.map(Element.fromDom);
	    };
	    var owner$1 = function (element) {
	      return owner(element);
	    };
	
	    var Navigation = /*#__PURE__*/Object.freeze({
	        __proto__: null,
	        view: view,
	        owner: owner$1
	    });
	
	    var find$3 = function (element) {
	      var doc = Element.fromDom(domGlobals.document);
	      var scroll = get$1(doc);
	      var frames = pathTo(element, Navigation);
	      var offset = viewport(element);
	      var r = foldr(frames, function (b, a) {
	        var loc = viewport(a);
	        return {
	          left: b.left + loc.left(),
	          top: b.top + loc.top()
	        };
	      }, {
	        left: 0,
	        top: 0
	      });
	      return Position(r.left + offset.left() + scroll.left(), r.top + offset.top() + scroll.top());
	    };
	
	    var excludeFromDescend = function (element) {
	      return name(element) === 'textarea';
	    };
	    var fireScrollIntoViewEvent = function (editor, data) {
	      var scrollEvent = editor.fire('ScrollIntoView', data);
	      return scrollEvent.isDefaultPrevented();
	    };
	    var fireAfterScrollIntoViewEvent = function (editor, data) {
	      editor.fire('AfterScrollIntoView', data);
	    };
	    var descend = function (element, offset) {
	      var children$1 = children(element);
	      if (children$1.length === 0 || excludeFromDescend(element)) {
	        return {
	          element: element,
	          offset: offset
	        };
	      } else if (offset < children$1.length && !excludeFromDescend(children$1[offset])) {
	        return {
	          element: children$1[offset],
	          offset: 0
	        };
	      } else {
	        var last = children$1[children$1.length - 1];
	        if (excludeFromDescend(last)) {
	          return {
	            element: element,
	            offset: offset
	          };
	        } else {
	          if (name(last) === 'img') {
	            return {
	              element: last,
	              offset: 1
	            };
	          } else if (isText(last)) {
	            return {
	              element: last,
	              offset: get$7(last).length
	            };
	          } else {
	            return {
	              element: last,
	              offset: children(last).length
	            };
	          }
	        }
	      }
	    };
	    var markerInfo = function (element, cleanupFun) {
	      var pos = absolute(element);
	      var height = get$8(element);
	      return {
	        element: element,
	        bottom: pos.top() + height,
	        height: height,
	        pos: pos,
	        cleanup: cleanupFun
	      };
	    };
	    var createMarker = function (element, offset) {
	      var startPoint = descend(element, offset);
	      var span = Element.fromHtml('<span data-mce-bogus="all">' + Zwsp.ZWSP + '</span>');
	      before(startPoint.element, span);
	      return markerInfo(span, function () {
	        return remove(span);
	      });
	    };
	    var elementMarker = function (element) {
	      return markerInfo(Element.fromDom(element), noop);
	    };
	    var withMarker = function (editor, f, rng, alignToTop) {
	      preserveWith(editor, function (_s, _e) {
	        return applyWithMarker(editor, f, rng, alignToTop);
	      }, rng);
	    };
	    var withScrollEvents = function (editor, doc, f, marker, alignToTop) {
	      var data = {
	        elm: marker.element.dom(),
	        alignToTop: alignToTop
	      };
	      if (fireScrollIntoViewEvent(editor, data)) {
	        return;
	      }
	      var scrollTop = get$1(doc).top();
	      f(doc, scrollTop, marker, alignToTop);
	      fireAfterScrollIntoViewEvent(editor, data);
	    };
	    var applyWithMarker = function (editor, f, rng, alignToTop) {
	      var body = Element.fromDom(editor.getBody());
	      var doc = Element.fromDom(editor.getDoc());
	      reflow(body);
	      var marker = createMarker(Element.fromDom(rng.startContainer), rng.startOffset);
	      withScrollEvents(editor, doc, f, marker, alignToTop);
	      marker.cleanup();
	    };
	    var withElement = function (editor, element, f, alignToTop) {
	      var doc = Element.fromDom(editor.getDoc());
	      withScrollEvents(editor, doc, f, elementMarker(element), alignToTop);
	    };
	    var preserveWith = function (editor, f, rng) {
	      var startElement = rng.startContainer;
	      var startOffset = rng.startOffset;
	      var endElement = rng.endContainer;
	      var endOffset = rng.endOffset;
	      f(Element.fromDom(startElement), Element.fromDom(endElement));
	      var newRng = editor.dom.createRng();
	      newRng.setStart(startElement, startOffset);
	      newRng.setEnd(endElement, endOffset);
	      editor.selection.setRng(rng);
	    };
	    var scrollToMarker = function (marker, viewHeight, alignToTop, doc) {
	      var pos = marker.pos;
	      if (alignToTop) {
	        to(pos.left(), pos.top(), doc);
	      } else {
	        var y = pos.top() - viewHeight + marker.height;
	        to(pos.left(), y, doc);
	      }
	    };
	    var intoWindowIfNeeded = function (doc, scrollTop, viewHeight, marker, alignToTop) {
	      var viewportBottom = viewHeight + scrollTop;
	      var markerTop = marker.pos.top();
	      var markerBottom = marker.bottom;
	      var largerThanViewport = markerBottom - markerTop >= viewHeight;
	      if (markerTop < scrollTop) {
	        scrollToMarker(marker, viewHeight, alignToTop !== false, doc);
	      } else if (markerTop > viewportBottom) {
	        var align = largerThanViewport ? alignToTop !== false : alignToTop === true;
	        scrollToMarker(marker, viewHeight, align, doc);
	      } else if (markerBottom > viewportBottom && !largerThanViewport) {
	        scrollToMarker(marker, viewHeight, alignToTop === true, doc);
	      }
	    };
	    var intoWindow = function (doc, scrollTop, marker, alignToTop) {
	      var viewHeight = doc.dom().defaultView.innerHeight;
	      intoWindowIfNeeded(doc, scrollTop, viewHeight, marker, alignToTop);
	    };
	    var intoFrame = function (doc, scrollTop, marker, alignToTop) {
	      var frameViewHeight = doc.dom().defaultView.innerHeight;
	      intoWindowIfNeeded(doc, scrollTop, frameViewHeight, marker, alignToTop);
	      var op = find$3(marker.element);
	      var viewportBounds = getBounds(domGlobals.window);
	      if (op.top() < viewportBounds.y()) {
	        intoView(marker.element, alignToTop !== false);
	      } else if (op.top() > viewportBounds.bottom()) {
	        intoView(marker.element, alignToTop === true);
	      }
	    };
	    var rangeIntoWindow = function (editor, rng, alignToTop) {
	      return withMarker(editor, intoWindow, rng, alignToTop);
	    };
	    var elementIntoWindow = function (editor, element, alignToTop) {
	      return withElement(editor, element, intoWindow, alignToTop);
	    };
	    var rangeIntoFrame = function (editor, rng, alignToTop) {
	      return withMarker(editor, intoFrame, rng, alignToTop);
	    };
	    var elementIntoFrame = function (editor, element, alignToTop) {
	      return withElement(editor, element, intoFrame, alignToTop);
	    };
	    var elementIntoView = function (editor, element, alignToTop) {
	      var scroller = editor.inline ? elementIntoWindow : elementIntoFrame;
	      scroller(editor, element, alignToTop);
	    };
	    var rangeIntoView = function (editor, rng, alignToTop) {
	      var scroller = editor.inline ? rangeIntoWindow : rangeIntoFrame;
	      scroller(editor, rng, alignToTop);
	    };
	    var ScrollIntoView = {
	      scrollElementIntoView: elementIntoView,
	      scrollRangeIntoView: rangeIntoView
	    };
	
	    var hasCeProperty = function (node) {
	      return NodeType.isContentEditableTrue(node) || NodeType.isContentEditableFalse(node);
	    };
	    var findParent = function (node, rootNode, predicate) {
	      while (node && node !== rootNode) {
	        if (predicate(node)) {
	          return node;
	        }
	        node = node.parentNode;
	      }
	      return null;
	    };
	    var findClosestIeRange = function (clientX, clientY, doc) {
	      var element, rng, rects;
	      element = doc.elementFromPoint(clientX, clientY);
	      rng = doc.body.createTextRange();
	      if (!element || element.tagName === 'HTML') {
	        element = doc.body;
	      }
	      rng.moveToElementText(element);
	      rects = Tools.toArray(rng.getClientRects());
	      rects = rects.sort(function (a, b) {
	        a = Math.abs(Math.max(a.top - clientY, a.bottom - clientY));
	        b = Math.abs(Math.max(b.top - clientY, b.bottom - clientY));
	        return a - b;
	      });
	      if (rects.length > 0) {
	        clientY = (rects[0].bottom + rects[0].top) / 2;
	        try {
	          rng.moveToPoint(clientX, clientY);
	          rng.collapse(true);
	          return rng;
	        } catch (ex) {
	        }
	      }
	      return null;
	    };
	    var moveOutOfContentEditableFalse = function (rng, rootNode) {
	      var parentElement = rng && rng.parentElement ? rng.parentElement() : null;
	      return NodeType.isContentEditableFalse(findParent(parentElement, rootNode, hasCeProperty)) ? null : rng;
	    };
	    var fromPoint$1 = function (clientX, clientY, doc) {
	      var rng, point;
	      var pointDoc = doc;
	      if (pointDoc.caretPositionFromPoint) {
	        point = pointDoc.caretPositionFromPoint(clientX, clientY);
	        if (point) {
	          rng = doc.createRange();
	          rng.setStart(point.offsetNode, point.offset);
	          rng.collapse(true);
	        }
	      } else if (doc.caretRangeFromPoint) {
	        rng = doc.caretRangeFromPoint(clientX, clientY);
	      } else if (pointDoc.body.createTextRange) {
	        rng = pointDoc.body.createTextRange();
	        try {
	          rng.moveToPoint(clientX, clientY);
	          rng.collapse(true);
	        } catch (ex) {
	          rng = findClosestIeRange(clientX, clientY, doc);
	        }
	        return moveOutOfContentEditableFalse(rng, doc.body);
	      }
	      return rng;
	    };
	    var CaretRangeFromPoint = { fromPoint: fromPoint$1 };
	
	    var processRanges = function (editor, ranges) {
	      return map(ranges, function (range) {
	        var evt = editor.fire('GetSelectionRange', { range: range });
	        return evt.range !== range ? evt.range : range;
	      });
	    };
	    var EventProcessRanges = { processRanges: processRanges };
	
	    var fromElements = function (elements, scope) {
	      var doc = scope || domGlobals.document;
	      var fragment = doc.createDocumentFragment();
	      each(elements, function (element) {
	        fragment.appendChild(element.dom());
	      });
	      return Element.fromDom(fragment);
	    };
	
	    var dropLast = function (xs) {
	      return xs.slice(0, -1);
	    };
	    var parentsUntil$1 = function (start, root, predicate) {
	      if (contains$2(root, start)) {
	        return dropLast(parents(start, function (elm) {
	          return predicate(elm) || eq(elm, root);
	        }));
	      } else {
	        return [];
	      }
	    };
	    var parents$1 = function (start, root) {
	      return parentsUntil$1(start, root, constant(false));
	    };
	    var parentsAndSelf = function (start, root) {
	      return [start].concat(parents$1(start, root));
	    };
	    var Parents = {
	      parentsUntil: parentsUntil$1,
	      parents: parents$1,
	      parentsAndSelf: parentsAndSelf
	    };
	
	    var getStartNode = function (rng) {
	      var sc = rng.startContainer, so = rng.startOffset;
	      if (NodeType.isText(sc)) {
	        return so === 0 ? Option.some(Element.fromDom(sc)) : Option.none();
	      } else {
	        return Option.from(sc.childNodes[so]).map(Element.fromDom);
	      }
	    };
	    var getEndNode = function (rng) {
	      var ec = rng.endContainer, eo = rng.endOffset;
	      if (NodeType.isText(ec)) {
	        return eo === ec.data.length ? Option.some(Element.fromDom(ec)) : Option.none();
	      } else {
	        return Option.from(ec.childNodes[eo - 1]).map(Element.fromDom);
	      }
	    };
	    var getFirstChildren = function (node) {
	      return firstChild(node).fold(constant([node]), function (child) {
	        return [node].concat(getFirstChildren(child));
	      });
	    };
	    var getLastChildren = function (node) {
	      return lastChild(node).fold(constant([node]), function (child) {
	        if (name(child) === 'br') {
	          return prevSibling(child).map(function (sibling) {
	            return [node].concat(getLastChildren(sibling));
	          }).getOr([]);
	        } else {
	          return [node].concat(getLastChildren(child));
	        }
	      });
	    };
	    var hasAllContentsSelected = function (elm, rng) {
	      return lift2(getStartNode(rng), getEndNode(rng), function (startNode, endNode) {
	        var start = find(getFirstChildren(elm), curry(eq, startNode));
	        var end = find(getLastChildren(elm), curry(eq, endNode));
	        return start.isSome() && end.isSome();
	      }).getOr(false);
	    };
	    var moveEndPoint$1 = function (dom, rng, node, start) {
	      var root = node, walker = new TreeWalker(node, root);
	      var nonEmptyElementsMap = dom.schema.getNonEmptyElements();
	      do {
	        if (node.nodeType === 3 && Tools.trim(node.nodeValue).length !== 0) {
	          if (start) {
	            rng.setStart(node, 0);
	          } else {
	            rng.setEnd(node, node.nodeValue.length);
	          }
	          return;
	        }
	        if (nonEmptyElementsMap[node.nodeName] && !/^(TD|TH)$/.test(node.nodeName)) {
	          if (start) {
	            rng.setStartBefore(node);
	          } else {
	            if (node.nodeName === 'BR') {
	              rng.setEndBefore(node);
	            } else {
	              rng.setEndAfter(node);
	            }
	          }
	          return;
	        }
	      } while (node = start ? walker.next() : walker.prev());
	      if (root.nodeName === 'BODY') {
	        if (start) {
	          rng.setStart(root, 0);
	        } else {
	          rng.setEnd(root, root.childNodes.length);
	        }
	      }
	    };
	    var hasAnyRanges = function (editor) {
	      var sel = editor.selection.getSel();
	      return sel && sel.rangeCount > 0;
	    };
	
	    var tableModel = Immutable('element', 'width', 'rows');
	    var tableRow = Immutable('element', 'cells');
	    var cellPosition = Immutable('x', 'y');
	    var getSpan = function (td, key) {
	      var value = parseInt(get$3(td, key), 10);
	      return isNaN(value) ? 1 : value;
	    };
	    var fillout = function (table, x, y, tr, td) {
	      var rowspan = getSpan(td, 'rowspan');
	      var colspan = getSpan(td, 'colspan');
	      var rows = table.rows();
	      for (var y2 = y; y2 < y + rowspan; y2++) {
	        if (!rows[y2]) {
	          rows[y2] = tableRow(deep(tr), []);
	        }
	        for (var x2 = x; x2 < x + colspan; x2++) {
	          var cells = rows[y2].cells();
	          cells[x2] = y2 === y && x2 === x ? td : shallow(td);
	        }
	      }
	    };
	    var cellExists = function (table, x, y) {
	      var rows = table.rows();
	      var cells = rows[y] ? rows[y].cells() : [];
	      return !!cells[x];
	    };
	    var skipCellsX = function (table, x, y) {
	      while (cellExists(table, x, y)) {
	        x++;
	      }
	      return x;
	    };
	    var getWidth = function (rows) {
	      return foldl(rows, function (acc, row) {
	        return row.cells().length > acc ? row.cells().length : acc;
	      }, 0);
	    };
	    var findElementPos = function (table, element) {
	      var rows = table.rows();
	      for (var y = 0; y < rows.length; y++) {
	        var cells = rows[y].cells();
	        for (var x = 0; x < cells.length; x++) {
	          if (eq(cells[x], element)) {
	            return Option.some(cellPosition(x, y));
	          }
	        }
	      }
	      return Option.none();
	    };
	    var extractRows = function (table, sx, sy, ex, ey) {
	      var newRows = [];
	      var rows = table.rows();
	      for (var y = sy; y <= ey; y++) {
	        var cells = rows[y].cells();
	        var slice = sx < ex ? cells.slice(sx, ex + 1) : cells.slice(ex, sx + 1);
	        newRows.push(tableRow(rows[y].element(), slice));
	      }
	      return newRows;
	    };
	    var subTable = function (table, startPos, endPos) {
	      var sx = startPos.x(), sy = startPos.y();
	      var ex = endPos.x(), ey = endPos.y();
	      var newRows = sy < ey ? extractRows(table, sx, sy, ex, ey) : extractRows(table, sx, ey, ex, sy);
	      return tableModel(table.element(), getWidth(newRows), newRows);
	    };
	    var createDomTable = function (table, rows) {
	      var tableElement = shallow(table.element());
	      var tableBody = Element.fromTag('tbody');
	      append$1(tableBody, rows);
	      append(tableElement, tableBody);
	      return tableElement;
	    };
	    var modelRowsToDomRows = function (table) {
	      return map(table.rows(), function (row) {
	        var cells = map(row.cells(), function (cell) {
	          var td = deep(cell);
	          remove$1(td, 'colspan');
	          remove$1(td, 'rowspan');
	          return td;
	        });
	        var tr = shallow(row.element());
	        append$1(tr, cells);
	        return tr;
	      });
	    };
	    var fromDom$1 = function (tableElm) {
	      var table = tableModel(shallow(tableElm), 0, []);
	      each(descendants$1(tableElm, 'tr'), function (tr, y) {
	        each(descendants$1(tr, 'td,th'), function (td, x) {
	          fillout(table, skipCellsX(table, x, y), y, tr, td);
	        });
	      });
	      return tableModel(table.element(), getWidth(table.rows()), table.rows());
	    };
	    var toDom = function (table) {
	      return createDomTable(table, modelRowsToDomRows(table));
	    };
	    var subsection = function (table, startElement, endElement) {
	      return findElementPos(table, startElement).bind(function (startPos) {
	        return findElementPos(table, endElement).map(function (endPos) {
	          return subTable(table, startPos, endPos);
	        });
	      });
	    };
	    var SimpleTableModel = {
	      fromDom: fromDom$1,
	      toDom: toDom,
	      subsection: subsection
	    };
	
	    var getRanges = function (selection) {
	      var ranges = [];
	      if (selection) {
	        for (var i = 0; i < selection.rangeCount; i++) {
	          ranges.push(selection.getRangeAt(i));
	        }
	      }
	      return ranges;
	    };
	    var getSelectedNodes = function (ranges) {
	      return bind(ranges, function (range) {
	        var node = getSelectedNode(range);
	        return node ? [Element.fromDom(node)] : [];
	      });
	    };
	    var hasMultipleRanges = function (selection) {
	      return getRanges(selection).length > 1;
	    };
	    var MultiRange = {
	      getRanges: getRanges,
	      getSelectedNodes: getSelectedNodes,
	      hasMultipleRanges: hasMultipleRanges
	    };
	
	    var getCellsFromRanges = function (ranges) {
	      return filter(MultiRange.getSelectedNodes(ranges), isTableCell);
	    };
	    var getCellsFromElement = function (elm) {
	      return descendants$1(elm, 'td[data-mce-selected],th[data-mce-selected]');
	    };
	    var getCellsFromElementOrRanges = function (ranges, element) {
	      var selectedCells = getCellsFromElement(element);
	      var rangeCells = getCellsFromRanges(ranges);
	      return selectedCells.length > 0 ? selectedCells : rangeCells;
	    };
	    var getCellsFromEditor = function (editor) {
	      return getCellsFromElementOrRanges(MultiRange.getRanges(editor.selection.getSel()), Element.fromDom(editor.getBody()));
	    };
	    var TableCellSelection = {
	      getCellsFromRanges: getCellsFromRanges,
	      getCellsFromElement: getCellsFromElement,
	      getCellsFromElementOrRanges: getCellsFromElementOrRanges,
	      getCellsFromEditor: getCellsFromEditor
	    };
	
	    var findParentListContainer = function (parents) {
	      return find(parents, function (elm) {
	        return name(elm) === 'ul' || name(elm) === 'ol';
	      });
	    };
	    var getFullySelectedListWrappers = function (parents, rng) {
	      return find(parents, function (elm) {
	        return name(elm) === 'li' && hasAllContentsSelected(elm, rng);
	      }).fold(constant([]), function (li) {
	        return findParentListContainer(parents).map(function (listCont) {
	          return [
	            Element.fromTag('li'),
	            Element.fromTag(name(listCont))
	          ];
	        }).getOr([]);
	      });
	    };
	    var wrap$2 = function (innerElm, elms) {
	      var wrapped = foldl(elms, function (acc, elm) {
	        append(elm, acc);
	        return elm;
	      }, innerElm);
	      return elms.length > 0 ? fromElements([wrapped]) : wrapped;
	    };
	    var directListWrappers = function (commonAnchorContainer) {
	      if (isListItem(commonAnchorContainer)) {
	        return parent(commonAnchorContainer).filter(isList).fold(constant([]), function (listElm) {
	          return [
	            commonAnchorContainer,
	            listElm
	          ];
	        });
	      } else {
	        return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];
	      }
	    };
	    var getWrapElements = function (rootNode, rng) {
	      var commonAnchorContainer = Element.fromDom(rng.commonAncestorContainer);
	      var parents = Parents.parentsAndSelf(commonAnchorContainer, rootNode);
	      var wrapElements = filter(parents, function (elm) {
	        return isInline(elm) || isHeading(elm);
	      });
	      var listWrappers = getFullySelectedListWrappers(parents, rng);
	      var allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));
	      return map(allWrappers, shallow);
	    };
	    var emptyFragment = function () {
	      return fromElements([]);
	    };
	    var getFragmentFromRange = function (rootNode, rng) {
	      return wrap$2(Element.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng));
	    };
	    var getParentTable = function (rootElm, cell) {
	      return ancestor$1(cell, 'table', curry(eq, rootElm));
	    };
	    var getTableFragment = function (rootNode, selectedTableCells) {
	      return getParentTable(rootNode, selectedTableCells[0]).bind(function (tableElm) {
	        var firstCell = selectedTableCells[0];
	        var lastCell = selectedTableCells[selectedTableCells.length - 1];
	        var fullTableModel = SimpleTableModel.fromDom(tableElm);
	        return SimpleTableModel.subsection(fullTableModel, firstCell, lastCell).map(function (sectionedTableModel) {
	          return fromElements([SimpleTableModel.toDom(sectionedTableModel)]);
	        });
	      }).getOrThunk(emptyFragment);
	    };
	    var getSelectionFragment = function (rootNode, ranges) {
	      return ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0]);
	    };
	    var read$1 = function (rootNode, ranges) {
	      var selectedCells = TableCellSelection.getCellsFromElementOrRanges(ranges, rootNode);
	      return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges);
	    };
	    var FragmentReader = { read: read$1 };
	
	    var getTextContent = function (editor) {
	      return Option.from(editor.selection.getRng()).map(function (rng) {
	        var bin = editor.dom.add(editor.getBody(), 'div', {
	          'data-mce-bogus': 'all',
	          'style': 'overflow: hidden; opacity: 0;'
	        }, rng.cloneContents());
	        var text = Zwsp.trim(bin.innerText);
	        editor.dom.remove(bin);
	        return text;
	      }).getOr('');
	    };
	    var getHtmlContent = function (editor, args) {
	      var rng = editor.selection.getRng(), tmpElm = editor.dom.create('body');
	      var sel = editor.selection.getSel();
	      var fragment;
	      var ranges = EventProcessRanges.processRanges(editor, MultiRange.getRanges(sel));
	      fragment = args.contextual ? FragmentReader.read(Element.fromDom(editor.getBody()), ranges).dom() : rng.cloneContents();
	      if (fragment) {
	        tmpElm.appendChild(fragment);
	      }
	      return editor.selection.serializer.serialize(tmpElm, args);
	    };
	    var getContent$1 = function (editor, args) {
	      if (args === void 0) {
	        args = {};
	      }
	      args.get = true;
	      args.format = args.format || 'html';
	      args.selection = true;
	      args = editor.fire('BeforeGetContent', args);
	      if (args.isDefaultPrevented()) {
	        editor.fire('GetContent', args);
	        return args.content;
	      }
	      if (args.format === 'text') {
	        return getTextContent(editor);
	      } else {
	        args.getInner = true;
	        var content = getHtmlContent(editor, args);
	        if (args.format === 'tree') {
	          return content;
	        } else {
	          args.content = editor.selection.isCollapsed() ? '' : content;
	          editor.fire('GetContent', args);
	          return args.content;
	        }
	      }
	    };
	    var GetSelectionContent = { getContent: getContent$1 };
	
	    var isEq$1 = function (rng1, rng2) {
	      return rng1 && rng2 && (rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset) && (rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset);
	    };
	    var RangeCompare = { isEq: isEq$1 };
	
	    var findParent$1 = function (node, rootNode, predicate) {
	      while (node && node !== rootNode) {
	        if (predicate(node)) {
	          return node;
	        }
	        node = node.parentNode;
	      }
	      return null;
	    };
	    var hasParent = function (node, rootNode, predicate) {
	      return findParent$1(node, rootNode, predicate) !== null;
	    };
	    var hasParentWithName = function (node, rootNode, name) {
	      return hasParent(node, rootNode, function (node) {
	        return node.nodeName === name;
	      });
	    };
	    var isTable$3 = function (node) {
	      return node && node.nodeName === 'TABLE';
	    };
	    var isTableCell$2 = function (node) {
	      return node && /^(TD|TH|CAPTION)$/.test(node.nodeName);
	    };
	    var isCeFalseCaretContainer = function (node, rootNode) {
	      return isCaretContainer(node) && hasParent(node, rootNode, isCaretNode) === false;
	    };
	    var hasBrBeforeAfter = function (dom, node, left) {
	      var walker = new TreeWalker(node, dom.getParent(node.parentNode, dom.isBlock) || dom.getRoot());
	      while (node = walker[left ? 'prev' : 'next']()) {
	        if (NodeType.isBr(node)) {
	          return true;
	        }
	      }
	    };
	    var isPrevNode = function (node, name) {
	      return node.previousSibling && node.previousSibling.nodeName === name;
	    };
	    var hasContentEditableFalseParent = function (body, node) {
	      while (node && node !== body) {
	        if (NodeType.isContentEditableFalse(node)) {
	          return true;
	        }
	        node = node.parentNode;
	      }
	      return false;
	    };
	    var findTextNodeRelative = function (dom, isAfterNode, collapsed, left, startNode) {
	      var lastInlineElement;
	      var body = dom.getRoot();
	      var node;
	      var nonEmptyElementsMap = dom.schema.getNonEmptyElements();
	      var parentBlockContainer = dom.getParent(startNode.parentNode, dom.isBlock) || body;
	      if (left && NodeType.isBr(startNode) && isAfterNode && dom.isEmpty(parentBlockContainer)) {
	        return Option.some(CaretPosition(startNode.parentNode, dom.nodeIndex(startNode)));
	      }
	      var walker = new TreeWalker(startNode, parentBlockContainer);
	      while (node = walker[left ? 'prev' : 'next']()) {
	        if (dom.getContentEditableParent(node) === 'false' || isCeFalseCaretContainer(node, body)) {
	          return Option.none();
	        }
	        if (NodeType.isText(node) && node.nodeValue.length > 0) {
	          if (hasParentWithName(node, body, 'A') === false) {
	            return Option.some(CaretPosition(node, left ? node.nodeValue.length : 0));
	          }
	          return Option.none();
	        }
	        if (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
	          return Option.none();
	        }
	        lastInlineElement = node;
	      }
	      if (collapsed && lastInlineElement) {
	        return Option.some(CaretPosition(lastInlineElement, 0));
	      }
	      return Option.none();
	    };
	    var normalizeEndPoint = function (dom, collapsed, start, rng) {
	      var container, offset;
	      var body = dom.getRoot();
	      var node, nonEmptyElementsMap;
	      var directionLeft, isAfterNode, normalized = false;
	      container = rng[(start ? 'start' : 'end') + 'Container'];
	      offset = rng[(start ? 'start' : 'end') + 'Offset'];
	      isAfterNode = NodeType.isElement(container) && offset === container.childNodes.length;
	      nonEmptyElementsMap = dom.schema.getNonEmptyElements();
	      directionLeft = start;
	      if (isCaretContainer(container)) {
	        return Option.none();
	      }
	      if (NodeType.isElement(container) && offset > container.childNodes.length - 1) {
	        directionLeft = false;
	      }
	      if (NodeType.isDocument(container)) {
	        container = body;
	        offset = 0;
	      }
	      if (container === body) {
	        if (directionLeft) {
	          node = container.childNodes[offset > 0 ? offset - 1 : 0];
	          if (node) {
	            if (isCaretContainer(node)) {
	              return Option.none();
	            }
	            if (nonEmptyElementsMap[node.nodeName] || isTable$3(node)) {
	              return Option.none();
	            }
	          }
	        }
	        if (container.hasChildNodes()) {
	          offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);
	          container = container.childNodes[offset];
	          offset = NodeType.isText(container) && isAfterNode ? container.data.length : 0;
	          if (!collapsed && container === body.lastChild && isTable$3(container)) {
	            return Option.none();
	          }
	          if (hasContentEditableFalseParent(body, container) || isCaretContainer(container)) {
	            return Option.none();
	          }
	          if (container.hasChildNodes() && isTable$3(container) === false) {
	            node = container;
	            var walker = new TreeWalker(container, body);
	            do {
	              if (NodeType.isContentEditableFalse(node) || isCaretContainer(node)) {
	                normalized = false;
	                break;
	              }
	              if (NodeType.isText(node) && node.nodeValue.length > 0) {
	                offset = directionLeft ? 0 : node.nodeValue.length;
	                container = node;
	                normalized = true;
	                break;
	              }
	              if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCell$2(node)) {
	                offset = dom.nodeIndex(node);
	                container = node.parentNode;
	                if (!directionLeft) {
	                  offset++;
	                }
	                normalized = true;
	                break;
	              }
	            } while (node = directionLeft ? walker.next() : walker.prev());
	          }
	        }
	      }
	      if (collapsed) {
	        if (NodeType.isText(container) && offset === 0) {
	          findTextNodeRelative(dom, isAfterNode, collapsed, true, container).each(function (pos) {
	            container = pos.container();
	            offset = pos.offset();
	            normalized = true;
	          });
	        }
	        if (NodeType.isElement(container)) {
	          node = container.childNodes[offset];
	          if (!node) {
	            node = container.childNodes[offset - 1];
	          }
	          if (node && NodeType.isBr(node) && !isPrevNode(node, 'A') && !hasBrBeforeAfter(dom, node, false) && !hasBrBeforeAfter(dom, node, true)) {
	            findTextNodeRelative(dom, isAfterNode, collapsed, true, node).each(function (pos) {
	              container = pos.container();
	              offset = pos.offset();
	              normalized = true;
	            });
	          }
	        }
	      }
	      if (directionLeft && !collapsed && NodeType.isText(container) && offset === container.nodeValue.length) {
	        findTextNodeRelative(dom, isAfterNode, collapsed, false, container).each(function (pos) {
	          container = pos.container();
	          offset = pos.offset();
	          normalized = true;
	        });
	      }
	      return normalized ? Option.some(CaretPosition(container, offset)) : Option.none();
	    };
	    var normalize = function (dom, rng) {
	      var collapsed = rng.collapsed, normRng = rng.cloneRange();
	      var startPos = CaretPosition.fromRangeStart(rng);
	      normalizeEndPoint(dom, collapsed, true, normRng).each(function (pos) {
	        if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {
	          normRng.setStart(pos.container(), pos.offset());
	        }
	      });
	      if (!collapsed) {
	        normalizeEndPoint(dom, collapsed, false, normRng).each(function (pos) {
	          normRng.setEnd(pos.container(), pos.offset());
	        });
	      }
	      if (collapsed) {
	        normRng.collapse(true);
	      }
	      return RangeCompare.isEq(rng, normRng) ? Option.none() : Option.some(normRng);
	    };
	    var NormalizeRange = { normalize: normalize };
	
	    var prependData = function (target, data) {
	      target.insertData(0, data);
	    };
	    var removeEmpty = function (text) {
	      if (text.dom().length === 0) {
	        remove(text);
	        return Option.none();
	      }
	      return Option.some(text);
	    };
	    var rngSetContent = function (rng, fragment) {
	      var firstChild = Option.from(fragment.firstChild).map(Element.fromDom);
	      var lastChild = Option.from(fragment.lastChild).map(Element.fromDom);
	      rng.deleteContents();
	      rng.insertNode(fragment);
	      var prevText = firstChild.bind(prevSibling).filter(isText).bind(removeEmpty);
	      var nextText = lastChild.bind(nextSibling).filter(isText).bind(removeEmpty);
	      lift2(prevText, firstChild.filter(isText), function (prev, start) {
	        prependData(start.dom(), prev.dom().data);
	        remove(prev);
	      });
	      lift2(nextText, lastChild.filter(isText), function (next, end) {
	        var oldLength = end.dom().length;
	        end.dom().appendData(next.dom().data);
	        rng.setEnd(end.dom(), oldLength);
	        remove(next);
	      });
	      rng.collapse(false);
	    };
	    var setupArgs = function (args, content) {
	      args = args || { format: 'html' };
	      args.set = true;
	      args.selection = true;
	      args.content = content;
	      return args;
	    };
	    var setContent$1 = function (editor, content, args) {
	      args = setupArgs(args, content);
	      if (!args.no_events) {
	        args = editor.fire('BeforeSetContent', args);
	        if (args.isDefaultPrevented()) {
	          editor.fire('SetContent', args);
	          return;
	        }
	      }
	      var rng = editor.selection.getRng();
	      rngSetContent(rng, rng.createContextualFragment(args.content));
	      editor.selection.setRng(rng);
	      ScrollIntoView.scrollRangeIntoView(editor, rng);
	      if (!args.no_events) {
	        editor.fire('SetContent', args);
	      }
	    };
	    var SetSelectionContent = { setContent: setContent$1 };
	
	    var getEndpointElement = function (root, rng, start, real, resolve) {
	      var container = start ? rng.startContainer : rng.endContainer;
	      var offset = start ? rng.startOffset : rng.endOffset;
	      return Option.from(container).map(Element.fromDom).map(function (elm) {
	        return !real || !rng.collapsed ? child(elm, resolve(elm, offset)).getOr(elm) : elm;
	      }).bind(function (elm) {
	        return isElement(elm) ? Option.some(elm) : parent(elm);
	      }).map(function (elm) {
	        return elm.dom();
	      }).getOr(root);
	    };
	    var getStart$2 = function (root, rng, real) {
	      return getEndpointElement(root, rng, true, real, function (elm, offset) {
	        return Math.min(childNodesCount(elm), offset);
	      });
	    };
	    var getEnd = function (root, rng, real) {
	      return getEndpointElement(root, rng, false, real, function (elm, offset) {
	        return offset > 0 ? offset - 1 : offset;
	      });
	    };
	    var skipEmptyTextNodes = function (node, forwards) {
	      var orig = node;
	      while (node && NodeType.isText(node) && node.length === 0) {
	        node = forwards ? node.nextSibling : node.previousSibling;
	      }
	      return node || orig;
	    };
	    var getNode$1 = function (root, rng) {
	      var elm, startContainer, endContainer, startOffset, endOffset;
	      if (!rng) {
	        return root;
	      }
	      startContainer = rng.startContainer;
	      endContainer = rng.endContainer;
	      startOffset = rng.startOffset;
	      endOffset = rng.endOffset;
	      elm = rng.commonAncestorContainer;
	      if (!rng.collapsed) {
	        if (startContainer === endContainer) {
	          if (endOffset - startOffset < 2) {
	            if (startContainer.hasChildNodes()) {
	              elm = startContainer.childNodes[startOffset];
	            }
	          }
	        }
	        if (startContainer.nodeType === 3 && endContainer.nodeType === 3) {
	          if (startContainer.length === startOffset) {
	            startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);
	          } else {
	            startContainer = startContainer.parentNode;
	          }
	          if (endOffset === 0) {
	            endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);
	          } else {
	            endContainer = endContainer.parentNode;
	          }
	          if (startContainer && startContainer === endContainer) {
	            return startContainer;
	          }
	        }
	      }
	      if (elm && elm.nodeType === 3) {
	        return elm.parentNode;
	      }
	      return elm;
	    };
	    var getSelectedBlocks = function (dom, rng, startElm, endElm) {
	      var node, root;
	      var selectedBlocks = [];
	      root = dom.getRoot();
	      startElm = dom.getParent(startElm || getStart$2(root, rng, rng.collapsed), dom.isBlock);
	      endElm = dom.getParent(endElm || getEnd(root, rng, rng.collapsed), dom.isBlock);
	      if (startElm && startElm !== root) {
	        selectedBlocks.push(startElm);
	      }
	      if (startElm && endElm && startElm !== endElm) {
	        node = startElm;
	        var walker = new TreeWalker(startElm, root);
	        while ((node = walker.next()) && node !== endElm) {
	          if (dom.isBlock(node)) {
	            selectedBlocks.push(node);
	          }
	        }
	      }
	      if (endElm && startElm !== endElm && endElm !== root) {
	        selectedBlocks.push(endElm);
	      }
	      return selectedBlocks;
	    };
	    var select$1 = function (dom, node, content) {
	      return Option.from(node).map(function (node) {
	        var idx = dom.nodeIndex(node);
	        var rng = dom.createRng();
	        rng.setStart(node.parentNode, idx);
	        rng.setEnd(node.parentNode, idx + 1);
	        if (content) {
	          moveEndPoint$1(dom, rng, node, true);
	          moveEndPoint$1(dom, rng, node, false);
	        }
	        return rng;
	      });
	    };
	
	    var deleteFromCallbackMap = function (callbackMap, selector, callback) {
	      if (callbackMap && callbackMap.hasOwnProperty(selector)) {
	        var newCallbacks = filter(callbackMap[selector], function (cb) {
	          return cb !== callback;
	        });
	        if (newCallbacks.length === 0) {
	          delete callbackMap[selector];
	        } else {
	          callbackMap[selector] = newCallbacks;
	        }
	      }
	    };
	    function SelectorChanged (dom, editor) {
	      var selectorChangedData;
	      var currentSelectors;
	      return {
	        selectorChangedWithUnbind: function (selector, callback) {
	          if (!selectorChangedData) {
	            selectorChangedData = {};
	            currentSelectors = {};
	            editor.on('NodeChange', function (e) {
	              var node = e.element, parents = dom.getParents(node, null, dom.getRoot()), matchedSelectors = {};
	              Tools.each(selectorChangedData, function (callbacks, selector) {
	                Tools.each(parents, function (node) {
	                  if (dom.is(node, selector)) {
	                    if (!currentSelectors[selector]) {
	                      Tools.each(callbacks, function (callback) {
	                        callback(true, {
	                          node: node,
	                          selector: selector,
	                          parents: parents
	                        });
	                      });
	                      currentSelectors[selector] = callbacks;
	                    }
	                    matchedSelectors[selector] = callbacks;
	                    return false;
	                  }
	                });
	              });
	              Tools.each(currentSelectors, function (callbacks, selector) {
	                if (!matchedSelectors[selector]) {
	                  delete currentSelectors[selector];
	                  Tools.each(callbacks, function (callback) {
	                    callback(false, {
	                      node: node,
	                      selector: selector,
	                      parents: parents
	                    });
	                  });
	                }
	              });
	            });
	          }
	          if (!selectorChangedData[selector]) {
	            selectorChangedData[selector] = [];
	          }
	          selectorChangedData[selector].push(callback);
	          return {
	            unbind: function () {
	              deleteFromCallbackMap(selectorChangedData, selector, callback);
	              deleteFromCallbackMap(currentSelectors, selector, callback);
	            }
	          };
	        }
	      };
	    }
	
	    var isNativeIeSelection = function (rng) {
	      return !!rng.select;
	    };
	    var isAttachedToDom = function (node) {
	      return !!(node && node.ownerDocument) && contains$2(Element.fromDom(node.ownerDocument), Element.fromDom(node));
	    };
	    var isValidRange = function (rng) {
	      if (!rng) {
	        return false;
	      } else if (isNativeIeSelection(rng)) {
	        return true;
	      } else {
	        return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);
	      }
	    };
	    var Selection$1 = function (dom, win, serializer, editor) {
	      var bookmarkManager;
	      var controlSelection;
	      var selectedRange;
	      var explicitRange;
	      var selectorChangedWithUnbind = SelectorChanged(dom, editor).selectorChangedWithUnbind;
	      var setCursorLocation = function (node, offset) {
	        var rng = dom.createRng();
	        if (!node) {
	          moveEndPoint$1(dom, rng, editor.getBody(), true);
	          setRng(rng);
	        } else {
	          rng.setStart(node, offset);
	          rng.setEnd(node, offset);
	          setRng(rng);
	          collapse(false);
	        }
	      };
	      var getContent = function (args) {
	        return GetSelectionContent.getContent(editor, args);
	      };
	      var setContent = function (content, args) {
	        return SetSelectionContent.setContent(editor, content, args);
	      };
	      var getStart = function (real) {
	        return getStart$2(editor.getBody(), getRng(), real);
	      };
	      var getEnd$1 = function (real) {
	        return getEnd(editor.getBody(), getRng(), real);
	      };
	      var getBookmark = function (type, normalized) {
	        return bookmarkManager.getBookmark(type, normalized);
	      };
	      var moveToBookmark = function (bookmark) {
	        return bookmarkManager.moveToBookmark(bookmark);
	      };
	      var select = function (node, content) {
	        select$1(dom, node, content).each(setRng);
	        return node;
	      };
	      var isCollapsed = function () {
	        var rng = getRng(), sel = getSel();
	        if (!rng || rng.item) {
	          return false;
	        }
	        if (rng.compareEndPoints) {
	          return rng.compareEndPoints('StartToEnd', rng) === 0;
	        }
	        return !sel || rng.collapsed;
	      };
	      var collapse = function (toStart) {
	        var rng = getRng();
	        rng.collapse(!!toStart);
	        setRng(rng);
	      };
	      var getSel = function () {
	        return win.getSelection ? win.getSelection() : win.document.selection;
	      };
	      var getRng = function () {
	        var selection, rng, elm, doc;
	        var tryCompareBoundaryPoints = function (how, sourceRange, destinationRange) {
	          try {
	            return sourceRange.compareBoundaryPoints(how, destinationRange);
	          } catch (ex) {
	            return -1;
	          }
	        };
	        if (!win) {
	          return null;
	        }
	        doc = win.document;
	        if (typeof doc === 'undefined' || doc === null) {
	          return null;
	        }
	        if (editor.bookmark !== undefined && EditorFocus.hasFocus(editor) === false) {
	          var bookmark = SelectionBookmark.getRng(editor);
	          if (bookmark.isSome()) {
	            return bookmark.map(function (r) {
	              return EventProcessRanges.processRanges(editor, [r])[0];
	            }).getOr(doc.createRange());
	          }
	        }
	        try {
	          if ((selection = getSel()) && !NodeType.isRestrictedNode(selection.anchorNode)) {
	            if (selection.rangeCount > 0) {
	              rng = selection.getRangeAt(0);
	            } else {
	              rng = selection.createRange ? selection.createRange() : doc.createRange();
	            }
	          }
	        } catch (ex) {
	        }
	        rng = EventProcessRanges.processRanges(editor, [rng])[0];
	        if (!rng) {
	          rng = doc.createRange ? doc.createRange() : doc.body.createTextRange();
	        }
	        if (rng.setStart && rng.startContainer.nodeType === 9 && rng.collapsed) {
	          elm = dom.getRoot();
	          rng.setStart(elm, 0);
	          rng.setEnd(elm, 0);
	        }
	        if (selectedRange && explicitRange) {
	          if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 && tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {
	            rng = explicitRange;
	          } else {
	            selectedRange = null;
	            explicitRange = null;
	          }
	        }
	        return rng;
	      };
	      var setRng = function (rng, forward) {
	        var sel, node, evt;
	        if (!isValidRange(rng)) {
	          return;
	        }
	        var ieRange = isNativeIeSelection(rng) ? rng : null;
	        if (ieRange) {
	          explicitRange = null;
	          try {
	            ieRange.select();
	          } catch (ex) {
	          }
	          return;
	        }
	        sel = getSel();
	        evt = editor.fire('SetSelectionRange', {
	          range: rng,
	          forward: forward
	        });
	        rng = evt.range;
	        if (sel) {
	          explicitRange = rng;
	          try {
	            sel.removeAllRanges();
	            sel.addRange(rng);
	          } catch (ex) {
	          }
	          if (forward === false && sel.extend) {
	            sel.collapse(rng.endContainer, rng.endOffset);
	            sel.extend(rng.startContainer, rng.startOffset);
	          }
	          selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
	        }
	        if (!rng.collapsed && rng.startContainer === rng.endContainer && sel.setBaseAndExtent && !Env.ie) {
	          if (rng.endOffset - rng.startOffset < 2) {
	            if (rng.startContainer.hasChildNodes()) {
	              node = rng.startContainer.childNodes[rng.startOffset];
	              if (node && node.tagName === 'IMG') {
	                sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);
	                if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {
	                  sel.setBaseAndExtent(node, 0, node, 1);
	                }
	              }
	            }
	          }
	        }
	        editor.fire('AfterSetSelectionRange', {
	          range: rng,
	          forward: forward
	        });
	      };
	      var setNode = function (elm) {
	        setContent(dom.getOuterHTML(elm));
	        return elm;
	      };
	      var getNode = function () {
	        return getNode$1(editor.getBody(), getRng());
	      };
	      var getSelectedBlocks$1 = function (startElm, endElm) {
	        return getSelectedBlocks(dom, getRng(), startElm, endElm);
	      };
	      var isForward = function () {
	        var sel = getSel();
	        var anchorRange, focusRange;
	        if (!sel || !sel.anchorNode || !sel.focusNode) {
	          return true;
	        }
	        anchorRange = dom.createRng();
	        anchorRange.setStart(sel.anchorNode, sel.anchorOffset);
	        anchorRange.collapse(true);
	        focusRange = dom.createRng();
	        focusRange.setStart(sel.focusNode, sel.focusOffset);
	        focusRange.collapse(true);
	        return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;
	      };
	      var normalize = function () {
	        var rng = getRng();
	        var sel = getSel();
	        if (!MultiRange.hasMultipleRanges(sel) && hasAnyRanges(editor)) {
	          var normRng = NormalizeRange.normalize(dom, rng);
	          normRng.each(function (normRng) {
	            setRng(normRng, isForward());
	          });
	          return normRng.getOr(rng);
	        }
	        return rng;
	      };
	      var selectorChanged = function (selector, callback) {
	        selectorChangedWithUnbind(selector, callback);
	        return exports;
	      };
	      var getScrollContainer = function () {
	        var scrollContainer;
	        var node = dom.getRoot();
	        while (node && node.nodeName !== 'BODY') {
	          if (node.scrollHeight > node.clientHeight) {
	            scrollContainer = node;
	            break;
	          }
	          node = node.parentNode;
	        }
	        return scrollContainer;
	      };
	      var scrollIntoView = function (elm, alignToTop) {
	        return ScrollIntoView.scrollElementIntoView(editor, elm, alignToTop);
	      };
	      var placeCaretAt = function (clientX, clientY) {
	        return setRng(CaretRangeFromPoint.fromPoint(clientX, clientY, editor.getDoc()));
	      };
	      var getBoundingClientRect = function () {
	        var rng = getRng();
	        return rng.collapsed ? CaretPosition$1.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();
	      };
	      var destroy = function () {
	        win = selectedRange = explicitRange = null;
	        controlSelection.destroy();
	      };
	      var exports = {
	        bookmarkManager: null,
	        controlSelection: null,
	        dom: dom,
	        win: win,
	        serializer: serializer,
	        editor: editor,
	        collapse: collapse,
	        setCursorLocation: setCursorLocation,
	        getContent: getContent,
	        setContent: setContent,
	        getBookmark: getBookmark,
	        moveToBookmark: moveToBookmark,
	        select: select,
	        isCollapsed: isCollapsed,
	        isForward: isForward,
	        setNode: setNode,
	        getNode: getNode,
	        getSel: getSel,
	        setRng: setRng,
	        getRng: getRng,
	        getStart: getStart,
	        getEnd: getEnd$1,
	        getSelectedBlocks: getSelectedBlocks$1,
	        normalize: normalize,
	        selectorChanged: selectorChanged,
	        selectorChangedWithUnbind: selectorChangedWithUnbind,
	        getScrollContainer: getScrollContainer,
	        scrollIntoView: scrollIntoView,
	        placeCaretAt: placeCaretAt,
	        getBoundingClientRect: getBoundingClientRect,
	        destroy: destroy
	      };
	      bookmarkManager = BookmarkManager$1(exports);
	      controlSelection = ControlSelection(exports, editor);
	      exports.bookmarkManager = bookmarkManager;
	      exports.controlSelection = controlSelection;
	      return exports;
	    };
	
	    var removeAttrs = function (node, names) {
	      each(names, function (name) {
	        node.attr(name, null);
	      });
	    };
	    var addFontToSpansFilter = function (domParser, styles, fontSizes) {
	      domParser.addNodeFilter('font', function (nodes) {
	        each(nodes, function (node) {
	          var props = styles.parse(node.attr('style'));
	          var color = node.attr('color');
	          var face = node.attr('face');
	          var size = node.attr('size');
	          if (color) {
	            props.color = color;
	          }
	          if (face) {
	            props['font-family'] = face;
	          }
	          if (size) {
	            props['font-size'] = fontSizes[parseInt(node.attr('size'), 10) - 1];
	          }
	          node.name = 'span';
	          node.attr('style', styles.serialize(props));
	          removeAttrs(node, [
	            'color',
	            'face',
	            'size'
	          ]);
	        });
	      });
	    };
	    var addStrikeToSpanFilter = function (domParser, styles) {
	      domParser.addNodeFilter('strike', function (nodes) {
	        each(nodes, function (node) {
	          var props = styles.parse(node.attr('style'));
	          props['text-decoration'] = 'line-through';
	          node.name = 'span';
	          node.attr('style', styles.serialize(props));
	        });
	      });
	    };
	    var addFilters = function (domParser, settings) {
	      var styles = Styles();
	      if (settings.convert_fonts_to_spans) {
	        addFontToSpansFilter(domParser, styles, Tools.explode(settings.font_size_legacy_values));
	      }
	      addStrikeToSpanFilter(domParser, styles);
	    };
	    var register$1 = function (domParser, settings) {
	      if (settings.inline_styles) {
	        addFilters(domParser, settings);
	      }
	    };
	    var LegacyFilter = { register: register$1 };
	
	    var paddEmptyNode = function (settings, args, blockElements, node) {
	      var brPreferred = settings.padd_empty_with_br || args.insert;
	      if (brPreferred && blockElements[node.name]) {
	        node.empty().append(new Node$1('br', 1)).shortEnded = true;
	      } else {
	        node.empty().append(new Node$1('#text', 3)).value = nbsp;
	      }
	    };
	    var isPaddedWithNbsp = function (node) {
	      return hasOnlyChild(node, '#text') && node.firstChild.value === nbsp;
	    };
	    var hasOnlyChild = function (node, name) {
	      return node && node.firstChild && node.firstChild === node.lastChild && node.firstChild.name === name;
	    };
	    var isPadded = function (schema, node) {
	      var rule = schema.getElementRule(node.name);
	      return rule && rule.paddEmpty;
	    };
	    var isEmpty$1 = function (schema, nonEmptyElements, whitespaceElements, node) {
	      return node.isEmpty(nonEmptyElements, whitespaceElements, function (node) {
	        return isPadded(schema, node);
	      });
	    };
	    var isLineBreakNode = function (node, blockElements) {
	      return node && (blockElements[node.name] || node.name === 'br');
	    };
	
	    var register$2 = function (parser, settings) {
	      var schema = parser.schema;
	      if (settings.remove_trailing_brs) {
	        parser.addNodeFilter('br', function (nodes, _, args) {
	          var i;
	          var l = nodes.length;
	          var node;
	          var blockElements = Tools.extend({}, schema.getBlockElements());
	          var nonEmptyElements = schema.getNonEmptyElements();
	          var parent, lastParent, prev, prevName;
	          var whiteSpaceElements = schema.getNonEmptyElements();
	          var elementRule, textNode;
	          blockElements.body = 1;
	          for (i = 0; i < l; i++) {
	            node = nodes[i];
	            parent = node.parent;
	            if (blockElements[node.parent.name] && node === parent.lastChild) {
	              prev = node.prev;
	              while (prev) {
	                prevName = prev.name;
	                if (prevName !== 'span' || prev.attr('data-mce-type') !== 'bookmark') {
	                  if (prevName !== 'br') {
	                    break;
	                  }
	                  if (prevName === 'br') {
	                    node = null;
	                    break;
	                  }
	                }
	                prev = prev.prev;
	              }
	              if (node) {
	                node.remove();
	                if (isEmpty$1(schema, nonEmptyElements, whiteSpaceElements, parent)) {
	                  elementRule = schema.getElementRule(parent.name);
	                  if (elementRule) {
	                    if (elementRule.removeEmpty) {
	                      parent.remove();
	                    } else if (elementRule.paddEmpty) {
	                      paddEmptyNode(settings, args, blockElements, parent);
	                    }
	                  }
	                }
	              }
	            } else {
	              lastParent = node;
	              while (parent && parent.firstChild === lastParent && parent.lastChild === lastParent) {
	                lastParent = parent;
	                if (blockElements[parent.name]) {
	                  break;
	                }
	                parent = parent.parent;
	              }
	              if (lastParent === parent && settings.padd_empty_with_br !== true) {
	                textNode = new Node$1('#text', 3);
	                textNode.value = nbsp;
	                node.replace(textNode);
	              }
	            }
	          }
	        });
	      }
	      parser.addAttributeFilter('href', function (nodes) {
	        var i = nodes.length, node;
	        var appendRel = function (rel) {
	          var parts = rel.split(' ').filter(function (p) {
	            return p.length > 0;
	          });
	          return parts.concat(['noopener']).sort().join(' ');
	        };
	        var addNoOpener = function (rel) {
	          var newRel = rel ? Tools.trim(rel) : '';
	          if (!/\b(noopener)\b/g.test(newRel)) {
	            return appendRel(newRel);
	          } else {
	            return newRel;
	          }
	        };
	        if (!settings.allow_unsafe_link_target) {
	          while (i--) {
	            node = nodes[i];
	            if (node.name === 'a' && node.attr('target') === '_blank') {
	              node.attr('rel', addNoOpener(node.attr('rel')));
	            }
	          }
	        }
	      });
	      if (!settings.allow_html_in_named_anchor) {
	        parser.addAttributeFilter('id,name', function (nodes) {
	          var i = nodes.length, sibling, prevSibling, parent, node;
	          while (i--) {
	            node = nodes[i];
	            if (node.name === 'a' && node.firstChild && !node.attr('href')) {
	              parent = node.parent;
	              sibling = node.lastChild;
	              do {
	                prevSibling = sibling.prev;
	                parent.insert(sibling, node);
	                sibling = prevSibling;
	              } while (sibling);
	            }
	          }
	        });
	      }
	      if (settings.fix_list_elements) {
	        parser.addNodeFilter('ul,ol', function (nodes) {
	          var i = nodes.length, node, parentNode;
	          while (i--) {
	            node = nodes[i];
	            parentNode = node.parent;
	            if (parentNode.name === 'ul' || parentNode.name === 'ol') {
	              if (node.prev && node.prev.name === 'li') {
	                node.prev.append(node);
	              } else {
	                var li = new Node$1('li', 1);
	                li.attr('style', 'list-style-type: none');
	                node.wrap(li);
	              }
	            }
	          }
	        });
	      }
	      if (settings.validate && schema.getValidClasses()) {
	        parser.addAttributeFilter('class', function (nodes) {
	          var i = nodes.length, node, classList, ci, className, classValue;
	          var validClasses = schema.getValidClasses();
	          var validClassesMap, valid;
	          while (i--) {
	            node = nodes[i];
	            classList = node.attr('class').split(' ');
	            classValue = '';
	            for (ci = 0; ci < classList.length; ci++) {
	              className = classList[ci];
	              valid = false;
	              validClassesMap = validClasses['*'];
	              if (validClassesMap && validClassesMap[className]) {
	                valid = true;
	              }
	              validClassesMap = validClasses[node.name];
	              if (!valid && validClassesMap && validClassesMap[className]) {
	                valid = true;
	              }
	              if (valid) {
	                if (classValue) {
	                  classValue += ' ';
	                }
	                classValue += className;
	              }
	            }
	            if (!classValue.length) {
	              classValue = null;
	            }
	            node.attr('class', classValue);
	          }
	        });
	      }
	    };
	
	    var makeMap$4 = Tools.makeMap, each$8 = Tools.each, explode$2 = Tools.explode, extend$2 = Tools.extend;
	    var DomParser = function (settings, schema) {
	      if (schema === void 0) {
	        schema = Schema();
	      }
	      var nodeFilters = {};
	      var attributeFilters = [];
	      var matchedNodes = {};
	      var matchedAttributes = {};
	      settings = settings || {};
	      settings.validate = 'validate' in settings ? settings.validate : true;
	      settings.root_name = settings.root_name || 'body';
	      var fixInvalidChildren = function (nodes) {
	        var ni, node, parent, parents, newParent, currentNode, tempNode, childNode, i;
	        var nonEmptyElements, whitespaceElements, nonSplitableElements, textBlockElements, specialElements, sibling, nextNode;
	        nonSplitableElements = makeMap$4('tr,td,th,tbody,thead,tfoot,table');
	        nonEmptyElements = schema.getNonEmptyElements();
	        whitespaceElements = schema.getWhiteSpaceElements();
	        textBlockElements = schema.getTextBlockElements();
	        specialElements = schema.getSpecialElements();
	        for (ni = 0; ni < nodes.length; ni++) {
	          node = nodes[ni];
	          if (!node.parent || node.fixed) {
	            continue;
	          }
	          if (textBlockElements[node.name] && node.parent.name === 'li') {
	            sibling = node.next;
	            while (sibling) {
	              if (textBlockElements[sibling.name]) {
	                sibling.name = 'li';
	                sibling.fixed = true;
	                node.parent.insert(sibling, node.parent);
	              } else {
	                break;
	              }
	              sibling = sibling.next;
	            }
	            node.unwrap(node);
	            continue;
	          }
	          parents = [node];
	          for (parent = node.parent; parent && !schema.isValidChild(parent.name, node.name) && !nonSplitableElements[parent.name]; parent = parent.parent) {
	            parents.push(parent);
	          }
	          if (parent && parents.length > 1) {
	            parents.reverse();
	            newParent = currentNode = filterNode(parents[0].clone());
	            for (i = 0; i < parents.length - 1; i++) {
	              if (schema.isValidChild(currentNode.name, parents[i].name)) {
	                tempNode = filterNode(parents[i].clone());
	                currentNode.append(tempNode);
	              } else {
	                tempNode = currentNode;
	              }
	              for (childNode = parents[i].firstChild; childNode && childNode !== parents[i + 1];) {
	                nextNode = childNode.next;
	                tempNode.append(childNode);
	                childNode = nextNode;
	              }
	              currentNode = tempNode;
	            }
	            if (!isEmpty$1(schema, nonEmptyElements, whitespaceElements, newParent)) {
	              parent.insert(newParent, parents[0], true);
	              parent.insert(node, newParent);
	            } else {
	              parent.insert(node, parents[0], true);
	            }
	            parent = parents[0];
	            if (isEmpty$1(schema, nonEmptyElements, whitespaceElements, parent) || hasOnlyChild(parent, 'br')) {
	              parent.empty().remove();
	            }
	          } else if (node.parent) {
	            if (node.name === 'li') {
	              sibling = node.prev;
	              if (sibling && (sibling.name === 'ul' || sibling.name === 'ul')) {
	                sibling.append(node);
	                continue;
	              }
	              sibling = node.next;
	              if (sibling && (sibling.name === 'ul' || sibling.name === 'ul')) {
	                sibling.insert(node, sibling.firstChild, true);
	                continue;
	              }
	              node.wrap(filterNode(new Node$1('ul', 1)));
	              continue;
	            }
	            if (schema.isValidChild(node.parent.name, 'div') && schema.isValidChild('div', node.name)) {
	              node.wrap(filterNode(new Node$1('div', 1)));
	            } else {
	              if (specialElements[node.name]) {
	                node.empty().remove();
	              } else {
	                node.unwrap();
	              }
	            }
	          }
	        }
	      };
	      var filterNode = function (node) {
	        var i, name, list;
	        name = node.name;
	        if (name in nodeFilters) {
	          list = matchedNodes[name];
	          if (list) {
	            list.push(node);
	          } else {
	            matchedNodes[name] = [node];
	          }
	        }
	        i = attributeFilters.length;
	        while (i--) {
	          name = attributeFilters[i].name;
	          if (name in node.attributes.map) {
	            list = matchedAttributes[name];
	            if (list) {
	              list.push(node);
	            } else {
	              matchedAttributes[name] = [node];
	            }
	          }
	        }
	        return node;
	      };
	      var addNodeFilter = function (name, callback) {
	        each$8(explode$2(name), function (name) {
	          var list = nodeFilters[name];
	          if (!list) {
	            nodeFilters[name] = list = [];
	          }
	          list.push(callback);
	        });
	      };
	      var getNodeFilters = function () {
	        var out = [];
	        for (var name_1 in nodeFilters) {
	          if (nodeFilters.hasOwnProperty(name_1)) {
	            out.push({
	              name: name_1,
	              callbacks: nodeFilters[name_1]
	            });
	          }
	        }
	        return out;
	      };
	      var addAttributeFilter = function (name, callback) {
	        each$8(explode$2(name), function (name) {
	          var i;
	          for (i = 0; i < attributeFilters.length; i++) {
	            if (attributeFilters[i].name === name) {
	              attributeFilters[i].callbacks.push(callback);
	              return;
	            }
	          }
	          attributeFilters.push({
	            name: name,
	            callbacks: [callback]
	          });
	        });
	      };
	      var getAttributeFilters = function () {
	        return [].concat(attributeFilters);
	      };
	      var parse = function (html, args) {
	        var parser, nodes, i, l, fi, fl, list, name;
	        var blockElements;
	        var invalidChildren = [];
	        var isInWhiteSpacePreservedElement;
	        var node;
	        var getRootBlockName = function (name) {
	          if (name === false) {
	            return '';
	          } else if (name === true) {
	            return 'p';
	          } else {
	            return name;
	          }
	        };
	        args = args || {};
	        matchedNodes = {};
	        matchedAttributes = {};
	        blockElements = extend$2(makeMap$4('script,style,head,html,body,title,meta,param'), schema.getBlockElements());
	        var nonEmptyElements = schema.getNonEmptyElements();
	        var children = schema.children;
	        var validate = settings.validate;
	        var forcedRootBlockName = 'forced_root_block' in args ? args.forced_root_block : settings.forced_root_block;
	        var rootBlockName = getRootBlockName(forcedRootBlockName);
	        var whiteSpaceElements = schema.getWhiteSpaceElements();
	        var startWhiteSpaceRegExp = /^[ \t\r\n]+/;
	        var endWhiteSpaceRegExp = /[ \t\r\n]+$/;
	        var allWhiteSpaceRegExp = /[ \t\r\n]+/g;
	        var isAllWhiteSpaceRegExp = /^[ \t\r\n]+$/;
	        isInWhiteSpacePreservedElement = whiteSpaceElements.hasOwnProperty(args.context) || whiteSpaceElements.hasOwnProperty(settings.root_name);
	        var addRootBlocks = function () {
	          var node = rootNode.firstChild, next, rootBlockNode;
	          var trim = function (rootBlockNode) {
	            if (rootBlockNode) {
	              node = rootBlockNode.firstChild;
	              if (node && node.type === 3) {
	                node.value = node.value.replace(startWhiteSpaceRegExp, '');
	              }
	              node = rootBlockNode.lastChild;
	              if (node && node.type === 3) {
	                node.value = node.value.replace(endWhiteSpaceRegExp, '');
	              }
	            }
	          };
	          if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {
	            return;
	          }
	          while (node) {
	            next = node.next;
	            if (node.type === 3 || node.type === 1 && node.name !== 'p' && !blockElements[node.name] && !node.attr('data-mce-type')) {
	              if (!rootBlockNode) {
	                rootBlockNode = createNode(rootBlockName, 1);
	                rootBlockNode.attr(settings.forced_root_block_attrs);
	                rootNode.insert(rootBlockNode, node);
	                rootBlockNode.append(node);
	              } else {
	                rootBlockNode.append(node);
	              }
	            } else {
	              trim(rootBlockNode);
	              rootBlockNode = null;
	            }
	            node = next;
	          }
	          trim(rootBlockNode);
	        };
	        var createNode = function (name, type) {
	          var node = new Node$1(name, type);
	          var list;
	          if (name in nodeFilters) {
	            list = matchedNodes[name];
	            if (list) {
	              list.push(node);
	            } else {
	              matchedNodes[name] = [node];
	            }
	          }
	          return node;
	        };
	        var removeWhitespaceBefore = function (node) {
	          var textNode, textNodeNext, textVal, sibling;
	          var blockElements = schema.getBlockElements();
	          for (textNode = node.prev; textNode && textNode.type === 3;) {
	            textVal = textNode.value.replace(endWhiteSpaceRegExp, '');
	            if (textVal.length > 0) {
	              textNode.value = textVal;
	              return;
	            }
	            textNodeNext = textNode.next;
	            if (textNodeNext) {
	              if (textNodeNext.type === 3 && textNodeNext.value.length) {
	                textNode = textNode.prev;
	                continue;
	              }
	              if (!blockElements[textNodeNext.name] && textNodeNext.name !== 'script' && textNodeNext.name !== 'style') {
	                textNode = textNode.prev;
	                continue;
	              }
	            }
	            sibling = textNode.prev;
	            textNode.remove();
	            textNode = sibling;
	          }
	        };
	        var cloneAndExcludeBlocks = function (input) {
	          var name;
	          var output = {};
	          for (name in input) {
	            if (name !== 'li' && name !== 'p') {
	              output[name] = input[name];
	            }
	          }
	          return output;
	        };
	        parser = SaxParser$1({
	          validate: validate,
	          allow_script_urls: settings.allow_script_urls,
	          allow_conditional_comments: settings.allow_conditional_comments,
	          preserve_cdata: settings.preserve_cdata,
	          self_closing_elements: cloneAndExcludeBlocks(schema.getSelfClosingElements()),
	          cdata: function (text) {
	            node.append(createNode('#cdata', 4)).value = text;
	          },
	          text: function (text, raw) {
	            var textNode;
	            if (!isInWhiteSpacePreservedElement) {
	              text = text.replace(allWhiteSpaceRegExp, ' ');
	              if (isLineBreakNode(node.lastChild, blockElements)) {
	                text = text.replace(startWhiteSpaceRegExp, '');
	              }
	            }
	            if (text.length !== 0) {
	              textNode = createNode('#text', 3);
	              textNode.raw = !!raw;
	              node.append(textNode).value = text;
	            }
	          },
	          comment: function (text) {
	            node.append(createNode('#comment', 8)).value = text;
	          },
	          pi: function (name, text) {
	            node.append(createNode(name, 7)).value = text;
	            removeWhitespaceBefore(node);
	          },
	          doctype: function (text) {
	            var newNode;
	            newNode = node.append(createNode('#doctype', 10));
	            newNode.value = text;
	            removeWhitespaceBefore(node);
	          },
	          start: function (name, attrs, empty) {
	            var newNode, attrFiltersLen, elementRule, attrName, parent;
	            elementRule = validate ? schema.getElementRule(name) : {};
	            if (elementRule) {
	              newNode = createNode(elementRule.outputName || name, 1);
	              newNode.attributes = attrs;
	              newNode.shortEnded = empty;
	              node.append(newNode);
	              parent = children[node.name];
	              if (parent && children[newNode.name] && !parent[newNode.name]) {
	                invalidChildren.push(newNode);
	              }
	              attrFiltersLen = attributeFilters.length;
	              while (attrFiltersLen--) {
	                attrName = attributeFilters[attrFiltersLen].name;
	                if (attrName in attrs.map) {
	                  list = matchedAttributes[attrName];
	                  if (list) {
	                    list.push(newNode);
	                  } else {
	                    matchedAttributes[attrName] = [newNode];
	                  }
	                }
	              }
	              if (blockElements[name]) {
	                removeWhitespaceBefore(newNode);
	              }
	              if (!empty) {
	                node = newNode;
	              }
	              if (!isInWhiteSpacePreservedElement && whiteSpaceElements[name]) {
	                isInWhiteSpacePreservedElement = true;
	              }
	            }
	          },
	          end: function (name) {
	            var textNode, elementRule, text, sibling, tempNode;
	            elementRule = validate ? schema.getElementRule(name) : {};
	            if (elementRule) {
	              if (blockElements[name]) {
	                if (!isInWhiteSpacePreservedElement) {
	                  textNode = node.firstChild;
	                  if (textNode && textNode.type === 3) {
	                    text = textNode.value.replace(startWhiteSpaceRegExp, '');
	                    if (text.length > 0) {
	                      textNode.value = text;
	                      textNode = textNode.next;
	                    } else {
	                      sibling = textNode.next;
	                      textNode.remove();
	                      textNode = sibling;
	                      while (textNode && textNode.type === 3) {
	                        text = textNode.value;
	                        sibling = textNode.next;
	                        if (text.length === 0 || isAllWhiteSpaceRegExp.test(text)) {
	                          textNode.remove();
	                          textNode = sibling;
	                        }
	                        textNode = sibling;
	                      }
	                    }
	                  }
	                  textNode = node.lastChild;
	                  if (textNode && textNode.type === 3) {
	                    text = textNode.value.replace(endWhiteSpaceRegExp, '');
	                    if (text.length > 0) {
	                      textNode.value = text;
	                      textNode = textNode.prev;
	                    } else {
	                      sibling = textNode.prev;
	                      textNode.remove();
	                      textNode = sibling;
	                      while (textNode && textNode.type === 3) {
	                        text = textNode.value;
	                        sibling = textNode.prev;
	                        if (text.length === 0 || isAllWhiteSpaceRegExp.test(text)) {
	                          textNode.remove();
	                          textNode = sibling;
	                        }
	                        textNode = sibling;
	                      }
	                    }
	                  }
	                }
	              }
	              if (isInWhiteSpacePreservedElement && whiteSpaceElements[name]) {
	                isInWhiteSpacePreservedElement = false;
	              }
	              if (elementRule.removeEmpty && isEmpty$1(schema, nonEmptyElements, whiteSpaceElements, node)) {
	                if (!node.attr('name') && !node.attr('id')) {
	                  tempNode = node.parent;
	                  if (blockElements[node.name]) {
	                    node.empty().remove();
	                  } else {
	                    node.unwrap();
	                  }
	                  node = tempNode;
	                  return;
	                }
	              }
	              if (elementRule.paddEmpty && (isPaddedWithNbsp(node) || isEmpty$1(schema, nonEmptyElements, whiteSpaceElements, node))) {
	                paddEmptyNode(settings, args, blockElements, node);
	              }
	              node = node.parent;
	            }
	          }
	        }, schema);
	        var rootNode = node = new Node$1(args.context || settings.root_name, 11);
	        parser.parse(html, args.format);
	        if (validate && invalidChildren.length) {
	          if (!args.context) {
	            fixInvalidChildren(invalidChildren);
	          } else {
	            args.invalid = true;
	          }
	        }
	        if (rootBlockName && (rootNode.name === 'body' || args.isRootContent)) {
	          addRootBlocks();
	        }
	        if (!args.invalid) {
	          for (name in matchedNodes) {
	            if (!matchedNodes.hasOwnProperty(name)) {
	              continue;
	            }
	            list = nodeFilters[name];
	            nodes = matchedNodes[name];
	            fi = nodes.length;
	            while (fi--) {
	              if (!nodes[fi].parent) {
	                nodes.splice(fi, 1);
	              }
	            }
	            for (i = 0, l = list.length; i < l; i++) {
	              list[i](nodes, name, args);
	            }
	          }
	          for (i = 0, l = attributeFilters.length; i < l; i++) {
	            list = attributeFilters[i];
	            if (list.name in matchedAttributes) {
	              nodes = matchedAttributes[list.name];
	              fi = nodes.length;
	              while (fi--) {
	                if (!nodes[fi].parent) {
	                  nodes.splice(fi, 1);
	                }
	              }
	              for (fi = 0, fl = list.callbacks.length; fi < fl; fi++) {
	                list.callbacks[fi](nodes, list.name, args);
	              }
	            }
	          }
	        }
	        return rootNode;
	      };
	      var exports = {
	        schema: schema,
	        addAttributeFilter: addAttributeFilter,
	        getAttributeFilters: getAttributeFilters,
	        addNodeFilter: addNodeFilter,
	        getNodeFilters: getNodeFilters,
	        filterNode: filterNode,
	        parse: parse
	      };
	      register$2(exports, settings);
	      LegacyFilter.register(exports, settings);
	      return exports;
	    };
	
	    var register$3 = function (htmlParser, settings, dom) {
	      htmlParser.addAttributeFilter('data-mce-tabindex', function (nodes, name) {
	        var i = nodes.length, node;
	        while (i--) {
	          node = nodes[i];
	          node.attr('tabindex', node.attr('data-mce-tabindex'));
	          node.attr(name, null);
	        }
	      });
	      htmlParser.addAttributeFilter('src,href,style', function (nodes, name) {
	        var i = nodes.length, node, value;
	        var internalName = 'data-mce-' + name;
	        var urlConverter = settings.url_converter;
	        var urlConverterScope = settings.url_converter_scope;
	        while (i--) {
	          node = nodes[i];
	          value = node.attr(internalName);
	          if (value !== undefined) {
	            node.attr(name, value.length > 0 ? value : null);
	            node.attr(internalName, null);
	          } else {
	            value = node.attr(name);
	            if (name === 'style') {
	              value = dom.serializeStyle(dom.parseStyle(value), node.name);
	            } else if (urlConverter) {
	              value = urlConverter.call(urlConverterScope, value, name, node.name);
	            }
	            node.attr(name, value.length > 0 ? value : null);
	          }
	        }
	      });
	      htmlParser.addAttributeFilter('class', function (nodes) {
	        var i = nodes.length, node, value;
	        while (i--) {
	          node = nodes[i];
	          value = node.attr('class');
	          if (value) {
	            value = node.attr('class').replace(/(?:^|\s)mce-item-\w+(?!\S)/g, '');
	            node.attr('class', value.length > 0 ? value : null);
	          }
	        }
	      });
	      htmlParser.addAttributeFilter('data-mce-type', function (nodes, name, args) {
	        var i = nodes.length, node;
	        while (i--) {
	          node = nodes[i];
	          if (node.attr('data-mce-type') === 'bookmark' && !args.cleanup) {
	            var hasChildren = Option.from(node.firstChild).exists(function (firstChild) {
	              return !Zwsp.isZwsp(firstChild.value);
	            });
	            if (hasChildren) {
	              node.unwrap();
	            } else {
	              node.remove();
	            }
	          }
	        }
	      });
	      htmlParser.addNodeFilter('noscript', function (nodes) {
	        var i = nodes.length, node;
	        while (i--) {
	          node = nodes[i].firstChild;
	          if (node) {
	            node.value = Entities.decode(node.value);
	          }
	        }
	      });
	      htmlParser.addNodeFilter('script,style', function (nodes, name) {
	        var i = nodes.length, node, value, type;
	        var trim = function (value) {
	          return value.replace(/(<!--\[CDATA\[|\]\]-->)/g, '\n').replace(/^[\r\n]*|[\r\n]*$/g, '').replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, '').replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, '');
	        };
	        while (i--) {
	          node = nodes[i];
	          value = node.firstChild ? node.firstChild.value : '';
	          if (name === 'script') {
	            type = node.attr('type');
	            if (type) {
	              node.attr('type', type === 'mce-no/type' ? null : type.replace(/^mce\-/, ''));
	            }
	            if (settings.element_format === 'xhtml' && value.length > 0) {
	              node.firstChild.value = '// <![CDATA[\n' + trim(value) + '\n// ]]>';
	            }
	          } else {
	            if (settings.element_format === 'xhtml' && value.length > 0) {
	              node.firstChild.value = '<!--\n' + trim(value) + '\n-->';
	            }
	          }
	        }
	      });
	      htmlParser.addNodeFilter('#comment', function (nodes) {
	        var i = nodes.length, node;
	        while (i--) {
	          node = nodes[i];
	          if (settings.preserve_cdata && node.value.indexOf('[CDATA[') === 0) {
	            node.name = '#cdata';
	            node.type = 4;
	            node.value = dom.decode(node.value.replace(/^\[CDATA\[|\]\]$/g, ''));
	          } else if (node.value.indexOf('mce:protected ') === 0) {
	            node.name = '#text';
	            node.type = 3;
	            node.raw = true;
	            node.value = unescape(node.value).substr(14);
	          }
	        }
	      });
	      htmlParser.addNodeFilter('xml:namespace,input', function (nodes, name) {
	        var i = nodes.length, node;
	        while (i--) {
	          node = nodes[i];
	          if (node.type === 7) {
	            node.remove();
	          } else if (node.type === 1) {
	            if (name === 'input' && !node.attr('type')) {
	              node.attr('type', 'text');
	            }
	          }
	        }
	      });
	      htmlParser.addAttributeFilter('data-mce-type', function (nodes) {
	        each(nodes, function (node) {
	          if (node.attr('data-mce-type') === 'format-caret') {
	            if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) {
	              node.remove();
	            } else {
	              node.unwrap();
	            }
	          }
	        });
	      });
	      htmlParser.addAttributeFilter('data-mce-src,data-mce-href,data-mce-style,' + 'data-mce-selected,data-mce-expando,' + 'data-mce-type,data-mce-resize,data-mce-placeholder', function (nodes, name) {
	        var i = nodes.length;
	        while (i--) {
	          nodes[i].attr(name, null);
	        }
	      });
	    };
	    var trimTrailingBr = function (rootNode) {
	      var brNode1, brNode2;
	      var isBr = function (node) {
	        return node && node.name === 'br';
	      };
	      brNode1 = rootNode.lastChild;
	      if (isBr(brNode1)) {
	        brNode2 = brNode1.prev;
	        if (isBr(brNode2)) {
	          brNode1.remove();
	          brNode2.remove();
	        }
	      }
	    };
	    var DomSerializerFilters = {
	      register: register$3,
	      trimTrailingBr: trimTrailingBr
	    };
	
	    var preProcess = function (editor, node, args) {
	      var impl, doc, oldDoc;
	      var dom = editor.dom;
	      node = node.cloneNode(true);
	      impl = domGlobals.document.implementation;
	      if (impl.createHTMLDocument) {
	        doc = impl.createHTMLDocument('');
	        Tools.each(node.nodeName === 'BODY' ? node.childNodes : [node], function (node) {
	          doc.body.appendChild(doc.importNode(node, true));
	        });
	        if (node.nodeName !== 'BODY') {
	          node = doc.body.firstChild;
	        } else {
	          node = doc.body;
	        }
	        oldDoc = dom.doc;
	        dom.doc = doc;
	      }
	      firePreProcess(editor, __assign(__assign({}, args), { node: node }));
	      if (oldDoc) {
	        dom.doc = oldDoc;
	      }
	      return node;
	    };
	    var shouldFireEvent = function (editor, args) {
	      return editor && editor.hasEventListeners('PreProcess') && !args.no_events;
	    };
	    var process = function (editor, node, args) {
	      return shouldFireEvent(editor, args) ? preProcess(editor, node, args) : node;
	    };
	    var DomSerializerPreProcess = { process: process };
	
	    var addTempAttr = function (htmlParser, tempAttrs, name) {
	      if (Tools.inArray(tempAttrs, name) === -1) {
	        htmlParser.addAttributeFilter(name, function (nodes, name) {
	          var i = nodes.length;
	          while (i--) {
	            nodes[i].attr(name, null);
	          }
	        });
	        tempAttrs.push(name);
	      }
	    };
	    var postProcess = function (editor, args, content) {
	      if (!args.no_events && editor) {
	        var outArgs = firePostProcess(editor, __assign(__assign({}, args), { content: content }));
	        return outArgs.content;
	      } else {
	        return content;
	      }
	    };
	    var getHtmlFromNode = function (dom, node, args) {
	      var html = Zwsp.trim(args.getInner ? node.innerHTML : dom.getOuterHTML(node));
	      return args.selection || isWsPreserveElement(Element.fromDom(node)) ? html : Tools.trim(html);
	    };
	    var parseHtml = function (htmlParser, html, args) {
	      var parserArgs = args.selection ? __assign({ forced_root_block: false }, args) : args;
	      var rootNode = htmlParser.parse(html, parserArgs);
	      DomSerializerFilters.trimTrailingBr(rootNode);
	      return rootNode;
	    };
	    var serializeNode = function (settings, schema, node) {
	      var htmlSerializer = Serializer(settings, schema);
	      return htmlSerializer.serialize(node);
	    };
	    var toHtml = function (editor, settings, schema, rootNode, args) {
	      var content = serializeNode(settings, schema, rootNode);
	      return postProcess(editor, args, content);
	    };
	    var DomSerializer = function (settings, editor) {
	      var tempAttrs = ['data-mce-selected'];
	      var dom = editor && editor.dom ? editor.dom : DOMUtils$1.DOM;
	      var schema = editor && editor.schema ? editor.schema : Schema(settings);
	      settings.entity_encoding = settings.entity_encoding || 'named';
	      settings.remove_trailing_brs = 'remove_trailing_brs' in settings ? settings.remove_trailing_brs : true;
	      var htmlParser = DomParser(settings, schema);
	      DomSerializerFilters.register(htmlParser, settings, dom);
	      var serialize = function (node, parserArgs) {
	        if (parserArgs === void 0) {
	          parserArgs = {};
	        }
	        var args = __assign({ format: 'html' }, parserArgs);
	        var targetNode = DomSerializerPreProcess.process(editor, node, args);
	        var html = getHtmlFromNode(dom, targetNode, args);
	        var rootNode = parseHtml(htmlParser, html, args);
	        return args.format === 'tree' ? rootNode : toHtml(editor, settings, schema, rootNode, args);
	      };
	      return {
	        schema: schema,
	        addNodeFilter: htmlParser.addNodeFilter,
	        addAttributeFilter: htmlParser.addAttributeFilter,
	        serialize: serialize,
	        addRules: function (rules) {
	          schema.addValidElements(rules);
	        },
	        setRules: function (rules) {
	          schema.setValidElements(rules);
	        },
	        addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),
	        getTempAttrs: function () {
	          return tempAttrs;
	        },
	        getNodeFilters: htmlParser.getNodeFilters,
	        getAttributeFilters: htmlParser.getAttributeFilters
	      };
	    };
	
	    var Serializer$1 = function (settings, editor) {
	      var domSerializer = DomSerializer(settings, editor);
	      return {
	        schema: domSerializer.schema,
	        addNodeFilter: domSerializer.addNodeFilter,
	        addAttributeFilter: domSerializer.addAttributeFilter,
	        serialize: domSerializer.serialize,
	        addRules: domSerializer.addRules,
	        setRules: domSerializer.setRules,
	        addTempAttr: domSerializer.addTempAttr,
	        getTempAttrs: domSerializer.getTempAttrs,
	        getNodeFilters: domSerializer.getNodeFilters,
	        getAttributeFilters: domSerializer.getAttributeFilters
	      };
	    };
	
	    var blobUriToBlob = function (url) {
	      return new promiseObj(function (resolve, reject) {
	        var rejectWithError = function () {
	          reject('Cannot convert ' + url + ' to Blob. Resource might not exist or is inaccessible.');
	        };
	        try {
	          var xhr = new domGlobals.XMLHttpRequest();
	          xhr.open('GET', url, true);
	          xhr.responseType = 'blob';
	          xhr.onload = function () {
	            if (this.status === 200) {
	              resolve(this.response);
	            } else {
	              rejectWithError();
	            }
	          };
	          xhr.onerror = rejectWithError;
	          xhr.send();
	        } catch (ex) {
	          rejectWithError();
	        }
	      });
	    };
	    var parseDataUri = function (uri) {
	      var type, matches;
	      var uriParts = decodeURIComponent(uri).split(',');
	      matches = /data:([^;]+)/.exec(uriParts[0]);
	      if (matches) {
	        type = matches[1];
	      }
	      return {
	        type: type,
	        data: uriParts[1]
	      };
	    };
	    var dataUriToBlob = function (uri) {
	      return new promiseObj(function (resolve) {
	        var str, arr, i;
	        var uriParts = parseDataUri(uri);
	        try {
	          str = domGlobals.atob(uriParts.data);
	        } catch (e) {
	          resolve(new domGlobals.Blob([]));
	          return;
	        }
	        arr = new Uint8Array(str.length);
	        for (i = 0; i < arr.length; i++) {
	          arr[i] = str.charCodeAt(i);
	        }
	        resolve(new domGlobals.Blob([arr], { type: uriParts.type }));
	      });
	    };
	    var uriToBlob = function (url) {
	      if (url.indexOf('blob:') === 0) {
	        return blobUriToBlob(url);
	      }
	      if (url.indexOf('data:') === 0) {
	        return dataUriToBlob(url);
	      }
	      return null;
	    };
	    var blobToDataUri = function (blob) {
	      return new promiseObj(function (resolve) {
	        var reader = new domGlobals.FileReader();
	        reader.onloadend = function () {
	          resolve(reader.result);
	        };
	        reader.readAsDataURL(blob);
	      });
	    };
	    var Conversions = {
	      uriToBlob: uriToBlob,
	      blobToDataUri: blobToDataUri,
	      parseDataUri: parseDataUri
	    };
	
	    var count = 0;
	    var uniqueId = function (prefix) {
	      return (prefix || 'blobid') + count++;
	    };
	    var imageToBlobInfo = function (blobCache, img, resolve, reject) {
	      var base64, blobInfo;
	      if (img.src.indexOf('blob:') === 0) {
	        blobInfo = blobCache.getByUri(img.src);
	        if (blobInfo) {
	          resolve({
	            image: img,
	            blobInfo: blobInfo
	          });
	        } else {
	          Conversions.uriToBlob(img.src).then(function (blob) {
	            Conversions.blobToDataUri(blob).then(function (dataUri) {
	              base64 = Conversions.parseDataUri(dataUri).data;
	              blobInfo = blobCache.create(uniqueId(), blob, base64);
	              blobCache.add(blobInfo);
	              resolve({
	                image: img,
	                blobInfo: blobInfo
	              });
	            });
	          }, function (err) {
	            reject(err);
	          });
	        }
	        return;
	      }
	      base64 = Conversions.parseDataUri(img.src).data;
	      blobInfo = blobCache.findFirst(function (cachedBlobInfo) {
	        return cachedBlobInfo.base64() === base64;
	      });
	      if (blobInfo) {
	        resolve({
	          image: img,
	          blobInfo: blobInfo
	        });
	      } else {
	        Conversions.uriToBlob(img.src).then(function (blob) {
	          blobInfo = blobCache.create(uniqueId(), blob, base64);
	          blobCache.add(blobInfo);
	          resolve({
	            image: img,
	            blobInfo: blobInfo
	          });
	        }, function (err) {
	          reject(err);
	        });
	      }
	    };
	    var getAllImages = function (elm) {
	      return elm ? from$1(elm.getElementsByTagName('img')) : [];
	    };
	    function ImageScanner(uploadStatus, blobCache) {
	      var cachedPromises = {};
	      var findAll = function (elm, predicate) {
	        var images;
	        if (!predicate) {
	          predicate = constant(true);
	        }
	        images = filter(getAllImages(elm), function (img) {
	          var src = img.src;
	          if (!Env.fileApi) {
	            return false;
	          }
	          if (img.hasAttribute('data-mce-bogus')) {
	            return false;
	          }
	          if (img.hasAttribute('data-mce-placeholder')) {
	            return false;
	          }
	          if (!src || src === Env.transparentSrc) {
	            return false;
	          }
	          if (src.indexOf('blob:') === 0) {
	            return !uploadStatus.isUploaded(src) && predicate(img);
	          }
	          if (src.indexOf('data:') === 0) {
	            return predicate(img);
	          }
	          return false;
	        });
	        var promises = map(images, function (img) {
	          if (cachedPromises[img.src]) {
	            return new promiseObj(function (resolve) {
	              cachedPromises[img.src].then(function (imageInfo) {
	                if (typeof imageInfo === 'string') {
	                  return imageInfo;
	                }
	                resolve({
	                  image: img,
	                  blobInfo: imageInfo.blobInfo
	                });
	              });
	            });
	          }
	          var newPromise = new promiseObj(function (resolve, reject) {
	            imageToBlobInfo(blobCache, img, resolve, reject);
	          }).then(function (result) {
	            delete cachedPromises[result.image.src];
	            return result;
	          }).catch(function (error) {
	            delete cachedPromises[img.src];
	            return error;
	          });
	          cachedPromises[img.src] = newPromise;
	          return newPromise;
	        });
	        return promiseObj.all(promises);
	      };
	      return { findAll: findAll };
	    }
	
	    function Uploader(uploadStatus, settings) {
	      var pendingPromises = {};
	      var pathJoin = function (path1, path2) {
	        if (path1) {
	          return path1.replace(/\/$/, '') + '/' + path2.replace(/^\//, '');
	        }
	        return path2;
	      };
	      var defaultHandler = function (blobInfo, success, failure, progress) {
	        var xhr, formData;
	        xhr = new domGlobals.XMLHttpRequest();
	        xhr.open('POST', settings.url);
	        xhr.withCredentials = settings.credentials;
	        xhr.upload.onprogress = function (e) {
	          progress(e.loaded / e.total * 100);
	        };
	        xhr.onerror = function () {
	          failure('Image upload failed due to a XHR Transport error. Code: ' + xhr.status);
	        };
	        xhr.onload = function () {
	          var json;
	          if (xhr.status < 200 || xhr.status >= 300) {
	            failure('HTTP Error: ' + xhr.status);
	            return;
	          }
	          json = JSON.parse(xhr.responseText);
	          if (!json || typeof json.location !== 'string') {
	            failure('Invalid JSON: ' + xhr.responseText);
	            return;
	          }
	          success(pathJoin(settings.basePath, json.location));
	        };
	        formData = new domGlobals.FormData();
	        formData.append('file', blobInfo.blob(), blobInfo.filename());
	        xhr.send(formData);
	      };
	      var noUpload = function () {
	        return new promiseObj(function (resolve) {
	          resolve([]);
	        });
	      };
	      var handlerSuccess = function (blobInfo, url) {
	        return {
	          url: url,
	          blobInfo: blobInfo,
	          status: true
	        };
	      };
	      var handlerFailure = function (blobInfo, error) {
	        return {
	          url: '',
	          blobInfo: blobInfo,
	          status: false,
	          error: error
	        };
	      };
	      var resolvePending = function (blobUri, result) {
	        Tools.each(pendingPromises[blobUri], function (resolve) {
	          resolve(result);
	        });
	        delete pendingPromises[blobUri];
	      };
	      var uploadBlobInfo = function (blobInfo, handler, openNotification) {
	        uploadStatus.markPending(blobInfo.blobUri());
	        return new promiseObj(function (resolve) {
	          var notification, progress;
	          var noop = function () {
	          };
	          try {
	            var closeNotification_1 = function () {
	              if (notification) {
	                notification.close();
	                progress = noop;
	              }
	            };
	            var success = function (url) {
	              closeNotification_1();
	              uploadStatus.markUploaded(blobInfo.blobUri(), url);
	              resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));
	              resolve(handlerSuccess(blobInfo, url));
	            };
	            var failure = function (error) {
	              closeNotification_1();
	              uploadStatus.removeFailed(blobInfo.blobUri());
	              resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error));
	              resolve(handlerFailure(blobInfo, error));
	            };
	            progress = function (percent) {
	              if (percent < 0 || percent > 100) {
	                return;
	              }
	              if (!notification) {
	                notification = openNotification();
	              }
	              notification.progressBar.value(percent);
	            };
	            handler(blobInfo, success, failure, progress);
	          } catch (ex) {
	            resolve(handlerFailure(blobInfo, ex.message));
	          }
	        });
	      };
	      var isDefaultHandler = function (handler) {
	        return handler === defaultHandler;
	      };
	      var pendingUploadBlobInfo = function (blobInfo) {
	        var blobUri = blobInfo.blobUri();
	        return new promiseObj(function (resolve) {
	          pendingPromises[blobUri] = pendingPromises[blobUri] || [];
	          pendingPromises[blobUri].push(resolve);
	        });
	      };
	      var uploadBlobs = function (blobInfos, openNotification) {
	        blobInfos = Tools.grep(blobInfos, function (blobInfo) {
	          return !uploadStatus.isUploaded(blobInfo.blobUri());
	        });
	        return promiseObj.all(Tools.map(blobInfos, function (blobInfo) {
	          return uploadStatus.isPending(blobInfo.blobUri()) ? pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, settings.handler, openNotification);
	        }));
	      };
	      var upload = function (blobInfos, openNotification) {
	        return !settings.url && isDefaultHandler(settings.handler) ? noUpload() : uploadBlobs(blobInfos, openNotification);
	      };
	      if (isFunction(settings.handler) === false) {
	        settings.handler = defaultHandler;
	      }
	      return { upload: upload };
	    }
	
	    function UploadStatus () {
	      var PENDING = 1, UPLOADED = 2;
	      var blobUriStatuses = {};
	      var createStatus = function (status, resultUri) {
	        return {
	          status: status,
	          resultUri: resultUri
	        };
	      };
	      var hasBlobUri = function (blobUri) {
	        return blobUri in blobUriStatuses;
	      };
	      var getResultUri = function (blobUri) {
	        var result = blobUriStatuses[blobUri];
	        return result ? result.resultUri : null;
	      };
	      var isPending = function (blobUri) {
	        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;
	      };
	      var isUploaded = function (blobUri) {
	        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;
	      };
	      var markPending = function (blobUri) {
	        blobUriStatuses[blobUri] = createStatus(PENDING, null);
	      };
	      var markUploaded = function (blobUri, resultUri) {
	        blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);
	      };
	      var removeFailed = function (blobUri) {
	        delete blobUriStatuses[blobUri];
	      };
	      var destroy = function () {
	        blobUriStatuses = {};
	      };
	      return {
	        hasBlobUri: hasBlobUri,
	        getResultUri: getResultUri,
	        isPending: isPending,
	        isUploaded: isUploaded,
	        markPending: markPending,
	        markUploaded: markUploaded,
	        removeFailed: removeFailed,
	        destroy: destroy
	      };
	    }
	
	    var count$1 = 0;
	    var seed = function () {
	      var rnd = function () {
	        return Math.round(Math.random() * 4294967295).toString(36);
	      };
	      var now = new Date().getTime();
	      return 's' + now.toString(36) + rnd() + rnd() + rnd();
	    };
	    var uuid = function (prefix) {
	      return prefix + count$1++ + seed();
	    };
	    var Uuid = { uuid: uuid };
	
	    var BlobCache = function () {
	      var cache = [];
	      var mimeToExt = function (mime) {
	        var mimes = {
	          'image/jpeg': 'jpg',
	          'image/jpg': 'jpg',
	          'image/gif': 'gif',
	          'image/png': 'png'
	        };
	        return mimes[mime.toLowerCase()] || 'dat';
	      };
	      var create = function (o, blob, base64, filename) {
	        if (isString(o)) {
	          var id = o;
	          return toBlobInfo({
	            id: id,
	            name: filename,
	            blob: blob,
	            base64: base64
	          });
	        } else if (isObject(o)) {
	          return toBlobInfo(o);
	        } else {
	          throw new Error('Unknown input type');
	        }
	      };
	      var toBlobInfo = function (o) {
	        var id, name;
	        if (!o.blob || !o.base64) {
	          throw new Error('blob and base64 representations of the image are required for BlobInfo to be created');
	        }
	        id = o.id || Uuid.uuid('blobid');
	        name = o.name || id;
	        return {
	          id: constant(id),
	          name: constant(name),
	          filename: constant(name + '.' + mimeToExt(o.blob.type)),
	          blob: constant(o.blob),
	          base64: constant(o.base64),
	          blobUri: constant(o.blobUri || domGlobals.URL.createObjectURL(o.blob)),
	          uri: constant(o.uri)
	        };
	      };
	      var add = function (blobInfo) {
	        if (!get(blobInfo.id())) {
	          cache.push(blobInfo);
	        }
	      };
	      var get = function (id) {
	        return findFirst(function (cachedBlobInfo) {
	          return cachedBlobInfo.id() === id;
	        });
	      };
	      var findFirst = function (predicate) {
	        return filter(cache, predicate)[0];
	      };
	      var getByUri = function (blobUri) {
	        return findFirst(function (blobInfo) {
	          return blobInfo.blobUri() === blobUri;
	        });
	      };
	      var removeByUri = function (blobUri) {
	        cache = filter(cache, function (blobInfo) {
	          if (blobInfo.blobUri() === blobUri) {
	            domGlobals.URL.revokeObjectURL(blobInfo.blobUri());
	            return false;
	          }
	          return true;
	        });
	      };
	      var destroy = function () {
	        each(cache, function (cachedBlobInfo) {
	          domGlobals.URL.revokeObjectURL(cachedBlobInfo.blobUri());
	        });
	        cache = [];
	      };
	      return {
	        create: create,
	        add: add,
	        get: get,
	        getByUri: getByUri,
	        findFirst: findFirst,
	        removeByUri: removeByUri,
	        destroy: destroy
	      };
	    };
	
	    var EditorUpload = function (editor) {
	      var blobCache = BlobCache();
	      var uploader, imageScanner;
	      var uploadStatus = UploadStatus();
	      var urlFilters = [];
	      var aliveGuard = function (callback) {
	        return function (result) {
	          if (editor.selection) {
	            return callback(result);
	          }
	          return [];
	        };
	      };
	      var cacheInvalidator = function (url) {
	        return url + (url.indexOf('?') === -1 ? '?' : '&') + new Date().getTime();
	      };
	      var replaceString = function (content, search, replace) {
	        var index = 0;
	        do {
	          index = content.indexOf(search, index);
	          if (index !== -1) {
	            content = content.substring(0, index) + replace + content.substr(index + search.length);
	            index += replace.length - search.length + 1;
	          }
	        } while (index !== -1);
	        return content;
	      };
	      var replaceImageUrl = function (content, targetUrl, replacementUrl) {
	        content = replaceString(content, 'src="' + targetUrl + '"', 'src="' + replacementUrl + '"');
	        content = replaceString(content, 'data-mce-src="' + targetUrl + '"', 'data-mce-src="' + replacementUrl + '"');
	        return content;
	      };
	      var replaceUrlInUndoStack = function (targetUrl, replacementUrl) {
	        each(editor.undoManager.data, function (level) {
	          if (level.type === 'fragmented') {
	            level.fragments = map(level.fragments, function (fragment) {
	              return replaceImageUrl(fragment, targetUrl, replacementUrl);
	            });
	          } else {
	            level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);
	          }
	        });
	      };
	      var openNotification = function () {
	        return editor.notificationManager.open({
	          text: editor.translate('Image uploading...'),
	          type: 'info',
	          timeout: -1,
	          progressBar: true
	        });
	      };
	      var replaceImageUri = function (image, resultUri) {
	        blobCache.removeByUri(image.src);
	        replaceUrlInUndoStack(image.src, resultUri);
	        editor.$(image).attr({
	          'src': Settings.shouldReuseFileName(editor) ? cacheInvalidator(resultUri) : resultUri,
	          'data-mce-src': editor.convertURL(resultUri, 'src')
	        });
	      };
	      var uploadImages = function (callback) {
	        if (!uploader) {
	          uploader = Uploader(uploadStatus, {
	            url: Settings.getImageUploadUrl(editor),
	            basePath: Settings.getImageUploadBasePath(editor),
	            credentials: Settings.getImagesUploadCredentials(editor),
	            handler: Settings.getImagesUploadHandler(editor)
	          });
	        }
	        return scanForImages().then(aliveGuard(function (imageInfos) {
	          var blobInfos = map(imageInfos, function (imageInfo) {
	            return imageInfo.blobInfo;
	          });
	          return uploader.upload(blobInfos, openNotification).then(aliveGuard(function (result) {
	            var filteredResult = map(result, function (uploadInfo, index) {
	              var image = imageInfos[index].image;
	              if (uploadInfo.status && Settings.shouldReplaceBlobUris(editor)) {
	                replaceImageUri(image, uploadInfo.url);
	              } else if (uploadInfo.error) {
	                ErrorReporter.uploadError(editor, uploadInfo.error);
	              }
	              return {
	                element: image,
	                status: uploadInfo.status
	              };
	            });
	            if (callback) {
	              callback(filteredResult);
	            }
	            return filteredResult;
	          }));
	        }));
	      };
	      var uploadImagesAuto = function (callback) {
	        if (Settings.isAutomaticUploadsEnabled(editor)) {
	          return uploadImages(callback);
	        }
	      };
	      var isValidDataUriImage = function (imgElm) {
	        if (forall(urlFilters, function (filter) {
	            return filter(imgElm);
	          }) === false) {
	          return false;
	        }
	        if (imgElm.getAttribute('src').indexOf('data:') === 0) {
	          var dataImgFilter = Settings.getImagesDataImgFilter(editor);
	          return dataImgFilter(imgElm);
	        }
	        return true;
	      };
	      var addFilter = function (filter) {
	        urlFilters.push(filter);
	      };
	      var scanForImages = function () {
	        if (!imageScanner) {
	          imageScanner = ImageScanner(uploadStatus, blobCache);
	        }
	        return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard(function (result) {
	          result = filter(result, function (resultItem) {
	            if (typeof resultItem === 'string') {
	              ErrorReporter.displayError(editor, resultItem);
	              return false;
	            }
	            return true;
	          });
	          each(result, function (resultItem) {
	            replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());
	            resultItem.image.src = resultItem.blobInfo.blobUri();
	            resultItem.image.removeAttribute('data-mce-src');
	          });
	          return result;
	        }));
	      };
	      var destroy = function () {
	        blobCache.destroy();
	        uploadStatus.destroy();
	        imageScanner = uploader = null;
	      };
	      var replaceBlobUris = function (content) {
	        return content.replace(/src="(blob:[^"]+)"/g, function (match, blobUri) {
	          var resultUri = uploadStatus.getResultUri(blobUri);
	          if (resultUri) {
	            return 'src="' + resultUri + '"';
	          }
	          var blobInfo = blobCache.getByUri(blobUri);
	          if (!blobInfo) {
	            blobInfo = foldl(editor.editorManager.get(), function (result, editor) {
	              return result || editor.editorUpload && editor.editorUpload.blobCache.getByUri(blobUri);
	            }, null);
	          }
	          if (blobInfo) {
	            var blob = blobInfo.blob();
	            return 'src="data:' + blob.type + ';base64,' + blobInfo.base64() + '"';
	          }
	          return match;
	        });
	      };
	      editor.on('SetContent', function () {
	        if (Settings.isAutomaticUploadsEnabled(editor)) {
	          uploadImagesAuto();
	        } else {
	          scanForImages();
	        }
	      });
	      editor.on('RawSaveContent', function (e) {
	        e.content = replaceBlobUris(e.content);
	      });
	      editor.on('GetContent', function (e) {
	        if (e.source_view || e.format === 'raw') {
	          return;
	        }
	        e.content = replaceBlobUris(e.content);
	      });
	      editor.on('PostRender', function () {
	        editor.parser.addNodeFilter('img', function (images) {
	          each(images, function (img) {
	            var src = img.attr('src');
	            if (blobCache.getByUri(src)) {
	              return;
	            }
	            var resultUri = uploadStatus.getResultUri(src);
	            if (resultUri) {
	              img.attr('src', resultUri);
	            }
	          });
	        });
	      });
	      return {
	        blobCache: blobCache,
	        addFilter: addFilter,
	        uploadImages: uploadImages,
	        uploadImagesAuto: uploadImagesAuto,
	        scanForImages: scanForImages,
	        destroy: destroy
	      };
	    };
	
	    var getLastChildren$1 = function (elm) {
	      var children = [];
	      var rawNode = elm.dom();
	      while (rawNode) {
	        children.push(Element.fromDom(rawNode));
	        rawNode = rawNode.lastChild;
	      }
	      return children;
	    };
	    var removeTrailingBr = function (elm) {
	      var allBrs = descendants$1(elm, 'br');
	      var brs = filter(getLastChildren$1(elm).slice(-1), isBr$1);
	      if (allBrs.length === brs.length) {
	        each(brs, remove);
	      }
	    };
	    var fillWithPaddingBr = function (elm) {
	      empty(elm);
	      append(elm, Element.fromHtml('<br data-mce-bogus="1">'));
	    };
	    var isPaddingContents = function (elm) {
	      return isText(elm) ? get$7(elm) === nbsp : isBr$1(elm);
	    };
	    var isPaddedElement = function (elm) {
	      return filter(children(elm), isPaddingContents).length === 1;
	    };
	    var trimBlockTrailingBr = function (elm) {
	      lastChild(elm).each(function (lastChild) {
	        prevSibling(lastChild).each(function (lastChildPrevSibling) {
	          if (isBlock(elm) && isBr$1(lastChild) && isBlock(lastChildPrevSibling)) {
	            remove(lastChild);
	          }
	        });
	      });
	    };
	    var PaddingBr = {
	      removeTrailingBr: removeTrailingBr,
	      fillWithPaddingBr: fillWithPaddingBr,
	      isPaddedElement: isPaddedElement,
	      trimBlockTrailingBr: trimBlockTrailingBr
	    };
	
	    var isEq$2 = isEq;
	    var matchesUnInheritedFormatSelector = function (ed, node, name) {
	      var formatList = ed.formatter.get(name);
	      if (formatList) {
	        for (var i = 0; i < formatList.length; i++) {
	          if (formatList[i].inherit === false && ed.dom.is(node, formatList[i].selector)) {
	            return true;
	          }
	        }
	      }
	      return false;
	    };
	    var matchParents = function (editor, node, name, vars) {
	      var root = editor.dom.getRoot();
	      if (node === root) {
	        return false;
	      }
	      node = editor.dom.getParent(node, function (node) {
	        if (matchesUnInheritedFormatSelector(editor, node, name)) {
	          return true;
	        }
	        return node.parentNode === root || !!matchNode(editor, node, name, vars, true);
	      });
	      return matchNode(editor, node, name, vars);
	    };
	    var matchName = function (dom, node, format) {
	      if (isEq$2(node, format.inline)) {
	        return true;
	      }
	      if (isEq$2(node, format.block)) {
	        return true;
	      }
	      if (format.selector) {
	        return node.nodeType === 1 && dom.is(node, format.selector);
	      }
	    };
	    var matchItems = function (dom, node, format, itemName, similar, vars) {
	      var key, value;
	      var items = format[itemName];
	      var i;
	      if (format.onmatch) {
	        return format.onmatch(node, format, itemName);
	      }
	      if (items) {
	        if (typeof items.length === 'undefined') {
	          for (key in items) {
	            if (items.hasOwnProperty(key)) {
	              if (itemName === 'attributes') {
	                value = dom.getAttrib(node, key);
	              } else {
	                value = getStyle(dom, node, key);
	              }
	              if (similar && !value && !format.exact) {
	                return;
	              }
	              if ((!similar || format.exact) && !isEq$2(value, normalizeStyleValue(dom, replaceVars(items[key], vars), key))) {
	                return;
	              }
	            }
	          }
	        } else {
	          for (i = 0; i < items.length; i++) {
	            if (itemName === 'attributes' ? dom.getAttrib(node, items[i]) : getStyle(dom, node, items[i])) {
	              return format;
	            }
	          }
	        }
	      }
	      return format;
	    };
	    var matchNode = function (ed, node, name, vars, similar) {
	      var formatList = ed.formatter.get(name);
	      var format, i, x, classes;
	      var dom = ed.dom;
	      if (formatList && node) {
	        for (i = 0; i < formatList.length; i++) {
	          format = formatList[i];
	          if (matchName(ed.dom, node, format) && matchItems(dom, node, format, 'attributes', similar, vars) && matchItems(dom, node, format, 'styles', similar, vars)) {
	            if (classes = format.classes) {
	              for (x = 0; x < classes.length; x++) {
	                if (!ed.dom.hasClass(node, classes[x])) {
	                  return;
	                }
	              }
	            }
	            return format;
	          }
	        }
	      }
	    };
	    var match = function (editor, name, vars, node) {
	      var startNode;
	      if (node) {
	        return matchParents(editor, node, name, vars);
	      }
	      node = editor.selection.getNode();
	      if (matchParents(editor, node, name, vars)) {
	        return true;
	      }
	      startNode = editor.selection.getStart();
	      if (startNode !== node) {
	        if (matchParents(editor, startNode, name, vars)) {
	          return true;
	        }
	      }
	      return false;
	    };
	    var matchAll = function (editor, names, vars) {
	      var startElement;
	      var matchedFormatNames = [];
	      var checkedMap = {};
	      startElement = editor.selection.getStart();
	      editor.dom.getParent(startElement, function (node) {
	        var i, name;
	        for (i = 0; i < names.length; i++) {
	          name = names[i];
	          if (!checkedMap[name] && matchNode(editor, node, name, vars)) {
	            checkedMap[name] = true;
	            matchedFormatNames.push(name);
	          }
	        }
	      }, editor.dom.getRoot());
	      return matchedFormatNames;
	    };
	    var canApply = function (editor, name) {
	      var formatList = editor.formatter.get(name);
	      var startNode, parents, i, x, selector;
	      var dom = editor.dom;
	      if (formatList) {
	        startNode = editor.selection.getStart();
	        parents = getParents$1(dom, startNode);
	        for (x = formatList.length - 1; x >= 0; x--) {
	          selector = formatList[x].selector;
	          if (!selector || formatList[x].defaultBlock) {
	            return true;
	          }
	          for (i = parents.length - 1; i >= 0; i--) {
	            if (dom.is(parents[i], selector)) {
	              return true;
	            }
	          }
	        }
	      }
	      return false;
	    };
	
	    var splitText = function (node, offset) {
	      return node.splitText(offset);
	    };
	    var split$1 = function (rng) {
	      var startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;
	      if (startContainer === endContainer && NodeType.isText(startContainer)) {
	        if (startOffset > 0 && startOffset < startContainer.nodeValue.length) {
	          endContainer = splitText(startContainer, startOffset);
	          startContainer = endContainer.previousSibling;
	          if (endOffset > startOffset) {
	            endOffset = endOffset - startOffset;
	            startContainer = endContainer = splitText(endContainer, endOffset).previousSibling;
	            endOffset = endContainer.nodeValue.length;
	            startOffset = 0;
	          } else {
	            endOffset = 0;
	          }
	        }
	      } else {
	        if (NodeType.isText(startContainer) && startOffset > 0 && startOffset < startContainer.nodeValue.length) {
	          startContainer = splitText(startContainer, startOffset);
	          startOffset = 0;
	        }
	        if (NodeType.isText(endContainer) && endOffset > 0 && endOffset < endContainer.nodeValue.length) {
	          endContainer = splitText(endContainer, endOffset).previousSibling;
	          endOffset = endContainer.nodeValue.length;
	        }
	      }
	      return {
	        startContainer: startContainer,
	        startOffset: startOffset,
	        endContainer: endContainer,
	        endOffset: endOffset
	      };
	    };
	
	    var normalizeContent = function (content, isStartOfContent, isEndOfContent) {
	      var result = foldl(content, function (acc, c) {
	        if (isWhiteSpace$1(c) || isNbsp(c)) {
	          if (acc.previousCharIsSpace || acc.str === '' && isStartOfContent || acc.str.length === content.length - 1 && isEndOfContent) {
	            return {
	              previousCharIsSpace: false,
	              str: acc.str + nbsp
	            };
	          } else {
	            return {
	              previousCharIsSpace: true,
	              str: acc.str + ' '
	            };
	          }
	        } else {
	          return {
	            previousCharIsSpace: false,
	            str: acc.str + c
	          };
	        }
	      }, {
	        previousCharIsSpace: false,
	        str: ''
	      });
	      return result.str;
	    };
	    var normalize$1 = function (node, offset, count) {
	      if (count === 0) {
	        return;
	      }
	      var whitespace = node.data.slice(offset, offset + count);
	      var isEndOfContent = offset + count >= node.data.length;
	      var isStartOfContent = offset === 0;
	      node.replaceData(offset, count, normalizeContent(whitespace, isStartOfContent, isEndOfContent));
	    };
	    var normalizeWhitespaceAfter = function (node, offset) {
	      var content = node.data.slice(offset);
	      var whitespaceCount = content.length - lTrim(content).length;
	      return normalize$1(node, offset, whitespaceCount);
	    };
	    var normalizeWhitespaceBefore = function (node, offset) {
	      var content = node.data.slice(0, offset);
	      var whitespaceCount = content.length - rTrim(content).length;
	      return normalize$1(node, offset - whitespaceCount, whitespaceCount);
	    };
	    var mergeTextNodes = function (prevNode, nextNode, normalizeWhitespace) {
	      var whitespaceOffset = rTrim(prevNode.data).length;
	      prevNode.appendData(nextNode.data);
	      remove(Element.fromDom(nextNode));
	      if (normalizeWhitespace) {
	        normalizeWhitespaceAfter(prevNode, whitespaceOffset);
	      }
	      return prevNode;
	    };
	
	    var ancestor$2 = function (scope, selector, isRoot) {
	      return ancestor$1(scope, selector, isRoot).isSome();
	    };
	
	    var hasWhitespacePreserveParent = function (rootNode, node) {
	      var rootElement = Element.fromDom(rootNode);
	      var startNode = Element.fromDom(node);
	      return ancestor$2(startNode, 'pre,code', curry(eq, rootElement));
	    };
	    var isWhitespace = function (rootNode, node) {
	      return NodeType.isText(node) && /^[ \t\r\n]*$/.test(node.data) && hasWhitespacePreserveParent(rootNode, node) === false;
	    };
	    var isNamedAnchor = function (node) {
	      return NodeType.isElement(node) && node.nodeName === 'A' && node.hasAttribute('name');
	    };
	    var isContent$1 = function (rootNode, node) {
	      return isCaretCandidate(node) && isWhitespace(rootNode, node) === false || isNamedAnchor(node) || isBookmark(node);
	    };
	    var isBookmark = NodeType.hasAttribute('data-mce-bookmark');
	    var isBogus$2 = NodeType.hasAttribute('data-mce-bogus');
	    var isBogusAll$1 = NodeType.hasAttributeValue('data-mce-bogus', 'all');
	    var isEmptyNode = function (targetNode, skipBogus) {
	      var node, brCount = 0;
	      if (isContent$1(targetNode, targetNode)) {
	        return false;
	      } else {
	        node = targetNode.firstChild;
	        if (!node) {
	          return true;
	        }
	        var walker = new TreeWalker(node, targetNode);
	        do {
	          if (skipBogus) {
	            if (isBogusAll$1(node)) {
	              node = walker.next(true);
	              continue;
	            }
	            if (isBogus$2(node)) {
	              node = walker.next();
	              continue;
	            }
	          }
	          if (NodeType.isBr(node)) {
	            brCount++;
	            node = walker.next();
	            continue;
	          }
	          if (isContent$1(targetNode, node)) {
	            return false;
	          }
	          node = walker.next();
	        } while (node);
	        return brCount <= 1;
	      }
	    };
	    var isEmpty$2 = function (elm, skipBogus) {
	      if (skipBogus === void 0) {
	        skipBogus = true;
	      }
	      return isEmptyNode(elm.dom(), skipBogus);
	    };
	    var Empty = { isEmpty: isEmpty$2 };
	
	    var needsReposition = function (pos, elm) {
	      var container = pos.container();
	      var offset = pos.offset();
	      return CaretPosition$1.isTextPosition(pos) === false && container === elm.parentNode && offset > CaretPosition$1.before(elm).offset();
	    };
	    var reposition = function (elm, pos) {
	      return needsReposition(pos, elm) ? CaretPosition$1(pos.container(), pos.offset() - 1) : pos;
	    };
	    var beforeOrStartOf = function (node) {
	      return NodeType.isText(node) ? CaretPosition$1(node, 0) : CaretPosition$1.before(node);
	    };
	    var afterOrEndOf = function (node) {
	      return NodeType.isText(node) ? CaretPosition$1(node, node.data.length) : CaretPosition$1.after(node);
	    };
	    var getPreviousSiblingCaretPosition = function (elm) {
	      if (isCaretCandidate(elm.previousSibling)) {
	        return Option.some(afterOrEndOf(elm.previousSibling));
	      } else {
	        return elm.previousSibling ? CaretFinder.lastPositionIn(elm.previousSibling) : Option.none();
	      }
	    };
	    var getNextSiblingCaretPosition = function (elm) {
	      if (isCaretCandidate(elm.nextSibling)) {
	        return Option.some(beforeOrStartOf(elm.nextSibling));
	      } else {
	        return elm.nextSibling ? CaretFinder.firstPositionIn(elm.nextSibling) : Option.none();
	      }
	    };
	    var findCaretPositionBackwardsFromElm = function (rootElement, elm) {
	      var startPosition = CaretPosition$1.before(elm.previousSibling ? elm.previousSibling : elm.parentNode);
	      return CaretFinder.prevPosition(rootElement, startPosition).fold(function () {
	        return CaretFinder.nextPosition(rootElement, CaretPosition$1.after(elm));
	      }, Option.some);
	    };
	    var findCaretPositionForwardsFromElm = function (rootElement, elm) {
	      return CaretFinder.nextPosition(rootElement, CaretPosition$1.after(elm)).fold(function () {
	        return CaretFinder.prevPosition(rootElement, CaretPosition$1.before(elm));
	      }, Option.some);
	    };
	    var findCaretPositionBackwards = function (rootElement, elm) {
	      return getPreviousSiblingCaretPosition(elm).orThunk(function () {
	        return getNextSiblingCaretPosition(elm);
	      }).orThunk(function () {
	        return findCaretPositionBackwardsFromElm(rootElement, elm);
	      });
	    };
	    var findCaretPositionForward = function (rootElement, elm) {
	      return getNextSiblingCaretPosition(elm).orThunk(function () {
	        return getPreviousSiblingCaretPosition(elm);
	      }).orThunk(function () {
	        return findCaretPositionForwardsFromElm(rootElement, elm);
	      });
	    };
	    var findCaretPosition$1 = function (forward, rootElement, elm) {
	      return forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);
	    };
	    var findCaretPosOutsideElmAfterDelete = function (forward, rootElement, elm) {
	      return findCaretPosition$1(forward, rootElement, elm).map(curry(reposition, elm));
	    };
	    var setSelection = function (editor, forward, pos) {
	      pos.fold(function () {
	        editor.focus();
	      }, function (pos) {
	        editor.selection.setRng(pos.toRange(), forward);
	      });
	    };
	    var eqRawNode = function (rawNode) {
	      return function (elm) {
	        return elm.dom() === rawNode;
	      };
	    };
	    var isBlock$2 = function (editor, elm) {
	      return elm && editor.schema.getBlockElements().hasOwnProperty(name(elm));
	    };
	    var paddEmptyBlock = function (elm) {
	      if (Empty.isEmpty(elm)) {
	        var br = Element.fromHtml('<br data-mce-bogus="1">');
	        empty(elm);
	        append(elm, br);
	        return Option.some(CaretPosition$1.before(br.dom()));
	      } else {
	        return Option.none();
	      }
	    };
	    var deleteNormalized = function (elm, afterDeletePosOpt, normalizeWhitespace) {
	      var prevTextOpt = prevSibling(elm).filter(isText);
	      var nextTextOpt = nextSibling(elm).filter(isText);
	      remove(elm);
	      return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, function (prev, next, pos) {
	        var prevNode = prev.dom(), nextNode = next.dom();
	        var offset = prevNode.data.length;
	        mergeTextNodes(prevNode, nextNode, normalizeWhitespace);
	        return pos.container() === nextNode ? CaretPosition$1(prevNode, offset) : pos;
	      }).orThunk(function () {
	        if (normalizeWhitespace) {
	          prevTextOpt.each(function (elm) {
	            return normalizeWhitespaceBefore(elm.dom(), elm.dom().length);
	          });
	          nextTextOpt.each(function (elm) {
	            return normalizeWhitespaceAfter(elm.dom(), 0);
	          });
	        }
	        return afterDeletePosOpt;
	      });
	    };
	    var isInlineElement = function (editor, element) {
	      return has(editor.schema.getTextInlineElements(), name(element));
	    };
	    var deleteElement = function (editor, forward, elm, moveCaret) {
	      if (moveCaret === void 0) {
	        moveCaret = true;
	      }
	      var afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom());
	      var parentBlock = ancestor(elm, curry(isBlock$2, editor), eqRawNode(editor.getBody()));
	      var normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, isInlineElement(editor, elm));
	      if (editor.dom.isEmpty(editor.getBody())) {
	        editor.setContent('');
	        editor.selection.setCursorLocation();
	      } else {
	        parentBlock.bind(paddEmptyBlock).fold(function () {
	          if (moveCaret) {
	            setSelection(editor, forward, normalizedAfterDeletePos);
	          }
	        }, function (paddPos) {
	          if (moveCaret) {
	            setSelection(editor, forward, Option.some(paddPos));
	          }
	        });
	      }
	    };
	    var DeleteElement = { deleteElement: deleteElement };
	
	    var ZWSP$1 = Zwsp.ZWSP, CARET_ID$1 = '_mce_caret';
	    var importNode = function (ownerDocument, node) {
	      return ownerDocument.importNode(node, true);
	    };
	    var getEmptyCaretContainers = function (node) {
	      var nodes = [];
	      while (node) {
	        if (node.nodeType === 3 && node.nodeValue !== ZWSP$1 || node.childNodes.length > 1) {
	          return [];
	        }
	        if (node.nodeType === 1) {
	          nodes.push(node);
	        }
	        node = node.firstChild;
	      }
	      return nodes;
	    };
	    var isCaretContainerEmpty = function (node) {
	      return getEmptyCaretContainers(node).length > 0;
	    };
	    var findFirstTextNode = function (node) {
	      if (node) {
	        var walker = new TreeWalker(node, node);
	        for (node = walker.current(); node; node = walker.next()) {
	          if (NodeType.isText(node)) {
	            return node;
	          }
	        }
	      }
	      return null;
	    };
	    var createCaretContainer = function (fill) {
	      var caretContainer = Element.fromTag('span');
	      setAll(caretContainer, {
	        'id': CARET_ID$1,
	        'data-mce-bogus': '1',
	        'data-mce-type': 'format-caret'
	      });
	      if (fill) {
	        append(caretContainer, Element.fromText(ZWSP$1));
	      }
	      return caretContainer;
	    };
	    var trimZwspFromCaretContainer = function (caretContainerNode) {
	      var textNode = findFirstTextNode(caretContainerNode);
	      if (textNode && textNode.nodeValue.charAt(0) === ZWSP$1) {
	        textNode.deleteData(0, 1);
	      }
	      return textNode;
	    };
	    var removeCaretContainerNode = function (editor, node, moveCaret) {
	      if (moveCaret === void 0) {
	        moveCaret = true;
	      }
	      var dom = editor.dom, selection = editor.selection;
	      if (isCaretContainerEmpty(node)) {
	        DeleteElement.deleteElement(editor, false, Element.fromDom(node), moveCaret);
	      } else {
	        var rng = selection.getRng();
	        var block = dom.getParent(node, dom.isBlock);
	        var textNode = trimZwspFromCaretContainer(node);
	        if (rng.startContainer === textNode && rng.startOffset > 0) {
	          rng.setStart(textNode, rng.startOffset - 1);
	        }
	        if (rng.endContainer === textNode && rng.endOffset > 0) {
	          rng.setEnd(textNode, rng.endOffset - 1);
	        }
	        dom.remove(node, true);
	        if (block && dom.isEmpty(block)) {
	          PaddingBr.fillWithPaddingBr(Element.fromDom(block));
	        }
	        selection.setRng(rng);
	      }
	    };
	    var removeCaretContainer = function (editor, node, moveCaret) {
	      if (moveCaret === void 0) {
	        moveCaret = true;
	      }
	      var dom = editor.dom, selection = editor.selection;
	      if (!node) {
	        node = getParentCaretContainer(editor.getBody(), selection.getStart());
	        if (!node) {
	          while (node = dom.get(CARET_ID$1)) {
	            removeCaretContainerNode(editor, node, false);
	          }
	        }
	      } else {
	        removeCaretContainerNode(editor, node, moveCaret);
	      }
	    };
	    var insertCaretContainerNode = function (editor, caretContainer, formatNode) {
	      var dom = editor.dom, block = dom.getParent(formatNode, curry(isTextBlock$1, editor));
	      if (block && dom.isEmpty(block)) {
	        formatNode.parentNode.replaceChild(caretContainer, formatNode);
	      } else {
	        PaddingBr.removeTrailingBr(Element.fromDom(formatNode));
	        if (dom.isEmpty(formatNode)) {
	          formatNode.parentNode.replaceChild(caretContainer, formatNode);
	        } else {
	          dom.insertAfter(caretContainer, formatNode);
	        }
	      }
	    };
	    var appendNode = function (parentNode, node) {
	      parentNode.appendChild(node);
	      return node;
	    };
	    var insertFormatNodesIntoCaretContainer = function (formatNodes, caretContainer) {
	      var innerMostFormatNode = foldr(formatNodes, function (parentNode, formatNode) {
	        return appendNode(parentNode, formatNode.cloneNode(false));
	      }, caretContainer);
	      return appendNode(innerMostFormatNode, innerMostFormatNode.ownerDocument.createTextNode(ZWSP$1));
	    };
	    var applyCaretFormat = function (editor, name, vars) {
	      var rng, caretContainer, textNode, offset, bookmark, container, text;
	      var selection = editor.selection;
	      rng = selection.getRng();
	      offset = rng.startOffset;
	      container = rng.startContainer;
	      text = container.nodeValue;
	      caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());
	      if (caretContainer) {
	        textNode = findFirstTextNode(caretContainer);
	      }
	      var wordcharRegex = /[^\s\u00a0\u00ad\u200b\ufeff]/;
	      if (text && offset > 0 && offset < text.length && wordcharRegex.test(text.charAt(offset)) && wordcharRegex.test(text.charAt(offset - 1))) {
	        bookmark = selection.getBookmark();
	        rng.collapse(true);
	        rng = expandRng(editor, rng, editor.formatter.get(name));
	        rng = split$1(rng);
	        editor.formatter.apply(name, vars, rng);
	        selection.moveToBookmark(bookmark);
	      } else {
	        if (!caretContainer || textNode.nodeValue !== ZWSP$1) {
	          caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom());
	          textNode = caretContainer.firstChild;
	          rng.insertNode(caretContainer);
	          offset = 1;
	          editor.formatter.apply(name, vars, caretContainer);
	        } else {
	          editor.formatter.apply(name, vars, caretContainer);
	        }
	        selection.setCursorLocation(textNode, offset);
	      }
	    };
	    var removeCaretFormat = function (editor, name, vars, similar) {
	      var dom = editor.dom, selection = editor.selection;
	      var container, offset, bookmark;
	      var hasContentAfter, node, formatNode;
	      var parents = [], rng = selection.getRng();
	      var caretContainer;
	      container = rng.startContainer;
	      offset = rng.startOffset;
	      node = container;
	      if (container.nodeType === 3) {
	        if (offset !== container.nodeValue.length) {
	          hasContentAfter = true;
	        }
	        node = node.parentNode;
	      }
	      while (node) {
	        if (matchNode(editor, node, name, vars, similar)) {
	          formatNode = node;
	          break;
	        }
	        if (node.nextSibling) {
	          hasContentAfter = true;
	        }
	        parents.push(node);
	        node = node.parentNode;
	      }
	      if (!formatNode) {
	        return;
	      }
	      if (hasContentAfter) {
	        bookmark = selection.getBookmark();
	        rng.collapse(true);
	        var expandedRng = expandRng(editor, rng, editor.formatter.get(name), true);
	        expandedRng = split$1(expandedRng);
	        editor.formatter.remove(name, vars, expandedRng);
	        selection.moveToBookmark(bookmark);
	      } else {
	        caretContainer = getParentCaretContainer(editor.getBody(), formatNode);
	        var newCaretContainer = createCaretContainer(false).dom();
	        var caretNode = insertFormatNodesIntoCaretContainer(parents, newCaretContainer);
	        if (caretContainer) {
	          insertCaretContainerNode(editor, newCaretContainer, caretContainer);
	        } else {
	          insertCaretContainerNode(editor, newCaretContainer, formatNode);
	        }
	        removeCaretContainerNode(editor, caretContainer, false);
	        selection.setCursorLocation(caretNode, 1);
	        if (dom.isEmpty(formatNode)) {
	          dom.remove(formatNode);
	        }
	      }
	    };
	    var disableCaretContainer = function (editor, keyCode) {
	      var selection = editor.selection, body = editor.getBody();
	      removeCaretContainer(editor, null, false);
	      if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP$1) {
	        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));
	      }
	      if (keyCode === 37 || keyCode === 39) {
	        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));
	      }
	    };
	    var setup$3 = function (editor) {
	      editor.on('mouseup keydown', function (e) {
	        disableCaretContainer(editor, e.keyCode);
	      });
	    };
	    var replaceWithCaretFormat = function (targetNode, formatNodes) {
	      var caretContainer = createCaretContainer(false);
	      var innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom());
	      before(Element.fromDom(targetNode), caretContainer);
	      remove(Element.fromDom(targetNode));
	      return CaretPosition$1(innerMost, 0);
	    };
	    var isFormatElement = function (editor, element) {
	      var inlineElements = editor.schema.getTextInlineElements();
	      return inlineElements.hasOwnProperty(name(element)) && !isCaretNode(element.dom()) && !NodeType.isBogus(element.dom());
	    };
	    var isEmptyCaretFormatElement = function (element) {
	      return isCaretNode(element.dom()) && isCaretContainerEmpty(element.dom());
	    };
	
	    var postProcessHooks = {}, filter$4 = ArrUtils.filter, each$9 = ArrUtils.each;
	    var addPostProcessHook = function (name, hook) {
	      var hooks = postProcessHooks[name];
	      if (!hooks) {
	        postProcessHooks[name] = hooks = [];
	      }
	      postProcessHooks[name].push(hook);
	    };
	    var postProcess$1 = function (name, editor) {
	      each$9(postProcessHooks[name], function (hook) {
	        hook(editor);
	      });
	    };
	    addPostProcessHook('pre', function (editor) {
	      var rng = editor.selection.getRng();
	      var isPre, blocks;
	      var hasPreSibling = function (pre) {
	        return isPre(pre.previousSibling) && ArrUtils.indexOf(blocks, pre.previousSibling) !== -1;
	      };
	      var joinPre = function (pre1, pre2) {
	        DomQuery(pre2).remove();
	        DomQuery(pre1).append('<br><br>').append(pre2.childNodes);
	      };
	      isPre = NodeType.matchNodeNames(['pre']);
	      if (!rng.collapsed) {
	        blocks = editor.selection.getSelectedBlocks();
	        each$9(filter$4(filter$4(blocks, isPre), hasPreSibling), function (pre) {
	          joinPre(pre.previousSibling, pre);
	        });
	      }
	    });
	
	    var each$a = Tools.each;
	    var ElementUtils = function (dom) {
	      this.compare = function (node1, node2) {
	        if (node1.nodeName !== node2.nodeName) {
	          return false;
	        }
	        var getAttribs = function (node) {
	          var attribs = {};
	          each$a(dom.getAttribs(node), function (attr) {
	            var name = attr.nodeName.toLowerCase();
	            if (name.indexOf('_') !== 0 && name !== 'style' && name.indexOf('data-') !== 0) {
	              attribs[name] = dom.getAttrib(node, name);
	            }
	          });
	          return attribs;
	        };
	        var compareObjects = function (obj1, obj2) {
	          var value, name;
	          for (name in obj1) {
	            if (obj1.hasOwnProperty(name)) {
	              value = obj2[name];
	              if (typeof value === 'undefined') {
	                return false;
	              }
	              if (obj1[name] !== value) {
	                return false;
	              }
	              delete obj2[name];
	            }
	          }
	          for (name in obj2) {
	            if (obj2.hasOwnProperty(name)) {
	              return false;
	            }
	          }
	          return true;
	        };
	        if (!compareObjects(getAttribs(node1), getAttribs(node2))) {
	          return false;
	        }
	        if (!compareObjects(dom.parseStyle(dom.getAttrib(node1, 'style')), dom.parseStyle(dom.getAttrib(node2, 'style')))) {
	          return false;
	        }
	        return !Bookmarks.isBookmarkNode(node1) && !Bookmarks.isBookmarkNode(node2);
	      };
	    };
	
	    var MCE_ATTR_RE = /^(src|href|style)$/;
	    var each$b = Tools.each;
	    var isEq$3 = isEq;
	    var isTableCell$3 = function (node) {
	      return /^(TH|TD)$/.test(node.nodeName);
	    };
	    var isChildOfInlineParent = function (dom, node, parent) {
	      return dom.isChildOf(node, parent) && node !== parent && !dom.isBlock(parent);
	    };
	    var getContainer = function (ed, rng, start) {
	      var container, offset;
	      container = rng[start ? 'startContainer' : 'endContainer'];
	      offset = rng[start ? 'startOffset' : 'endOffset'];
	      if (NodeType.isElement(container)) {
	        var lastIdx = container.childNodes.length - 1;
	        if (!start && offset) {
	          offset--;
	        }
	        container = container.childNodes[offset > lastIdx ? lastIdx : offset];
	      }
	      if (NodeType.isText(container) && start && offset >= container.nodeValue.length) {
	        container = new TreeWalker(container, ed.getBody()).next() || container;
	      }
	      if (NodeType.isText(container) && !start && offset === 0) {
	        container = new TreeWalker(container, ed.getBody()).prev() || container;
	      }
	      return container;
	    };
	    var wrap$3 = function (dom, node, name, attrs) {
	      var wrapper = dom.create(name, attrs);
	      node.parentNode.insertBefore(wrapper, node);
	      wrapper.appendChild(node);
	      return wrapper;
	    };
	    var wrapWithSiblings = function (dom, node, next, name, attrs) {
	      var start = Element.fromDom(node);
	      var wrapper = Element.fromDom(dom.create(name, attrs));
	      var siblings = next ? nextSiblings(start) : prevSiblings(start);
	      append$1(wrapper, siblings);
	      if (next) {
	        before(start, wrapper);
	        prepend(wrapper, start);
	      } else {
	        after(start, wrapper);
	        append(wrapper, start);
	      }
	      return wrapper.dom();
	    };
	    var matchName$1 = function (dom, node, format) {
	      if (isEq$3(node, format.inline)) {
	        return true;
	      }
	      if (isEq$3(node, format.block)) {
	        return true;
	      }
	      if (format.selector) {
	        return NodeType.isElement(node) && dom.is(node, format.selector);
	      }
	    };
	    var isColorFormatAndAnchor = function (node, format) {
	      return format.links && node.nodeName === 'A';
	    };
	    var find$4 = function (dom, node, next, inc) {
	      node = getNonWhiteSpaceSibling(node, next, inc);
	      return !node || (node.nodeName === 'BR' || dom.isBlock(node));
	    };
	    var removeNode$1 = function (ed, node, format) {
	      var parentNode = node.parentNode;
	      var rootBlockElm;
	      var dom = ed.dom, forcedRootBlock = Settings.getForcedRootBlock(ed);
	      if (format.block) {
	        if (!forcedRootBlock) {
	          if (dom.isBlock(node) && !dom.isBlock(parentNode)) {
	            if (!find$4(dom, node, false) && !find$4(dom, node.firstChild, true, true)) {
	              node.insertBefore(dom.create('br'), node.firstChild);
	            }
	            if (!find$4(dom, node, true) && !find$4(dom, node.lastChild, false, true)) {
	              node.appendChild(dom.create('br'));
	            }
	          }
	        } else {
	          if (parentNode === dom.getRoot()) {
	            if (!format.list_block || !isEq$3(node, format.list_block)) {
	              each$b(Tools.grep(node.childNodes), function (node) {
	                if (isValid(ed, forcedRootBlock, node.nodeName.toLowerCase())) {
	                  if (!rootBlockElm) {
	                    rootBlockElm = wrap$3(dom, node, forcedRootBlock);
	                    dom.setAttribs(rootBlockElm, ed.settings.forced_root_block_attrs);
	                  } else {
	                    rootBlockElm.appendChild(node);
	                  }
	                } else {
	                  rootBlockElm = 0;
	                }
	              });
	            }
	          }
	        }
	      }
	      if (format.selector && format.inline && !isEq$3(format.inline, node)) {
	        return;
	      }
	      dom.remove(node, true);
	    };
	    var removeFormat = function (ed, format, vars, node, compareNode) {
	      var stylesModified;
	      var dom = ed.dom;
	      if (!matchName$1(dom, node, format) && !isColorFormatAndAnchor(node, format)) {
	        return false;
	      }
	      var elm = node;
	      if (format.remove !== 'all') {
	        each$b(format.styles, function (value, name) {
	          value = normalizeStyleValue(dom, replaceVars(value, vars), name);
	          if (typeof name === 'number') {
	            name = value;
	            compareNode = null;
	          }
	          if (format.remove_similar || (!compareNode || isEq$3(getStyle(dom, compareNode, name), value))) {
	            dom.setStyle(elm, name, '');
	          }
	          stylesModified = true;
	        });
	        if (stylesModified && dom.getAttrib(elm, 'style') === '') {
	          elm.removeAttribute('style');
	          elm.removeAttribute('data-mce-style');
	        }
	        each$b(format.attributes, function (value, name) {
	          var valueOut;
	          value = replaceVars(value, vars);
	          if (typeof name === 'number') {
	            name = value;
	            compareNode = null;
	          }
	          if (format.remove_similar || (!compareNode || isEq$3(dom.getAttrib(compareNode, name), value))) {
	            if (name === 'class') {
	              value = dom.getAttrib(elm, name);
	              if (value) {
	                valueOut = '';
	                each$b(value.split(/\s+/), function (cls) {
	                  if (/mce\-\w+/.test(cls)) {
	                    valueOut += (valueOut ? ' ' : '') + cls;
	                  }
	                });
	                if (valueOut) {
	                  dom.setAttrib(elm, name, valueOut);
	                  return;
	                }
	              }
	            }
	            if (name === 'class') {
	              elm.removeAttribute('className');
	            }
	            if (MCE_ATTR_RE.test(name)) {
	              elm.removeAttribute('data-mce-' + name);
	            }
	            elm.removeAttribute(name);
	          }
	        });
	        each$b(format.classes, function (value) {
	          value = replaceVars(value, vars);
	          if (!compareNode || dom.hasClass(compareNode, value)) {
	            dom.removeClass(elm, value);
	          }
	        });
	        var attrs = dom.getAttribs(elm);
	        for (var i = 0; i < attrs.length; i++) {
	          var attrName = attrs[i].nodeName;
	          if (attrName.indexOf('_') !== 0 && attrName.indexOf('data-') !== 0) {
	            return false;
	          }
	        }
	      }
	      if (format.remove !== 'none') {
	        removeNode$1(ed, elm, format);
	        return true;
	      }
	    };
	    var findFormatRoot = function (editor, container, name, vars, similar) {
	      var formatRoot;
	      each$b(getParents$1(editor.dom, container.parentNode).reverse(), function (parent) {
	        var format;
	        if (!formatRoot && parent.id !== '_start' && parent.id !== '_end') {
	          format = matchNode(editor, parent, name, vars, similar);
	          if (format && format.split !== false) {
	            formatRoot = parent;
	          }
	        }
	      });
	      return formatRoot;
	    };
	    var wrapAndSplit = function (editor, formatList, formatRoot, container, target, split, format, vars) {
	      var parent, clone, lastClone, firstClone, i, formatRootParent;
	      var dom = editor.dom;
	      if (formatRoot) {
	        formatRootParent = formatRoot.parentNode;
	        for (parent = container.parentNode; parent && parent !== formatRootParent; parent = parent.parentNode) {
	          clone = dom.clone(parent, false);
	          for (i = 0; i < formatList.length; i++) {
	            if (removeFormat(editor, formatList[i], vars, clone, clone)) {
	              clone = 0;
	              break;
	            }
	          }
	          if (clone) {
	            if (lastClone) {
	              clone.appendChild(lastClone);
	            }
	            if (!firstClone) {
	              firstClone = clone;
	            }
	            lastClone = clone;
	          }
	        }
	        if (split && (!format.mixed || !dom.isBlock(formatRoot))) {
	          container = dom.split(formatRoot, container);
	        }
	        if (lastClone) {
	          target.parentNode.insertBefore(lastClone, target);
	          firstClone.appendChild(target);
	        }
	      }
	      return container;
	    };
	    var remove$7 = function (ed, name, vars, node, similar) {
	      var formatList = ed.formatter.get(name), format = formatList[0];
	      var bookmark, rng, contentEditable = true;
	      var dom = ed.dom;
	      var selection = ed.selection;
	      var splitToFormatRoot = function (container) {
	        var formatRoot = findFormatRoot(ed, container, name, vars, similar);
	        return wrapAndSplit(ed, formatList, formatRoot, container, container, true, format, vars);
	      };
	      var isRemoveBookmarkNode = function (node) {
	        return Bookmarks.isBookmarkNode(node) && NodeType.isElement(node) && (node.id === '_start' || node.id === '_end');
	      };
	      var process = function (node) {
	        var children, i, l, lastContentEditable, hasContentEditableState;
	        if (NodeType.isElement(node) && dom.getContentEditable(node)) {
	          lastContentEditable = contentEditable;
	          contentEditable = dom.getContentEditable(node) === 'true';
	          hasContentEditableState = true;
	        }
	        children = Tools.grep(node.childNodes);
	        if (contentEditable && !hasContentEditableState) {
	          for (i = 0, l = formatList.length; i < l; i++) {
	            if (removeFormat(ed, formatList[i], vars, node, node)) {
	              break;
	            }
	          }
	        }
	        if (format.deep) {
	          if (children.length) {
	            for (i = 0, l = children.length; i < l; i++) {
	              process(children[i]);
	            }
	            if (hasContentEditableState) {
	              contentEditable = lastContentEditable;
	            }
	          }
	        }
	      };
	      var unwrap = function (start) {
	        var node = dom.get(start ? '_start' : '_end');
	        var out = node[start ? 'firstChild' : 'lastChild'];
	        if (isRemoveBookmarkNode(out)) {
	          out = out[start ? 'firstChild' : 'lastChild'];
	        }
	        if (NodeType.isText(out) && out.data.length === 0) {
	          out = start ? node.previousSibling || node.nextSibling : node.nextSibling || node.previousSibling;
	        }
	        dom.remove(node, true);
	        return out;
	      };
	      var removeRngStyle = function (rng) {
	        var startContainer, endContainer;
	        var commonAncestorContainer = rng.commonAncestorContainer;
	        var expandedRng = expandRng(ed, rng, formatList, true);
	        if (format.split) {
	          expandedRng = split$1(expandedRng);
	          startContainer = getContainer(ed, expandedRng, true);
	          endContainer = getContainer(ed, expandedRng);
	          if (startContainer !== endContainer) {
	            if (/^(TR|TH|TD)$/.test(startContainer.nodeName) && startContainer.firstChild) {
	              if (startContainer.nodeName === 'TR') {
	                startContainer = startContainer.firstChild.firstChild || startContainer;
	              } else {
	                startContainer = startContainer.firstChild || startContainer;
	              }
	            }
	            if (commonAncestorContainer && /^T(HEAD|BODY|FOOT|R)$/.test(commonAncestorContainer.nodeName) && isTableCell$3(endContainer) && endContainer.firstChild) {
	              endContainer = endContainer.firstChild || endContainer;
	            }
	            if (isChildOfInlineParent(dom, startContainer, endContainer)) {
	              var marker = Option.from(startContainer.firstChild).getOr(startContainer);
	              splitToFormatRoot(wrapWithSiblings(dom, marker, true, 'span', {
	                'id': '_start',
	                'data-mce-type': 'bookmark'
	              }));
	              unwrap(true);
	              return;
	            }
	            if (isChildOfInlineParent(dom, endContainer, startContainer)) {
	              var marker = Option.from(endContainer.lastChild).getOr(endContainer);
	              splitToFormatRoot(wrapWithSiblings(dom, marker, false, 'span', {
	                'id': '_end',
	                'data-mce-type': 'bookmark'
	              }));
	              unwrap(false);
	              return;
	            }
	            startContainer = wrap$3(dom, startContainer, 'span', {
	              'id': '_start',
	              'data-mce-type': 'bookmark'
	            });
	            endContainer = wrap$3(dom, endContainer, 'span', {
	              'id': '_end',
	              'data-mce-type': 'bookmark'
	            });
	            var newRng = dom.createRng();
	            newRng.setStartAfter(startContainer);
	            newRng.setEndBefore(endContainer);
	            RangeWalk.walk(dom, newRng, function (nodes) {
	              each(nodes, function (n) {
	                if (!Bookmarks.isBookmarkNode(n) && !Bookmarks.isBookmarkNode(n.parentNode)) {
	                  splitToFormatRoot(n);
	                }
	              });
	            });
	            splitToFormatRoot(startContainer);
	            splitToFormatRoot(endContainer);
	            startContainer = unwrap(true);
	            endContainer = unwrap();
	          } else {
	            startContainer = endContainer = splitToFormatRoot(startContainer);
	          }
	          expandedRng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;
	          expandedRng.startOffset = dom.nodeIndex(startContainer);
	          expandedRng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;
	          expandedRng.endOffset = dom.nodeIndex(endContainer) + 1;
	        }
	        RangeWalk.walk(dom, expandedRng, function (nodes) {
	          each$b(nodes, function (node) {
	            process(node);
	            if (NodeType.isElement(node) && ed.dom.getStyle(node, 'text-decoration') === 'underline' && node.parentNode && getTextDecoration(dom, node.parentNode) === 'underline') {
	              removeFormat(ed, {
	                deep: false,
	                exact: true,
	                inline: 'span',
	                styles: { textDecoration: 'underline' }
	              }, null, node);
	            }
	          });
	        });
	      };
	      if (node) {
	        if (isNode(node)) {
	          rng = dom.createRng();
	          rng.setStartBefore(node);
	          rng.setEndAfter(node);
	          removeRngStyle(rng);
	        } else {
	          removeRngStyle(node);
	        }
	        return;
	      }
	      if (dom.getContentEditable(selection.getNode()) === 'false') {
	        node = selection.getNode();
	        for (var i = 0, l = formatList.length; i < l; i++) {
	          if (formatList[i].ceFalseOverride) {
	            if (removeFormat(ed, formatList[i], vars, node, node)) {
	              break;
	            }
	          }
	        }
	        return;
	      }
	      if (!selection.isCollapsed() || !format.inline || dom.select('td[data-mce-selected],th[data-mce-selected]').length) {
	        bookmark = GetBookmark.getPersistentBookmark(ed.selection, true);
	        removeRngStyle(selection.getRng());
	        selection.moveToBookmark(bookmark);
	        if (format.inline && match(ed, name, vars, selection.getStart())) {
	          moveStart(dom, selection, selection.getRng());
	        }
	        ed.nodeChanged();
	      } else {
	        removeCaretFormat(ed, name, vars, similar);
	      }
	    };
	
	    var each$c = Tools.each;
	    var isElementNode = function (node) {
	      return NodeType.isElement(node) && !Bookmarks.isBookmarkNode(node) && !isCaretNode(node) && !NodeType.isBogus(node);
	    };
	    var findElementSibling = function (node, siblingName) {
	      var sibling;
	      for (sibling = node; sibling; sibling = sibling[siblingName]) {
	        if (NodeType.isText(sibling) && sibling.nodeValue.length !== 0) {
	          return node;
	        }
	        if (NodeType.isElement(sibling) && !Bookmarks.isBookmarkNode(sibling)) {
	          return sibling;
	        }
	      }
	      return node;
	    };
	    var mergeSiblingsNodes = function (dom, prev, next) {
	      var sibling, tmpSibling;
	      var elementUtils = new ElementUtils(dom);
	      if (prev && next) {
	        prev = findElementSibling(prev, 'previousSibling');
	        next = findElementSibling(next, 'nextSibling');
	        if (elementUtils.compare(prev, next)) {
	          for (sibling = prev.nextSibling; sibling && sibling !== next;) {
	            tmpSibling = sibling;
	            sibling = sibling.nextSibling;
	            prev.appendChild(tmpSibling);
	          }
	          dom.remove(next);
	          Tools.each(Tools.grep(next.childNodes), function (node) {
	            prev.appendChild(node);
	          });
	          return prev;
	        }
	      }
	      return next;
	    };
	    var processChildElements = function (node, filter, process) {
	      each$c(node.childNodes, function (node) {
	        if (isElementNode(node)) {
	          if (filter(node)) {
	            process(node);
	          }
	          if (node.hasChildNodes()) {
	            processChildElements(node, filter, process);
	          }
	        }
	      });
	    };
	    var hasStyle = function (dom, name) {
	      return curry(function (name, node) {
	        return !!(node && getStyle(dom, node, name));
	      }, name);
	    };
	    var applyStyle = function (dom, name, value) {
	      return curry(function (name, value, node) {
	        dom.setStyle(node, name, value);
	        if (node.getAttribute('style') === '') {
	          node.removeAttribute('style');
	        }
	        unwrapEmptySpan(dom, node);
	      }, name, value);
	    };
	    var unwrapEmptySpan = function (dom, node) {
	      if (node.nodeName === 'SPAN' && dom.getAttribs(node).length === 0) {
	        dom.remove(node, true);
	      }
	    };
	    var processUnderlineAndColor = function (dom, node) {
	      var textDecoration;
	      if (node.nodeType === 1 && node.parentNode && node.parentNode.nodeType === 1) {
	        textDecoration = getTextDecoration(dom, node.parentNode);
	        if (dom.getStyle(node, 'color') && textDecoration) {
	          dom.setStyle(node, 'text-decoration', textDecoration);
	        } else if (dom.getStyle(node, 'text-decoration') === textDecoration) {
	          dom.setStyle(node, 'text-decoration', null);
	        }
	      }
	    };
	    var mergeUnderlineAndColor = function (dom, format, vars, node) {
	      if (format.styles.color || format.styles.textDecoration) {
	        Tools.walk(node, curry(processUnderlineAndColor, dom), 'childNodes');
	        processUnderlineAndColor(dom, node);
	      }
	    };
	    var mergeBackgroundColorAndFontSize = function (dom, format, vars, node) {
	      if (format.styles && format.styles.backgroundColor) {
	        processChildElements(node, hasStyle(dom, 'fontSize'), applyStyle(dom, 'backgroundColor', replaceVars(format.styles.backgroundColor, vars)));
	      }
	    };
	    var mergeSubSup = function (dom, format, vars, node) {
	      if (format.inline === 'sub' || format.inline === 'sup') {
	        processChildElements(node, hasStyle(dom, 'fontSize'), applyStyle(dom, 'fontSize', ''));
	        dom.remove(dom.select(format.inline === 'sup' ? 'sub' : 'sup', node), true);
	      }
	    };
	    var mergeSiblings = function (dom, format, vars, node) {
	      if (node && format.merge_siblings !== false) {
	        node = mergeSiblingsNodes(dom, getNonWhiteSpaceSibling(node), node);
	        node = mergeSiblingsNodes(dom, node, getNonWhiteSpaceSibling(node, true));
	      }
	    };
	    var clearChildStyles = function (dom, format, node) {
	      if (format.clear_child_styles) {
	        var selector = format.links ? '*:not(a)' : '*';
	        each$c(dom.select(selector, node), function (node) {
	          if (isElementNode(node)) {
	            each$c(format.styles, function (value, name) {
	              dom.setStyle(node, name, '');
	            });
	          }
	        });
	      }
	    };
	    var mergeWithChildren = function (editor, formatList, vars, node) {
	      each$c(formatList, function (format) {
	        each$c(editor.dom.select(format.inline, node), function (child) {
	          if (!isElementNode(child)) {
	            return;
	          }
	          removeFormat(editor, format, vars, child, format.exact ? child : null);
	        });
	        clearChildStyles(editor.dom, format, node);
	      });
	    };
	    var mergeWithParents = function (editor, format, name, vars, node) {
	      if (matchNode(editor, node.parentNode, name, vars)) {
	        if (removeFormat(editor, format, vars, node)) {
	          return;
	        }
	      }
	      if (format.merge_with_parents) {
	        editor.dom.getParent(node.parentNode, function (parent) {
	          if (matchNode(editor, parent, name, vars)) {
	            removeFormat(editor, format, vars, node);
	            return true;
	          }
	        });
	      }
	    };
	
	    var createRange$1 = function (sc, so, ec, eo) {
	      var rng = domGlobals.document.createRange();
	      rng.setStart(sc, so);
	      rng.setEnd(ec, eo);
	      return rng;
	    };
	    var normalizeBlockSelectionRange = function (rng) {
	      var startPos = CaretPosition$1.fromRangeStart(rng);
	      var endPos = CaretPosition$1.fromRangeEnd(rng);
	      var rootNode = rng.commonAncestorContainer;
	      return CaretFinder.fromPosition(false, rootNode, endPos).map(function (newEndPos) {
	        if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) {
	          return createRange$1(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());
	        } else {
	          return rng;
	        }
	      }).getOr(rng);
	    };
	    var normalize$2 = function (rng) {
	      return rng.collapsed ? rng : normalizeBlockSelectionRange(rng);
	    };
	    var RangeNormalizer = { normalize: normalize$2 };
	
	    var each$d = Tools.each;
	    var isElementNode$1 = function (node) {
	      return node && node.nodeType === 1 && !Bookmarks.isBookmarkNode(node) && !isCaretNode(node) && !NodeType.isBogus(node);
	    };
	    var applyFormat = function (ed, name, vars, node) {
	      var formatList = ed.formatter.get(name);
	      var format = formatList[0];
	      var bookmark, rng;
	      var isCollapsed = !node && ed.selection.isCollapsed();
	      var dom = ed.dom, selection = ed.selection;
	      var setElementFormat = function (elm, fmt) {
	        fmt = fmt || format;
	        if (elm) {
	          if (fmt.onformat) {
	            fmt.onformat(elm, fmt, vars, node);
	          }
	          each$d(fmt.styles, function (value, name) {
	            dom.setStyle(elm, name, replaceVars(value, vars));
	          });
	          if (fmt.styles) {
	            var styleVal = dom.getAttrib(elm, 'style');
	            if (styleVal) {
	              dom.setAttrib(elm, 'data-mce-style', styleVal);
	            }
	          }
	          each$d(fmt.attributes, function (value, name) {
	            dom.setAttrib(elm, name, replaceVars(value, vars));
	          });
	          each$d(fmt.classes, function (value) {
	            value = replaceVars(value, vars);
	            if (!dom.hasClass(elm, value)) {
	              dom.addClass(elm, value);
	            }
	          });
	        }
	      };
	      var applyNodeStyle = function (formatList, node) {
	        var found = false;
	        if (!format.selector) {
	          return false;
	        }
	        each$d(formatList, function (format) {
	          if ('collapsed' in format && format.collapsed !== isCollapsed) {
	            return;
	          }
	          if (dom.is(node, format.selector) && !isCaretNode(node)) {
	            setElementFormat(node, format);
	            found = true;
	            return false;
	          }
	        });
	        return found;
	      };
	      var applyRngStyle = function (dom, rng, bookmark, nodeSpecific) {
	        var newWrappers = [];
	        var wrapName, wrapElm, contentEditable = true;
	        wrapName = format.inline || format.block;
	        wrapElm = dom.create(wrapName);
	        setElementFormat(wrapElm);
	        RangeWalk.walk(dom, rng, function (nodes) {
	          var currentWrapElm;
	          var process = function (node) {
	            var hasContentEditableState = false;
	            var lastContentEditable = contentEditable;
	            var nodeName = node.nodeName.toLowerCase();
	            var parentName = node.parentNode.nodeName.toLowerCase();
	            if (NodeType.isElement(node) && dom.getContentEditable(node)) {
	              lastContentEditable = contentEditable;
	              contentEditable = dom.getContentEditable(node) === 'true';
	              hasContentEditableState = true;
	            }
	            if (isEq(nodeName, 'br')) {
	              currentWrapElm = 0;
	              if (format.block) {
	                dom.remove(node);
	              }
	              return;
	            }
	            if (format.wrapper && matchNode(ed, node, name, vars)) {
	              currentWrapElm = 0;
	              return;
	            }
	            if (contentEditable && !hasContentEditableState && format.block && !format.wrapper && isTextBlock$1(ed, nodeName) && isValid(ed, parentName, wrapName)) {
	              node = dom.rename(node, wrapName);
	              setElementFormat(node);
	              newWrappers.push(node);
	              currentWrapElm = 0;
	              return;
	            }
	            if (format.selector) {
	              var found = applyNodeStyle(formatList, node);
	              if (!format.inline || found) {
	                currentWrapElm = 0;
	                return;
	              }
	            }
	            if (contentEditable && !hasContentEditableState && isValid(ed, wrapName, nodeName) && isValid(ed, parentName, wrapName) && !(!nodeSpecific && node.nodeType === 3 && node.nodeValue.length === 1 && node.nodeValue.charCodeAt(0) === 65279) && !isCaretNode(node) && (!format.inline || !dom.isBlock(node))) {
	              if (!currentWrapElm) {
	                currentWrapElm = dom.clone(wrapElm, false);
	                node.parentNode.insertBefore(currentWrapElm, node);
	                newWrappers.push(currentWrapElm);
	              }
	              currentWrapElm.appendChild(node);
	            } else {
	              currentWrapElm = 0;
	              each$d(Tools.grep(node.childNodes), process);
	              if (hasContentEditableState) {
	                contentEditable = lastContentEditable;
	              }
	              currentWrapElm = 0;
	            }
	          };
	          each$d(nodes, process);
	        });
	        if (format.links === true) {
	          each$d(newWrappers, function (node) {
	            var process = function (node) {
	              if (node.nodeName === 'A') {
	                setElementFormat(node, format);
	              }
	              each$d(Tools.grep(node.childNodes), process);
	            };
	            process(node);
	          });
	        }
	        each$d(newWrappers, function (node) {
	          var childCount;
	          var getChildCount = function (node) {
	            var count = 0;
	            each$d(node.childNodes, function (node) {
	              if (!isEmptyTextNode(node) && !Bookmarks.isBookmarkNode(node)) {
	                count++;
	              }
	            });
	            return count;
	          };
	          var getChildElementNode = function (root) {
	            var child = false;
	            each$d(root.childNodes, function (node) {
	              if (isElementNode$1(node)) {
	                child = node;
	                return false;
	              }
	            });
	            return child;
	          };
	          var mergeStyles = function (node) {
	            var child, clone;
	            child = getChildElementNode(node);
	            if (child && !Bookmarks.isBookmarkNode(child) && matchName(dom, child, format)) {
	              clone = dom.clone(child, false);
	              setElementFormat(clone);
	              dom.replace(clone, node, true);
	              dom.remove(child, true);
	            }
	            return clone || node;
	          };
	          childCount = getChildCount(node);
	          if ((newWrappers.length > 1 || !dom.isBlock(node)) && childCount === 0) {
	            dom.remove(node, true);
	            return;
	          }
	          if (format.inline || format.wrapper) {
	            if (!format.exact && childCount === 1) {
	              node = mergeStyles(node);
	            }
	            mergeWithChildren(ed, formatList, vars, node);
	            mergeWithParents(ed, format, name, vars, node);
	            mergeBackgroundColorAndFontSize(dom, format, vars, node);
	            mergeSubSup(dom, format, vars, node);
	            mergeSiblings(dom, format, vars, node);
	          }
	        });
	      };
	      if (dom.getContentEditable(selection.getNode()) === 'false') {
	        node = selection.getNode();
	        for (var i = 0, l = formatList.length; i < l; i++) {
	          if (formatList[i].ceFalseOverride && dom.is(node, formatList[i].selector)) {
	            setElementFormat(node, formatList[i]);
	            return;
	          }
	        }
	        return;
	      }
	      if (format) {
	        if (node) {
	          if (isNode(node)) {
	            if (!applyNodeStyle(formatList, node)) {
	              rng = dom.createRng();
	              rng.setStartBefore(node);
	              rng.setEndAfter(node);
	              applyRngStyle(dom, expandRng(ed, rng, formatList), null, true);
	            }
	          } else {
	            applyRngStyle(dom, node, null, true);
	          }
	        } else {
	          if (!isCollapsed || !format.inline || dom.select('td[data-mce-selected],th[data-mce-selected]').length) {
	            var curSelNode = ed.selection.getNode();
	            if (!ed.settings.forced_root_block && formatList[0].defaultBlock && !dom.getParent(curSelNode, dom.isBlock)) {
	              applyFormat(ed, formatList[0].defaultBlock);
	            }
	            ed.selection.setRng(RangeNormalizer.normalize(ed.selection.getRng()));
	            bookmark = GetBookmark.getPersistentBookmark(ed.selection, true);
	            applyRngStyle(dom, expandRng(ed, selection.getRng(), formatList));
	            if (format.styles) {
	              mergeUnderlineAndColor(dom, format, vars, curSelNode);
	            }
	            selection.moveToBookmark(bookmark);
	            moveStart(dom, selection, selection.getRng());
	            ed.nodeChanged();
	          } else {
	            applyCaretFormat(ed, name, vars);
	          }
	        }
	        postProcess$1(name, ed);
	      }
	    };
	
	    var setup$4 = function (registeredFormatListeners, editor) {
	      var currentFormats = Cell({});
	      registeredFormatListeners.set({});
	      editor.on('NodeChange', function (e) {
	        updateAndFireChangeCallbacks(editor, e.element, currentFormats, registeredFormatListeners.get());
	      });
	    };
	    var updateAndFireChangeCallbacks = function (editor, elm, currentFormats, formatChangeData) {
	      var formatsList = keys(currentFormats.get());
	      var newFormats = {};
	      var matchedFormats = {};
	      var parents = filter(getParents$1(editor.dom, elm), function (node) {
	        return node.nodeType === 1 && !node.getAttribute('data-mce-bogus');
	      });
	      each$1(formatChangeData, function (data, format) {
	        Tools.each(parents, function (node) {
	          if (editor.formatter.matchNode(node, format, {}, data.similar)) {
	            if (formatsList.indexOf(format) === -1) {
	              each(data.callbacks, function (callback) {
	                callback(true, {
	                  node: node,
	                  format: format,
	                  parents: parents
	                });
	              });
	              newFormats[format] = data.callbacks;
	            }
	            matchedFormats[format] = data.callbacks;
	            return false;
	          }
	          if (matchesUnInheritedFormatSelector(editor, node, format)) {
	            return false;
	          }
	        });
	      });
	      var remainingFormats = filterRemainingFormats(currentFormats.get(), matchedFormats, elm, parents);
	      currentFormats.set(__assign(__assign({}, newFormats), remainingFormats));
	    };
	    var filterRemainingFormats = function (currentFormats, matchedFormats, elm, parents) {
	      return bifilter(currentFormats, function (callbacks, format) {
	        if (!has(matchedFormats, format)) {
	          each(callbacks, function (callback) {
	            callback(false, {
	              node: elm,
	              format: format,
	              parents: parents
	            });
	          });
	          return false;
	        } else {
	          return true;
	        }
	      }).t;
	    };
	    var addListeners = function (registeredFormatListeners, formats, callback, similar) {
	      var formatChangeItems = registeredFormatListeners.get();
	      each(formats.split(','), function (format) {
	        if (!formatChangeItems[format]) {
	          formatChangeItems[format] = {
	            similar: similar,
	            callbacks: []
	          };
	        }
	        formatChangeItems[format].callbacks.push(callback);
	      });
	      registeredFormatListeners.set(formatChangeItems);
	    };
	    var removeListeners = function (registeredFormatListeners, formats, callback) {
	      var formatChangeItems = registeredFormatListeners.get();
	      each(formats.split(','), function (format) {
	        formatChangeItems[format].callbacks = filter(formatChangeItems[format].callbacks, function (c) {
	          return c !== callback;
	        });
	        if (formatChangeItems[format].callbacks.length === 0) {
	          delete formatChangeItems[format];
	        }
	      });
	      registeredFormatListeners.set(formatChangeItems);
	    };
	    var formatChanged = function (editor, registeredFormatListeners, formats, callback, similar) {
	      if (registeredFormatListeners.get() === null) {
	        setup$4(registeredFormatListeners, editor);
	      }
	      addListeners(registeredFormatListeners, formats, callback, similar);
	      return {
	        unbind: function () {
	          return removeListeners(registeredFormatListeners, formats, callback);
	        }
	      };
	    };
	
	    var get$9 = function (dom) {
	      var formats = {
	        valigntop: [{
	            selector: 'td,th',
	            styles: { verticalAlign: 'top' }
	          }],
	        valignmiddle: [{
	            selector: 'td,th',
	            styles: { verticalAlign: 'middle' }
	          }],
	        valignbottom: [{
	            selector: 'td,th',
	            styles: { verticalAlign: 'bottom' }
	          }],
	        alignleft: [
	          {
	            selector: 'figure.image',
	            collapsed: false,
	            classes: 'align-left',
	            ceFalseOverride: true,
	            preview: 'font-family font-size'
	          },
	          {
	            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',
	            styles: { textAlign: 'left' },
	            inherit: false,
	            preview: false,
	            defaultBlock: 'div'
	          },
	          {
	            selector: 'img,table',
	            collapsed: false,
	            styles: { float: 'left' },
	            preview: 'font-family font-size'
	          }
	        ],
	        aligncenter: [
	          {
	            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',
	            styles: { textAlign: 'center' },
	            inherit: false,
	            preview: 'font-family font-size',
	            defaultBlock: 'div'
	          },
	          {
	            selector: 'figure.image',
	            collapsed: false,
	            classes: 'align-center',
	            ceFalseOverride: true,
	            preview: 'font-family font-size'
	          },
	          {
	            selector: 'img',
	            collapsed: false,
	            styles: {
	              display: 'block',
	              marginLeft: 'auto',
	              marginRight: 'auto'
	            },
	            preview: false
	          },
	          {
	            selector: 'table',
	            collapsed: false,
	            styles: {
	              marginLeft: 'auto',
	              marginRight: 'auto'
	            },
	            preview: 'font-family font-size'
	          }
	        ],
	        alignright: [
	          {
	            selector: 'figure.image',
	            collapsed: false,
	            classes: 'align-right',
	            ceFalseOverride: true,
	            preview: 'font-family font-size'
	          },
	          {
	            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',
	            styles: { textAlign: 'right' },
	            inherit: false,
	            preview: 'font-family font-size',
	            defaultBlock: 'div'
	          },
	          {
	            selector: 'img,table',
	            collapsed: false,
	            styles: { float: 'right' },
	            preview: 'font-family font-size'
	          }
	        ],
	        alignjustify: [{
	            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li',
	            styles: { textAlign: 'justify' },
	            inherit: false,
	            defaultBlock: 'div',
	            preview: 'font-family font-size'
	          }],
	        bold: [
	          {
	            inline: 'strong',
	            remove: 'all'
	          },
	          {
	            inline: 'span',
	            styles: { fontWeight: 'bold' }
	          },
	          {
	            inline: 'b',
	            remove: 'all'
	          }
	        ],
	        italic: [
	          {
	            inline: 'em',
	            remove: 'all'
	          },
	          {
	            inline: 'span',
	            styles: { fontStyle: 'italic' }
	          },
	          {
	            inline: 'i',
	            remove: 'all'
	          }
	        ],
	        underline: [
	          {
	            inline: 'span',
	            styles: { textDecoration: 'underline' },
	            exact: true
	          },
	          {
	            inline: 'u',
	            remove: 'all'
	          }
	        ],
	        strikethrough: [
	          {
	            inline: 'span',
	            styles: { textDecoration: 'line-through' },
	            exact: true
	          },
	          {
	            inline: 'strike',
	            remove: 'all'
	          }
	        ],
	        forecolor: {
	          inline: 'span',
	          styles: { color: '%value' },
	          links: true,
	          remove_similar: true,
	          clear_child_styles: true
	        },
	        hilitecolor: {
	          inline: 'span',
	          styles: { backgroundColor: '%value' },
	          links: true,
	          remove_similar: true,
	          clear_child_styles: true
	        },
	        fontname: {
	          inline: 'span',
	          toggle: false,
	          styles: { fontFamily: '%value' },
	          clear_child_styles: true
	        },
	        fontsize: {
	          inline: 'span',
	          toggle: false,
	          styles: { fontSize: '%value' },
	          clear_child_styles: true
	        },
	        fontsize_class: {
	          inline: 'span',
	          attributes: { class: '%value' }
	        },
	        blockquote: {
	          block: 'blockquote',
	          wrapper: true,
	          remove: 'all'
	        },
	        subscript: { inline: 'sub' },
	        superscript: { inline: 'sup' },
	        code: { inline: 'code' },
	        link: {
	          inline: 'a',
	          selector: 'a',
	          remove: 'all',
	          split: true,
	          deep: true,
	          onmatch: function () {
	            return true;
	          },
	          onformat: function (elm, fmt, vars) {
	            Tools.each(vars, function (value, key) {
	              dom.setAttrib(elm, key, value);
	            });
	          }
	        },
	        removeformat: [
	          {
	            selector: 'b,strong,em,i,font,u,strike,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins',
	            remove: 'all',
	            split: true,
	            expand: false,
	            block_expand: true,
	            deep: true
	          },
	          {
	            selector: 'span',
	            attributes: [
	              'style',
	              'class'
	            ],
	            remove: 'empty',
	            split: true,
	            expand: false,
	            deep: true
	          },
	          {
	            selector: '*',
	            attributes: [
	              'style',
	              'class'
	            ],
	            split: false,
	            expand: false,
	            deep: true
	          }
	        ]
	      };
	      Tools.each('p h1 h2 h3 h4 h5 h6 div address pre div dt dd samp'.split(/\s/), function (name) {
	        formats[name] = {
	          block: name,
	          remove: 'all'
	        };
	      });
	      return formats;
	    };
	    var DefaultFormats = { get: get$9 };
	
	    function FormatRegistry(editor) {
	      var formats = {};
	      var get = function (name) {
	        return name ? formats[name] : formats;
	      };
	      var has$1 = function (name) {
	        return has(formats, name);
	      };
	      var register = function (name, format) {
	        if (name) {
	          if (typeof name !== 'string') {
	            Tools.each(name, function (format, name) {
	              register(name, format);
	            });
	          } else {
	            if (!isArray(format)) {
	              format = [format];
	            }
	            Tools.each(format, function (format) {
	              if (typeof format.deep === 'undefined') {
	                format.deep = !format.selector;
	              }
	              if (typeof format.split === 'undefined') {
	                format.split = !format.selector || format.inline;
	              }
	              if (typeof format.remove === 'undefined' && format.selector && !format.inline) {
	                format.remove = 'none';
	              }
	              if (format.selector && format.inline) {
	                format.mixed = true;
	                format.block_expand = true;
	              }
	              if (typeof format.classes === 'string') {
	                format.classes = format.classes.split(/\s+/);
	              }
	            });
	            formats[name] = format;
	          }
	        }
	      };
	      var unregister = function (name) {
	        if (name && formats[name]) {
	          delete formats[name];
	        }
	        return formats;
	      };
	      register(DefaultFormats.get(editor.dom));
	      register(editor.settings.formats);
	      return {
	        get: get,
	        has: has$1,
	        register: register,
	        unregister: unregister
	      };
	    }
	
	    var each$e = Tools.each;
	    var dom = DOMUtils$1.DOM;
	    var parsedSelectorToHtml = function (ancestry, editor) {
	      var elm, item, fragment;
	      var schema = editor && editor.schema || Schema({});
	      var decorate = function (elm, item) {
	        if (item.classes.length) {
	          dom.addClass(elm, item.classes.join(' '));
	        }
	        dom.setAttribs(elm, item.attrs);
	      };
	      var createElement = function (sItem) {
	        var elm;
	        item = typeof sItem === 'string' ? {
	          name: sItem,
	          classes: [],
	          attrs: {}
	        } : sItem;
	        elm = dom.create(item.name);
	        decorate(elm, item);
	        return elm;
	      };
	      var getRequiredParent = function (elm, candidate) {
	        var name = typeof elm !== 'string' ? elm.nodeName.toLowerCase() : elm;
	        var elmRule = schema.getElementRule(name);
	        var parentsRequired = elmRule && elmRule.parentsRequired;
	        if (parentsRequired && parentsRequired.length) {
	          return candidate && Tools.inArray(parentsRequired, candidate) !== -1 ? candidate : parentsRequired[0];
	        } else {
	          return false;
	        }
	      };
	      var wrapInHtml = function (elm, ancestry, siblings) {
	        var parent, parentCandidate, parentRequired;
	        var ancestor = ancestry.length > 0 && ancestry[0];
	        var ancestorName = ancestor && ancestor.name;
	        parentRequired = getRequiredParent(elm, ancestorName);
	        if (parentRequired) {
	          if (ancestorName === parentRequired) {
	            parentCandidate = ancestry[0];
	            ancestry = ancestry.slice(1);
	          } else {
	            parentCandidate = parentRequired;
	          }
	        } else if (ancestor) {
	          parentCandidate = ancestry[0];
	          ancestry = ancestry.slice(1);
	        } else if (!siblings) {
	          return elm;
	        }
	        if (parentCandidate) {
	          parent = createElement(parentCandidate);
	          parent.appendChild(elm);
	        }
	        if (siblings) {
	          if (!parent) {
	            parent = dom.create('div');
	            parent.appendChild(elm);
	          }
	          Tools.each(siblings, function (sibling) {
	            var siblingElm = createElement(sibling);
	            parent.insertBefore(siblingElm, elm);
	          });
	        }
	        return wrapInHtml(parent, ancestry, parentCandidate && parentCandidate.siblings);
	      };
	      if (ancestry && ancestry.length) {
	        item = ancestry[0];
	        elm = createElement(item);
	        fragment = dom.create('div');
	        fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), item.siblings));
	        return fragment;
	      } else {
	        return '';
	      }
	    };
	    var parseSelectorItem = function (item) {
	      var tagName;
	      var obj = {
	        classes: [],
	        attrs: {}
	      };
	      item = obj.selector = Tools.trim(item);
	      if (item !== '*') {
	        tagName = item.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, function ($0, $1, $2, $3, $4) {
	          switch ($1) {
	          case '#':
	            obj.attrs.id = $2;
	            break;
	          case '.':
	            obj.classes.push($2);
	            break;
	          case ':':
	            if (Tools.inArray('checked disabled enabled read-only required'.split(' '), $2) !== -1) {
	              obj.attrs[$2] = $2;
	            }
	            break;
	          }
	          if ($3 === '[') {
	            var m = $4.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
	            if (m) {
	              obj.attrs[m[1]] = m[2];
	            }
	          }
	          return '';
	        });
	      }
	      obj.name = tagName || 'div';
	      return obj;
	    };
	    var parseSelector = function (selector) {
	      if (!selector || typeof selector !== 'string') {
	        return [];
	      }
	      selector = selector.split(/\s*,\s*/)[0];
	      selector = selector.replace(/\s*(~\+|~|\+|>)\s*/g, '$1');
	      return Tools.map(selector.split(/(?:>|\s+(?![^\[\]]+\]))/), function (item) {
	        var siblings = Tools.map(item.split(/(?:~\+|~|\+)/), parseSelectorItem);
	        var obj = siblings.pop();
	        if (siblings.length) {
	          obj.siblings = siblings;
	        }
	        return obj;
	      }).reverse();
	    };
	    var getCssText = function (editor, format) {
	      var name, previewFrag, previewElm, items;
	      var previewCss = '', parentFontSize, previewStyles;
	      previewStyles = editor.settings.preview_styles;
	      if (previewStyles === false) {
	        return '';
	      }
	      if (typeof previewStyles !== 'string') {
	        previewStyles = 'font-family font-size font-weight font-style text-decoration ' + 'text-transform color background-color border border-radius outline text-shadow';
	      }
	      var removeVars = function (val) {
	        return val.replace(/%(\w+)/g, '');
	      };
	      if (typeof format === 'string') {
	        format = editor.formatter.get(format);
	        if (!format) {
	          return;
	        }
	        format = format[0];
	      }
	      if ('preview' in format) {
	        previewStyles = format.preview;
	        if (previewStyles === false) {
	          return '';
	        }
	      }
	      name = format.block || format.inline || 'span';
	      items = parseSelector(format.selector);
	      if (items.length) {
	        if (!items[0].name) {
	          items[0].name = name;
	        }
	        name = format.selector;
	        previewFrag = parsedSelectorToHtml(items, editor);
	      } else {
	        previewFrag = parsedSelectorToHtml([name], editor);
	      }
	      previewElm = dom.select(name, previewFrag)[0] || previewFrag.firstChild;
	      each$e(format.styles, function (value, name) {
	        value = removeVars(value);
	        if (value) {
	          dom.setStyle(previewElm, name, value);
	        }
	      });
	      each$e(format.attributes, function (value, name) {
	        value = removeVars(value);
	        if (value) {
	          dom.setAttrib(previewElm, name, value);
	        }
	      });
	      each$e(format.classes, function (value) {
	        value = removeVars(value);
	        if (!dom.hasClass(previewElm, value)) {
	          dom.addClass(previewElm, value);
	        }
	      });
	      editor.fire('PreviewFormats');
	      dom.setStyles(previewFrag, {
	        position: 'absolute',
	        left: -65535
	      });
	      editor.getBody().appendChild(previewFrag);
	      parentFontSize = dom.getStyle(editor.getBody(), 'fontSize', true);
	      parentFontSize = /px$/.test(parentFontSize) ? parseInt(parentFontSize, 10) : 0;
	      each$e(previewStyles.split(' '), function (name) {
	        var value = dom.getStyle(previewElm, name, true);
	        if (name === 'background-color' && /transparent|rgba\s*\([^)]+,\s*0\)/.test(value)) {
	          value = dom.getStyle(editor.getBody(), name, true);
	          if (dom.toHex(value).toLowerCase() === '#ffffff') {
	            return;
	          }
	        }
	        if (name === 'color') {
	          if (dom.toHex(value).toLowerCase() === '#000000') {
	            return;
	          }
	        }
	        if (name === 'font-size') {
	          if (/em|%$/.test(value)) {
	            if (parentFontSize === 0) {
	              return;
	            }
	            var numValue = parseFloat(value) / (/%$/.test(value) ? 100 : 1);
	            value = numValue * parentFontSize + 'px';
	          }
	        }
	        if (name === 'border' && value) {
	          previewCss += 'padding:0 2px;';
	        }
	        previewCss += name + ':' + value + ';';
	      });
	      editor.fire('AfterPreviewFormats');
	      dom.remove(previewFrag);
	      return previewCss;
	    };
	
	    var toggle = function (editor, formats, name, vars, node) {
	      var fmt = formats.get(name);
	      if (match(editor, name, vars, node) && (!('toggle' in fmt[0]) || fmt[0].toggle)) {
	        remove$7(editor, name, vars, node);
	      } else {
	        applyFormat(editor, name, vars, node);
	      }
	    };
	
	    var setup$5 = function (editor) {
	      editor.addShortcut('meta+b', '', 'Bold');
	      editor.addShortcut('meta+i', '', 'Italic');
	      editor.addShortcut('meta+u', '', 'Underline');
	      for (var i = 1; i <= 6; i++) {
	        editor.addShortcut('access+' + i, '', [
	          'FormatBlock',
	          false,
	          'h' + i
	        ]);
	      }
	      editor.addShortcut('access+7', '', [
	        'FormatBlock',
	        false,
	        'p'
	      ]);
	      editor.addShortcut('access+8', '', [
	        'FormatBlock',
	        false,
	        'div'
	      ]);
	      editor.addShortcut('access+9', '', [
	        'FormatBlock',
	        false,
	        'address'
	      ]);
	    };
	    var FormatShortcuts = { setup: setup$5 };
	
	    var Formatter = function (editor) {
	      var formats = FormatRegistry(editor);
	      var formatChangeState = Cell(null);
	      FormatShortcuts.setup(editor);
	      setup$3(editor);
	      return {
	        get: formats.get,
	        has: formats.has,
	        register: formats.register,
	        unregister: formats.unregister,
	        apply: curry(applyFormat, editor),
	        remove: curry(remove$7, editor),
	        toggle: curry(toggle, editor, formats),
	        match: curry(match, editor),
	        matchAll: curry(matchAll, editor),
	        matchNode: curry(matchNode, editor),
	        canApply: curry(canApply, editor),
	        formatChanged: curry(formatChanged, editor, formatChangeState),
	        getCssText: curry(getCssText, editor)
	      };
	    };
	
	    var KEEP = 0, INSERT = 1, DELETE = 2;
	    var diff = function (left, right) {
	      var size = left.length + right.length + 2;
	      var vDown = new Array(size);
	      var vUp = new Array(size);
	      var snake = function (start, end, diag) {
	        return {
	          start: start,
	          end: end,
	          diag: diag
	        };
	      };
	      var buildScript = function (start1, end1, start2, end2, script) {
	        var middle = getMiddleSnake(start1, end1, start2, end2);
	        if (middle === null || middle.start === end1 && middle.diag === end1 - end2 || middle.end === start1 && middle.diag === start1 - start2) {
	          var i = start1;
	          var j = start2;
	          while (i < end1 || j < end2) {
	            if (i < end1 && j < end2 && left[i] === right[j]) {
	              script.push([
	                KEEP,
	                left[i]
	              ]);
	              ++i;
	              ++j;
	            } else {
	              if (end1 - start1 > end2 - start2) {
	                script.push([
	                  DELETE,
	                  left[i]
	                ]);
	                ++i;
	              } else {
	                script.push([
	                  INSERT,
	                  right[j]
	                ]);
	                ++j;
	              }
	            }
	          }
	        } else {
	          buildScript(start1, middle.start, start2, middle.start - middle.diag, script);
	          for (var i2 = middle.start; i2 < middle.end; ++i2) {
	            script.push([
	              KEEP,
	              left[i2]
	            ]);
	          }
	          buildScript(middle.end, end1, middle.end - middle.diag, end2, script);
	        }
	      };
	      var buildSnake = function (start, diag, end1, end2) {
	        var end = start;
	        while (end - diag < end2 && end < end1 && left[end] === right[end - diag]) {
	          ++end;
	        }
	        return snake(start, end, diag);
	      };
	      var getMiddleSnake = function (start1, end1, start2, end2) {
	        var m = end1 - start1;
	        var n = end2 - start2;
	        if (m === 0 || n === 0) {
	          return null;
	        }
	        var delta = m - n;
	        var sum = n + m;
	        var offset = (sum % 2 === 0 ? sum : sum + 1) / 2;
	        vDown[1 + offset] = start1;
	        vUp[1 + offset] = end1 + 1;
	        var d, k, i, x, y;
	        for (d = 0; d <= offset; ++d) {
	          for (k = -d; k <= d; k += 2) {
	            i = k + offset;
	            if (k === -d || k !== d && vDown[i - 1] < vDown[i + 1]) {
	              vDown[i] = vDown[i + 1];
	            } else {
	              vDown[i] = vDown[i - 1] + 1;
	            }
	            x = vDown[i];
	            y = x - start1 + start2 - k;
	            while (x < end1 && y < end2 && left[x] === right[y]) {
	              vDown[i] = ++x;
	              ++y;
	            }
	            if (delta % 2 !== 0 && delta - d <= k && k <= delta + d) {
	              if (vUp[i - delta] <= vDown[i]) {
	                return buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);
	              }
	            }
	          }
	          for (k = delta - d; k <= delta + d; k += 2) {
	            i = k + offset - delta;
	            if (k === delta - d || k !== delta + d && vUp[i + 1] <= vUp[i - 1]) {
	              vUp[i] = vUp[i + 1] - 1;
	            } else {
	              vUp[i] = vUp[i - 1];
	            }
	            x = vUp[i] - 1;
	            y = x - start1 + start2 - k;
	            while (x >= start1 && y >= start2 && left[x] === right[y]) {
	              vUp[i] = x--;
	              y--;
	            }
	            if (delta % 2 === 0 && -d <= k && k <= d) {
	              if (vUp[i] <= vDown[i + delta]) {
	                return buildSnake(vUp[i], k + start1 - start2, end1, end2);
	              }
	            }
	          }
	        }
	      };
	      var script = [];
	      buildScript(0, left.length, 0, right.length, script);
	      return script;
	    };
	    var Diff = {
	      KEEP: KEEP,
	      DELETE: DELETE,
	      INSERT: INSERT,
	      diff: diff
	    };
	
	    var getOuterHtml = function (elm) {
	      if (NodeType.isElement(elm)) {
	        return elm.outerHTML;
	      } else if (NodeType.isText(elm)) {
	        return Entities.encodeRaw(elm.data, false);
	      } else if (NodeType.isComment(elm)) {
	        return '<!--' + elm.data + '-->';
	      }
	      return '';
	    };
	    var createFragment$1 = function (html) {
	      var frag, node, container;
	      container = domGlobals.document.createElement('div');
	      frag = domGlobals.document.createDocumentFragment();
	      if (html) {
	        container.innerHTML = html;
	      }
	      while (node = container.firstChild) {
	        frag.appendChild(node);
	      }
	      return frag;
	    };
	    var insertAt = function (elm, html, index) {
	      var fragment = createFragment$1(html);
	      if (elm.hasChildNodes() && index < elm.childNodes.length) {
	        var target = elm.childNodes[index];
	        target.parentNode.insertBefore(fragment, target);
	      } else {
	        elm.appendChild(fragment);
	      }
	    };
	    var removeAt = function (elm, index) {
	      if (elm.hasChildNodes() && index < elm.childNodes.length) {
	        var target = elm.childNodes[index];
	        target.parentNode.removeChild(target);
	      }
	    };
	    var applyDiff = function (diff, elm) {
	      var index = 0;
	      each(diff, function (action) {
	        if (action[0] === Diff.KEEP) {
	          index++;
	        } else if (action[0] === Diff.INSERT) {
	          insertAt(elm, action[1], index);
	          index++;
	        } else if (action[0] === Diff.DELETE) {
	          removeAt(elm, index);
	        }
	      });
	    };
	    var read$2 = function (elm) {
	      return filter(map(from$1(elm.childNodes), getOuterHtml), function (item) {
	        return item.length > 0;
	      });
	    };
	    var write = function (fragments, elm) {
	      var currentFragments = map(from$1(elm.childNodes), getOuterHtml);
	      applyDiff(Diff.diff(currentFragments, fragments), elm);
	      return elm;
	    };
	    var Fragments = {
	      read: read$2,
	      write: write
	    };
	
	    var undoLevelDocument = Cell(Option.none());
	    var lazyTempDocument = function () {
	      return undoLevelDocument.get().getOrThunk(function () {
	        var doc = domGlobals.document.implementation.createHTMLDocument('undo');
	        undoLevelDocument.set(Option.some(doc));
	        return doc;
	      });
	    };
	    var hasIframes = function (html) {
	      return html.indexOf('</iframe>') !== -1;
	    };
	    var createFragmentedLevel = function (fragments) {
	      return {
	        type: 'fragmented',
	        fragments: fragments,
	        content: '',
	        bookmark: null,
	        beforeBookmark: null
	      };
	    };
	    var createCompleteLevel = function (content) {
	      return {
	        type: 'complete',
	        fragments: null,
	        content: content,
	        bookmark: null,
	        beforeBookmark: null
	      };
	    };
	    var createFromEditor = function (editor) {
	      var fragments, content, trimmedFragments;
	      fragments = Fragments.read(editor.getBody());
	      trimmedFragments = bind(fragments, function (html) {
	        var trimmed = TrimHtml.trimInternal(editor.serializer, html);
	        return trimmed.length > 0 ? [trimmed] : [];
	      });
	      content = trimmedFragments.join('');
	      return hasIframes(content) ? createFragmentedLevel(trimmedFragments) : createCompleteLevel(content);
	    };
	    var applyToEditor = function (editor, level, before) {
	      if (level.type === 'fragmented') {
	        Fragments.write(level.fragments, editor.getBody());
	      } else {
	        editor.setContent(level.content, { format: 'raw' });
	      }
	      editor.selection.moveToBookmark(before ? level.beforeBookmark : level.bookmark);
	    };
	    var getLevelContent = function (level) {
	      return level.type === 'fragmented' ? level.fragments.join('') : level.content;
	    };
	    var getCleanLevelContent = function (level) {
	      var elm = Element.fromTag('body', lazyTempDocument());
	      set$1(elm, getLevelContent(level));
	      each(descendants$1(elm, '*[data-mce-bogus]'), unwrap);
	      return get$6(elm);
	    };
	    var hasEqualContent = function (level1, level2) {
	      return getLevelContent(level1) === getLevelContent(level2);
	    };
	    var hasEqualCleanedContent = function (level1, level2) {
	      return getCleanLevelContent(level1) === getCleanLevelContent(level2);
	    };
	    var isEq$4 = function (level1, level2) {
	      if (!level1 || !level2) {
	        return false;
	      } else if (hasEqualContent(level1, level2)) {
	        return true;
	      } else {
	        return hasEqualCleanedContent(level1, level2);
	      }
	    };
	    var Levels = {
	      createFragmentedLevel: createFragmentedLevel,
	      createCompleteLevel: createCompleteLevel,
	      createFromEditor: createFromEditor,
	      applyToEditor: applyToEditor,
	      isEq: isEq$4
	    };
	
	    var isUnlocked = function (locks) {
	      return locks.get() === 0;
	    };
	
	    var setTyping = function (undoManager, typing, locks) {
	      if (isUnlocked(locks)) {
	        undoManager.typing = typing;
	      }
	    };
	    var endTyping = function (undoManager, locks) {
	      if (undoManager.typing) {
	        setTyping(undoManager, false, locks);
	        undoManager.add();
	      }
	    };
	    var endTypingLevelIgnoreLocks = function (undoManager) {
	      if (undoManager.typing) {
	        undoManager.typing = false;
	        undoManager.add();
	      }
	    };
	
	    var beforeChange = function (editor, locks, beforeBookmark) {
	      if (isUnlocked(locks)) {
	        beforeBookmark.set(Option.some(GetBookmark.getUndoBookmark(editor.selection)));
	      }
	    };
	    var addUndoLevel = function (editor, undoManager, index, locks, beforeBookmark, level, event) {
	      var settings = editor.settings;
	      var currentLevel = Levels.createFromEditor(editor);
	      level = level || {};
	      level = Tools.extend(level, currentLevel);
	      if (isUnlocked(locks) === false || editor.removed) {
	        return null;
	      }
	      var lastLevel = undoManager.data[index.get()];
	      if (editor.fire('BeforeAddUndo', {
	          level: level,
	          lastLevel: lastLevel,
	          originalEvent: event
	        }).isDefaultPrevented()) {
	        return null;
	      }
	      if (lastLevel && Levels.isEq(lastLevel, level)) {
	        return null;
	      }
	      if (undoManager.data[index.get()]) {
	        beforeBookmark.get().each(function (bm) {
	          undoManager.data[index.get()].beforeBookmark = bm;
	        });
	      }
	      if (settings.custom_undo_redo_levels) {
	        if (undoManager.data.length > settings.custom_undo_redo_levels) {
	          for (var i = 0; i < undoManager.data.length - 1; i++) {
	            undoManager.data[i] = undoManager.data[i + 1];
	          }
	          undoManager.data.length--;
	          index.set(undoManager.data.length);
	        }
	      }
	      level.bookmark = GetBookmark.getUndoBookmark(editor.selection);
	      if (index.get() < undoManager.data.length - 1) {
	        undoManager.data.length = index.get() + 1;
	      }
	      undoManager.data.push(level);
	      index.set(undoManager.data.length - 1);
	      var args = {
	        level: level,
	        lastLevel: lastLevel,
	        originalEvent: event
	      };
	      editor.fire('AddUndo', args);
	      if (index.get() > 0) {
	        editor.setDirty(true);
	        editor.fire('change', args);
	      }
	      return level;
	    };
	    var clear = function (editor, undoManager, index) {
	      undoManager.data = [];
	      index.set(0);
	      undoManager.typing = false;
	      editor.fire('ClearUndos');
	    };
	    var extra = function (editor, undoManager, index, callback1, callback2) {
	      if (undoManager.transact(callback1)) {
	        var bookmark = undoManager.data[index.get()].bookmark;
	        var lastLevel = undoManager.data[index.get() - 1];
	        Levels.applyToEditor(editor, lastLevel, true);
	        if (undoManager.transact(callback2)) {
	          undoManager.data[index.get() - 1].beforeBookmark = bookmark;
	        }
	      }
	    };
	    var redo = function (editor, index, data) {
	      var level;
	      if (index.get() < data.length - 1) {
	        index.set(index.get() + 1);
	        level = data[index.get()];
	        Levels.applyToEditor(editor, level, false);
	        editor.setDirty(true);
	        editor.fire('Redo', { level: level });
	      }
	      return level;
	    };
	    var undo = function (editor, undoManager, locks, index) {
	      var level;
	      if (undoManager.typing) {
	        undoManager.add();
	        undoManager.typing = false;
	        setTyping(undoManager, false, locks);
	      }
	      if (index.get() > 0) {
	        index.set(index.get() - 1);
	        level = undoManager.data[index.get()];
	        Levels.applyToEditor(editor, level, true);
	        editor.setDirty(true);
	        editor.fire('Undo', { level: level });
	      }
	      return level;
	    };
	    var reset = function (undoManager) {
	      undoManager.clear();
	      undoManager.add();
	    };
	    var hasUndo = function (editor, undoManager, index) {
	      return index.get() > 0 || undoManager.typing && undoManager.data[0] && !Levels.isEq(Levels.createFromEditor(editor), undoManager.data[0]);
	    };
	    var hasRedo = function (undoManager, index) {
	      return index.get() < undoManager.data.length - 1 && !undoManager.typing;
	    };
	    var transact = function (undoManager, locks, callback) {
	      endTyping(undoManager, locks);
	      undoManager.beforeChange();
	      undoManager.ignore(callback);
	      return undoManager.add();
	    };
	    var ignore = function (locks, callback) {
	      try {
	        locks.set(locks.get() + 1);
	        callback();
	      } finally {
	        locks.set(locks.get() - 1);
	      }
	    };
	
	    var registerEvents$1 = function (editor, undoManager, locks) {
	      var isFirstTypedCharacter = Cell(false);
	      var addNonTypingUndoLevel = function (e) {
	        setTyping(undoManager, false, locks);
	        undoManager.add({}, e);
	      };
	      editor.on('init', function () {
	        undoManager.add();
	      });
	      editor.on('BeforeExecCommand', function (e) {
	        var cmd = e.command;
	        if (cmd !== 'Undo' && cmd !== 'Redo' && cmd !== 'mceRepaint') {
	          endTyping(undoManager, locks);
	          undoManager.beforeChange();
	        }
	      });
	      editor.on('ExecCommand', function (e) {
	        var cmd = e.command;
	        if (cmd !== 'Undo' && cmd !== 'Redo' && cmd !== 'mceRepaint') {
	          addNonTypingUndoLevel(e);
	        }
	      });
	      editor.on('ObjectResizeStart cut', function () {
	        undoManager.beforeChange();
	      });
	      editor.on('SaveContent ObjectResized blur', addNonTypingUndoLevel);
	      editor.on('dragend', addNonTypingUndoLevel);
	      editor.on('keyup', function (e) {
	        var keyCode = e.keyCode;
	        if (e.isDefaultPrevented()) {
	          return;
	        }
	        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45 || e.ctrlKey) {
	          addNonTypingUndoLevel();
	          editor.nodeChanged();
	        }
	        if (keyCode === 46 || keyCode === 8) {
	          editor.nodeChanged();
	        }
	        if (isFirstTypedCharacter.get() && undoManager.typing && Levels.isEq(Levels.createFromEditor(editor), undoManager.data[0]) === false) {
	          if (editor.isDirty() === false) {
	            editor.setDirty(true);
	            editor.fire('change', {
	              level: undoManager.data[0],
	              lastLevel: null
	            });
	          }
	          editor.fire('TypingUndo');
	          isFirstTypedCharacter.set(false);
	          editor.nodeChanged();
	        }
	      });
	      editor.on('keydown', function (e) {
	        var keyCode = e.keyCode;
	        if (e.isDefaultPrevented()) {
	          return;
	        }
	        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45) {
	          if (undoManager.typing) {
	            addNonTypingUndoLevel(e);
	          }
	          return;
	        }
	        var modKey = e.ctrlKey && !e.altKey || e.metaKey;
	        if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !undoManager.typing && !modKey) {
	          undoManager.beforeChange();
	          setTyping(undoManager, true, locks);
	          undoManager.add({}, e);
	          isFirstTypedCharacter.set(true);
	        }
	      });
	      editor.on('mousedown', function (e) {
	        if (undoManager.typing) {
	          addNonTypingUndoLevel(e);
	        }
	      });
	      var isInsertReplacementText = function (event) {
	        return event.inputType === 'insertReplacementText';
	      };
	      var isInsertTextDataNull = function (event) {
	        return event.inputType === 'insertText' && event.data === null;
	      };
	      editor.on('input', function (e) {
	        if (e.inputType && (isInsertReplacementText(e) || isInsertTextDataNull(e))) {
	          addNonTypingUndoLevel(e);
	        }
	      });
	      editor.on('AddUndo Undo Redo ClearUndos', function (e) {
	        if (!e.isDefaultPrevented()) {
	          editor.nodeChanged();
	        }
	      });
	    };
	    var addKeyboardShortcuts = function (editor) {
	      editor.addShortcut('meta+z', '', 'Undo');
	      editor.addShortcut('meta+y,meta+shift+z', '', 'Redo');
	    };
	
	    var UndoManager = function (editor) {
	      var beforeBookmark = Cell(Option.none());
	      var locks = Cell(0);
	      var index = Cell(0);
	      var undoManager = {
	        data: [],
	        typing: false,
	        beforeChange: function () {
	          beforeChange(editor, locks, beforeBookmark);
	        },
	        add: function (level, event) {
	          return addUndoLevel(editor, undoManager, index, locks, beforeBookmark, level, event);
	        },
	        undo: function () {
	          return undo(editor, undoManager, locks, index);
	        },
	        redo: function () {
	          return redo(editor, index, undoManager.data);
	        },
	        clear: function () {
	          clear(editor, undoManager, index);
	        },
	        reset: function () {
	          reset(undoManager);
	        },
	        hasUndo: function () {
	          return hasUndo(editor, undoManager, index);
	        },
	        hasRedo: function () {
	          return hasRedo(undoManager, index);
	        },
	        transact: function (callback) {
	          return transact(undoManager, locks, callback);
	        },
	        ignore: function (callback) {
	          ignore(locks, callback);
	        },
	        extra: function (callback1, callback2) {
	          extra(editor, undoManager, index, callback1, callback2);
	        }
	      };
	      registerEvents$1(editor, undoManager, locks);
	      addKeyboardShortcuts(editor);
	      return undoManager;
	    };
	
	    var nonTypingKeycodes = [
	      9,
	      27,
	      VK.HOME,
	      VK.END,
	      19,
	      20,
	      44,
	      144,
	      145,
	      33,
	      34,
	      45,
	      16,
	      17,
	      18,
	      91,
	      92,
	      93,
	      VK.DOWN,
	      VK.UP,
	      VK.LEFT,
	      VK.RIGHT
	    ].concat(Env.browser.isFirefox() ? [224] : []);
	    var placeholderAttr = 'data-mce-placeholder';
	    var isKeyboardEvent = function (e) {
	      return e.type === 'keydown' || e.type === 'keyup';
	    };
	    var isDeleteEvent = function (e) {
	      var keyCode = e.keyCode;
	      return keyCode === VK.BACKSPACE || keyCode === VK.DELETE;
	    };
	    var isNonTypingKeyboardEvent = function (e) {
	      if (isKeyboardEvent(e)) {
	        var keyCode = e.keyCode;
	        return !isDeleteEvent(e) && (VK.metaKeyPressed(e) || e.altKey || keyCode >= 112 && keyCode <= 123 || contains(nonTypingKeycodes, keyCode));
	      } else {
	        return false;
	      }
	    };
	    var isTypingKeyboardEvent = function (e) {
	      return isKeyboardEvent(e) && !(isDeleteEvent(e) || e.type === 'keyup' && e.keyCode === 229);
	    };
	    var isVisuallyEmpty = function (dom, rootElm, forcedRootBlock) {
	      if (Empty.isEmpty(Element.fromDom(rootElm), false)) {
	        var isForcedRootBlockFalse = forcedRootBlock === '';
	        var firstElement = rootElm.firstElementChild;
	        if (!firstElement) {
	          return true;
	        } else if (dom.getStyle(rootElm.firstElementChild, 'padding-left') || dom.getStyle(rootElm.firstElementChild, 'padding-right')) {
	          return false;
	        } else {
	          return isForcedRootBlockFalse ? !dom.isBlock(firstElement) : forcedRootBlock === firstElement.nodeName.toLowerCase();
	        }
	      } else {
	        return false;
	      }
	    };
	    var setup$6 = function (editor) {
	      var dom = editor.dom;
	      var rootBlock = Settings.getForcedRootBlock(editor);
	      var placeholder = Settings.getPlaceholder(editor);
	      var updatePlaceholder = function (e, initial) {
	        if (isNonTypingKeyboardEvent(e)) {
	          return;
	        }
	        var body = editor.getBody();
	        var showPlaceholder = isTypingKeyboardEvent(e) ? false : isVisuallyEmpty(dom, body, rootBlock);
	        var isPlaceholderShown = dom.getAttrib(body, placeholderAttr) !== '';
	        if (isPlaceholderShown !== showPlaceholder || initial) {
	          dom.setAttrib(body, placeholderAttr, showPlaceholder ? placeholder : null);
	          dom.setAttrib(body, 'aria-placeholder', showPlaceholder ? placeholder : null);
	          firePlaceholderToggle(editor, showPlaceholder);
	          editor.on(showPlaceholder ? 'keydown' : 'keyup', updatePlaceholder);
	          editor.off(showPlaceholder ? 'keyup' : 'keydown', updatePlaceholder);
	        }
	      };
	      if (placeholder) {
	        editor.on('init', function (e) {
	          updatePlaceholder(e, true);
	          editor.on('change SetContent ExecCommand', updatePlaceholder);
	          editor.on('remove', function () {
	            var body = editor.getBody();
	            dom.setAttrib(body, placeholderAttr, null);
	            dom.setAttrib(body, 'aria-placeholder', null);
	          });
	        });
	      }
	    };
	
	    var SIGNIFICANT_MOVE = 5;
	    var LONGPRESS_DELAY = 400;
	    var getTouch = function (event) {
	      if (event.touches === undefined || event.touches.length !== 1) {
	        return Option.none();
	      }
	      return Option.some(event.touches[0]);
	    };
	    var isFarEnough = function (touch, data) {
	      var distX = Math.abs(touch.clientX - data.x());
	      var distY = Math.abs(touch.clientY - data.y());
	      return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;
	    };
	    var setup$7 = function (editor) {
	      var startData = Cell(Option.none());
	      var longpressFired = Cell(false);
	      var debounceLongpress = last$2(function (e) {
	        editor.fire('longpress', __assign(__assign({}, e), { type: 'longpress' }));
	        longpressFired.set(true);
	      }, LONGPRESS_DELAY);
	      editor.on('touchstart', function (e) {
	        getTouch(e).each(function (touch) {
	          debounceLongpress.cancel();
	          var data = {
	            x: constant(touch.clientX),
	            y: constant(touch.clientY),
	            target: constant(e.target)
	          };
	          debounceLongpress.throttle(e);
	          longpressFired.set(false);
	          startData.set(Option.some(data));
	        });
	      }, true);
	      editor.on('touchmove', function (e) {
	        debounceLongpress.cancel();
	        getTouch(e).each(function (touch) {
	          startData.get().each(function (data) {
	            if (isFarEnough(touch, data)) {
	              startData.set(Option.none());
	              longpressFired.set(false);
	              editor.fire('longpresscancel');
	            }
	          });
	        });
	      }, true);
	      editor.on('touchend touchcancel', function (e) {
	        debounceLongpress.cancel();
	        if (e.type === 'touchcancel') {
	          return;
	        }
	        startData.get().filter(function (data) {
	          return data.target().isEqualNode(e.target);
	        }).each(function () {
	          if (longpressFired.get()) {
	            e.preventDefault();
	          } else {
	            editor.fire('tap', __assign(__assign({}, e), { type: 'tap' }));
	          }
	        });
	      }, true);
	    };
	    var TouchEvents = { setup: setup$7 };
	
	    var isBlockElement = function (blockElements, node) {
	      return blockElements.hasOwnProperty(node.nodeName);
	    };
	    var isValidTarget = function (blockElements, node) {
	      if (NodeType.isText(node)) {
	        return true;
	      } else if (NodeType.isElement(node)) {
	        return !isBlockElement(blockElements, node) && !Bookmarks.isBookmarkNode(node);
	      } else {
	        return false;
	      }
	    };
	    var hasBlockParent = function (blockElements, root, node) {
	      return exists(Parents.parents(Element.fromDom(node), Element.fromDom(root)), function (elm) {
	        return isBlockElement(blockElements, elm.dom());
	      });
	    };
	    var shouldRemoveTextNode = function (blockElements, node) {
	      if (NodeType.isText(node)) {
	        if (node.nodeValue.length === 0) {
	          return true;
	        } else if (/^\s+$/.test(node.nodeValue) && (!node.nextSibling || isBlockElement(blockElements, node.nextSibling))) {
	          return true;
	        }
	      }
	      return false;
	    };
	    var addRootBlocks = function (editor) {
	      var dom = editor.dom, selection = editor.selection;
	      var schema = editor.schema, blockElements = schema.getBlockElements();
	      var node = selection.getStart();
	      var rootNode = editor.getBody();
	      var rng;
	      var startContainer, startOffset, endContainer, endOffset, rootBlockNode;
	      var tempNode, wrapped, restoreSelection;
	      var rootNodeName;
	      var forcedRootBlock = Settings.getForcedRootBlock(editor);
	      if (!node || !NodeType.isElement(node) || !forcedRootBlock) {
	        return;
	      }
	      rootNodeName = rootNode.nodeName.toLowerCase();
	      if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, node)) {
	        return;
	      }
	      rng = selection.getRng();
	      startContainer = rng.startContainer;
	      startOffset = rng.startOffset;
	      endContainer = rng.endContainer;
	      endOffset = rng.endOffset;
	      restoreSelection = EditorFocus.hasFocus(editor);
	      node = rootNode.firstChild;
	      while (node) {
	        if (isValidTarget(blockElements, node)) {
	          if (shouldRemoveTextNode(blockElements, node)) {
	            tempNode = node;
	            node = node.nextSibling;
	            dom.remove(tempNode);
	            continue;
	          }
	          if (!rootBlockNode) {
	            rootBlockNode = dom.create(forcedRootBlock, Settings.getForcedRootBlockAttrs(editor));
	            node.parentNode.insertBefore(rootBlockNode, node);
	            wrapped = true;
	          }
	          tempNode = node;
	          node = node.nextSibling;
	          rootBlockNode.appendChild(tempNode);
	        } else {
	          rootBlockNode = null;
	          node = node.nextSibling;
	        }
	      }
	      if (wrapped && restoreSelection) {
	        rng.setStart(startContainer, startOffset);
	        rng.setEnd(endContainer, endOffset);
	        selection.setRng(rng);
	        editor.nodeChanged();
	      }
	    };
	    var setup$8 = function (editor) {
	      if (Settings.getForcedRootBlock(editor)) {
	        editor.on('NodeChange', curry(addRootBlocks, editor));
	      }
	    };
	    var ForceBlocks = { setup: setup$8 };
	
	    var isText$8 = NodeType.isText;
	    var startsWithCaretContainer$1 = function (node) {
	      return isText$8(node) && node.data[0] === Zwsp.ZWSP;
	    };
	    var endsWithCaretContainer$1 = function (node) {
	      return isText$8(node) && node.data[node.data.length - 1] === Zwsp.ZWSP;
	    };
	    var createZwsp = function (node) {
	      return node.ownerDocument.createTextNode(Zwsp.ZWSP);
	    };
	    var insertBefore = function (node) {
	      if (isText$8(node.previousSibling)) {
	        if (endsWithCaretContainer$1(node.previousSibling)) {
	          return node.previousSibling;
	        } else {
	          node.previousSibling.appendData(Zwsp.ZWSP);
	          return node.previousSibling;
	        }
	      } else if (isText$8(node)) {
	        if (startsWithCaretContainer$1(node)) {
	          return node;
	        } else {
	          node.insertData(0, Zwsp.ZWSP);
	          return node;
	        }
	      } else {
	        var newNode = createZwsp(node);
	        node.parentNode.insertBefore(newNode, node);
	        return newNode;
	      }
	    };
	    var insertAfter = function (node) {
	      if (isText$8(node.nextSibling)) {
	        if (startsWithCaretContainer$1(node.nextSibling)) {
	          return node.nextSibling;
	        } else {
	          node.nextSibling.insertData(0, Zwsp.ZWSP);
	          return node.nextSibling;
	        }
	      } else if (isText$8(node)) {
	        if (endsWithCaretContainer$1(node)) {
	          return node;
	        } else {
	          node.appendData(Zwsp.ZWSP);
	          return node;
	        }
	      } else {
	        var newNode = createZwsp(node);
	        if (node.nextSibling) {
	          node.parentNode.insertBefore(newNode, node.nextSibling);
	        } else {
	          node.parentNode.appendChild(newNode);
	        }
	        return newNode;
	      }
	    };
	    var insertInline$1 = function (before, node) {
	      return before ? insertBefore(node) : insertAfter(node);
	    };
	    var insertInlineBefore = curry(insertInline$1, true);
	    var insertInlineAfter = curry(insertInline$1, false);
	
	    var insertInlinePos = function (pos, before) {
	      if (NodeType.isText(pos.container())) {
	        return insertInline$1(before, pos.container());
	      } else {
	        return insertInline$1(before, pos.getNode());
	      }
	    };
	    var isPosCaretContainer = function (pos, caret) {
	      var caretNode = caret.get();
	      return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);
	    };
	    var renderCaret = function (caret, location) {
	      return location.fold(function (element) {
	        CaretContainerRemove.remove(caret.get());
	        var text = insertInlineBefore(element);
	        caret.set(text);
	        return Option.some(CaretPosition$1(text, text.length - 1));
	      }, function (element) {
	        return CaretFinder.firstPositionIn(element).map(function (pos) {
	          if (!isPosCaretContainer(pos, caret)) {
	            CaretContainerRemove.remove(caret.get());
	            var text = insertInlinePos(pos, true);
	            caret.set(text);
	            return CaretPosition$1(text, 1);
	          } else {
	            return CaretPosition$1(caret.get(), 1);
	          }
	        });
	      }, function (element) {
	        return CaretFinder.lastPositionIn(element).map(function (pos) {
	          if (!isPosCaretContainer(pos, caret)) {
	            CaretContainerRemove.remove(caret.get());
	            var text = insertInlinePos(pos, false);
	            caret.set(text);
	            return CaretPosition$1(text, text.length - 1);
	          } else {
	            return CaretPosition$1(caret.get(), caret.get().length - 1);
	          }
	        });
	      }, function (element) {
	        CaretContainerRemove.remove(caret.get());
	        var text = insertInlineAfter(element);
	        caret.set(text);
	        return Option.some(CaretPosition$1(text, 1));
	      });
	    };
	    var BoundaryCaret = { renderCaret: renderCaret };
	
	    var strongRtl = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/;
	    var hasStrongRtl = function (text) {
	      return strongRtl.test(text);
	    };
	
	    var isInlineTarget = function (editor, elm) {
	      return is(Element.fromDom(elm), Settings.getInlineBoundarySelector(editor));
	    };
	    var isRtl$1 = function (element) {
	      return DOMUtils$1.DOM.getStyle(element, 'direction', true) === 'rtl' || hasStrongRtl(element.textContent);
	    };
	    var findInlineParents = function (isInlineTarget, rootNode, pos) {
	      return filter(DOMUtils$1.DOM.getParents(pos.container(), '*', rootNode), isInlineTarget);
	    };
	    var findRootInline = function (isInlineTarget, rootNode, pos) {
	      var parents = findInlineParents(isInlineTarget, rootNode, pos);
	      return Option.from(parents[parents.length - 1]);
	    };
	    var hasSameParentBlock = function (rootNode, node1, node2) {
	      var block1 = getParentBlock(node1, rootNode);
	      var block2 = getParentBlock(node2, rootNode);
	      return block1 && block1 === block2;
	    };
	    var isAtZwsp = function (pos) {
	      return isBeforeInline(pos) || isAfterInline(pos);
	    };
	    var normalizePosition = function (forward, pos) {
	      if (!pos) {
	        return pos;
	      }
	      var container = pos.container(), offset = pos.offset();
	      if (forward) {
	        if (isCaretContainerInline(container)) {
	          if (NodeType.isText(container.nextSibling)) {
	            return CaretPosition$1(container.nextSibling, 0);
	          } else {
	            return CaretPosition$1.after(container);
	          }
	        } else {
	          return isBeforeInline(pos) ? CaretPosition$1(container, offset + 1) : pos;
	        }
	      } else {
	        if (isCaretContainerInline(container)) {
	          if (NodeType.isText(container.previousSibling)) {
	            return CaretPosition$1(container.previousSibling, container.previousSibling.data.length);
	          } else {
	            return CaretPosition$1.before(container);
	          }
	        } else {
	          return isAfterInline(pos) ? CaretPosition$1(container, offset - 1) : pos;
	        }
	      }
	    };
	    var normalizeForwards = curry(normalizePosition, true);
	    var normalizeBackwards = curry(normalizePosition, false);
	    var InlineUtils = {
	      isInlineTarget: isInlineTarget,
	      findRootInline: findRootInline,
	      isRtl: isRtl$1,
	      isAtZwsp: isAtZwsp,
	      normalizePosition: normalizePosition,
	      normalizeForwards: normalizeForwards,
	      normalizeBackwards: normalizeBackwards,
	      hasSameParentBlock: hasSameParentBlock
	    };
	
	    var evaluateUntil = function (fns, args) {
	      for (var i = 0; i < fns.length; i++) {
	        var result = fns[i].apply(null, args);
	        if (result.isSome()) {
	          return result;
	        }
	      }
	      return Option.none();
	    };
	    var LazyEvaluator = { evaluateUntil: evaluateUntil };
	
	    var Location = Adt.generate([
	      { before: ['element'] },
	      { start: ['element'] },
	      { end: ['element'] },
	      { after: ['element'] }
	    ]);
	    var rescope = function (rootNode, node) {
	      var parentBlock = getParentBlock(node, rootNode);
	      return parentBlock ? parentBlock : rootNode;
	    };
	    var before$4 = function (isInlineTarget, rootNode, pos) {
	      var nPos = InlineUtils.normalizeForwards(pos);
	      var scope = rescope(rootNode, nPos.container());
	      return InlineUtils.findRootInline(isInlineTarget, scope, nPos).fold(function () {
	        return CaretFinder.nextPosition(scope, nPos).bind(curry(InlineUtils.findRootInline, isInlineTarget, scope)).map(function (inline) {
	          return Location.before(inline);
	        });
	      }, Option.none);
	    };
	    var isNotInsideFormatCaretContainer = function (rootNode, elm) {
	      return getParentCaretContainer(rootNode, elm) === null;
	    };
	    var findInsideRootInline = function (isInlineTarget, rootNode, pos) {
	      return InlineUtils.findRootInline(isInlineTarget, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));
	    };
	    var start = function (isInlineTarget, rootNode, pos) {
	      var nPos = InlineUtils.normalizeBackwards(pos);
	      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(function (inline) {
	        var prevPos = CaretFinder.prevPosition(inline, nPos);
	        return prevPos.isNone() ? Option.some(Location.start(inline)) : Option.none();
	      });
	    };
	    var end = function (isInlineTarget, rootNode, pos) {
	      var nPos = InlineUtils.normalizeForwards(pos);
	      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(function (inline) {
	        var nextPos = CaretFinder.nextPosition(inline, nPos);
	        return nextPos.isNone() ? Option.some(Location.end(inline)) : Option.none();
	      });
	    };
	    var after$3 = function (isInlineTarget, rootNode, pos) {
	      var nPos = InlineUtils.normalizeBackwards(pos);
	      var scope = rescope(rootNode, nPos.container());
	      return InlineUtils.findRootInline(isInlineTarget, scope, nPos).fold(function () {
	        return CaretFinder.prevPosition(scope, nPos).bind(curry(InlineUtils.findRootInline, isInlineTarget, scope)).map(function (inline) {
	          return Location.after(inline);
	        });
	      }, Option.none);
	    };
	    var isValidLocation = function (location) {
	      return InlineUtils.isRtl(getElement(location)) === false;
	    };
	    var readLocation = function (isInlineTarget, rootNode, pos) {
	      var location = LazyEvaluator.evaluateUntil([
	        before$4,
	        start,
	        end,
	        after$3
	      ], [
	        isInlineTarget,
	        rootNode,
	        pos
	      ]);
	      return location.filter(isValidLocation);
	    };
	    var getElement = function (location) {
	      return location.fold(identity, identity, identity, identity);
	    };
	    var getName = function (location) {
	      return location.fold(constant('before'), constant('start'), constant('end'), constant('after'));
	    };
	    var outside = function (location) {
	      return location.fold(Location.before, Location.before, Location.after, Location.after);
	    };
	    var inside = function (location) {
	      return location.fold(Location.start, Location.start, Location.end, Location.end);
	    };
	    var isEq$5 = function (location1, location2) {
	      return getName(location1) === getName(location2) && getElement(location1) === getElement(location2);
	    };
	    var betweenInlines = function (forward, isInlineTarget, rootNode, from, to, location) {
	      return lift2(InlineUtils.findRootInline(isInlineTarget, rootNode, from), InlineUtils.findRootInline(isInlineTarget, rootNode, to), function (fromInline, toInline) {
	        if (fromInline !== toInline && InlineUtils.hasSameParentBlock(rootNode, fromInline, toInline)) {
	          return Location.after(forward ? fromInline : toInline);
	        } else {
	          return location;
	        }
	      }).getOr(location);
	    };
	    var skipNoMovement = function (fromLocation, toLocation) {
	      return fromLocation.fold(constant(true), function (fromLocation) {
	        return !isEq$5(fromLocation, toLocation);
	      });
	    };
	    var findLocationTraverse = function (forward, isInlineTarget, rootNode, fromLocation, pos) {
	      var from = InlineUtils.normalizePosition(forward, pos);
	      var to = CaretFinder.fromPosition(forward, rootNode, from).map(curry(InlineUtils.normalizePosition, forward));
	      var location = to.fold(function () {
	        return fromLocation.map(outside);
	      }, function (to) {
	        return readLocation(isInlineTarget, rootNode, to).map(curry(betweenInlines, forward, isInlineTarget, rootNode, from, to)).filter(curry(skipNoMovement, fromLocation));
	      });
	      return location.filter(isValidLocation);
	    };
	    var findLocationSimple = function (forward, location) {
	      if (forward) {
	        return location.fold(compose(Option.some, Location.start), Option.none, compose(Option.some, Location.after), Option.none);
	      } else {
	        return location.fold(Option.none, compose(Option.some, Location.before), Option.none, compose(Option.some, Location.end));
	      }
	    };
	    var findLocation = function (forward, isInlineTarget, rootNode, pos) {
	      var from = InlineUtils.normalizePosition(forward, pos);
	      var fromLocation = readLocation(isInlineTarget, rootNode, from);
	      return readLocation(isInlineTarget, rootNode, from).bind(curry(findLocationSimple, forward)).orThunk(function () {
	        return findLocationTraverse(forward, isInlineTarget, rootNode, fromLocation, pos);
	      });
	    };
	    var BoundaryLocation = {
	      readLocation: readLocation,
	      findLocation: findLocation,
	      prevLocation: curry(findLocation, false),
	      nextLocation: curry(findLocation, true),
	      getElement: getElement,
	      outside: outside,
	      inside: inside
	    };
	
	    var hasSelectionModifyApi = function (editor) {
	      return isFunction(editor.selection.getSel().modify);
	    };
	    var moveRel = function (forward, selection, pos) {
	      var delta = forward ? 1 : -1;
	      selection.setRng(CaretPosition$1(pos.container(), pos.offset() + delta).toRange());
	      selection.getSel().modify('move', forward ? 'forward' : 'backward', 'word');
	      return true;
	    };
	    var moveByWord = function (forward, editor) {
	      var rng = editor.selection.getRng();
	      var pos = forward ? CaretPosition$1.fromRangeEnd(rng) : CaretPosition$1.fromRangeStart(rng);
	      if (!hasSelectionModifyApi(editor)) {
	        return false;
	      } else if (forward && isBeforeInline(pos)) {
	        return moveRel(true, editor.selection, pos);
	      } else if (!forward && isAfterInline(pos)) {
	        return moveRel(false, editor.selection, pos);
	      } else {
	        return false;
	      }
	    };
	    var WordSelection = {
	      hasSelectionModifyApi: hasSelectionModifyApi,
	      moveByWord: moveByWord
	    };
	
	    var setCaretPosition = function (editor, pos) {
	      var rng = editor.dom.createRng();
	      rng.setStart(pos.container(), pos.offset());
	      rng.setEnd(pos.container(), pos.offset());
	      editor.selection.setRng(rng);
	    };
	    var isFeatureEnabled = function (editor) {
	      return editor.settings.inline_boundaries !== false;
	    };
	    var setSelected = function (state, elm) {
	      if (state) {
	        elm.setAttribute('data-mce-selected', 'inline-boundary');
	      } else {
	        elm.removeAttribute('data-mce-selected');
	      }
	    };
	    var renderCaretLocation = function (editor, caret, location) {
	      return BoundaryCaret.renderCaret(caret, location).map(function (pos) {
	        setCaretPosition(editor, pos);
	        return location;
	      });
	    };
	    var findLocation$1 = function (editor, caret, forward) {
	      var rootNode = editor.getBody();
	      var from = CaretPosition$1.fromRangeStart(editor.selection.getRng());
	      var isInlineTarget = curry(InlineUtils.isInlineTarget, editor);
	      var location = BoundaryLocation.findLocation(forward, isInlineTarget, rootNode, from);
	      return location.bind(function (location) {
	        return renderCaretLocation(editor, caret, location);
	      });
	    };
	    var toggleInlines = function (isInlineTarget, dom, elms) {
	      var selectedInlines = filter(dom.select('*[data-mce-selected="inline-boundary"]'), isInlineTarget);
	      var targetInlines = filter(elms, isInlineTarget);
	      each(difference(selectedInlines, targetInlines), curry(setSelected, false));
	      each(difference(targetInlines, selectedInlines), curry(setSelected, true));
	    };
	    var safeRemoveCaretContainer = function (editor, caret) {
	      if (editor.selection.isCollapsed() && editor.composing !== true && caret.get()) {
	        var pos = CaretPosition$1.fromRangeStart(editor.selection.getRng());
	        if (CaretPosition$1.isTextPosition(pos) && InlineUtils.isAtZwsp(pos) === false) {
	          setCaretPosition(editor, CaretContainerRemove.removeAndReposition(caret.get(), pos));
	          caret.set(null);
	        }
	      }
	    };
	    var renderInsideInlineCaret = function (isInlineTarget, editor, caret, elms) {
	      if (editor.selection.isCollapsed()) {
	        var inlines = filter(elms, isInlineTarget);
	        each(inlines, function (inline) {
	          var pos = CaretPosition$1.fromRangeStart(editor.selection.getRng());
	          BoundaryLocation.readLocation(isInlineTarget, editor.getBody(), pos).bind(function (location) {
	            return renderCaretLocation(editor, caret, location);
	          });
	        });
	      }
	    };
	    var move = function (editor, caret, forward) {
	      return function () {
	        return isFeatureEnabled(editor) ? findLocation$1(editor, caret, forward).isSome() : false;
	      };
	    };
	    var moveWord = function (forward, editor, caret) {
	      return function () {
	        return isFeatureEnabled(editor) ? WordSelection.moveByWord(forward, editor) : false;
	      };
	    };
	    var setupSelectedState = function (editor) {
	      var caret = Cell(null);
	      var isInlineTarget = curry(InlineUtils.isInlineTarget, editor);
	      editor.on('NodeChange', function (e) {
	        if (isFeatureEnabled(editor) && !(Env.browser.isIE() && e.initial)) {
	          toggleInlines(isInlineTarget, editor.dom, e.parents);
	          safeRemoveCaretContainer(editor, caret);
	          renderInsideInlineCaret(isInlineTarget, editor, caret, e.parents);
	        }
	      });
	      return caret;
	    };
	    var moveNextWord = curry(moveWord, true);
	    var movePrevWord = curry(moveWord, false);
	    var BoundarySelection = {
	      move: move,
	      moveNextWord: moveNextWord,
	      movePrevWord: movePrevWord,
	      setupSelectedState: setupSelectedState,
	      setCaretPosition: setCaretPosition
	    };
	
	    var getNodeClientRects = function (node) {
	      var toArrayWithNode = function (clientRects) {
	        return map(clientRects, function (clientRect) {
	          clientRect = clone$1(clientRect);
	          clientRect.node = node;
	          return clientRect;
	        });
	      };
	      if (NodeType.isElement(node)) {
	        return toArrayWithNode(node.getClientRects());
	      }
	      if (NodeType.isText(node)) {
	        var rng = node.ownerDocument.createRange();
	        rng.setStart(node, 0);
	        rng.setEnd(node, node.data.length);
	        return toArrayWithNode(rng.getClientRects());
	      }
	    };
	    var getClientRects = function (node) {
	      return foldl(node, function (result, node) {
	        return result.concat(getNodeClientRects(node));
	      }, []);
	    };
	
	    var VDirection;
	    (function (VDirection) {
	      VDirection[VDirection['Up'] = -1] = 'Up';
	      VDirection[VDirection['Down'] = 1] = 'Down';
	    }(VDirection || (VDirection = {})));
	    var findUntil = function (direction, root, predicateFn, node) {
	      while (node = findNode(node, direction, isEditableCaretCandidate, root)) {
	        if (predicateFn(node)) {
	          return;
	        }
	      }
	    };
	    var walkUntil = function (direction, isAboveFn, isBeflowFn, root, predicateFn, caretPosition) {
	      var line = 0, node;
	      var result = [];
	      var targetClientRect;
	      var add = function (node) {
	        var i, clientRect, clientRects;
	        clientRects = getClientRects([node]);
	        if (direction === -1) {
	          clientRects = clientRects.reverse();
	        }
	        for (i = 0; i < clientRects.length; i++) {
	          clientRect = clientRects[i];
	          if (isBeflowFn(clientRect, targetClientRect)) {
	            continue;
	          }
	          if (result.length > 0 && isAboveFn(clientRect, ArrUtils.last(result))) {
	            line++;
	          }
	          clientRect.line = line;
	          if (predicateFn(clientRect)) {
	            return true;
	          }
	          result.push(clientRect);
	        }
	      };
	      targetClientRect = ArrUtils.last(caretPosition.getClientRects());
	      if (!targetClientRect) {
	        return result;
	      }
	      node = caretPosition.getNode();
	      add(node);
	      findUntil(direction, root, add, node);
	      return result;
	    };
	    var aboveLineNumber = function (lineNumber, clientRect) {
	      return clientRect.line > lineNumber;
	    };
	    var isLineNumber = function (lineNumber, clientRect) {
	      return clientRect.line === lineNumber;
	    };
	    var upUntil = curry(walkUntil, VDirection.Up, isAbove, isBelow);
	    var downUntil = curry(walkUntil, VDirection.Down, isBelow, isAbove);
	    var positionsUntil = function (direction, root, predicateFn, node) {
	      var caretWalker = CaretWalker(root);
	      var walkFn, isBelowFn, isAboveFn, caretPosition;
	      var result = [];
	      var line = 0, clientRect, targetClientRect;
	      var getClientRect = function (caretPosition) {
	        if (direction === 1) {
	          return ArrUtils.last(caretPosition.getClientRects());
	        }
	        return ArrUtils.last(caretPosition.getClientRects());
	      };
	      if (direction === 1) {
	        walkFn = caretWalker.next;
	        isBelowFn = isBelow;
	        isAboveFn = isAbove;
	        caretPosition = CaretPosition$1.after(node);
	      } else {
	        walkFn = caretWalker.prev;
	        isBelowFn = isAbove;
	        isAboveFn = isBelow;
	        caretPosition = CaretPosition$1.before(node);
	      }
	      targetClientRect = getClientRect(caretPosition);
	      do {
	        if (!caretPosition.isVisible()) {
	          continue;
	        }
	        clientRect = getClientRect(caretPosition);
	        if (isAboveFn(clientRect, targetClientRect)) {
	          continue;
	        }
	        if (result.length > 0 && isBelowFn(clientRect, ArrUtils.last(result))) {
	          line++;
	        }
	        clientRect = clone$1(clientRect);
	        clientRect.position = caretPosition;
	        clientRect.line = line;
	        if (predicateFn(clientRect)) {
	          return result;
	        }
	        result.push(clientRect);
	      } while (caretPosition = walkFn(caretPosition));
	      return result;
	    };
	    var isAboveLine = function (lineNumber) {
	      return function (clientRect) {
	        return aboveLineNumber(lineNumber, clientRect);
	      };
	    };
	    var isLine = function (lineNumber) {
	      return function (clientRect) {
	        return isLineNumber(lineNumber, clientRect);
	      };
	    };
	
	    var isContentEditableFalse$7 = NodeType.isContentEditableFalse;
	    var findNode$1 = findNode;
	    var distanceToRectLeft = function (clientRect, clientX) {
	      return Math.abs(clientRect.left - clientX);
	    };
	    var distanceToRectRight = function (clientRect, clientX) {
	      return Math.abs(clientRect.right - clientX);
	    };
	    var isInside = function (clientX, clientRect) {
	      return clientX >= clientRect.left && clientX <= clientRect.right;
	    };
	    var findClosestClientRect = function (clientRects, clientX) {
	      return ArrUtils.reduce(clientRects, function (oldClientRect, clientRect) {
	        var oldDistance, newDistance;
	        oldDistance = Math.min(distanceToRectLeft(oldClientRect, clientX), distanceToRectRight(oldClientRect, clientX));
	        newDistance = Math.min(distanceToRectLeft(clientRect, clientX), distanceToRectRight(clientRect, clientX));
	        if (isInside(clientX, clientRect)) {
	          return clientRect;
	        }
	        if (isInside(clientX, oldClientRect)) {
	          return oldClientRect;
	        }
	        if (newDistance === oldDistance && isContentEditableFalse$7(clientRect.node)) {
	          return clientRect;
	        }
	        if (newDistance < oldDistance) {
	          return clientRect;
	        }
	        return oldClientRect;
	      });
	    };
	    var walkUntil$1 = function (direction, root, predicateFn, node) {
	      while (node = findNode$1(node, direction, isEditableCaretCandidate, root)) {
	        if (predicateFn(node)) {
	          return;
	        }
	      }
	    };
	    var findLineNodeRects = function (root, targetNodeRect) {
	      var clientRects = [];
	      var collect = function (checkPosFn, node) {
	        var lineRects;
	        lineRects = filter(getClientRects([node]), function (clientRect) {
	          return !checkPosFn(clientRect, targetNodeRect);
	        });
	        clientRects = clientRects.concat(lineRects);
	        return lineRects.length === 0;
	      };
	      clientRects.push(targetNodeRect);
	      walkUntil$1(VDirection.Up, root, curry(collect, isAbove), targetNodeRect.node);
	      walkUntil$1(VDirection.Down, root, curry(collect, isBelow), targetNodeRect.node);
	      return clientRects;
	    };
	    var getFakeCaretTargets = function (root) {
	      return filter(from$1(root.getElementsByTagName('*')), isFakeCaretTarget);
	    };
	    var caretInfo = function (clientRect, clientX) {
	      return {
	        node: clientRect.node,
	        before: distanceToRectLeft(clientRect, clientX) < distanceToRectRight(clientRect, clientX)
	      };
	    };
	    var closestCaret = function (root, clientX, clientY) {
	      var closestNodeRect;
	      var contentEditableFalseNodeRects = getClientRects(getFakeCaretTargets(root));
	      var targetNodeRects = filter(contentEditableFalseNodeRects, function (rect) {
	        return clientY >= rect.top && clientY <= rect.bottom;
	      });
	      closestNodeRect = findClosestClientRect(targetNodeRects, clientX);
	      if (closestNodeRect) {
	        closestNodeRect = findClosestClientRect(findLineNodeRects(root, closestNodeRect), clientX);
	        if (closestNodeRect && isFakeCaretTarget(closestNodeRect.node)) {
	          return caretInfo(closestNodeRect, clientX);
	        }
	      }
	      return null;
	    };
	
	    var isContentEditableTrue$3 = NodeType.isContentEditableTrue;
	    var isContentEditableFalse$8 = NodeType.isContentEditableFalse;
	    var showCaret = function (direction, editor, node, before, scrollIntoView) {
	      return editor._selectionOverrides.showCaret(direction, node, before, scrollIntoView);
	    };
	    var getNodeRange = function (node) {
	      var rng = node.ownerDocument.createRange();
	      rng.selectNode(node);
	      return rng;
	    };
	    var selectNode = function (editor, node) {
	      var e = editor.fire('BeforeObjectSelected', { target: node });
	      if (e.isDefaultPrevented()) {
	        return null;
	      }
	      return getNodeRange(node);
	    };
	    var renderCaretAtRange = function (editor, range, scrollIntoView) {
	      var normalizedRange = normalizeRange(1, editor.getBody(), range);
	      var caretPosition = CaretPosition$1.fromRangeStart(normalizedRange);
	      var caretPositionNode = caretPosition.getNode();
	      if (isContentEditableFalse$8(caretPositionNode)) {
	        return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);
	      }
	      var caretPositionBeforeNode = caretPosition.getNode(true);
	      if (isContentEditableFalse$8(caretPositionBeforeNode)) {
	        return showCaret(1, editor, caretPositionBeforeNode, false, false);
	      }
	      var ceRoot = editor.dom.getParent(caretPosition.getNode(), function (node) {
	        return isContentEditableFalse$8(node) || isContentEditableTrue$3(node);
	      });
	      if (isContentEditableFalse$8(ceRoot)) {
	        return showCaret(1, editor, ceRoot, false, scrollIntoView);
	      }
	      return null;
	    };
	    var renderRangeCaret = function (editor, range, scrollIntoView) {
	      if (!range || !range.collapsed) {
	        return range;
	      }
	      var caretRange = renderCaretAtRange(editor, range, scrollIntoView);
	      if (caretRange) {
	        return caretRange;
	      }
	      return range;
	    };
	
	    var isChar = function (forward, predicate, pos) {
	      return Option.from(pos.container()).filter(NodeType.isText).exists(function (text) {
	        var delta = forward ? 0 : -1;
	        return predicate(text.data.charAt(pos.offset() + delta));
	      });
	    };
	    var isBeforeSpace = curry(isChar, true, isWhiteSpace$1);
	    var isAfterSpace = curry(isChar, false, isWhiteSpace$1);
	    var isEmptyText = function (pos) {
	      var container = pos.container();
	      return NodeType.isText(container) && container.data.length === 0;
	    };
	    var matchesElementPosition = function (before, predicate) {
	      return function (pos) {
	        return Option.from(getChildNodeAtRelativeOffset(before ? 0 : -1, pos)).filter(predicate).isSome();
	      };
	    };
	    var isImageBlock = function (node) {
	      return node.nodeName === 'IMG' && get$4(Element.fromDom(node), 'display') === 'block';
	    };
	    var isCefNode = function (node) {
	      return NodeType.isContentEditableFalse(node) && !NodeType.isBogusAll(node);
	    };
	    var isBeforeImageBlock = matchesElementPosition(true, isImageBlock);
	    var isAfterImageBlock = matchesElementPosition(false, isImageBlock);
	    var isBeforeTable = matchesElementPosition(true, NodeType.isTable);
	    var isAfterTable = matchesElementPosition(false, NodeType.isTable);
	    var isBeforeContentEditableFalse = matchesElementPosition(true, isCefNode);
	    var isAfterContentEditableFalse = matchesElementPosition(false, isCefNode);
	
	    var BreakType;
	    (function (BreakType) {
	      BreakType[BreakType['Br'] = 0] = 'Br';
	      BreakType[BreakType['Block'] = 1] = 'Block';
	      BreakType[BreakType['Wrap'] = 2] = 'Wrap';
	      BreakType[BreakType['Eol'] = 3] = 'Eol';
	    }(BreakType || (BreakType = {})));
	    var flip = function (direction, positions) {
	      return direction === HDirection.Backwards ? reverse(positions) : positions;
	    };
	    var walk$3 = function (direction, caretWalker, pos) {
	      return direction === HDirection.Forwards ? caretWalker.next(pos) : caretWalker.prev(pos);
	    };
	    var getBreakType = function (scope, direction, currentPos, nextPos) {
	      if (NodeType.isBr(nextPos.getNode(direction === HDirection.Forwards))) {
	        return BreakType.Br;
	      } else if (isInSameBlock(currentPos, nextPos) === false) {
	        return BreakType.Block;
	      } else {
	        return BreakType.Wrap;
	      }
	    };
	    var getPositionsUntil = function (predicate, direction, scope, start) {
	      var caretWalker = CaretWalker(scope);
	      var currentPos = start, nextPos;
	      var positions = [];
	      while (currentPos) {
	        nextPos = walk$3(direction, caretWalker, currentPos);
	        if (!nextPos) {
	          break;
	        }
	        if (NodeType.isBr(nextPos.getNode(false))) {
	          if (direction === HDirection.Forwards) {
	            return {
	              positions: flip(direction, positions).concat([nextPos]),
	              breakType: BreakType.Br,
	              breakAt: Option.some(nextPos)
	            };
	          } else {
	            return {
	              positions: flip(direction, positions),
	              breakType: BreakType.Br,
	              breakAt: Option.some(nextPos)
	            };
	          }
	        }
	        if (!nextPos.isVisible()) {
	          currentPos = nextPos;
	          continue;
	        }
	        if (predicate(currentPos, nextPos)) {
	          var breakType = getBreakType(scope, direction, currentPos, nextPos);
	          return {
	            positions: flip(direction, positions),
	            breakType: breakType,
	            breakAt: Option.some(nextPos)
	          };
	        }
	        positions.push(nextPos);
	        currentPos = nextPos;
	      }
	      return {
	        positions: flip(direction, positions),
	        breakType: BreakType.Eol,
	        breakAt: Option.none()
	      };
	    };
	    var getAdjacentLinePositions = function (direction, getPositionsUntilBreak, scope, start) {
	      return getPositionsUntilBreak(scope, start).breakAt.map(function (pos) {
	        var positions = getPositionsUntilBreak(scope, pos).positions;
	        return direction === HDirection.Backwards ? positions.concat(pos) : [pos].concat(positions);
	      }).getOr([]);
	    };
	    var findClosestHorizontalPositionFromPoint = function (positions, x) {
	      return foldl(positions, function (acc, newPos) {
	        return acc.fold(function () {
	          return Option.some(newPos);
	        }, function (lastPos) {
	          return lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), function (lastRect, newRect) {
	            var lastDist = Math.abs(x - lastRect.left);
	            var newDist = Math.abs(x - newRect.left);
	            return newDist <= lastDist ? newPos : lastPos;
	          }).or(acc);
	        });
	      }, Option.none());
	    };
	    var findClosestHorizontalPosition = function (positions, pos) {
	      return head(pos.getClientRects()).bind(function (targetRect) {
	        return findClosestHorizontalPositionFromPoint(positions, targetRect.left);
	      });
	    };
	    var getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);
	    var getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);
	    var isAtFirstLine = function (scope, pos) {
	      return getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();
	    };
	    var isAtLastLine = function (scope, pos) {
	      return getPositionsUntilNextLine(scope, pos).breakAt.isNone();
	    };
	    var getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);
	    var getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);
	    var getFirstLinePositions = function (scope) {
	      return CaretFinder.firstPositionIn(scope).map(function (pos) {
	        return [pos].concat(getPositionsUntilNextLine(scope, pos).positions);
	      }).getOr([]);
	    };
	    var getLastLinePositions = function (scope) {
	      return CaretFinder.lastPositionIn(scope).map(function (pos) {
	        return getPositionsUntilPreviousLine(scope, pos).positions.concat(pos);
	      }).getOr([]);
	    };
	
	    var isContentEditableFalse$9 = NodeType.isContentEditableFalse;
	    var getSelectedNode$1 = getSelectedNode;
	    var moveToCeFalseHorizontally = function (direction, editor, getNextPosFn, range) {
	      var forwards = direction === HDirection.Forwards;
	      var isBeforeContentEditableFalseFn = forwards ? isBeforeContentEditableFalse : isAfterContentEditableFalse;
	      if (!range.collapsed) {
	        var node = getSelectedNode$1(range);
	        if (isContentEditableFalse$9(node)) {
	          return showCaret(direction, editor, node, direction === HDirection.Backwards, true);
	        }
	      }
	      var rangeIsInContainerBlock = isRangeInCaretContainerBlock(range);
	      var caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);
	      if (isBeforeContentEditableFalseFn(caretPosition)) {
	        return selectNode(editor, caretPosition.getNode(!forwards));
	      }
	      var nextCaretPosition = InlineUtils.normalizePosition(forwards, getNextPosFn(caretPosition));
	      if (!nextCaretPosition) {
	        if (rangeIsInContainerBlock) {
	          return range;
	        }
	        return null;
	      }
	      if (isBeforeContentEditableFalseFn(nextCaretPosition)) {
	        return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, true);
	      }
	      var peekCaretPosition = getNextPosFn(nextCaretPosition);
	      if (peekCaretPosition && isBeforeContentEditableFalseFn(peekCaretPosition)) {
	        if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {
	          return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, true);
	        }
	      }
	      if (rangeIsInContainerBlock) {
	        return renderRangeCaret(editor, nextCaretPosition.toRange(), true);
	      }
	      return null;
	    };
	    var moveToCeFalseVertically = function (direction, editor, walkerFn, range) {
	      var caretPosition, linePositions, nextLinePositions;
	      var closestNextLineRect, caretClientRect, clientX;
	      var dist1, dist2, contentEditableFalseNode;
	      contentEditableFalseNode = getSelectedNode$1(range);
	      caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);
	      linePositions = walkerFn(editor.getBody(), isAboveLine(1), caretPosition);
	      nextLinePositions = filter(linePositions, isLine(1));
	      caretClientRect = ArrUtils.last(caretPosition.getClientRects());
	      if (isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition)) {
	        contentEditableFalseNode = caretPosition.getNode();
	      }
	      if (isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition)) {
	        contentEditableFalseNode = caretPosition.getNode(true);
	      }
	      if (!caretClientRect) {
	        return null;
	      }
	      clientX = caretClientRect.left;
	      closestNextLineRect = findClosestClientRect(nextLinePositions, clientX);
	      if (closestNextLineRect) {
	        if (isContentEditableFalse$9(closestNextLineRect.node)) {
	          dist1 = Math.abs(clientX - closestNextLineRect.left);
	          dist2 = Math.abs(clientX - closestNextLineRect.right);
	          return showCaret(direction, editor, closestNextLineRect.node, dist1 < dist2, true);
	        }
	      }
	      if (contentEditableFalseNode) {
	        var caretPositions = positionsUntil(direction, editor.getBody(), isAboveLine(1), contentEditableFalseNode);
	        closestNextLineRect = findClosestClientRect(filter(caretPositions, isLine(1)), clientX);
	        if (closestNextLineRect) {
	          return renderRangeCaret(editor, closestNextLineRect.position.toRange(), true);
	        }
	        closestNextLineRect = ArrUtils.last(filter(caretPositions, isLine(0)));
	        if (closestNextLineRect) {
	          return renderRangeCaret(editor, closestNextLineRect.position.toRange(), true);
	        }
	      }
	    };
	    var createTextBlock = function (editor) {
	      var textBlock = editor.dom.create(Settings.getForcedRootBlock(editor));
	      if (!Env.ie || Env.ie >= 11) {
	        textBlock.innerHTML = '<br data-mce-bogus="1">';
	      }
	      return textBlock;
	    };
	    var exitPreBlock = function (editor, direction, range) {
	      var pre, caretPos, newBlock;
	      var caretWalker = CaretWalker(editor.getBody());
	      var getNextVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.next);
	      var getPrevVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.prev);
	      if (range.collapsed && editor.settings.forced_root_block) {
	        pre = editor.dom.getParent(range.startContainer, 'PRE');
	        if (!pre) {
	          return;
	        }
	        if (direction === 1) {
	          caretPos = getNextVisualCaretPosition(CaretPosition$1.fromRangeStart(range));
	        } else {
	          caretPos = getPrevVisualCaretPosition(CaretPosition$1.fromRangeStart(range));
	        }
	        if (!caretPos) {
	          newBlock = createTextBlock(editor);
	          if (direction === 1) {
	            editor.$(pre).after(newBlock);
	          } else {
	            editor.$(pre).before(newBlock);
	          }
	          editor.selection.select(newBlock, true);
	          editor.selection.collapse();
	        }
	      }
	    };
	    var getHorizontalRange = function (editor, forward) {
	      var caretWalker = CaretWalker(editor.getBody());
	      var getNextVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.next);
	      var getPrevVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.prev);
	      var newRange;
	      var direction = forward ? HDirection.Forwards : HDirection.Backwards;
	      var getNextPosFn = forward ? getNextVisualCaretPosition : getPrevVisualCaretPosition;
	      var range = editor.selection.getRng();
	      newRange = moveToCeFalseHorizontally(direction, editor, getNextPosFn, range);
	      if (newRange) {
	        return newRange;
	      }
	      newRange = exitPreBlock(editor, direction, range);
	      if (newRange) {
	        return newRange;
	      }
	      return null;
	    };
	    var getVerticalRange = function (editor, down) {
	      var newRange;
	      var direction = down ? 1 : -1;
	      var walkerFn = down ? downUntil : upUntil;
	      var range = editor.selection.getRng();
	      newRange = moveToCeFalseVertically(direction, editor, walkerFn, range);
	      if (newRange) {
	        return newRange;
	      }
	      newRange = exitPreBlock(editor, direction, range);
	      if (newRange) {
	        return newRange;
	      }
	      return null;
	    };
	    var moveH = function (editor, forward) {
	      return function () {
	        var newRng = getHorizontalRange(editor, forward);
	        if (newRng) {
	          editor.selection.setRng(newRng);
	          return true;
	        } else {
	          return false;
	        }
	      };
	    };
	    var moveV = function (editor, down) {
	      return function () {
	        var newRng = getVerticalRange(editor, down);
	        if (newRng) {
	          editor.selection.setRng(newRng);
	          return true;
	        } else {
	          return false;
	        }
	      };
	    };
	    var isCefPosition = function (forward) {
	      return function (pos) {
	        return forward ? isAfterContentEditableFalse(pos) : isBeforeContentEditableFalse(pos);
	      };
	    };
	    var moveToLineEndPoint = function (editor, forward) {
	      return function () {
	        var from = forward ? CaretPosition$1.fromRangeEnd(editor.selection.getRng()) : CaretPosition$1.fromRangeStart(editor.selection.getRng());
	        var result = forward ? getPositionsUntilNextLine(editor.getBody(), from) : getPositionsUntilPreviousLine(editor.getBody(), from);
	        var to = forward ? last(result.positions) : head(result.positions);
	        return to.filter(isCefPosition(forward)).fold(constant(false), function (pos) {
	          editor.selection.setRng(pos.toRange());
	          return true;
	        });
	      };
	    };
	
	    var deflate = function (rect, delta) {
	      return {
	        left: rect.left - delta,
	        top: rect.top - delta,
	        right: rect.right + delta * 2,
	        bottom: rect.bottom + delta * 2,
	        width: rect.width + delta,
	        height: rect.height + delta
	      };
	    };
	    var getCorners = function (getYAxisValue, tds) {
	      return bind(tds, function (td) {
	        var rect = deflate(clone$1(td.getBoundingClientRect()), -1);
	        return [
	          {
	            x: rect.left,
	            y: getYAxisValue(rect),
	            cell: td
	          },
	          {
	            x: rect.right,
	            y: getYAxisValue(rect),
	            cell: td
	          }
	        ];
	      });
	    };
	    var findClosestCorner = function (corners, x, y) {
	      return foldl(corners, function (acc, newCorner) {
	        return acc.fold(function () {
	          return Option.some(newCorner);
	        }, function (oldCorner) {
	          var oldDist = Math.sqrt(Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y));
	          var newDist = Math.sqrt(Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y));
	          return Option.some(newDist < oldDist ? newCorner : oldCorner);
	        });
	      }, Option.none());
	    };
	    var getClosestCell = function (getYAxisValue, isTargetCorner, table, x, y) {
	      var cells = descendants$1(Element.fromDom(table), 'td,th,caption').map(function (e) {
	        return e.dom();
	      });
	      var corners = filter(getCorners(getYAxisValue, cells), function (corner) {
	        return isTargetCorner(corner, y);
	      });
	      return findClosestCorner(corners, x, y).map(function (corner) {
	        return corner.cell;
	      });
	    };
	    var getBottomValue = function (rect) {
	      return rect.bottom;
	    };
	    var getTopValue = function (rect) {
	      return rect.top;
	    };
	    var isAbove$1 = function (corner, y) {
	      return corner.y < y;
	    };
	    var isBelow$1 = function (corner, y) {
	      return corner.y > y;
	    };
	    var getClosestCellAbove = curry(getClosestCell, getBottomValue, isAbove$1);
	    var getClosestCellBelow = curry(getClosestCell, getTopValue, isBelow$1);
	    var findClosestPositionInAboveCell = function (table, pos) {
	      return head(pos.getClientRects()).bind(function (rect) {
	        return getClosestCellAbove(table, rect.left, rect.top);
	      }).bind(function (cell) {
	        return findClosestHorizontalPosition(getLastLinePositions(cell), pos);
	      });
	    };
	    var findClosestPositionInBelowCell = function (table, pos) {
	      return last(pos.getClientRects()).bind(function (rect) {
	        return getClosestCellBelow(table, rect.left, rect.top);
	      }).bind(function (cell) {
	        return findClosestHorizontalPosition(getFirstLinePositions(cell), pos);
	      });
	    };
	
	    var moveToRange = function (editor, rng) {
	      editor.selection.setRng(rng);
	      ScrollIntoView.scrollRangeIntoView(editor, rng);
	    };
	    var hasNextBreak = function (getPositionsUntil, scope, lineInfo) {
	      return lineInfo.breakAt.map(function (breakPos) {
	        return getPositionsUntil(scope, breakPos).breakAt.isSome();
	      }).getOr(false);
	    };
	    var startsWithWrapBreak = function (lineInfo) {
	      return lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;
	    };
	    var startsWithBrBreak = function (lineInfo) {
	      return lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;
	    };
	    var isAtTableCellLine = function (getPositionsUntil, scope, pos) {
	      var lineInfo = getPositionsUntil(scope, pos);
	      if (startsWithWrapBreak(lineInfo) || !NodeType.isBr(pos.getNode()) && startsWithBrBreak(lineInfo)) {
	        return !hasNextBreak(getPositionsUntil, scope, lineInfo);
	      } else {
	        return lineInfo.breakAt.isNone();
	      }
	    };
	    var isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);
	    var isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);
	    var isCaretAtStartOrEndOfTable = function (forward, rng, table) {
	      var caretPos = CaretPosition$1.fromRangeStart(rng);
	      return CaretFinder.positionIn(!forward, table).map(function (pos) {
	        return pos.isEqual(caretPos);
	      }).getOr(false);
	    };
	    var navigateHorizontally = function (editor, forward, table, td) {
	      var rng = editor.selection.getRng();
	      var direction = forward ? 1 : -1;
	      if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table)) {
	        var newRng = showCaret(direction, editor, table, !forward, true);
	        moveToRange(editor, newRng);
	        return true;
	      }
	      return false;
	    };
	    var getClosestAbovePosition = function (root, table, start) {
	      return findClosestPositionInAboveCell(table, start).orThunk(function () {
	        return head(start.getClientRects()).bind(function (rect) {
	          return findClosestHorizontalPositionFromPoint(getPositionsAbove(root, CaretPosition$1.before(table)), rect.left);
	        });
	      }).getOr(CaretPosition$1.before(table));
	    };
	    var getClosestBelowPosition = function (root, table, start) {
	      return findClosestPositionInBelowCell(table, start).orThunk(function () {
	        return head(start.getClientRects()).bind(function (rect) {
	          return findClosestHorizontalPositionFromPoint(getPositionsBelow(root, CaretPosition$1.after(table)), rect.left);
	        });
	      }).getOr(CaretPosition$1.after(table));
	    };
	    var getTable = function (previous, pos) {
	      var node = pos.getNode(previous);
	      return NodeType.isElement(node) && node.nodeName === 'TABLE' ? Option.some(node) : Option.none();
	    };
	    var renderBlock = function (down, editor, table, pos) {
	      var forcedRootBlock = Settings.getForcedRootBlock(editor);
	      if (forcedRootBlock) {
	        editor.undoManager.transact(function () {
	          var element = Element.fromTag(forcedRootBlock);
	          setAll(element, Settings.getForcedRootBlockAttrs(editor));
	          append(element, Element.fromTag('br'));
	          if (down) {
	            after(Element.fromDom(table), element);
	          } else {
	            before(Element.fromDom(table), element);
	          }
	          var rng = editor.dom.createRng();
	          rng.setStart(element.dom(), 0);
	          rng.setEnd(element.dom(), 0);
	          moveToRange(editor, rng);
	        });
	      } else {
	        moveToRange(editor, pos.toRange());
	      }
	    };
	    var moveCaret = function (editor, down, pos) {
	      var table = down ? getTable(true, pos) : getTable(false, pos);
	      var last = down === false;
	      table.fold(function () {
	        return moveToRange(editor, pos.toRange());
	      }, function (table) {
	        return CaretFinder.positionIn(last, editor.getBody()).filter(function (lastPos) {
	          return lastPos.isEqual(pos);
	        }).fold(function () {
	          return moveToRange(editor, pos.toRange());
	        }, function (_) {
	          return renderBlock(down, editor, table, pos);
	        });
	      });
	    };
	    var navigateVertically = function (editor, down, table, td) {
	      var rng = editor.selection.getRng();
	      var pos = CaretPosition$1.fromRangeStart(rng);
	      var root = editor.getBody();
	      if (!down && isAtFirstTableCellLine(td, pos)) {
	        var newPos = getClosestAbovePosition(root, table, pos);
	        moveCaret(editor, down, newPos);
	        return true;
	      } else if (down && isAtLastTableCellLine(td, pos)) {
	        var newPos = getClosestBelowPosition(root, table, pos);
	        moveCaret(editor, down, newPos);
	        return true;
	      } else {
	        return false;
	      }
	    };
	    var moveH$1 = function (editor, forward) {
	      return function () {
	        return Option.from(editor.dom.getParent(editor.selection.getNode(), 'td,th')).bind(function (td) {
	          return Option.from(editor.dom.getParent(td, 'table')).map(function (table) {
	            return navigateHorizontally(editor, forward, table);
	          });
	        }).getOr(false);
	      };
	    };
	    var moveV$1 = function (editor, forward) {
	      return function () {
	        return Option.from(editor.dom.getParent(editor.selection.getNode(), 'td,th')).bind(function (td) {
	          return Option.from(editor.dom.getParent(td, 'table')).map(function (table) {
	            return navigateVertically(editor, forward, table, td);
	          });
	        }).getOr(false);
	      };
	    };
	
	    var isTarget = function (node) {
	      return contains(['figcaption'], name(node));
	    };
	    var rangeBefore = function (target) {
	      var rng = domGlobals.document.createRange();
	      rng.setStartBefore(target.dom());
	      rng.setEndBefore(target.dom());
	      return rng;
	    };
	    var insertElement = function (root, elm, forward) {
	      if (forward) {
	        append(root, elm);
	      } else {
	        prepend(root, elm);
	      }
	    };
	    var insertBr = function (root, forward) {
	      var br = Element.fromTag('br');
	      insertElement(root, br, forward);
	      return rangeBefore(br);
	    };
	    var insertBlock$1 = function (root, forward, blockName, attrs) {
	      var block = Element.fromTag(blockName);
	      var br = Element.fromTag('br');
	      setAll(block, attrs);
	      append(block, br);
	      insertElement(root, block, forward);
	      return rangeBefore(br);
	    };
	    var insertEmptyLine = function (root, rootBlockName, attrs, forward) {
	      if (rootBlockName === '') {
	        return insertBr(root, forward);
	      } else {
	        return insertBlock$1(root, forward, rootBlockName, attrs);
	      }
	    };
	    var getClosestTargetBlock = function (pos, root) {
	      var isRoot = curry(eq, root);
	      return closest(Element.fromDom(pos.container()), isBlock, isRoot).filter(isTarget);
	    };
	    var isAtFirstOrLastLine = function (root, forward, pos) {
	      return forward ? isAtLastLine(root.dom(), pos) : isAtFirstLine(root.dom(), pos);
	    };
	    var moveCaretToNewEmptyLine = function (editor, forward) {
	      var root = Element.fromDom(editor.getBody());
	      var pos = CaretPosition$1.fromRangeStart(editor.selection.getRng());
	      var rootBlock = Settings.getForcedRootBlock(editor);
	      var rootBlockAttrs = Settings.getForcedRootBlockAttrs(editor);
	      return getClosestTargetBlock(pos, root).exists(function () {
	        if (isAtFirstOrLastLine(root, forward, pos)) {
	          var rng = insertEmptyLine(root, rootBlock, rootBlockAttrs, forward);
	          editor.selection.setRng(rng);
	          return true;
	        } else {
	          return false;
	        }
	      });
	    };
	    var moveV$2 = function (editor, forward) {
	      return function () {
	        if (editor.selection.isCollapsed()) {
	          return moveCaretToNewEmptyLine(editor, forward);
	        } else {
	          return false;
	        }
	      };
	    };
	
	    var defaultPatterns = function (patterns) {
	      return map(patterns, function (pattern) {
	        return __assign({
	          shiftKey: false,
	          altKey: false,
	          ctrlKey: false,
	          metaKey: false,
	          keyCode: 0,
	          action: noop
	        }, pattern);
	      });
	    };
	    var matchesEvent = function (pattern, evt) {
	      return evt.keyCode === pattern.keyCode && evt.shiftKey === pattern.shiftKey && evt.altKey === pattern.altKey && evt.ctrlKey === pattern.ctrlKey && evt.metaKey === pattern.metaKey;
	    };
	    var match$1 = function (patterns, evt) {
	      return bind(defaultPatterns(patterns), function (pattern) {
	        return matchesEvent(pattern, evt) ? [pattern] : [];
	      });
	    };
	    var action = function (f) {
	      var x = [];
	      for (var _i = 1; _i < arguments.length; _i++) {
	        x[_i - 1] = arguments[_i];
	      }
	      var args = Array.prototype.slice.call(arguments, 1);
	      return function () {
	        return f.apply(null, args);
	      };
	    };
	    var execute = function (patterns, evt) {
	      return find(match$1(patterns, evt), function (pattern) {
	        return pattern.action();
	      });
	    };
	    var MatchKeys = {
	      match: match$1,
	      action: action,
	      execute: execute
	    };
	
	    var executeKeydownOverride = function (editor, caret, evt) {
	      var os = detect$3().os;
	      MatchKeys.execute([
	        {
	          keyCode: VK.RIGHT,
	          action: moveH(editor, true)
	        },
	        {
	          keyCode: VK.LEFT,
	          action: moveH(editor, false)
	        },
	        {
	          keyCode: VK.UP,
	          action: moveV(editor, false)
	        },
	        {
	          keyCode: VK.DOWN,
	          action: moveV(editor, true)
	        },
	        {
	          keyCode: VK.RIGHT,
	          action: moveH$1(editor, true)
	        },
	        {
	          keyCode: VK.LEFT,
	          action: moveH$1(editor, false)
	        },
	        {
	          keyCode: VK.UP,
	          action: moveV$1(editor, false)
	        },
	        {
	          keyCode: VK.DOWN,
	          action: moveV$1(editor, true)
	        },
	        {
	          keyCode: VK.RIGHT,
	          action: BoundarySelection.move(editor, caret, true)
	        },
	        {
	          keyCode: VK.LEFT,
	          action: BoundarySelection.move(editor, caret, false)
	        },
	        {
	          keyCode: VK.RIGHT,
	          ctrlKey: !os.isOSX(),
	          altKey: os.isOSX(),
	          action: BoundarySelection.moveNextWord(editor, caret)
	        },
	        {
	          keyCode: VK.LEFT,
	          ctrlKey: !os.isOSX(),
	          altKey: os.isOSX(),
	          action: BoundarySelection.movePrevWord(editor, caret)
	        },
	        {
	          keyCode: VK.UP,
	          action: moveV$2(editor, false)
	        },
	        {
	          keyCode: VK.DOWN,
	          action: moveV$2(editor, true)
	        }
	      ], evt).each(function (_) {
	        evt.preventDefault();
	      });
	    };
	    var setup$9 = function (editor, caret) {
	      editor.on('keydown', function (evt) {
	        if (evt.isDefaultPrevented() === false) {
	          executeKeydownOverride(editor, caret, evt);
	        }
	      });
	    };
	    var ArrowKeys = { setup: setup$9 };
	
	    var isBeforeRoot = function (rootNode) {
	      return function (elm) {
	        return eq(rootNode, Element.fromDom(elm.dom().parentNode));
	      };
	    };
	    var getParentBlock$1 = function (rootNode, elm) {
	      return contains$2(rootNode, elm) ? closest(elm, function (element) {
	        return isTextBlock(element) || isListItem(element);
	      }, isBeforeRoot(rootNode)) : Option.none();
	    };
	    var placeCaretInEmptyBody = function (editor) {
	      var body = editor.getBody();
	      var node = body.firstChild && editor.dom.isBlock(body.firstChild) ? body.firstChild : body;
	      editor.selection.setCursorLocation(node, 0);
	    };
	    var paddEmptyBody = function (editor) {
	      if (editor.dom.isEmpty(editor.getBody())) {
	        editor.setContent('');
	        placeCaretInEmptyBody(editor);
	      }
	    };
	    var willDeleteLastPositionInElement = function (forward, fromPos, elm) {
	      return lift2(CaretFinder.firstPositionIn(elm), CaretFinder.lastPositionIn(elm), function (firstPos, lastPos) {
	        var normalizedFirstPos = InlineUtils.normalizePosition(true, firstPos);
	        var normalizedLastPos = InlineUtils.normalizePosition(false, lastPos);
	        var normalizedFromPos = InlineUtils.normalizePosition(false, fromPos);
	        if (forward) {
	          return CaretFinder.nextPosition(elm, normalizedFromPos).map(function (nextPos) {
	            return nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos);
	          }).getOr(false);
	        } else {
	          return CaretFinder.prevPosition(elm, normalizedFromPos).map(function (prevPos) {
	            return prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos);
	          }).getOr(false);
	        }
	      }).getOr(true);
	    };
	    var DeleteUtils = {
	      getParentBlock: getParentBlock$1,
	      paddEmptyBody: paddEmptyBody,
	      willDeleteLastPositionInElement: willDeleteLastPositionInElement
	    };
	
	    var blockPosition = function (block, position) {
	      return {
	        block: constant(block),
	        position: constant(position)
	      };
	    };
	    var blockBoundary = function (from, to) {
	      return {
	        from: constant(from),
	        to: constant(to)
	      };
	    };
	    var getBlockPosition = function (rootNode, pos) {
	      var rootElm = Element.fromDom(rootNode);
	      var containerElm = Element.fromDom(pos.container());
	      return DeleteUtils.getParentBlock(rootElm, containerElm).map(function (block) {
	        return blockPosition(block, pos);
	      });
	    };
	    var isDifferentBlocks = function (blockBoundary) {
	      return eq(blockBoundary.from().block(), blockBoundary.to().block()) === false;
	    };
	    var hasSameParent = function (blockBoundary) {
	      return parent(blockBoundary.from().block()).bind(function (parent1) {
	        return parent(blockBoundary.to().block()).filter(function (parent2) {
	          return eq(parent1, parent2);
	        });
	      }).isSome();
	    };
	    var isEditable = function (blockBoundary) {
	      return NodeType.isContentEditableFalse(blockBoundary.from().block().dom()) === false && NodeType.isContentEditableFalse(blockBoundary.to().block().dom()) === false;
	    };
	    var skipLastBr = function (rootNode, forward, blockPosition) {
	      if (NodeType.isBr(blockPosition.position().getNode()) && Empty.isEmpty(blockPosition.block()) === false) {
	        return CaretFinder.positionIn(false, blockPosition.block().dom()).bind(function (lastPositionInBlock) {
	          if (lastPositionInBlock.isEqual(blockPosition.position())) {
	            return CaretFinder.fromPosition(forward, rootNode, lastPositionInBlock).bind(function (to) {
	              return getBlockPosition(rootNode, to);
	            });
	          } else {
	            return Option.some(blockPosition);
	          }
	        }).getOr(blockPosition);
	      } else {
	        return blockPosition;
	      }
	    };
	    var readFromRange = function (rootNode, forward, rng) {
	      var fromBlockPos = getBlockPosition(rootNode, CaretPosition$1.fromRangeStart(rng));
	      var toBlockPos = fromBlockPos.bind(function (blockPos) {
	        return CaretFinder.fromPosition(forward, rootNode, blockPos.position()).bind(function (to) {
	          return getBlockPosition(rootNode, to).map(function (blockPos) {
	            return skipLastBr(rootNode, forward, blockPos);
	          });
	        });
	      });
	      return lift2(fromBlockPos, toBlockPos, blockBoundary).filter(function (blockBoundary) {
	        return isDifferentBlocks(blockBoundary) && hasSameParent(blockBoundary) && isEditable(blockBoundary);
	      });
	    };
	    var read$3 = function (rootNode, forward, rng) {
	      return rng.collapsed ? readFromRange(rootNode, forward, rng) : Option.none();
	    };
	    var BlockMergeBoundary = { read: read$3 };
	
	    var getChildrenUntilBlockBoundary = function (block) {
	      var children$1 = children(block);
	      return findIndex(children$1, isBlock).fold(function () {
	        return children$1;
	      }, function (index) {
	        return children$1.slice(0, index);
	      });
	    };
	    var extractChildren = function (block) {
	      var children = getChildrenUntilBlockBoundary(block);
	      each(children, remove);
	      return children;
	    };
	    var removeEmptyRoot = function (rootNode, block) {
	      var parents = Parents.parentsAndSelf(block, rootNode);
	      return find(parents.reverse(), function (element) {
	        return Empty.isEmpty(element);
	      }).each(remove);
	    };
	    var isEmptyBefore = function (el) {
	      return filter(prevSiblings(el), function (el) {
	        return !Empty.isEmpty(el);
	      }).length === 0;
	    };
	    var nestedBlockMerge = function (rootNode, fromBlock, toBlock, insertionPoint) {
	      if (Empty.isEmpty(toBlock)) {
	        PaddingBr.fillWithPaddingBr(toBlock);
	        return CaretFinder.firstPositionIn(toBlock.dom());
	      }
	      if (isEmptyBefore(insertionPoint) && Empty.isEmpty(fromBlock)) {
	        before(insertionPoint, Element.fromTag('br'));
	      }
	      var position = CaretFinder.prevPosition(toBlock.dom(), CaretPosition$1.before(insertionPoint.dom()));
	      each(extractChildren(fromBlock), function (child) {
	        before(insertionPoint, child);
	      });
	      removeEmptyRoot(rootNode, fromBlock);
	      return position;
	    };
	    var sidelongBlockMerge = function (rootNode, fromBlock, toBlock) {
	      if (Empty.isEmpty(toBlock)) {
	        remove(toBlock);
	        if (Empty.isEmpty(fromBlock)) {
	          PaddingBr.fillWithPaddingBr(fromBlock);
	        }
	        return CaretFinder.firstPositionIn(fromBlock.dom());
	      }
	      var position = CaretFinder.lastPositionIn(toBlock.dom());
	      each(extractChildren(fromBlock), function (child) {
	        append(toBlock, child);
	      });
	      removeEmptyRoot(rootNode, fromBlock);
	      return position;
	    };
	    var findInsertionPoint = function (toBlock, block) {
	      var parentsAndSelf = Parents.parentsAndSelf(block, toBlock);
	      return Option.from(parentsAndSelf[parentsAndSelf.length - 1]);
	    };
	    var getInsertionPoint = function (fromBlock, toBlock) {
	      return contains$2(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Option.none();
	    };
	    var trimBr = function (first, block) {
	      CaretFinder.positionIn(first, block.dom()).map(function (position) {
	        return position.getNode();
	      }).map(Element.fromDom).filter(isBr$1).each(remove);
	    };
	    var mergeBlockInto = function (rootNode, fromBlock, toBlock) {
	      trimBr(true, fromBlock);
	      trimBr(false, toBlock);
	      return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock), curry(nestedBlockMerge, rootNode, fromBlock, toBlock));
	    };
	    var mergeBlocks = function (rootNode, forward, block1, block2) {
	      return forward ? mergeBlockInto(rootNode, block2, block1) : mergeBlockInto(rootNode, block1, block2);
	    };
	    var MergeBlocks = { mergeBlocks: mergeBlocks };
	
	    var backspaceDelete = function (editor, forward) {
	      var rootNode = Element.fromDom(editor.getBody());
	      var position = BlockMergeBoundary.read(rootNode.dom(), forward, editor.selection.getRng()).bind(function (blockBoundary) {
	        return MergeBlocks.mergeBlocks(rootNode, forward, blockBoundary.from().block(), blockBoundary.to().block());
	      });
	      position.each(function (pos) {
	        editor.selection.setRng(pos.toRange());
	      });
	      return position.isSome();
	    };
	    var BlockBoundaryDelete = { backspaceDelete: backspaceDelete };
	
	    var deleteRangeMergeBlocks = function (rootNode, selection) {
	      var rng = selection.getRng();
	      return lift2(DeleteUtils.getParentBlock(rootNode, Element.fromDom(rng.startContainer)), DeleteUtils.getParentBlock(rootNode, Element.fromDom(rng.endContainer)), function (block1, block2) {
	        if (eq(block1, block2) === false) {
	          rng.deleteContents();
	          MergeBlocks.mergeBlocks(rootNode, true, block1, block2).each(function (pos) {
	            selection.setRng(pos.toRange());
	          });
	          return true;
	        } else {
	          return false;
	        }
	      }).getOr(false);
	    };
	    var isRawNodeInTable = function (root, rawNode) {
	      var node = Element.fromDom(rawNode);
	      var isRoot = curry(eq, root);
	      return ancestor(node, isTableCell, isRoot).isSome();
	    };
	    var isSelectionInTable = function (root, rng) {
	      return isRawNodeInTable(root, rng.startContainer) || isRawNodeInTable(root, rng.endContainer);
	    };
	    var isEverythingSelected = function (root, rng) {
	      var noPrevious = CaretFinder.prevPosition(root.dom(), CaretPosition$1.fromRangeStart(rng)).isNone();
	      var noNext = CaretFinder.nextPosition(root.dom(), CaretPosition$1.fromRangeEnd(rng)).isNone();
	      return !isSelectionInTable(root, rng) && noPrevious && noNext;
	    };
	    var emptyEditor = function (editor) {
	      editor.setContent('');
	      editor.selection.setCursorLocation();
	      return true;
	    };
	    var deleteRange = function (editor) {
	      var rootNode = Element.fromDom(editor.getBody());
	      var rng = editor.selection.getRng();
	      return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection);
	    };
	    var backspaceDelete$1 = function (editor, forward) {
	      return editor.selection.isCollapsed() ? false : deleteRange(editor);
	    };
	    var BlockRangeDelete = { backspaceDelete: backspaceDelete$1 };
	
	    var isBr$5 = function (pos) {
	      return getElementFromPosition(pos).exists(isBr$1);
	    };
	    var findBr = function (forward, root, pos) {
	      var parentBlocks = filter(Parents.parentsAndSelf(Element.fromDom(pos.container()), root), isBlock);
	      var scope = head(parentBlocks).getOr(root);
	      return CaretFinder.fromPosition(forward, scope.dom(), pos).filter(isBr$5);
	    };
	    var isBeforeBr = function (root, pos) {
	      return getElementFromPosition(pos).exists(isBr$1) || findBr(true, root, pos).isSome();
	    };
	    var isAfterBr = function (root, pos) {
	      return getElementFromPrevPosition(pos).exists(isBr$1) || findBr(false, root, pos).isSome();
	    };
	    var findPreviousBr = curry(findBr, false);
	    var findNextBr = curry(findBr, true);
	
	    var isCompoundElement = function (node) {
	      return isTableCell(Element.fromDom(node)) || isListItem(Element.fromDom(node));
	    };
	    var DeleteAction = Adt.generate([
	      { remove: ['element'] },
	      { moveToElement: ['element'] },
	      { moveToPosition: ['position'] }
	    ]);
	    var isAtContentEditableBlockCaret = function (forward, from) {
	      var elm = from.getNode(forward === false);
	      var caretLocation = forward ? 'after' : 'before';
	      return NodeType.isElement(elm) && elm.getAttribute('data-mce-caret') === caretLocation;
	    };
	    var isDeleteFromCefDifferentBlocks = function (root, forward, from, to) {
	      var inSameBlock = function (elm) {
	        return isInline(Element.fromDom(elm)) && !isInSameBlock(from, to, root);
	      };
	      return getRelativeCefElm(!forward, from).fold(function () {
	        return getRelativeCefElm(forward, to).fold(constant(false), inSameBlock);
	      }, inSameBlock);
	    };
	    var deleteEmptyBlockOrMoveToCef = function (root, forward, from, to) {
	      var toCefElm = to.getNode(forward === false);
	      return DeleteUtils.getParentBlock(Element.fromDom(root), Element.fromDom(from.getNode())).map(function (blockElm) {
	        return Empty.isEmpty(blockElm) ? DeleteAction.remove(blockElm.dom()) : DeleteAction.moveToElement(toCefElm);
	      }).orThunk(function () {
	        return Option.some(DeleteAction.moveToElement(toCefElm));
	      });
	    };
	    var findCefPosition = function (root, forward, from) {
	      return CaretFinder.fromPosition(forward, root, from).bind(function (to) {
	        if (isCompoundElement(to.getNode())) {
	          return Option.none();
	        } else if (isDeleteFromCefDifferentBlocks(root, forward, from, to)) {
	          return Option.none();
	        } else if (forward && NodeType.isContentEditableFalse(to.getNode())) {
	          return deleteEmptyBlockOrMoveToCef(root, forward, from, to);
	        } else if (forward === false && NodeType.isContentEditableFalse(to.getNode(true))) {
	          return deleteEmptyBlockOrMoveToCef(root, forward, from, to);
	        } else if (forward && isAfterContentEditableFalse(from)) {
	          return Option.some(DeleteAction.moveToPosition(to));
	        } else if (forward === false && isBeforeContentEditableFalse(from)) {
	          return Option.some(DeleteAction.moveToPosition(to));
	        } else {
	          return Option.none();
	        }
	      });
	    };
	    var getContentEditableBlockAction = function (forward, elm) {
	      if (forward && NodeType.isContentEditableFalse(elm.nextSibling)) {
	        return Option.some(DeleteAction.moveToElement(elm.nextSibling));
	      } else if (forward === false && NodeType.isContentEditableFalse(elm.previousSibling)) {
	        return Option.some(DeleteAction.moveToElement(elm.previousSibling));
	      } else {
	        return Option.none();
	      }
	    };
	    var skipMoveToActionFromInlineCefToContent = function (root, from, deleteAction) {
	      return deleteAction.fold(function (elm) {
	        return Option.some(DeleteAction.remove(elm));
	      }, function (elm) {
	        return Option.some(DeleteAction.moveToElement(elm));
	      }, function (to) {
	        if (isInSameBlock(from, to, root)) {
	          return Option.none();
	        } else {
	          return Option.some(DeleteAction.moveToPosition(to));
	        }
	      });
	    };
	    var getContentEditableAction = function (root, forward, from) {
	      if (isAtContentEditableBlockCaret(forward, from)) {
	        return getContentEditableBlockAction(forward, from.getNode(forward === false)).fold(function () {
	          return findCefPosition(root, forward, from);
	        }, Option.some);
	      } else {
	        return findCefPosition(root, forward, from).bind(function (deleteAction) {
	          return skipMoveToActionFromInlineCefToContent(root, from, deleteAction);
	        });
	      }
	    };
	    var read$4 = function (root, forward, rng) {
	      var normalizedRange = normalizeRange(forward ? 1 : -1, root, rng);
	      var from = CaretPosition$1.fromRangeStart(normalizedRange);
	      var rootElement = Element.fromDom(root);
	      if (forward === false && isAfterContentEditableFalse(from)) {
	        return Option.some(DeleteAction.remove(from.getNode(true)));
	      } else if (forward && isBeforeContentEditableFalse(from)) {
	        return Option.some(DeleteAction.remove(from.getNode()));
	      } else if (forward === false && isBeforeContentEditableFalse(from) && isAfterBr(rootElement, from)) {
	        return findPreviousBr(rootElement, from).map(function (br) {
	          return DeleteAction.remove(br.getNode());
	        });
	      } else if (forward && isAfterContentEditableFalse(from) && isBeforeBr(rootElement, from)) {
	        return findNextBr(rootElement, from).map(function (br) {
	          return DeleteAction.remove(br.getNode());
	        });
	      } else {
	        return getContentEditableAction(root, forward, from);
	      }
	    };
	
	    var deleteElement$1 = function (editor, forward) {
	      return function (element) {
	        editor._selectionOverrides.hideFakeCaret();
	        DeleteElement.deleteElement(editor, forward, Element.fromDom(element));
	        return true;
	      };
	    };
	    var moveToElement = function (editor, forward) {
	      return function (element) {
	        var pos = forward ? CaretPosition$1.before(element) : CaretPosition$1.after(element);
	        editor.selection.setRng(pos.toRange());
	        return true;
	      };
	    };
	    var moveToPosition = function (editor) {
	      return function (pos) {
	        editor.selection.setRng(pos.toRange());
	        return true;
	      };
	    };
	    var getAncestorCe = function (editor, node) {
	      return Option.from(getContentEditableRoot$1(editor.getBody(), node));
	    };
	    var backspaceDeleteCaret = function (editor, forward) {
	      var selectedNode = editor.selection.getNode();
	      return getAncestorCe(editor, selectedNode).filter(NodeType.isContentEditableFalse).fold(function () {
	        var result = read$4(editor.getBody(), forward, editor.selection.getRng()).map(function (deleteAction) {
	          return deleteAction.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor));
	        });
	        return result.getOr(false);
	      }, function () {
	        return true;
	      });
	    };
	    var deleteOffscreenSelection = function (rootElement) {
	      each(descendants$1(rootElement, '.mce-offscreen-selection'), remove);
	    };
	    var backspaceDeleteRange = function (editor, forward) {
	      var selectedNode = editor.selection.getNode();
	      if (NodeType.isContentEditableFalse(selectedNode)) {
	        var hasCefAncestor = getAncestorCe(editor, selectedNode.parentNode).filter(NodeType.isContentEditableFalse);
	        return hasCefAncestor.fold(function () {
	          deleteOffscreenSelection(Element.fromDom(editor.getBody()));
	          DeleteElement.deleteElement(editor, forward, Element.fromDom(editor.selection.getNode()));
	          DeleteUtils.paddEmptyBody(editor);
	          return true;
	        }, function () {
	          return true;
	        });
	      }
	      return false;
	    };
	    var getContentEditableRoot$1 = function (root, node) {
	      while (node && node !== root) {
	        if (NodeType.isContentEditableTrue(node) || NodeType.isContentEditableFalse(node)) {
	          return node;
	        }
	        node = node.parentNode;
	      }
	      return null;
	    };
	    var paddEmptyElement = function (editor) {
	      var br;
	      var ceRoot = getContentEditableRoot$1(editor.getBody(), editor.selection.getNode());
	      if (NodeType.isContentEditableTrue(ceRoot) && editor.dom.isBlock(ceRoot) && editor.dom.isEmpty(ceRoot)) {
	        br = editor.dom.create('br', { 'data-mce-bogus': '1' });
	        editor.dom.setHTML(ceRoot, '');
	        ceRoot.appendChild(br);
	        editor.selection.setRng(CaretPosition$1.before(br).toRange());
	      }
	      return true;
	    };
	    var backspaceDelete$2 = function (editor, forward) {
	      if (editor.selection.isCollapsed()) {
	        return backspaceDeleteCaret(editor, forward);
	      } else {
	        return backspaceDeleteRange(editor, forward);
	      }
	    };
	    var CefDelete = {
	      backspaceDelete: backspaceDelete$2,
	      paddEmptyElement: paddEmptyElement
	    };
	
	    var trimEmptyTextNode$1 = function (dom, node) {
	      if (NodeType.isText(node) && node.data.length === 0) {
	        dom.remove(node);
	      }
	    };
	    var deleteContentAndShowCaret = function (editor, range, node, direction, forward, peekCaretPosition) {
	      var caretRange = showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true);
	      if (range.collapsed) {
	        var deleteRange = range.cloneRange();
	        if (forward) {
	          deleteRange.setEnd(caretRange.startContainer, caretRange.startOffset);
	        } else {
	          deleteRange.setStart(caretRange.endContainer, caretRange.endOffset);
	        }
	        deleteRange.deleteContents();
	      } else {
	        range.deleteContents();
	      }
	      editor.selection.setRng(caretRange);
	      trimEmptyTextNode$1(editor.dom, node);
	      return true;
	    };
	    var deleteCefBoundaryText = function (editor, forward) {
	      var range = editor.selection.getRng();
	      if (!NodeType.isText(range.commonAncestorContainer)) {
	        return false;
	      }
	      var direction = forward ? HDirection.Forwards : HDirection.Backwards;
	      var caretWalker = CaretWalker(editor.getBody());
	      var getNextVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.next);
	      var getPrevVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.prev);
	      var getNextPosFn = forward ? getNextVisualCaretPosition : getPrevVisualCaretPosition;
	      var isBeforeContentEditableFalseFn = forward ? isBeforeContentEditableFalse : isAfterContentEditableFalse;
	      var caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);
	      var nextCaretPosition = InlineUtils.normalizePosition(forward, getNextPosFn(caretPosition));
	      if (!nextCaretPosition || !isMoveInsideSameBlock(caretPosition, nextCaretPosition)) {
	        return false;
	      } else if (isBeforeContentEditableFalseFn(nextCaretPosition)) {
	        return deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, nextCaretPosition);
	      }
	      var peekCaretPosition = getNextPosFn(nextCaretPosition);
	      if (peekCaretPosition && isBeforeContentEditableFalseFn(peekCaretPosition)) {
	        if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {
	          return deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, peekCaretPosition);
	        }
	      }
	      return false;
	    };
	    var backspaceDelete$3 = function (editor, forward) {
	      return deleteCefBoundaryText(editor, forward);
	    };
	    var CefBoundaryDelete = { backspaceDelete: backspaceDelete$3 };
	
	    var isFeatureEnabled$1 = function (editor) {
	      return editor.settings.inline_boundaries !== false;
	    };
	    var rangeFromPositions = function (from, to) {
	      var range = domGlobals.document.createRange();
	      range.setStart(from.container(), from.offset());
	      range.setEnd(to.container(), to.offset());
	      return range;
	    };
	    var hasOnlyTwoOrLessPositionsLeft = function (elm) {
	      return lift2(CaretFinder.firstPositionIn(elm), CaretFinder.lastPositionIn(elm), function (firstPos, lastPos) {
	        var normalizedFirstPos = InlineUtils.normalizePosition(true, firstPos);
	        var normalizedLastPos = InlineUtils.normalizePosition(false, lastPos);
	        return CaretFinder.nextPosition(elm, normalizedFirstPos).map(function (pos) {
	          return pos.isEqual(normalizedLastPos);
	        }).getOr(true);
	      }).getOr(true);
	    };
	    var setCaretLocation = function (editor, caret) {
	      return function (location) {
	        return BoundaryCaret.renderCaret(caret, location).map(function (pos) {
	          BoundarySelection.setCaretPosition(editor, pos);
	          return true;
	        }).getOr(false);
	      };
	    };
	    var deleteFromTo = function (editor, caret, from, to) {
	      var rootNode = editor.getBody();
	      var isInlineTarget = curry(InlineUtils.isInlineTarget, editor);
	      editor.undoManager.ignore(function () {
	        editor.selection.setRng(rangeFromPositions(from, to));
	        editor.execCommand('Delete');
	        BoundaryLocation.readLocation(isInlineTarget, rootNode, CaretPosition$1.fromRangeStart(editor.selection.getRng())).map(BoundaryLocation.inside).map(setCaretLocation(editor, caret));
	      });
	      editor.nodeChanged();
	    };
	    var rescope$1 = function (rootNode, node) {
	      var parentBlock = getParentBlock(node, rootNode);
	      return parentBlock ? parentBlock : rootNode;
	    };
	    var backspaceDeleteCollapsed = function (editor, caret, forward, from) {
	      var rootNode = rescope$1(editor.getBody(), from.container());
	      var isInlineTarget = curry(InlineUtils.isInlineTarget, editor);
	      var fromLocation = BoundaryLocation.readLocation(isInlineTarget, rootNode, from);
	      return fromLocation.bind(function (location) {
	        if (forward) {
	          return location.fold(constant(Option.some(BoundaryLocation.inside(location))), Option.none, constant(Option.some(BoundaryLocation.outside(location))), Option.none);
	        } else {
	          return location.fold(Option.none, constant(Option.some(BoundaryLocation.outside(location))), Option.none, constant(Option.some(BoundaryLocation.inside(location))));
	        }
	      }).map(setCaretLocation(editor, caret)).getOrThunk(function () {
	        var toPosition = CaretFinder.navigate(forward, rootNode, from);
	        var toLocation = toPosition.bind(function (pos) {
	          return BoundaryLocation.readLocation(isInlineTarget, rootNode, pos);
	        });
	        if (fromLocation.isSome() && toLocation.isSome()) {
	          return InlineUtils.findRootInline(isInlineTarget, rootNode, from).map(function (elm) {
	            if (hasOnlyTwoOrLessPositionsLeft(elm)) {
	              DeleteElement.deleteElement(editor, forward, Element.fromDom(elm));
	              return true;
	            } else {
	              return false;
	            }
	          }).getOr(false);
	        } else {
	          return toLocation.bind(function (_) {
	            return toPosition.map(function (to) {
	              if (forward) {
	                deleteFromTo(editor, caret, from, to);
	              } else {
	                deleteFromTo(editor, caret, to, from);
	              }
	              return true;
	            });
	          }).getOr(false);
	        }
	      });
	    };
	    var backspaceDelete$4 = function (editor, caret, forward) {
	      if (editor.selection.isCollapsed() && isFeatureEnabled$1(editor)) {
	        var from = CaretPosition$1.fromRangeStart(editor.selection.getRng());
	        return backspaceDeleteCollapsed(editor, caret, forward, from);
	      }
	      return false;
	    };
	    var BoundaryDelete = { backspaceDelete: backspaceDelete$4 };
	
	    var getParentInlines = function (rootElm, startElm) {
	      var parents = Parents.parentsAndSelf(startElm, rootElm);
	      return findIndex(parents, isBlock).fold(constant(parents), function (index) {
	        return parents.slice(0, index);
	      });
	    };
	    var hasOnlyOneChild = function (elm) {
	      return children(elm).length === 1;
	    };
	    var deleteLastPosition = function (forward, editor, target, parentInlines) {
	      var isFormatElement$1 = curry(isFormatElement, editor);
	      var formatNodes = map(filter(parentInlines, isFormatElement$1), function (elm) {
	        return elm.dom();
	      });
	      if (formatNodes.length === 0) {
	        DeleteElement.deleteElement(editor, forward, target);
	      } else {
	        var pos = replaceWithCaretFormat(target.dom(), formatNodes);
	        editor.selection.setRng(pos.toRange());
	      }
	    };
	    var deleteCaret = function (editor, forward) {
	      var rootElm = Element.fromDom(editor.getBody());
	      var startElm = Element.fromDom(editor.selection.getStart());
	      var parentInlines = filter(getParentInlines(rootElm, startElm), hasOnlyOneChild);
	      return last(parentInlines).map(function (target) {
	        var fromPos = CaretPosition$1.fromRangeStart(editor.selection.getRng());
	        if (DeleteUtils.willDeleteLastPositionInElement(forward, fromPos, target.dom()) && !isEmptyCaretFormatElement(target)) {
	          deleteLastPosition(forward, editor, target, parentInlines);
	          return true;
	        } else {
	          return false;
	        }
	      }).getOr(false);
	    };
	    var backspaceDelete$5 = function (editor, forward) {
	      return editor.selection.isCollapsed() ? deleteCaret(editor, forward) : false;
	    };
	    var InlineFormatDelete = { backspaceDelete: backspaceDelete$5 };
	
	    var tableCellRng = function (start, end) {
	      return {
	        start: constant(start),
	        end: constant(end)
	      };
	    };
	    var tableSelection = function (rng, table, cells) {
	      return {
	        rng: constant(rng),
	        table: constant(table),
	        cells: constant(cells)
	      };
	    };
	    var deleteAction = Adt.generate([
	      { removeTable: ['element'] },
	      { emptyCells: ['cells'] }
	    ]);
	    var isRootFromElement = function (root) {
	      return function (cur) {
	        return eq(root, cur);
	      };
	    };
	    var getClosestCell$1 = function (container, isRoot) {
	      return closest$1(Element.fromDom(container), 'td,th', isRoot);
	    };
	    var getClosestTable = function (cell, isRoot) {
	      return ancestor$1(cell, 'table', isRoot);
	    };
	    var isExpandedCellRng = function (cellRng) {
	      return eq(cellRng.start(), cellRng.end()) === false;
	    };
	    var getTableFromCellRng = function (cellRng, isRoot) {
	      return getClosestTable(cellRng.start(), isRoot).bind(function (startParentTable) {
	        return getClosestTable(cellRng.end(), isRoot).bind(function (endParentTable) {
	          return someIf(eq(startParentTable, endParentTable), startParentTable);
	        });
	      });
	    };
	    var getTableCells = function (table) {
	      return descendants$1(table, 'td,th');
	    };
	    var getCellRangeFromStartTable = function (cellRng, isRoot) {
	      return getClosestTable(cellRng.start(), isRoot).bind(function (table) {
	        return last(getTableCells(table)).map(function (endCell) {
	          return tableCellRng(cellRng.start(), endCell);
	        });
	      });
	    };
	    var partialSelection = function (isRoot, rng) {
	      var startCell = getClosestCell$1(rng.startContainer, isRoot);
	      var endCell = getClosestCell$1(rng.endContainer, isRoot);
	      return rng.collapsed ? Option.none() : lift2(startCell, endCell, tableCellRng).fold(function () {
	        return startCell.fold(function () {
	          return endCell.bind(function (endCell) {
	            return getClosestTable(endCell, isRoot).bind(function (table) {
	              return head(getTableCells(table)).map(function (startCell) {
	                return tableCellRng(startCell, endCell);
	              });
	            });
	          });
	        }, function (startCell) {
	          return getClosestTable(startCell, isRoot).bind(function (table) {
	            return last(getTableCells(table)).map(function (endCell) {
	              return tableCellRng(startCell, endCell);
	            });
	          });
	        });
	      }, function (cellRng) {
	        return isWithinSameTable(isRoot, cellRng) ? Option.none() : getCellRangeFromStartTable(cellRng, isRoot);
	      });
	    };
	    var isWithinSameTable = function (isRoot, cellRng) {
	      return getTableFromCellRng(cellRng, isRoot).isSome();
	    };
	    var getCellRng = function (rng, isRoot) {
	      var startCell = getClosestCell$1(rng.startContainer, isRoot);
	      var endCell = getClosestCell$1(rng.endContainer, isRoot);
	      return lift2(startCell, endCell, tableCellRng).filter(isExpandedCellRng).filter(function (cellRng) {
	        return isWithinSameTable(isRoot, cellRng);
	      }).orThunk(function () {
	        return partialSelection(isRoot, rng);
	      });
	    };
	    var getTableSelectionFromCellRng = function (cellRng, isRoot) {
	      return getTableFromCellRng(cellRng, isRoot).map(function (table) {
	        return tableSelection(cellRng, table, getTableCells(table));
	      });
	    };
	    var getTableSelectionFromRng = function (root, rng) {
	      var isRoot = isRootFromElement(root);
	      return getCellRng(rng, isRoot).bind(function (cellRng) {
	        return getTableSelectionFromCellRng(cellRng, isRoot);
	      });
	    };
	    var getCellIndex = function (cells, cell) {
	      return findIndex(cells, function (x) {
	        return eq(x, cell);
	      });
	    };
	    var getSelectedCells = function (tableSelection) {
	      return lift2(getCellIndex(tableSelection.cells(), tableSelection.rng().start()), getCellIndex(tableSelection.cells(), tableSelection.rng().end()), function (startIndex, endIndex) {
	        return tableSelection.cells().slice(startIndex, endIndex + 1);
	      });
	    };
	    var getAction = function (tableSelection) {
	      return getSelectedCells(tableSelection).map(function (selected) {
	        var cells = tableSelection.cells();
	        return selected.length === cells.length ? deleteAction.removeTable(tableSelection.table()) : deleteAction.emptyCells(selected);
	      });
	    };
	    var getActionFromRange = function (root, rng) {
	      return getTableSelectionFromRng(root, rng).bind(getAction);
	    };
	
	    var emptyCells = function (editor, cells) {
	      each(cells, PaddingBr.fillWithPaddingBr);
	      editor.selection.setCursorLocation(cells[0].dom(), 0);
	      return true;
	    };
	    var deleteTableElement = function (editor, table) {
	      DeleteElement.deleteElement(editor, false, table);
	      return true;
	    };
	    var deleteCellRange = function (editor, rootElm, rng) {
	      return getActionFromRange(rootElm, rng).map(function (action) {
	        return action.fold(curry(deleteTableElement, editor), curry(emptyCells, editor));
	      });
	    };
	    var deleteCaptionRange = function (editor, caption) {
	      return emptyElement(editor, caption);
	    };
	    var deleteTableRange = function (editor, rootElm, rng, startElm) {
	      return getParentCaption(rootElm, startElm).fold(function () {
	        return deleteCellRange(editor, rootElm, rng);
	      }, function (caption) {
	        return deleteCaptionRange(editor, caption);
	      }).getOr(false);
	    };
	    var deleteRange$1 = function (editor, startElm) {
	      var rootNode = Element.fromDom(editor.getBody());
	      var rng = editor.selection.getRng();
	      var selectedCells = TableCellSelection.getCellsFromEditor(editor);
	      return selectedCells.length !== 0 ? emptyCells(editor, selectedCells) : deleteTableRange(editor, rootNode, rng, startElm);
	    };
	    var getParentCell = function (rootElm, elm) {
	      return find(Parents.parentsAndSelf(elm, rootElm), isTableCell);
	    };
	    var getParentCaption = function (rootElm, elm) {
	      return find(Parents.parentsAndSelf(elm, rootElm), function (elm) {
	        return name(elm) === 'caption';
	      });
	    };
	    var deleteBetweenCells = function (editor, rootElm, forward, fromCell, from) {
	      return CaretFinder.navigate(forward, editor.getBody(), from).bind(function (to) {
	        return getParentCell(rootElm, Element.fromDom(to.getNode())).map(function (toCell) {
	          return eq(toCell, fromCell) === false;
	        });
	      });
	    };
	    var emptyElement = function (editor, elm) {
	      PaddingBr.fillWithPaddingBr(elm);
	      editor.selection.setCursorLocation(elm.dom(), 0);
	      return Option.some(true);
	    };
	    var isDeleteOfLastCharPos = function (fromCaption, forward, from, to) {
	      return CaretFinder.firstPositionIn(fromCaption.dom()).bind(function (first) {
	        return CaretFinder.lastPositionIn(fromCaption.dom()).map(function (last) {
	          return forward ? from.isEqual(first) && to.isEqual(last) : from.isEqual(last) && to.isEqual(first);
	        });
	      }).getOr(true);
	    };
	    var emptyCaretCaption = function (editor, elm) {
	      return emptyElement(editor, elm);
	    };
	    var validateCaretCaption = function (rootElm, fromCaption, to) {
	      return getParentCaption(rootElm, Element.fromDom(to.getNode())).map(function (toCaption) {
	        return eq(toCaption, fromCaption) === false;
	      });
	    };
	    var deleteCaretInsideCaption = function (editor, rootElm, forward, fromCaption, from) {
	      return CaretFinder.navigate(forward, editor.getBody(), from).bind(function (to) {
	        return isDeleteOfLastCharPos(fromCaption, forward, from, to) ? emptyCaretCaption(editor, fromCaption) : validateCaretCaption(rootElm, fromCaption, to);
	      }).or(Option.some(true));
	    };
	    var deleteCaretCells = function (editor, forward, rootElm, startElm) {
	      var from = CaretPosition$1.fromRangeStart(editor.selection.getRng());
	      return getParentCell(rootElm, startElm).bind(function (fromCell) {
	        return Empty.isEmpty(fromCell) ? emptyElement(editor, fromCell) : deleteBetweenCells(editor, rootElm, forward, fromCell, from);
	      }).getOr(false);
	    };
	    var deleteCaretCaption = function (editor, forward, rootElm, fromCaption) {
	      var from = CaretPosition$1.fromRangeStart(editor.selection.getRng());
	      return Empty.isEmpty(fromCaption) ? emptyElement(editor, fromCaption) : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from);
	    };
	    var isNearTable = function (forward, pos) {
	      return forward ? isBeforeTable(pos) : isAfterTable(pos);
	    };
	    var isBeforeOrAfterTable = function (editor, forward) {
	      var fromPos = CaretPosition$1.fromRangeStart(editor.selection.getRng());
	      return isNearTable(forward, fromPos) || CaretFinder.fromPosition(forward, editor.getBody(), fromPos).map(function (pos) {
	        return isNearTable(forward, pos);
	      }).getOr(false);
	    };
	    var deleteCaret$1 = function (editor, forward, startElm) {
	      var rootElm = Element.fromDom(editor.getBody());
	      return getParentCaption(rootElm, startElm).fold(function () {
	        return deleteCaretCells(editor, forward, rootElm, startElm) || isBeforeOrAfterTable(editor, forward);
	      }, function (fromCaption) {
	        return deleteCaretCaption(editor, forward, rootElm, fromCaption).getOr(false);
	      });
	    };
	    var backspaceDelete$6 = function (editor, forward) {
	      var startElm = Element.fromDom(editor.selection.getStart(true));
	      var cells = TableCellSelection.getCellsFromEditor(editor);
	      return editor.selection.isCollapsed() && cells.length === 0 ? deleteCaret$1(editor, forward, startElm) : deleteRange$1(editor, startElm);
	    };
	    var TableDelete = { backspaceDelete: backspaceDelete$6 };
	
	    var deleteCaret$2 = function (editor, forward) {
	      var fromPos = CaretPosition$1.fromRangeStart(editor.selection.getRng());
	      return CaretFinder.fromPosition(forward, editor.getBody(), fromPos).filter(function (pos) {
	        return forward ? isBeforeImageBlock(pos) : isAfterImageBlock(pos);
	      }).bind(function (pos) {
	        return Option.from(getChildNodeAtRelativeOffset(forward ? 0 : -1, pos));
	      }).map(function (elm) {
	        editor.selection.select(elm);
	        return true;
	      }).getOr(false);
	    };
	    var backspaceDelete$7 = function (editor, forward) {
	      return editor.selection.isCollapsed() ? deleteCaret$2(editor, forward) : false;
	    };
	    var PageBreakDelete = { backspaceDelete: backspaceDelete$7 };
	
	    var isEditable$1 = function (target) {
	      return closest(target, function (elm) {
	        return NodeType.isContentEditableTrue(elm.dom()) || NodeType.isContentEditableFalse(elm.dom());
	      }).exists(function (elm) {
	        return NodeType.isContentEditableTrue(elm.dom());
	      });
	    };
	    var parseIndentValue = function (value) {
	      var number = parseInt(value, 10);
	      return isNaN(number) ? 0 : number;
	    };
	    var getIndentStyleName = function (useMargin, element) {
	      var indentStyleName = useMargin || isTable$1(element) ? 'margin' : 'padding';
	      var suffix = get$4(element, 'direction') === 'rtl' ? '-right' : '-left';
	      return indentStyleName + suffix;
	    };
	    var indentElement = function (dom, command, useMargin, value, unit, element) {
	      var indentStyleName = getIndentStyleName(useMargin, Element.fromDom(element));
	      if (command === 'outdent') {
	        var styleValue = Math.max(0, parseIndentValue(element.style[indentStyleName]) - value);
	        dom.setStyle(element, indentStyleName, styleValue ? styleValue + unit : '');
	      } else {
	        var styleValue = parseIndentValue(element.style[indentStyleName]) + value + unit;
	        dom.setStyle(element, indentStyleName, styleValue);
	      }
	    };
	    var validateBlocks = function (editor, blocks) {
	      return forall(blocks, function (block) {
	        var indentStyleName = getIndentStyleName(Settings.shouldIndentUseMargin(editor), block);
	        var intentValue = getRaw(block, indentStyleName).map(parseIndentValue).getOr(0);
	        var contentEditable = editor.dom.getContentEditable(block.dom());
	        return contentEditable !== 'false' && intentValue > 0;
	      });
	    };
	    var canOutdent = function (editor) {
	      var blocks = getBlocksToIndent(editor);
	      return !editor.mode.isReadOnly() && (blocks.length > 1 || validateBlocks(editor, blocks));
	    };
	    var isListComponent = function (el) {
	      return isList(el) || isListItem(el);
	    };
	    var parentIsListComponent = function (el) {
	      return parent(el).map(isListComponent).getOr(false);
	    };
	    var getBlocksToIndent = function (editor) {
	      return filter(map(editor.selection.getSelectedBlocks(), Element.fromDom), function (el) {
	        return !isListComponent(el) && !parentIsListComponent(el) && isEditable$1(el);
	      });
	    };
	    var handle = function (editor, command) {
	      var dom = editor.dom, selection = editor.selection, formatter = editor.formatter;
	      var indentation = Settings.getIndentation(editor);
	      var indentUnit = /[a-z%]+$/i.exec(indentation)[0];
	      var indentValue = parseInt(indentation, 10);
	      var useMargin = Settings.shouldIndentUseMargin(editor);
	      var forcedRootBlock = Settings.getForcedRootBlock(editor);
	      if (!editor.queryCommandState('InsertUnorderedList') && !editor.queryCommandState('InsertOrderedList')) {
	        if (forcedRootBlock === '' && !dom.getParent(selection.getNode(), dom.isBlock)) {
	          formatter.apply('div');
	        }
	      }
	      each(getBlocksToIndent(editor), function (block) {
	        indentElement(dom, command, useMargin, indentValue, indentUnit, block.dom());
	      });
	    };
	
	    var navigateIgnoreEmptyTextNodes = function (forward, root, from) {
	      return CaretFinder.navigateIgnore(forward, root, from, isEmptyText);
	    };
	    var getClosestBlock = function (root, pos) {
	      return find(Parents.parentsAndSelf(Element.fromDom(pos.container()), root), isBlock);
	    };
	    var isAtBeforeAfterBlockBoundary = function (forward, root, pos) {
	      return navigateIgnoreEmptyTextNodes(forward, root.dom(), pos).forall(function (newPos) {
	        return getClosestBlock(root, pos).fold(function () {
	          return isInSameBlock(newPos, pos, root.dom()) === false;
	        }, function (fromBlock) {
	          return isInSameBlock(newPos, pos, root.dom()) === false && contains$2(fromBlock, Element.fromDom(newPos.container()));
	        });
	      });
	    };
	    var isAtBlockBoundary = function (forward, root, pos) {
	      return getClosestBlock(root, pos).fold(function () {
	        return navigateIgnoreEmptyTextNodes(forward, root.dom(), pos).forall(function (newPos) {
	          return isInSameBlock(newPos, pos, root.dom()) === false;
	        });
	      }, function (parent) {
	        return navigateIgnoreEmptyTextNodes(forward, parent.dom(), pos).isNone();
	      });
	    };
	    var isAtStartOfBlock = curry(isAtBlockBoundary, false);
	    var isAtEndOfBlock = curry(isAtBlockBoundary, true);
	    var isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);
	    var isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);
	
	    var backspaceDelete$8 = function (editor, _caret, _forward) {
	      if (editor.selection.isCollapsed() && canOutdent(editor)) {
	        var dom = editor.dom;
	        var rng = editor.selection.getRng();
	        var pos = CaretPosition$1.fromRangeStart(rng);
	        var block = dom.getParent(rng.startContainer, dom.isBlock);
	        if (block !== null && isAtStartOfBlock(Element.fromDom(block), pos)) {
	          handle(editor, 'outdent');
	          return true;
	        }
	      }
	      return false;
	    };
	    var Outdent = { backspaceDelete: backspaceDelete$8 };
	
	    var executeKeydownOverride$1 = function (editor, caret, evt) {
	      MatchKeys.execute([
	        {
	          keyCode: VK.BACKSPACE,
	          action: MatchKeys.action(Outdent.backspaceDelete, editor, false)
	        },
	        {
	          keyCode: VK.BACKSPACE,
	          action: MatchKeys.action(CefDelete.backspaceDelete, editor, false)
	        },
	        {
	          keyCode: VK.DELETE,
	          action: MatchKeys.action(CefDelete.backspaceDelete, editor, true)
	        },
	        {
	          keyCode: VK.BACKSPACE,
	          action: MatchKeys.action(CefBoundaryDelete.backspaceDelete, editor, false)
	        },
	        {
	          keyCode: VK.DELETE,
	          action: MatchKeys.action(CefBoundaryDelete.backspaceDelete, editor, true)
	        },
	        {
	          keyCode: VK.BACKSPACE,
	          action: MatchKeys.action(BoundaryDelete.backspaceDelete, editor, caret, false)
	        },
	        {
	          keyCode: VK.DELETE,
	          action: MatchKeys.action(BoundaryDelete.backspaceDelete, editor, caret, true)
	        },
	        {
	          keyCode: VK.BACKSPACE,
	          action: MatchKeys.action(TableDelete.backspaceDelete, editor, false)
	        },
	        {
	          keyCode: VK.DELETE,
	          action: MatchKeys.action(TableDelete.backspaceDelete, editor, true)
	        },
	        {
	          keyCode: VK.BACKSPACE,
	          action: MatchKeys.action(PageBreakDelete.backspaceDelete, editor, false)
	        },
	        {
	          keyCode: VK.DELETE,
	          action: MatchKeys.action(PageBreakDelete.backspaceDelete, editor, true)
	        },
	        {
	          keyCode: VK.BACKSPACE,
	          action: MatchKeys.action(BlockRangeDelete.backspaceDelete, editor, false)
	        },
	        {
	          keyCode: VK.DELETE,
	          action: MatchKeys.action(BlockRangeDelete.backspaceDelete, editor, true)
	        },
	        {
	          keyCode: VK.BACKSPACE,
	          action: MatchKeys.action(BlockBoundaryDelete.backspaceDelete, editor, false)
	        },
	        {
	          keyCode: VK.DELETE,
	          action: MatchKeys.action(BlockBoundaryDelete.backspaceDelete, editor, true)
	        },
	        {
	          keyCode: VK.BACKSPACE,
	          action: MatchKeys.action(InlineFormatDelete.backspaceDelete, editor, false)
	        },
	        {
	          keyCode: VK.DELETE,
	          action: MatchKeys.action(InlineFormatDelete.backspaceDelete, editor, true)
	        }
	      ], evt).each(function (_) {
	        evt.preventDefault();
	      });
	    };
	    var executeKeyupOverride = function (editor, evt) {
	      MatchKeys.execute([
	        {
	          keyCode: VK.BACKSPACE,
	          action: MatchKeys.action(CefDelete.paddEmptyElement, editor)
	        },
	        {
	          keyCode: VK.DELETE,
	          action: MatchKeys.action(CefDelete.paddEmptyElement, editor)
	        }
	      ], evt);
	    };
	    var setup$a = function (editor, caret) {
	      editor.on('keydown', function (evt) {
	        if (evt.isDefaultPrevented() === false) {
	          executeKeydownOverride$1(editor, caret, evt);
	        }
	      });
	      editor.on('keyup', function (evt) {
	        if (evt.isDefaultPrevented() === false) {
	          executeKeyupOverride(editor, evt);
	        }
	      });
	    };
	    var DeleteBackspaceKeys = { setup: setup$a };
	
	    var firstNonWhiteSpaceNodeSibling = function (node) {
	      while (node) {
	        if (node.nodeType === 1 || node.nodeType === 3 && node.data && /[\r\n\s]/.test(node.data)) {
	          return node;
	        }
	        node = node.nextSibling;
	      }
	    };
	    var moveToCaretPosition = function (editor, root) {
	      var node, rng, lastNode = root;
	      var dom = editor.dom;
	      var moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();
	      if (!root) {
	        return;
	      }
	      if (/^(LI|DT|DD)$/.test(root.nodeName)) {
	        var firstChild = firstNonWhiteSpaceNodeSibling(root.firstChild);
	        if (firstChild && /^(UL|OL|DL)$/.test(firstChild.nodeName)) {
	          root.insertBefore(dom.doc.createTextNode(nbsp), root.firstChild);
	        }
	      }
	      rng = dom.createRng();
	      root.normalize();
	      if (root.hasChildNodes()) {
	        var walker = new TreeWalker(root, root);
	        while (node = walker.current()) {
	          if (NodeType.isText(node)) {
	            rng.setStart(node, 0);
	            rng.setEnd(node, 0);
	            break;
	          }
	          if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {
	            rng.setStartBefore(node);
	            rng.setEndBefore(node);
	            break;
	          }
	          lastNode = node;
	          node = walker.next();
	        }
	        if (!node) {
	          rng.setStart(lastNode, 0);
	          rng.setEnd(lastNode, 0);
	        }
	      } else {
	        if (NodeType.isBr(root)) {
	          if (root.nextSibling && dom.isBlock(root.nextSibling)) {
	            rng.setStartBefore(root);
	            rng.setEndBefore(root);
	          } else {
	            rng.setStartAfter(root);
	            rng.setEndAfter(root);
	          }
	        } else {
	          rng.setStart(root, 0);
	          rng.setEnd(root, 0);
	        }
	      }
	      editor.selection.setRng(rng);
	      ScrollIntoView.scrollRangeIntoView(editor, rng);
	    };
	    var getEditableRoot = function (dom, node) {
	      var root = dom.getRoot();
	      var parent, editableRoot;
	      parent = node;
	      while (parent !== root && dom.getContentEditable(parent) !== 'false') {
	        if (dom.getContentEditable(parent) === 'true') {
	          editableRoot = parent;
	        }
	        parent = parent.parentNode;
	      }
	      return parent !== root ? editableRoot : root;
	    };
	    var getParentBlock$2 = function (editor) {
	      return Option.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));
	    };
	    var getParentBlockName = function (editor) {
	      return getParentBlock$2(editor).fold(constant(''), function (parentBlock) {
	        return parentBlock.nodeName.toUpperCase();
	      });
	    };
	    var isListItemParentBlock = function (editor) {
	      return getParentBlock$2(editor).filter(function (elm) {
	        return isListItem(Element.fromDom(elm));
	      }).isSome();
	    };
	    var NewLineUtils = {
	      moveToCaretPosition: moveToCaretPosition,
	      getEditableRoot: getEditableRoot,
	      getParentBlock: getParentBlock$2,
	      getParentBlockName: getParentBlockName,
	      isListItemParentBlock: isListItemParentBlock
	    };
	
	    var hasFirstChild = function (elm, name) {
	      return elm.firstChild && elm.firstChild.nodeName === name;
	    };
	    var hasParent$1 = function (elm, parentName) {
	      return elm && elm.parentNode && elm.parentNode.nodeName === parentName;
	    };
	    var isListBlock = function (elm) {
	      return elm && /^(OL|UL|LI)$/.test(elm.nodeName);
	    };
	    var isNestedList = function (elm) {
	      return isListBlock(elm) && isListBlock(elm.parentNode);
	    };
	    var getContainerBlock = function (containerBlock) {
	      var containerBlockParent = containerBlock.parentNode;
	      if (/^(LI|DT|DD)$/.test(containerBlockParent.nodeName)) {
	        return containerBlockParent;
	      }
	      return containerBlock;
	    };
	    var isFirstOrLastLi = function (containerBlock, parentBlock, first) {
	      var node = containerBlock[first ? 'firstChild' : 'lastChild'];
	      while (node) {
	        if (NodeType.isElement(node)) {
	          break;
	        }
	        node = node[first ? 'nextSibling' : 'previousSibling'];
	      }
	      return node === parentBlock;
	    };
	    var insert = function (editor, createNewBlock, containerBlock, parentBlock, newBlockName) {
	      var dom = editor.dom;
	      var rng = editor.selection.getRng();
	      if (containerBlock === editor.getBody()) {
	        return;
	      }
	      if (isNestedList(containerBlock)) {
	        newBlockName = 'LI';
	      }
	      var newBlock = newBlockName ? createNewBlock(newBlockName) : dom.create('BR');
	      if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) {
	        if (hasParent$1(containerBlock, 'LI')) {
	          dom.insertAfter(newBlock, getContainerBlock(containerBlock));
	        } else {
	          dom.replace(newBlock, containerBlock);
	        }
	      } else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {
	        if (hasParent$1(containerBlock, 'LI')) {
	          dom.insertAfter(newBlock, getContainerBlock(containerBlock));
	          newBlock.appendChild(dom.doc.createTextNode(' '));
	          newBlock.appendChild(containerBlock);
	        } else {
	          containerBlock.parentNode.insertBefore(newBlock, containerBlock);
	        }
	      } else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {
	        dom.insertAfter(newBlock, getContainerBlock(containerBlock));
	      } else {
	        containerBlock = getContainerBlock(containerBlock);
	        var tmpRng = rng.cloneRange();
	        tmpRng.setStartAfter(parentBlock);
	        tmpRng.setEndAfter(containerBlock);
	        var fragment = tmpRng.extractContents();
	        if (newBlockName === 'LI' && hasFirstChild(fragment, 'LI')) {
	          newBlock = fragment.firstChild;
	          dom.insertAfter(fragment, containerBlock);
	        } else {
	          dom.insertAfter(fragment, containerBlock);
	          dom.insertAfter(newBlock, containerBlock);
	        }
	      }
	      dom.remove(parentBlock);
	      NewLineUtils.moveToCaretPosition(editor, newBlock);
	    };
	    var InsertLi = { insert: insert };
	
	    var trimZwsp = function (fragment) {
	      each(descendants(Element.fromDom(fragment), isText), function (text) {
	        var rawNode = text.dom();
	        rawNode.nodeValue = Zwsp.trim(rawNode.nodeValue);
	      });
	    };
	    var isEmptyAnchor = function (dom, elm) {
	      return elm && elm.nodeName === 'A' && dom.isEmpty(elm);
	    };
	    var isTableCell$4 = function (node) {
	      return node && /^(TD|TH|CAPTION)$/.test(node.nodeName);
	    };
	    var emptyBlock = function (elm) {
	      elm.innerHTML = '<br data-mce-bogus="1">';
	    };
	    var containerAndSiblingName = function (container, nodeName) {
	      return container.nodeName === nodeName || container.previousSibling && container.previousSibling.nodeName === nodeName;
	    };
	    var canSplitBlock = function (dom, node) {
	      return node && dom.isBlock(node) && !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) && !/^(fixed|absolute)/i.test(node.style.position) && dom.getContentEditable(node) !== 'true';
	    };
	    var trimInlineElementsOnLeftSideOfBlock = function (dom, nonEmptyElementsMap, block) {
	      var node = block;
	      var firstChilds = [];
	      var i;
	      if (!node) {
	        return;
	      }
	      while (node = node.firstChild) {
	        if (dom.isBlock(node)) {
	          return;
	        }
	        if (NodeType.isElement(node) && !nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
	          firstChilds.push(node);
	        }
	      }
	      i = firstChilds.length;
	      while (i--) {
	        node = firstChilds[i];
	        if (!node.hasChildNodes() || node.firstChild === node.lastChild && node.firstChild.nodeValue === '') {
	          dom.remove(node);
	        } else {
	          if (isEmptyAnchor(dom, node)) {
	            dom.remove(node);
	          }
	        }
	      }
	    };
	    var normalizeZwspOffset = function (start, container, offset) {
	      if (NodeType.isText(container) === false) {
	        return offset;
	      } else if (start) {
	        return offset === 1 && container.data.charAt(offset - 1) === Zwsp.ZWSP ? 0 : offset;
	      } else {
	        return offset === container.data.length - 1 && container.data.charAt(offset) === Zwsp.ZWSP ? container.data.length : offset;
	      }
	    };
	    var includeZwspInRange = function (rng) {
	      var newRng = rng.cloneRange();
	      newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));
	      newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));
	      return newRng;
	    };
	    var trimLeadingLineBreaks = function (node) {
	      do {
	        if (NodeType.isText(node)) {
	          node.nodeValue = node.nodeValue.replace(/^[\r\n]+/, '');
	        }
	        node = node.firstChild;
	      } while (node);
	    };
	    var getEditableRoot$1 = function (dom, node) {
	      var root = dom.getRoot();
	      var parent, editableRoot;
	      parent = node;
	      while (parent !== root && dom.getContentEditable(parent) !== 'false') {
	        if (dom.getContentEditable(parent) === 'true') {
	          editableRoot = parent;
	        }
	        parent = parent.parentNode;
	      }
	      return parent !== root ? editableRoot : root;
	    };
	    var applyAttributes = function (editor, node, forcedRootBlockAttrs) {
	      Option.from(forcedRootBlockAttrs.style).map(editor.dom.parseStyle).each(function (attrStyles) {
	        var currentStyles = getAllRaw(Element.fromDom(node));
	        var newStyles = __assign(__assign({}, currentStyles), attrStyles);
	        editor.dom.setStyles(node, newStyles);
	      });
	      var attrClassesOpt = Option.from(forcedRootBlockAttrs.class).map(function (attrClasses) {
	        return attrClasses.split(/\s+/);
	      });
	      var currentClassesOpt = Option.from(node.className).map(function (currentClasses) {
	        return filter(currentClasses.split(/\s+/), function (clazz) {
	          return clazz !== '';
	        });
	      });
	      lift2(attrClassesOpt, currentClassesOpt, function (attrClasses, currentClasses) {
	        var filteredClasses = filter(currentClasses, function (clazz) {
	          return !contains(attrClasses, clazz);
	        });
	        var newClasses = __spreadArrays(attrClasses, filteredClasses);
	        editor.dom.setAttrib(node, 'class', newClasses.join(' '));
	      });
	      var appliedAttrs = [
	        'style',
	        'class'
	      ];
	      var remainingAttrs = filter$1(forcedRootBlockAttrs, function (_, attrs) {
	        return !contains(appliedAttrs, attrs);
	      });
	      editor.dom.setAttribs(node, remainingAttrs);
	    };
	    var setForcedBlockAttrs = function (editor, node) {
	      var forcedRootBlockName = Settings.getForcedRootBlock(editor);
	      if (forcedRootBlockName && forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {
	        var forcedRootBlockAttrs = Settings.getForcedRootBlockAttrs(editor);
	        applyAttributes(editor, node, forcedRootBlockAttrs);
	      }
	    };
	    var wrapSelfAndSiblingsInDefaultBlock = function (editor, newBlockName, rng, container, offset) {
	      var newBlock, parentBlock, startNode, node, next, rootBlockName;
	      var blockName = newBlockName || 'P';
	      var dom = editor.dom, editableRoot = getEditableRoot$1(dom, container);
	      parentBlock = dom.getParent(container, dom.isBlock);
	      if (!parentBlock || !canSplitBlock(dom, parentBlock)) {
	        parentBlock = parentBlock || editableRoot;
	        if (parentBlock === editor.getBody() || isTableCell$4(parentBlock)) {
	          rootBlockName = parentBlock.nodeName.toLowerCase();
	        } else {
	          rootBlockName = parentBlock.parentNode.nodeName.toLowerCase();
	        }
	        if (!parentBlock.hasChildNodes()) {
	          newBlock = dom.create(blockName);
	          setForcedBlockAttrs(editor, newBlock);
	          parentBlock.appendChild(newBlock);
	          rng.setStart(newBlock, 0);
	          rng.setEnd(newBlock, 0);
	          return newBlock;
	        }
	        node = container;
	        while (node.parentNode !== parentBlock) {
	          node = node.parentNode;
	        }
	        while (node && !dom.isBlock(node)) {
	          startNode = node;
	          node = node.previousSibling;
	        }
	        if (startNode && editor.schema.isValidChild(rootBlockName, blockName.toLowerCase())) {
	          newBlock = dom.create(blockName);
	          setForcedBlockAttrs(editor, newBlock);
	          startNode.parentNode.insertBefore(newBlock, startNode);
	          node = startNode;
	          while (node && !dom.isBlock(node)) {
	            next = node.nextSibling;
	            newBlock.appendChild(node);
	            node = next;
	          }
	          rng.setStart(container, offset);
	          rng.setEnd(container, offset);
	        }
	      }
	      return container;
	    };
	    var addBrToBlockIfNeeded = function (dom, block) {
	      var lastChild;
	      block.normalize();
	      lastChild = block.lastChild;
	      if (!lastChild || /^(left|right)$/gi.test(dom.getStyle(lastChild, 'float', true))) {
	        dom.add(block, 'br');
	      }
	    };
	    var insert$1 = function (editor, evt) {
	      var tmpRng, editableRoot, container, offset, parentBlock, shiftKey;
	      var newBlock, fragment, containerBlock, parentBlockName, containerBlockName, newBlockName, isAfterLastNodeInContainer;
	      var dom = editor.dom;
	      var schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements();
	      var rng = editor.selection.getRng();
	      var createNewBlock = function (name) {
	        var node = container, block, clonedNode, caretNode;
	        var textInlineElements = schema.getTextInlineElements();
	        if (name || parentBlockName === 'TABLE' || parentBlockName === 'HR') {
	          block = dom.create(name || newBlockName);
	        } else {
	          block = parentBlock.cloneNode(false);
	        }
	        caretNode = block;
	        if (Settings.shouldKeepStyles(editor) === false) {
	          dom.setAttrib(block, 'style', null);
	          dom.setAttrib(block, 'class', null);
	        } else {
	          do {
	            if (textInlineElements[node.nodeName]) {
	              if (isCaretNode(node) || Bookmarks.isBookmarkNode(node)) {
	                continue;
	              }
	              clonedNode = node.cloneNode(false);
	              dom.setAttrib(clonedNode, 'id', '');
	              if (block.hasChildNodes()) {
	                clonedNode.appendChild(block.firstChild);
	                block.appendChild(clonedNode);
	              } else {
	                caretNode = clonedNode;
	                block.appendChild(clonedNode);
	              }
	            }
	          } while ((node = node.parentNode) && node !== editableRoot);
	        }
	        setForcedBlockAttrs(editor, block);
	        emptyBlock(caretNode);
	        return block;
	      };
	      var isCaretAtStartOrEndOfBlock = function (start) {
	        var node, name;
	        var normalizedOffset = normalizeZwspOffset(start, container, offset);
	        if (NodeType.isText(container) && (start ? normalizedOffset > 0 : normalizedOffset < container.nodeValue.length)) {
	          return false;
	        }
	        if (container.parentNode === parentBlock && isAfterLastNodeInContainer && !start) {
	          return true;
	        }
	        if (start && NodeType.isElement(container) && container === parentBlock.firstChild) {
	          return true;
	        }
	        if (containerAndSiblingName(container, 'TABLE') || containerAndSiblingName(container, 'HR')) {
	          return isAfterLastNodeInContainer && !start || !isAfterLastNodeInContainer && start;
	        }
	        var walker = new TreeWalker(container, parentBlock);
	        if (NodeType.isText(container)) {
	          if (start && normalizedOffset === 0) {
	            walker.prev();
	          } else if (!start && normalizedOffset === container.nodeValue.length) {
	            walker.next();
	          }
	        }
	        while (node = walker.current()) {
	          if (NodeType.isElement(node)) {
	            if (!node.getAttribute('data-mce-bogus')) {
	              name = node.nodeName.toLowerCase();
	              if (nonEmptyElementsMap[name] && name !== 'br') {
	                return false;
	              }
	            }
	          } else if (NodeType.isText(node) && !/^[ \t\r\n]*$/.test(node.nodeValue)) {
	            return false;
	          }
	          if (start) {
	            walker.prev();
	          } else {
	            walker.next();
	          }
	        }
	        return true;
	      };
	      var insertNewBlockAfter = function () {
	        if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== 'HGROUP') {
	          newBlock = createNewBlock(newBlockName);
	        } else {
	          newBlock = createNewBlock();
	        }
	        if (Settings.shouldEndContainerOnEmptyBlock(editor) && canSplitBlock(dom, containerBlock) && dom.isEmpty(parentBlock)) {
	          newBlock = dom.split(containerBlock, parentBlock);
	        } else {
	          dom.insertAfter(newBlock, parentBlock);
	        }
	        NewLineUtils.moveToCaretPosition(editor, newBlock);
	      };
	      NormalizeRange.normalize(dom, rng).each(function (normRng) {
	        rng.setStart(normRng.startContainer, normRng.startOffset);
	        rng.setEnd(normRng.endContainer, normRng.endOffset);
	      });
	      container = rng.startContainer;
	      offset = rng.startOffset;
	      newBlockName = Settings.getForcedRootBlock(editor);
	      shiftKey = !!(evt && evt.shiftKey);
	      var ctrlKey = !!(evt && evt.ctrlKey);
	      if (NodeType.isElement(container) && container.hasChildNodes()) {
	        isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
	        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
	        if (isAfterLastNodeInContainer && NodeType.isText(container)) {
	          offset = container.nodeValue.length;
	        } else {
	          offset = 0;
	        }
	      }
	      editableRoot = getEditableRoot$1(dom, container);
	      if (!editableRoot) {
	        return;
	      }
	      if (newBlockName && !shiftKey || !newBlockName && shiftKey) {
	        container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset);
	      }
	      parentBlock = dom.getParent(container, dom.isBlock);
	      containerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;
	      parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';
	      containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';
	      if (containerBlockName === 'LI' && !ctrlKey) {
	        parentBlock = containerBlock;
	        containerBlock = containerBlock.parentNode;
	        parentBlockName = containerBlockName;
	      }
	      if (/^(LI|DT|DD)$/.test(parentBlockName)) {
	        if (dom.isEmpty(parentBlock)) {
	          InsertLi.insert(editor, createNewBlock, containerBlock, parentBlock, newBlockName);
	          return;
	        }
	      }
	      if (newBlockName && parentBlock === editor.getBody()) {
	        return;
	      }
	      newBlockName = newBlockName || 'P';
	      if (isCaretContainerBlock(parentBlock)) {
	        newBlock = showCaretContainerBlock(parentBlock);
	        if (dom.isEmpty(parentBlock)) {
	          emptyBlock(parentBlock);
	        }
	        setForcedBlockAttrs(editor, newBlock);
	        NewLineUtils.moveToCaretPosition(editor, newBlock);
	      } else if (isCaretAtStartOrEndOfBlock()) {
	        insertNewBlockAfter();
	      } else if (isCaretAtStartOrEndOfBlock(true)) {
	        newBlock = parentBlock.parentNode.insertBefore(createNewBlock(), parentBlock);
	        NewLineUtils.moveToCaretPosition(editor, containerAndSiblingName(parentBlock, 'HR') ? newBlock : parentBlock);
	      } else {
	        tmpRng = includeZwspInRange(rng).cloneRange();
	        tmpRng.setEndAfter(parentBlock);
	        fragment = tmpRng.extractContents();
	        trimZwsp(fragment);
	        trimLeadingLineBreaks(fragment);
	        newBlock = fragment.firstChild;
	        dom.insertAfter(fragment, parentBlock);
	        trimInlineElementsOnLeftSideOfBlock(dom, nonEmptyElementsMap, newBlock);
	        addBrToBlockIfNeeded(dom, parentBlock);
	        if (dom.isEmpty(parentBlock)) {
	          emptyBlock(parentBlock);
	        }
	        newBlock.normalize();
	        if (dom.isEmpty(newBlock)) {
	          dom.remove(newBlock);
	          insertNewBlockAfter();
	        } else {
	          setForcedBlockAttrs(editor, newBlock);
	          NewLineUtils.moveToCaretPosition(editor, newBlock);
	        }
	      }
	      dom.setAttrib(newBlock, 'id', '');
	      editor.fire('NewBlock', { newBlock: newBlock });
	    };
	    var InsertBlock = { insert: insert$1 };
	
	    var hasRightSideContent = function (schema, container, parentBlock) {
	      var walker = new TreeWalker(container, parentBlock);
	      var node;
	      var nonEmptyElementsMap = schema.getNonEmptyElements();
	      while (node = walker.next()) {
	        if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || node.length > 0) {
	          return true;
	        }
	      }
	    };
	    var scrollToBr = function (dom, selection, brElm) {
	      var marker = dom.create('span', {}, '&nbsp;');
	      brElm.parentNode.insertBefore(marker, brElm);
	      selection.scrollIntoView(marker);
	      dom.remove(marker);
	    };
	    var moveSelectionToBr = function (dom, selection, brElm, extraBr) {
	      var rng = dom.createRng();
	      if (!extraBr) {
	        rng.setStartAfter(brElm);
	        rng.setEndAfter(brElm);
	      } else {
	        rng.setStartBefore(brElm);
	        rng.setEndBefore(brElm);
	      }
	      selection.setRng(rng);
	    };
	    var insertBrAtCaret = function (editor, evt) {
	      var selection = editor.selection;
	      var dom = editor.dom;
	      var rng = selection.getRng();
	      var brElm;
	      var extraBr;
	      NormalizeRange.normalize(dom, rng).each(function (normRng) {
	        rng.setStart(normRng.startContainer, normRng.startOffset);
	        rng.setEnd(normRng.endContainer, normRng.endOffset);
	      });
	      var offset = rng.startOffset;
	      var container = rng.startContainer;
	      if (container.nodeType === 1 && container.hasChildNodes()) {
	        var isAfterLastNodeInContainer = offset > container.childNodes.length - 1;
	        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
	        if (isAfterLastNodeInContainer && container.nodeType === 3) {
	          offset = container.nodeValue.length;
	        } else {
	          offset = 0;
	        }
	      }
	      var parentBlock = dom.getParent(container, dom.isBlock);
	      var containerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;
	      var containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';
	      var isControlKey = !!(evt && evt.ctrlKey);
	      if (containerBlockName === 'LI' && !isControlKey) {
	        parentBlock = containerBlock;
	      }
	      if (container && container.nodeType === 3 && offset >= container.nodeValue.length) {
	        if (!hasRightSideContent(editor.schema, container, parentBlock)) {
	          brElm = dom.create('br');
	          rng.insertNode(brElm);
	          rng.setStartAfter(brElm);
	          rng.setEndAfter(brElm);
	          extraBr = true;
	        }
	      }
	      brElm = dom.create('br');
	      rangeInsertNode(dom, rng, brElm);
	      scrollToBr(dom, selection, brElm);
	      moveSelectionToBr(dom, selection, brElm, extraBr);
	      editor.undoManager.add();
	    };
	    var insertBrBefore = function (editor, inline) {
	      var br = Element.fromTag('br');
	      before(Element.fromDom(inline), br);
	      editor.undoManager.add();
	    };
	    var insertBrAfter = function (editor, inline) {
	      if (!hasBrAfter(editor.getBody(), inline)) {
	        after(Element.fromDom(inline), Element.fromTag('br'));
	      }
	      var br = Element.fromTag('br');
	      after(Element.fromDom(inline), br);
	      scrollToBr(editor.dom, editor.selection, br.dom());
	      moveSelectionToBr(editor.dom, editor.selection, br.dom(), false);
	      editor.undoManager.add();
	    };
	    var isBeforeBr$1 = function (pos) {
	      return NodeType.isBr(pos.getNode());
	    };
	    var hasBrAfter = function (rootNode, startNode) {
	      if (isBeforeBr$1(CaretPosition$1.after(startNode))) {
	        return true;
	      } else {
	        return CaretFinder.nextPosition(rootNode, CaretPosition$1.after(startNode)).map(function (pos) {
	          return NodeType.isBr(pos.getNode());
	        }).getOr(false);
	      }
	    };
	    var isAnchorLink = function (elm) {
	      return elm && elm.nodeName === 'A' && 'href' in elm;
	    };
	    var isInsideAnchor = function (location) {
	      return location.fold(constant(false), isAnchorLink, isAnchorLink, constant(false));
	    };
	    var readInlineAnchorLocation = function (editor) {
	      var isInlineTarget = curry(InlineUtils.isInlineTarget, editor);
	      var position = CaretPosition$1.fromRangeStart(editor.selection.getRng());
	      return BoundaryLocation.readLocation(isInlineTarget, editor.getBody(), position).filter(isInsideAnchor);
	    };
	    var insertBrOutsideAnchor = function (editor, location) {
	      location.fold(noop, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop);
	    };
	    var insert$2 = function (editor, evt) {
	      var anchorLocation = readInlineAnchorLocation(editor);
	      if (anchorLocation.isSome()) {
	        anchorLocation.each(curry(insertBrOutsideAnchor, editor));
	      } else {
	        insertBrAtCaret(editor, evt);
	      }
	    };
	    var InsertBr = { insert: insert$2 };
	
	    var matchesSelector = function (editor, selector) {
	      return NewLineUtils.getParentBlock(editor).filter(function (parentBlock) {
	        return selector.length > 0 && is(Element.fromDom(parentBlock), selector);
	      }).isSome();
	    };
	    var shouldInsertBr = function (editor) {
	      return matchesSelector(editor, Settings.getBrNewLineSelector(editor));
	    };
	    var shouldBlockNewLine = function (editor) {
	      return matchesSelector(editor, Settings.getNoNewLineSelector(editor));
	    };
	    var ContextSelectors = {
	      shouldInsertBr: shouldInsertBr,
	      shouldBlockNewLine: shouldBlockNewLine
	    };
	
	    var newLineAction = Adt.generate([
	      { br: [] },
	      { block: [] },
	      { none: [] }
	    ]);
	    var shouldBlockNewLine$1 = function (editor, shiftKey) {
	      return ContextSelectors.shouldBlockNewLine(editor);
	    };
	    var isBrMode = function (requiredState) {
	      return function (editor, shiftKey) {
	        var brMode = Settings.getForcedRootBlock(editor) === '';
	        return brMode === requiredState;
	      };
	    };
	    var inListBlock = function (requiredState) {
	      return function (editor, shiftKey) {
	        return NewLineUtils.isListItemParentBlock(editor) === requiredState;
	      };
	    };
	    var inBlock = function (blockName, requiredState) {
	      return function (editor, shiftKey) {
	        var state = NewLineUtils.getParentBlockName(editor) === blockName.toUpperCase();
	        return state === requiredState;
	      };
	    };
	    var inPreBlock = function (requiredState) {
	      return inBlock('pre', requiredState);
	    };
	    var inSummaryBlock = function () {
	      return inBlock('summary', true);
	    };
	    var shouldPutBrInPre$1 = function (requiredState) {
	      return function (editor, shiftKey) {
	        return Settings.shouldPutBrInPre(editor) === requiredState;
	      };
	    };
	    var inBrContext = function (editor, shiftKey) {
	      return ContextSelectors.shouldInsertBr(editor);
	    };
	    var hasShiftKey = function (editor, shiftKey) {
	      return shiftKey;
	    };
	    var canInsertIntoEditableRoot = function (editor) {
	      var forcedRootBlock = Settings.getForcedRootBlock(editor);
	      var rootEditable = NewLineUtils.getEditableRoot(editor.dom, editor.selection.getStart());
	      return rootEditable && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock ? forcedRootBlock : 'P');
	    };
	    var match$2 = function (predicates, action) {
	      return function (editor, shiftKey) {
	        var isMatch = foldl(predicates, function (res, p) {
	          return res && p(editor, shiftKey);
	        }, true);
	        return isMatch ? Option.some(action) : Option.none();
	      };
	    };
	    var getAction$1 = function (editor, evt) {
	      return LazyEvaluator.evaluateUntil([
	        match$2([shouldBlockNewLine$1], newLineAction.none()),
	        match$2([inSummaryBlock()], newLineAction.br()),
	        match$2([
	          inPreBlock(true),
	          shouldPutBrInPre$1(false),
	          hasShiftKey
	        ], newLineAction.br()),
	        match$2([
	          inPreBlock(true),
	          shouldPutBrInPre$1(false)
	        ], newLineAction.block()),
	        match$2([
	          inPreBlock(true),
	          shouldPutBrInPre$1(true),
	          hasShiftKey
	        ], newLineAction.block()),
	        match$2([
	          inPreBlock(true),
	          shouldPutBrInPre$1(true)
	        ], newLineAction.br()),
	        match$2([
	          inListBlock(true),
	          hasShiftKey
	        ], newLineAction.br()),
	        match$2([inListBlock(true)], newLineAction.block()),
	        match$2([
	          isBrMode(true),
	          hasShiftKey,
	          canInsertIntoEditableRoot
	        ], newLineAction.block()),
	        match$2([isBrMode(true)], newLineAction.br()),
	        match$2([inBrContext], newLineAction.br()),
	        match$2([
	          isBrMode(false),
	          hasShiftKey
	        ], newLineAction.br()),
	        match$2([canInsertIntoEditableRoot], newLineAction.block())
	      ], [
	        editor,
	        !!(evt && evt.shiftKey)
	      ]).getOr(newLineAction.none());
	    };
	    var NewLineAction = { getAction: getAction$1 };
	
	    var insert$3 = function (editor, evt) {
	      NewLineAction.getAction(editor, evt).fold(function () {
	        InsertBr.insert(editor, evt);
	      }, function () {
	        InsertBlock.insert(editor, evt);
	      }, noop);
	    };
	    var InsertNewLine = { insert: insert$3 };
	
	    var handleEnterKeyEvent = function (editor, event) {
	      if (event.isDefaultPrevented()) {
	        return;
	      }
	      event.preventDefault();
	      endTypingLevelIgnoreLocks(editor.undoManager);
	      editor.undoManager.transact(function () {
	        if (editor.selection.isCollapsed() === false) {
	          editor.execCommand('Delete');
	        }
	        InsertNewLine.insert(editor, event);
	      });
	    };
	    var setup$b = function (editor) {
	      editor.on('keydown', function (event) {
	        if (event.keyCode === VK.ENTER) {
	          handleEnterKeyEvent(editor, event);
	        }
	      });
	    };
	    var EnterKey = { setup: setup$b };
	
	    var insertTextAtPosition = function (text, pos) {
	      var container = pos.container();
	      var offset = pos.offset();
	      if (NodeType.isText(container)) {
	        container.insertData(offset, text);
	        return Option.some(CaretPosition(container, offset + text.length));
	      } else {
	        return getElementFromPosition(pos).map(function (elm) {
	          var textNode = Element.fromText(text);
	          if (pos.isAtEnd()) {
	            after(elm, textNode);
	          } else {
	            before(elm, textNode);
	          }
	          return CaretPosition(textNode.dom(), text.length);
	        });
	      }
	    };
	    var insertNbspAtPosition = curry(insertTextAtPosition, nbsp);
	    var insertSpaceAtPosition = curry(insertTextAtPosition, ' ');
	
	    var isInMiddleOfText = function (pos) {
	      return CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();
	    };
	    var getClosestBlock$1 = function (root, pos) {
	      var parentBlocks = filter(Parents.parentsAndSelf(Element.fromDom(pos.container()), root), isBlock);
	      return head(parentBlocks).getOr(root);
	    };
	    var hasSpaceBefore = function (root, pos) {
	      if (isInMiddleOfText(pos)) {
	        return isAfterSpace(pos);
	      } else {
	        return isAfterSpace(pos) || CaretFinder.prevPosition(getClosestBlock$1(root, pos).dom(), pos).exists(isAfterSpace);
	      }
	    };
	    var hasSpaceAfter = function (root, pos) {
	      if (isInMiddleOfText(pos)) {
	        return isBeforeSpace(pos);
	      } else {
	        return isBeforeSpace(pos) || CaretFinder.nextPosition(getClosestBlock$1(root, pos).dom(), pos).exists(isBeforeSpace);
	      }
	    };
	    var isPreValue = function (value) {
	      return contains([
	        'pre',
	        'pre-wrap'
	      ], value);
	    };
	    var isInPre = function (pos) {
	      return getElementFromPosition(pos).bind(function (elm) {
	        return closest(elm, isElement);
	      }).exists(function (elm) {
	        return isPreValue(get$4(elm, 'white-space'));
	      });
	    };
	    var isAtBeginningOfBody = function (root, pos) {
	      return CaretFinder.prevPosition(root.dom(), pos).isNone();
	    };
	    var isAtEndOfBody = function (root, pos) {
	      return CaretFinder.nextPosition(root.dom(), pos).isNone();
	    };
	    var isAtLineBoundary = function (root, pos) {
	      return isAtBeginningOfBody(root, pos) || isAtEndOfBody(root, pos) || isAtStartOfBlock(root, pos) || isAtEndOfBlock(root, pos) || isAfterBr(root, pos) || isBeforeBr(root, pos);
	    };
	    var needsToHaveNbsp = function (root, pos) {
	      if (isInPre(pos)) {
	        return false;
	      } else {
	        return isAtLineBoundary(root, pos) || hasSpaceBefore(root, pos) || hasSpaceAfter(root, pos);
	      }
	    };
	    var needsToBeNbspLeft = function (root, pos) {
	      if (isInPre(pos)) {
	        return false;
	      } else {
	        return isAtStartOfBlock(root, pos) || isBeforeBlock(root, pos) || isAfterBr(root, pos) || hasSpaceBefore(root, pos);
	      }
	    };
	    var leanRight = function (pos) {
	      var container = pos.container();
	      var offset = pos.offset();
	      if (NodeType.isText(container) && offset < container.data.length) {
	        return CaretPosition(container, offset + 1);
	      } else {
	        return pos;
	      }
	    };
	    var needsToBeNbspRight = function (root, pos) {
	      var afterPos = leanRight(pos);
	      if (isInPre(afterPos)) {
	        return false;
	      } else {
	        return isAtEndOfBlock(root, afterPos) || isAfterBlock(root, afterPos) || isBeforeBr(root, afterPos) || hasSpaceAfter(root, afterPos);
	      }
	    };
	    var needsToBeNbsp = function (root, pos) {
	      return needsToBeNbspLeft(root, pos) || needsToBeNbspRight(root, pos);
	    };
	    var isNbspAt = function (text, offset) {
	      return isNbsp(text.charAt(offset));
	    };
	    var hasNbsp = function (pos) {
	      var container = pos.container();
	      return NodeType.isText(container) && contains$1(container.data, nbsp);
	    };
	    var normalizeNbspMiddle = function (text) {
	      var chars = text.split('');
	      return map(chars, function (chr, i) {
	        if (isNbsp(chr) && i > 0 && i < chars.length - 1 && isContent(chars[i - 1]) && isContent(chars[i + 1])) {
	          return ' ';
	        } else {
	          return chr;
	        }
	      }).join('');
	    };
	    var normalizeNbspAtStart = function (root, node) {
	      var text = node.data;
	      var firstPos = CaretPosition(node, 0);
	      if (isNbspAt(text, 0) && !needsToBeNbsp(root, firstPos)) {
	        node.data = ' ' + text.slice(1);
	        return true;
	      } else {
	        return false;
	      }
	    };
	    var normalizeNbspInMiddleOfTextNode = function (node) {
	      var text = node.data;
	      var newText = normalizeNbspMiddle(text);
	      if (newText !== text) {
	        node.data = newText;
	        return true;
	      } else {
	        return false;
	      }
	    };
	    var normalizeNbspAtEnd = function (root, node) {
	      var text = node.data;
	      var lastPos = CaretPosition(node, text.length - 1);
	      if (isNbspAt(text, text.length - 1) && !needsToBeNbsp(root, lastPos)) {
	        node.data = text.slice(0, -1) + ' ';
	        return true;
	      } else {
	        return false;
	      }
	    };
	    var normalizeNbsps = function (root, pos) {
	      return Option.some(pos).filter(hasNbsp).bind(function (pos) {
	        var container = pos.container();
	        var normalized = normalizeNbspAtStart(root, container) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root, container);
	        return normalized ? Option.some(pos) : Option.none();
	      });
	    };
	    var normalizeNbspsInEditor = function (editor) {
	      var root = Element.fromDom(editor.getBody());
	      if (editor.selection.isCollapsed()) {
	        normalizeNbsps(root, CaretPosition.fromRangeStart(editor.selection.getRng())).each(function (pos) {
	          editor.selection.setRng(pos.toRange());
	        });
	      }
	    };
	
	    var locationToCaretPosition = function (root) {
	      return function (location) {
	        return location.fold(function (element) {
	          return CaretFinder.prevPosition(root.dom(), CaretPosition$1.before(element));
	        }, function (element) {
	          return CaretFinder.firstPositionIn(element);
	        }, function (element) {
	          return CaretFinder.lastPositionIn(element);
	        }, function (element) {
	          return CaretFinder.nextPosition(root.dom(), CaretPosition$1.after(element));
	        });
	      };
	    };
	    var insertInlineBoundarySpaceOrNbsp = function (root, pos) {
	      return function (checkPos) {
	        return needsToHaveNbsp(root, checkPos) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);
	      };
	    };
	    var setSelection$1 = function (editor) {
	      return function (pos) {
	        editor.selection.setRng(pos.toRange());
	        editor.nodeChanged();
	        return true;
	      };
	    };
	    var insertSpaceOrNbspAtSelection = function (editor) {
	      var pos = CaretPosition$1.fromRangeStart(editor.selection.getRng());
	      var root = Element.fromDom(editor.getBody());
	      if (editor.selection.isCollapsed()) {
	        var isInlineTarget = curry(InlineUtils.isInlineTarget, editor);
	        var caretPosition = CaretPosition$1.fromRangeStart(editor.selection.getRng());
	        return BoundaryLocation.readLocation(isInlineTarget, editor.getBody(), caretPosition).bind(locationToCaretPosition(root)).bind(insertInlineBoundarySpaceOrNbsp(root, pos)).exists(setSelection$1(editor));
	      } else {
	        return false;
	      }
	    };
	
	    var executeKeydownOverride$2 = function (editor, evt) {
	      MatchKeys.execute([{
	          keyCode: VK.SPACEBAR,
	          action: MatchKeys.action(insertSpaceOrNbspAtSelection, editor)
	        }], evt).each(function (_) {
	        evt.preventDefault();
	      });
	    };
	    var setup$c = function (editor) {
	      editor.on('keydown', function (evt) {
	        if (evt.isDefaultPrevented() === false) {
	          executeKeydownOverride$2(editor, evt);
	        }
	      });
	    };
	    var SpaceKey = { setup: setup$c };
	
	    var findBlockCaretContainer = function (editor) {
	      return descendant(Element.fromDom(editor.getBody()), '*[data-mce-caret]').fold(constant(null), function (elm) {
	        return elm.dom();
	      });
	    };
	    var removeIeControlRect = function (editor) {
	      editor.selection.setRng(editor.selection.getRng());
	    };
	    var showBlockCaretContainer = function (editor, blockCaretContainer) {
	      if (blockCaretContainer.hasAttribute('data-mce-caret')) {
	        showCaretContainerBlock(blockCaretContainer);
	        removeIeControlRect(editor);
	        editor.selection.scrollIntoView(blockCaretContainer);
	      }
	    };
	    var handleBlockContainer = function (editor, e) {
	      var blockCaretContainer = findBlockCaretContainer(editor);
	      if (!blockCaretContainer) {
	        return;
	      }
	      if (e.type === 'compositionstart') {
	        e.preventDefault();
	        e.stopPropagation();
	        showBlockCaretContainer(editor, blockCaretContainer);
	        return;
	      }
	      if (hasContent(blockCaretContainer)) {
	        showBlockCaretContainer(editor, blockCaretContainer);
	        editor.undoManager.add();
	      }
	    };
	    var setup$d = function (editor) {
	      editor.on('keyup compositionstart', curry(handleBlockContainer, editor));
	    };
	    var CaretContainerInput = { setup: setup$d };
	
	    var browser$5 = detect$3().browser;
	    var setupIeInput = function (editor) {
	      var keypressThrotter = first(function () {
	        if (!editor.composing) {
	          normalizeNbspsInEditor(editor);
	        }
	      }, 0);
	      if (browser$5.isIE()) {
	        editor.on('keypress', function (e) {
	          keypressThrotter.throttle();
	        });
	        editor.on('remove', function (e) {
	          keypressThrotter.cancel();
	        });
	      }
	    };
	    var setup$e = function (editor) {
	      setupIeInput(editor);
	      editor.on('input', function (e) {
	        if (e.isComposing === false) {
	          normalizeNbspsInEditor(editor);
	        }
	      });
	    };
	
	    var executeKeydownOverride$3 = function (editor, evt) {
	      MatchKeys.execute([
	        {
	          keyCode: VK.END,
	          action: moveToLineEndPoint(editor, true)
	        },
	        {
	          keyCode: VK.HOME,
	          action: moveToLineEndPoint(editor, false)
	        }
	      ], evt).each(function (_) {
	        evt.preventDefault();
	      });
	    };
	    var setup$f = function (editor) {
	      editor.on('keydown', function (evt) {
	        if (evt.isDefaultPrevented() === false) {
	          executeKeydownOverride$3(editor, evt);
	        }
	      });
	    };
	    var HomeEndKeys = { setup: setup$f };
	
	    var setup$g = function (editor) {
	      var caret = BoundarySelection.setupSelectedState(editor);
	      CaretContainerInput.setup(editor);
	      ArrowKeys.setup(editor, caret);
	      DeleteBackspaceKeys.setup(editor, caret);
	      EnterKey.setup(editor);
	      SpaceKey.setup(editor);
	      setup$e(editor);
	      HomeEndKeys.setup(editor);
	    };
	    var KeyboardOverrides = { setup: setup$g };
	
	    var NodeChange = function () {
	      function NodeChange(editor) {
	        this.lastPath = [];
	        this.editor = editor;
	        var lastRng;
	        var self = this;
	        if (!('onselectionchange' in editor.getDoc())) {
	          editor.on('NodeChange click mouseup keyup focus', function (e) {
	            var nativeRng, fakeRng;
	            nativeRng = editor.selection.getRng();
	            fakeRng = {
	              startContainer: nativeRng.startContainer,
	              startOffset: nativeRng.startOffset,
	              endContainer: nativeRng.endContainer,
	              endOffset: nativeRng.endOffset
	            };
	            if (e.type === 'nodechange' || !RangeCompare.isEq(fakeRng, lastRng)) {
	              editor.fire('SelectionChange');
	            }
	            lastRng = fakeRng;
	          });
	        }
	        editor.on('contextmenu', function () {
	          editor.fire('SelectionChange');
	        });
	        editor.on('SelectionChange', function () {
	          var startElm = editor.selection.getStart(true);
	          if (!startElm || !Env.range && editor.selection.isCollapsed()) {
	            return;
	          }
	          if (hasAnyRanges(editor) && !self.isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {
	            editor.nodeChanged({ selectionChange: true });
	          }
	        });
	        editor.on('mouseup', function (e) {
	          if (!e.isDefaultPrevented() && hasAnyRanges(editor)) {
	            if (editor.selection.getNode().nodeName === 'IMG') {
	              Delay.setEditorTimeout(editor, function () {
	                editor.nodeChanged();
	              });
	            } else {
	              editor.nodeChanged();
	            }
	          }
	        });
	      }
	      NodeChange.prototype.nodeChanged = function (args) {
	        var selection = this.editor.selection;
	        var node, parents, root;
	        if (this.editor.initialized && selection && !this.editor.settings.disable_nodechange && !this.editor.mode.isReadOnly()) {
	          root = this.editor.getBody();
	          node = selection.getStart(true) || root;
	          if (node.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(node, root)) {
	            node = root;
	          }
	          parents = [];
	          this.editor.dom.getParent(node, function (node) {
	            if (node === root) {
	              return true;
	            }
	            parents.push(node);
	          });
	          args = args || {};
	          args.element = node;
	          args.parents = parents;
	          this.editor.fire('NodeChange', args);
	        }
	      };
	      NodeChange.prototype.isSameElementPath = function (startElm) {
	        var i, currentPath;
	        currentPath = this.editor.$(startElm).parentsUntil(this.editor.getBody()).add(startElm);
	        if (currentPath.length === this.lastPath.length) {
	          for (i = currentPath.length; i >= 0; i--) {
	            if (currentPath[i] !== this.lastPath[i]) {
	              break;
	            }
	          }
	          if (i === -1) {
	            this.lastPath = currentPath;
	            return true;
	          }
	        }
	        this.lastPath = currentPath;
	        return false;
	      };
	      return NodeChange;
	    }();
	
	    var preventSummaryToggle = function (editor) {
	      editor.on('click', function (e) {
	        if (editor.dom.getParent(e.target, 'details')) {
	          e.preventDefault();
	        }
	      });
	    };
	    var filterDetails = function (editor) {
	      editor.parser.addNodeFilter('details', function (elms) {
	        each(elms, function (details) {
	          details.attr('data-mce-open', details.attr('open'));
	          details.attr('open', 'open');
	        });
	      });
	      editor.serializer.addNodeFilter('details', function (elms) {
	        each(elms, function (details) {
	          var open = details.attr('data-mce-open');
	          details.attr('open', isString(open) ? open : null);
	          details.attr('data-mce-open', null);
	        });
	      });
	    };
	    var setup$h = function (editor) {
	      preventSummaryToggle(editor);
	      filterDetails(editor);
	    };
	
	    var isTextBlockNode = function (node) {
	      return NodeType.isElement(node) && isTextBlock(Element.fromDom(node));
	    };
	    var normalizeSelection$1 = function (editor) {
	      var rng = editor.selection.getRng();
	      var startPos = CaretPosition.fromRangeStart(rng);
	      var endPos = CaretPosition.fromRangeEnd(rng);
	      if (CaretPosition.isElementPosition(startPos)) {
	        var container = startPos.container();
	        if (isTextBlockNode(container)) {
	          CaretFinder.firstPositionIn(container).each(function (pos) {
	            return rng.setStart(pos.container(), pos.offset());
	          });
	        }
	      }
	      if (CaretPosition.isElementPosition(endPos)) {
	        var container = startPos.container();
	        if (isTextBlockNode(container)) {
	          CaretFinder.lastPositionIn(container).each(function (pos) {
	            return rng.setEnd(pos.container(), pos.offset());
	          });
	        }
	      }
	      editor.selection.setRng(RangeNormalizer.normalize(rng));
	    };
	    var setup$i = function (editor) {
	      editor.on('click', function (e) {
	        if (e.detail >= 3) {
	          normalizeSelection$1(editor);
	        }
	      });
	    };
	
	    var getAbsolutePosition = function (elm) {
	      var doc, docElem, win, clientRect;
	      clientRect = elm.getBoundingClientRect();
	      doc = elm.ownerDocument;
	      docElem = doc.documentElement;
	      win = doc.defaultView;
	      return {
	        top: clientRect.top + win.pageYOffset - docElem.clientTop,
	        left: clientRect.left + win.pageXOffset - docElem.clientLeft
	      };
	    };
	    var getBodyPosition = function (editor) {
	      return editor.inline ? getAbsolutePosition(editor.getBody()) : {
	        left: 0,
	        top: 0
	      };
	    };
	    var getScrollPosition = function (editor) {
	      var body = editor.getBody();
	      return editor.inline ? {
	        left: body.scrollLeft,
	        top: body.scrollTop
	      } : {
	        left: 0,
	        top: 0
	      };
	    };
	    var getBodyScroll = function (editor) {
	      var body = editor.getBody(), docElm = editor.getDoc().documentElement;
	      var inlineScroll = {
	        left: body.scrollLeft,
	        top: body.scrollTop
	      };
	      var iframeScroll = {
	        left: body.scrollLeft || docElm.scrollLeft,
	        top: body.scrollTop || docElm.scrollTop
	      };
	      return editor.inline ? inlineScroll : iframeScroll;
	    };
	    var getMousePosition = function (editor, event) {
	      if (event.target.ownerDocument !== editor.getDoc()) {
	        var iframePosition = getAbsolutePosition(editor.getContentAreaContainer());
	        var scrollPosition = getBodyScroll(editor);
	        return {
	          left: event.pageX - iframePosition.left + scrollPosition.left,
	          top: event.pageY - iframePosition.top + scrollPosition.top
	        };
	      }
	      return {
	        left: event.pageX,
	        top: event.pageY
	      };
	    };
	    var calculatePosition = function (bodyPosition, scrollPosition, mousePosition) {
	      return {
	        pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,
	        pageY: mousePosition.top - bodyPosition.top + scrollPosition.top
	      };
	    };
	    var calc = function (editor, event) {
	      return calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));
	    };
	    var MousePosition = { calc: calc };
	
	    var isContentEditableFalse$a = NodeType.isContentEditableFalse, isContentEditableTrue$4 = NodeType.isContentEditableTrue;
	    var isDraggable = function (rootElm, elm) {
	      return isContentEditableFalse$a(elm) && elm !== rootElm;
	    };
	    var isValidDropTarget = function (editor, targetElement, dragElement) {
	      if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {
	        return false;
	      }
	      return !isContentEditableFalse$a(targetElement);
	    };
	    var cloneElement = function (elm) {
	      var cloneElm = elm.cloneNode(true);
	      cloneElm.removeAttribute('data-mce-selected');
	      return cloneElm;
	    };
	    var createGhost = function (editor, elm, width, height) {
	      var clonedElm = elm.cloneNode(true);
	      editor.dom.setStyles(clonedElm, {
	        width: width,
	        height: height
	      });
	      editor.dom.setAttrib(clonedElm, 'data-mce-selected', null);
	      var ghostElm = editor.dom.create('div', {
	        'class': 'mce-drag-container',
	        'data-mce-bogus': 'all',
	        'unselectable': 'on',
	        'contenteditable': 'false'
	      });
	      editor.dom.setStyles(ghostElm, {
	        position: 'absolute',
	        opacity: 0.5,
	        overflow: 'hidden',
	        border: 0,
	        padding: 0,
	        margin: 0,
	        width: width,
	        height: height
	      });
	      editor.dom.setStyles(clonedElm, {
	        margin: 0,
	        boxSizing: 'border-box'
	      });
	      ghostElm.appendChild(clonedElm);
	      return ghostElm;
	    };
	    var appendGhostToBody = function (ghostElm, bodyElm) {
	      if (ghostElm.parentNode !== bodyElm) {
	        bodyElm.appendChild(ghostElm);
	      }
	    };
	    var moveGhost = function (ghostElm, position, width, height, maxX, maxY) {
	      var overflowX = 0, overflowY = 0;
	      ghostElm.style.left = position.pageX + 'px';
	      ghostElm.style.top = position.pageY + 'px';
	      if (position.pageX + width > maxX) {
	        overflowX = position.pageX + width - maxX;
	      }
	      if (position.pageY + height > maxY) {
	        overflowY = position.pageY + height - maxY;
	      }
	      ghostElm.style.width = width - overflowX + 'px';
	      ghostElm.style.height = height - overflowY + 'px';
	    };
	    var removeElement = function (elm) {
	      if (elm && elm.parentNode) {
	        elm.parentNode.removeChild(elm);
	      }
	    };
	    var isLeftMouseButtonPressed = function (e) {
	      return e.button === 0;
	    };
	    var hasDraggableElement = function (state) {
	      return state.element;
	    };
	    var applyRelPos = function (state, position) {
	      return {
	        pageX: position.pageX - state.relX,
	        pageY: position.pageY + 5
	      };
	    };
	    var start$1 = function (state, editor) {
	      return function (e) {
	        if (isLeftMouseButtonPressed(e)) {
	          var ceElm = find(editor.dom.getParents(e.target), Predicate.or(isContentEditableFalse$a, isContentEditableTrue$4)).getOr(null);
	          if (isDraggable(editor.getBody(), ceElm)) {
	            var elmPos = editor.dom.getPos(ceElm);
	            var bodyElm = editor.getBody();
	            var docElm = editor.getDoc().documentElement;
	            state.element = ceElm;
	            state.screenX = e.screenX;
	            state.screenY = e.screenY;
	            state.maxX = (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2;
	            state.maxY = (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2;
	            state.relX = e.pageX - elmPos.x;
	            state.relY = e.pageY - elmPos.y;
	            state.width = ceElm.offsetWidth;
	            state.height = ceElm.offsetHeight;
	            state.ghost = createGhost(editor, ceElm, state.width, state.height);
	          }
	        }
	      };
	    };
	    var move$1 = function (state, editor) {
	      var throttledPlaceCaretAt = Delay.throttle(function (clientX, clientY) {
	        editor._selectionOverrides.hideFakeCaret();
	        editor.selection.placeCaretAt(clientX, clientY);
	      }, 0);
	      return function (e) {
	        var movement = Math.max(Math.abs(e.screenX - state.screenX), Math.abs(e.screenY - state.screenY));
	        if (hasDraggableElement(state) && !state.dragging && movement > 10) {
	          var args = editor.fire('dragstart', { target: state.element });
	          if (args.isDefaultPrevented()) {
	            return;
	          }
	          state.dragging = true;
	          editor.focus();
	        }
	        if (state.dragging) {
	          var targetPos = applyRelPos(state, MousePosition.calc(editor, e));
	          appendGhostToBody(state.ghost, editor.getBody());
	          moveGhost(state.ghost, targetPos, state.width, state.height, state.maxX, state.maxY);
	          throttledPlaceCaretAt(e.clientX, e.clientY);
	        }
	      };
	    };
	    var getRawTarget = function (selection) {
	      var rng = selection.getSel().getRangeAt(0);
	      var startContainer = rng.startContainer;
	      return startContainer.nodeType === 3 ? startContainer.parentNode : startContainer;
	    };
	    var drop = function (state, editor) {
	      return function (e) {
	        if (state.dragging) {
	          if (isValidDropTarget(editor, getRawTarget(editor.selection), state.element)) {
	            var targetClone_1 = cloneElement(state.element);
	            var args = editor.fire('drop', {
	              targetClone: targetClone_1,
	              clientX: e.clientX,
	              clientY: e.clientY
	            });
	            if (!args.isDefaultPrevented()) {
	              targetClone_1 = args.targetClone;
	              editor.undoManager.transact(function () {
	                removeElement(state.element);
	                editor.insertContent(editor.dom.getOuterHTML(targetClone_1));
	                editor._selectionOverrides.hideFakeCaret();
	              });
	            }
	          }
	        }
	        removeDragState(state);
	      };
	    };
	    var stop = function (state, editor) {
	      return function () {
	        if (state.dragging) {
	          editor.fire('dragend');
	        }
	        removeDragState(state);
	      };
	    };
	    var removeDragState = function (state) {
	      state.dragging = false;
	      state.element = null;
	      removeElement(state.ghost);
	    };
	    var bindFakeDragEvents = function (editor) {
	      var state = {};
	      var pageDom, dragStartHandler, dragHandler, dropHandler, dragEndHandler, rootDocument;
	      pageDom = DOMUtils$1.DOM;
	      rootDocument = domGlobals.document;
	      dragStartHandler = start$1(state, editor);
	      dragHandler = move$1(state, editor);
	      dropHandler = drop(state, editor);
	      dragEndHandler = stop(state, editor);
	      editor.on('mousedown', dragStartHandler);
	      editor.on('mousemove', dragHandler);
	      editor.on('mouseup', dropHandler);
	      pageDom.bind(rootDocument, 'mousemove', dragHandler);
	      pageDom.bind(rootDocument, 'mouseup', dragEndHandler);
	      editor.on('remove', function () {
	        pageDom.unbind(rootDocument, 'mousemove', dragHandler);
	        pageDom.unbind(rootDocument, 'mouseup', dragEndHandler);
	      });
	    };
	    var blockIeDrop = function (editor) {
	      editor.on('drop', function (e) {
	        var realTarget = typeof e.clientX !== 'undefined' ? editor.getDoc().elementFromPoint(e.clientX, e.clientY) : null;
	        if (isContentEditableFalse$a(realTarget) || isContentEditableFalse$a(editor.dom.getContentEditableParent(realTarget))) {
	          e.preventDefault();
	        }
	      });
	    };
	    var init = function (editor) {
	      bindFakeDragEvents(editor);
	      blockIeDrop(editor);
	    };
	    var DragDropOverrides = { init: init };
	
	    var setup$j = function (editor) {
	      var renderFocusCaret = first(function () {
	        if (!editor.removed && editor.getBody().contains(domGlobals.document.activeElement)) {
	          var rng = editor.selection.getRng();
	          if (rng.collapsed) {
	            var caretRange = renderRangeCaret(editor, editor.selection.getRng(), false);
	            editor.selection.setRng(caretRange);
	          }
	        }
	      }, 0);
	      editor.on('focus', function () {
	        renderFocusCaret.throttle();
	      });
	      editor.on('blur', function () {
	        renderFocusCaret.cancel();
	      });
	    };
	    var CefFocus = { setup: setup$j };
	
	    var isContentEditableTrue$5 = NodeType.isContentEditableTrue;
	    var isContentEditableFalse$b = NodeType.isContentEditableFalse;
	    var getContentEditableRoot$2 = function (editor, node) {
	      var root = editor.getBody();
	      while (node && node !== root) {
	        if (isContentEditableTrue$5(node) || isContentEditableFalse$b(node)) {
	          return node;
	        }
	        node = node.parentNode;
	      }
	      return null;
	    };
	    var SelectionOverrides = function (editor) {
	      var isBlock = function (node) {
	        return editor.dom.isBlock(node);
	      };
	      var rootNode = editor.getBody();
	      var fakeCaret = FakeCaret(editor, rootNode, isBlock, function () {
	        return EditorFocus.hasFocus(editor);
	      });
	      var realSelectionId = 'sel-' + editor.dom.uniqueId();
	      var selectedContentEditableNode;
	      var isFakeSelectionElement = function (elm) {
	        return editor.dom.hasClass(elm, 'mce-offscreen-selection');
	      };
	      var getRealSelectionElement = function () {
	        var container = editor.dom.get(realSelectionId);
	        return container ? container.getElementsByTagName('*')[0] : container;
	      };
	      var setRange = function (range) {
	        if (range) {
	          editor.selection.setRng(range);
	        }
	      };
	      var getRange = function () {
	        return editor.selection.getRng();
	      };
	      var showCaret = function (direction, node, before, scrollIntoView) {
	        if (scrollIntoView === void 0) {
	          scrollIntoView = true;
	        }
	        var e;
	        e = editor.fire('ShowCaret', {
	          target: node,
	          direction: direction,
	          before: before
	        });
	        if (e.isDefaultPrevented()) {
	          return null;
	        }
	        if (scrollIntoView) {
	          editor.selection.scrollIntoView(node, direction === -1);
	        }
	        return fakeCaret.show(before, node);
	      };
	      var showBlockCaretContainer = function (blockCaretContainer) {
	        if (blockCaretContainer.hasAttribute('data-mce-caret')) {
	          showCaretContainerBlock(blockCaretContainer);
	          setRange(getRange());
	          editor.selection.scrollIntoView(blockCaretContainer);
	        }
	      };
	      var registerEvents = function () {
	        editor.on('mouseup', function (e) {
	          var range = getRange();
	          if (range.collapsed && EditorView.isXYInContentArea(editor, e.clientX, e.clientY)) {
	            setRange(renderCaretAtRange(editor, range, false));
	          }
	        });
	        editor.on('click', function (e) {
	          var contentEditableRoot;
	          contentEditableRoot = getContentEditableRoot$2(editor, e.target);
	          if (contentEditableRoot) {
	            if (isContentEditableFalse$b(contentEditableRoot)) {
	              e.preventDefault();
	              editor.focus();
	            }
	            if (isContentEditableTrue$5(contentEditableRoot)) {
	              if (editor.dom.isChildOf(contentEditableRoot, editor.selection.getNode())) {
	                removeContentEditableSelection();
	              }
	            }
	          }
	        });
	        editor.on('blur NewBlock', function () {
	          removeContentEditableSelection();
	        });
	        editor.on('ResizeWindow FullscreenStateChanged', function () {
	          return fakeCaret.reposition();
	        });
	        var handleTouchSelect = function (editor) {
	          editor.on('tap', function (e) {
	            var contentEditableRoot = getContentEditableRoot$2(editor, e.target);
	            if (isContentEditableFalse$b(contentEditableRoot)) {
	              e.preventDefault();
	              setContentEditableSelection(selectNode(editor, contentEditableRoot));
	            }
	          }, true);
	        };
	        var hasNormalCaretPosition = function (elm) {
	          var caretWalker = CaretWalker(elm);
	          if (!elm.firstChild) {
	            return false;
	          }
	          var startPos = CaretPosition$1.before(elm.firstChild);
	          var newPos = caretWalker.next(startPos);
	          return newPos && !isBeforeContentEditableFalse(newPos) && !isAfterContentEditableFalse(newPos);
	        };
	        var isInSameBlock = function (node1, node2) {
	          var block1 = editor.dom.getParent(node1, editor.dom.isBlock);
	          var block2 = editor.dom.getParent(node2, editor.dom.isBlock);
	          return block1 === block2;
	        };
	        var hasBetterMouseTarget = function (targetNode, caretNode) {
	          var targetBlock = editor.dom.getParent(targetNode, editor.dom.isBlock);
	          var caretBlock = editor.dom.getParent(caretNode, editor.dom.isBlock);
	          if (targetBlock && editor.dom.isChildOf(targetBlock, caretBlock) && isContentEditableFalse$b(getContentEditableRoot$2(editor, targetBlock)) === false) {
	            return true;
	          }
	          return targetBlock && !isInSameBlock(targetBlock, caretBlock) && hasNormalCaretPosition(targetBlock);
	        };
	        handleTouchSelect(editor);
	        editor.on('mousedown', function (e) {
	          var contentEditableRoot;
	          var targetElm = e.target;
	          if (targetElm !== rootNode && targetElm.nodeName !== 'HTML' && !editor.dom.isChildOf(targetElm, rootNode)) {
	            return;
	          }
	          if (EditorView.isXYInContentArea(editor, e.clientX, e.clientY) === false) {
	            return;
	          }
	          contentEditableRoot = getContentEditableRoot$2(editor, targetElm);
	          if (contentEditableRoot) {
	            if (isContentEditableFalse$b(contentEditableRoot)) {
	              e.preventDefault();
	              setContentEditableSelection(selectNode(editor, contentEditableRoot));
	            } else {
	              removeContentEditableSelection();
	              if (!(isContentEditableTrue$5(contentEditableRoot) && e.shiftKey) && !RangePoint.isXYWithinRange(e.clientX, e.clientY, editor.selection.getRng())) {
	                hideFakeCaret();
	                editor.selection.placeCaretAt(e.clientX, e.clientY);
	              }
	            }
	          } else if (isFakeCaretTarget(targetElm) === false) {
	            removeContentEditableSelection();
	            hideFakeCaret();
	            var caretInfo = closestCaret(rootNode, e.clientX, e.clientY);
	            if (caretInfo) {
	              if (!hasBetterMouseTarget(e.target, caretInfo.node)) {
	                e.preventDefault();
	                var range = showCaret(1, caretInfo.node, caretInfo.before, false);
	                editor.getBody().focus();
	                setRange(range);
	              }
	            }
	          }
	        });
	        editor.on('keypress', function (e) {
	          if (VK.modifierPressed(e)) {
	            return;
	          }
	          switch (e.keyCode) {
	          default:
	            if (isContentEditableFalse$b(editor.selection.getNode())) {
	              e.preventDefault();
	            }
	            break;
	          }
	        });
	        editor.on('GetSelectionRange', function (e) {
	          var rng = e.range;
	          if (selectedContentEditableNode) {
	            if (!selectedContentEditableNode.parentNode) {
	              selectedContentEditableNode = null;
	              return;
	            }
	            rng = rng.cloneRange();
	            rng.selectNode(selectedContentEditableNode);
	            e.range = rng;
	          }
	        });
	        editor.on('SetSelectionRange', function (e) {
	          e.range = normalizeShortEndedElementSelection(e.range);
	          var rng = setContentEditableSelection(e.range, e.forward);
	          if (rng) {
	            e.range = rng;
	          }
	        });
	        var isPasteBin = function (node) {
	          return node.id === 'mcepastebin';
	        };
	        editor.on('AfterSetSelectionRange', function (e) {
	          var rng = e.range;
	          if (!isRangeInCaretContainer(rng) && !isPasteBin(rng.startContainer.parentNode)) {
	            hideFakeCaret();
	          }
	          if (!isFakeSelectionElement(rng.startContainer.parentNode)) {
	            removeContentEditableSelection();
	          }
	        });
	        editor.on('copy', function (e) {
	          var clipboardData = e.clipboardData;
	          if (!e.isDefaultPrevented() && e.clipboardData && !Env.ie) {
	            var realSelectionElement = getRealSelectionElement();
	            if (realSelectionElement) {
	              e.preventDefault();
	              clipboardData.clearData();
	              clipboardData.setData('text/html', realSelectionElement.outerHTML);
	              clipboardData.setData('text/plain', realSelectionElement.outerText);
	            }
	          }
	        });
	        DragDropOverrides.init(editor);
	        CefFocus.setup(editor);
	      };
	      var isWithinCaretContainer = function (node) {
	        return isCaretContainer(node) || startsWithCaretContainer(node) || endsWithCaretContainer(node);
	      };
	      var isRangeInCaretContainer = function (rng) {
	        return isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);
	      };
	      var normalizeShortEndedElementSelection = function (rng) {
	        var shortEndedElements = editor.schema.getShortEndedElements();
	        var newRng = editor.dom.createRng();
	        var startContainer = rng.startContainer;
	        var startOffset = rng.startOffset;
	        var endContainer = rng.endContainer;
	        var endOffset = rng.endOffset;
	        if (has(shortEndedElements, startContainer.nodeName.toLowerCase())) {
	          if (startOffset === 0) {
	            newRng.setStartBefore(startContainer);
	          } else {
	            newRng.setStartAfter(startContainer);
	          }
	        } else {
	          newRng.setStart(startContainer, startOffset);
	        }
	        if (has(shortEndedElements, endContainer.nodeName.toLowerCase())) {
	          if (endOffset === 0) {
	            newRng.setEndBefore(endContainer);
	          } else {
	            newRng.setEndAfter(endContainer);
	          }
	        } else {
	          newRng.setEnd(endContainer, endOffset);
	        }
	        return newRng;
	      };
	      var setContentEditableSelection = function (range, forward) {
	        var node;
	        var $ = editor.$;
	        var dom = editor.dom;
	        var $realSelectionContainer, sel, startContainer, startOffset, endOffset, e, caretPosition, targetClone, origTargetClone;
	        if (!range) {
	          return null;
	        }
	        if (range.collapsed) {
	          if (!isRangeInCaretContainer(range)) {
	            if (forward === false) {
	              caretPosition = getNormalizedRangeEndPoint(-1, rootNode, range);
	              if (isFakeCaretTarget(caretPosition.getNode(true))) {
	                return showCaret(-1, caretPosition.getNode(true), false, false);
	              }
	              if (isFakeCaretTarget(caretPosition.getNode())) {
	                return showCaret(-1, caretPosition.getNode(), !caretPosition.isAtEnd(), false);
	              }
	            } else {
	              caretPosition = getNormalizedRangeEndPoint(1, rootNode, range);
	              if (isFakeCaretTarget(caretPosition.getNode())) {
	                return showCaret(1, caretPosition.getNode(), !caretPosition.isAtEnd(), false);
	              }
	              if (isFakeCaretTarget(caretPosition.getNode(true))) {
	                return showCaret(1, caretPosition.getNode(true), false, false);
	              }
	            }
	          }
	          return null;
	        }
	        startContainer = range.startContainer;
	        startOffset = range.startOffset;
	        endOffset = range.endOffset;
	        if (startContainer.nodeType === 3 && startOffset === 0 && isContentEditableFalse$b(startContainer.parentNode)) {
	          startContainer = startContainer.parentNode;
	          startOffset = dom.nodeIndex(startContainer);
	          startContainer = startContainer.parentNode;
	        }
	        if (startContainer.nodeType !== 1) {
	          return null;
	        }
	        if (endOffset === startOffset + 1 && startContainer === range.endContainer) {
	          node = startContainer.childNodes[startOffset];
	        }
	        if (!isContentEditableFalse$b(node)) {
	          return null;
	        }
	        targetClone = origTargetClone = node.cloneNode(true);
	        e = editor.fire('ObjectSelected', {
	          target: node,
	          targetClone: targetClone
	        });
	        if (e.isDefaultPrevented()) {
	          return null;
	        }
	        $realSelectionContainer = descendant(Element.fromDom(editor.getBody()), '#' + realSelectionId).fold(function () {
	          return $([]);
	        }, function (elm) {
	          return $([elm.dom()]);
	        });
	        targetClone = e.targetClone;
	        if ($realSelectionContainer.length === 0) {
	          $realSelectionContainer = $('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>').attr('id', realSelectionId);
	          $realSelectionContainer.appendTo(editor.getBody());
	        }
	        range = editor.dom.createRng();
	        if (targetClone === origTargetClone && Env.ie) {
	          $realSelectionContainer.empty().append('<p style="font-size: 0" data-mce-bogus="all">\xA0</p>').append(targetClone);
	          range.setStartAfter($realSelectionContainer[0].firstChild.firstChild);
	          range.setEndAfter(targetClone);
	        } else {
	          $realSelectionContainer.empty().append(nbsp).append(targetClone).append(nbsp);
	          range.setStart($realSelectionContainer[0].firstChild, 1);
	          range.setEnd($realSelectionContainer[0].lastChild, 0);
	        }
	        $realSelectionContainer.css({ top: dom.getPos(node, editor.getBody()).y });
	        $realSelectionContainer[0].focus();
	        sel = editor.selection.getSel();
	        sel.removeAllRanges();
	        sel.addRange(range);
	        var nodeElm = Element.fromDom(node);
	        each(descendants$1(Element.fromDom(editor.getBody()), '*[data-mce-selected]'), function (elm) {
	          if (!eq(nodeElm, elm)) {
	            remove$1(elm, 'data-mce-selected');
	          }
	        });
	        if (!editor.dom.getAttrib(node, 'data-mce-selected')) {
	          node.setAttribute('data-mce-selected', '1');
	        }
	        selectedContentEditableNode = node;
	        hideFakeCaret();
	        return range;
	      };
	      var removeContentEditableSelection = function () {
	        if (selectedContentEditableNode) {
	          selectedContentEditableNode.removeAttribute('data-mce-selected');
	          descendant(Element.fromDom(editor.getBody()), '#' + realSelectionId).each(remove);
	          selectedContentEditableNode = null;
	        }
	        descendant(Element.fromDom(editor.getBody()), '#' + realSelectionId).each(remove);
	        selectedContentEditableNode = null;
	      };
	      var destroy = function () {
	        fakeCaret.destroy();
	        selectedContentEditableNode = null;
	      };
	      var hideFakeCaret = function () {
	        fakeCaret.hide();
	      };
	      if (Env.ceFalse) {
	        registerEvents();
	      }
	      return {
	        showCaret: showCaret,
	        showBlockCaretContainer: showBlockCaretContainer,
	        hideFakeCaret: hideFakeCaret,
	        destroy: destroy
	      };
	    };
	
	    var Quirks = function (editor) {
	      var each = Tools.each;
	      var BACKSPACE = VK.BACKSPACE, DELETE = VK.DELETE, dom = editor.dom, selection = editor.selection, settings = editor.settings, parser = editor.parser;
	      var isGecko = Env.gecko, isIE = Env.ie, isWebKit = Env.webkit;
	      var mceInternalUrlPrefix = 'data:text/mce-internal,';
	      var mceInternalDataType = isIE ? 'Text' : 'URL';
	      var setEditorCommandState = function (cmd, state) {
	        try {
	          editor.getDoc().execCommand(cmd, false, state);
	        } catch (ex) {
	        }
	      };
	      var isDefaultPrevented = function (e) {
	        return e.isDefaultPrevented();
	      };
	      var setMceInternalContent = function (e) {
	        var selectionHtml, internalContent;
	        if (e.dataTransfer) {
	          if (editor.selection.isCollapsed() && e.target.tagName === 'IMG') {
	            selection.select(e.target);
	          }
	          selectionHtml = editor.selection.getContent();
	          if (selectionHtml.length > 0) {
	            internalContent = mceInternalUrlPrefix + escape(editor.id) + ',' + escape(selectionHtml);
	            e.dataTransfer.setData(mceInternalDataType, internalContent);
	          }
	        }
	      };
	      var getMceInternalContent = function (e) {
	        var internalContent;
	        if (e.dataTransfer) {
	          internalContent = e.dataTransfer.getData(mceInternalDataType);
	          if (internalContent && internalContent.indexOf(mceInternalUrlPrefix) >= 0) {
	            internalContent = internalContent.substr(mceInternalUrlPrefix.length).split(',');
	            return {
	              id: unescape(internalContent[0]),
	              html: unescape(internalContent[1])
	            };
	          }
	        }
	        return null;
	      };
	      var insertClipboardContents = function (content, internal) {
	        if (editor.queryCommandSupported('mceInsertClipboardContent')) {
	          editor.execCommand('mceInsertClipboardContent', false, {
	            content: content,
	            internal: internal
	          });
	        } else {
	          editor.execCommand('mceInsertContent', false, content);
	        }
	      };
	      var emptyEditorWhenDeleting = function () {
	        var serializeRng = function (rng) {
	          var body = dom.create('body');
	          var contents = rng.cloneContents();
	          body.appendChild(contents);
	          return selection.serializer.serialize(body, { format: 'html' });
	        };
	        var allContentsSelected = function (rng) {
	          var selection = serializeRng(rng);
	          var allRng = dom.createRng();
	          allRng.selectNode(editor.getBody());
	          var allSelection = serializeRng(allRng);
	          return selection === allSelection;
	        };
	        editor.on('keydown', function (e) {
	          var keyCode = e.keyCode;
	          var isCollapsed, body;
	          if (!isDefaultPrevented(e) && (keyCode === DELETE || keyCode === BACKSPACE)) {
	            isCollapsed = editor.selection.isCollapsed();
	            body = editor.getBody();
	            if (isCollapsed && !dom.isEmpty(body)) {
	              return;
	            }
	            if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {
	              return;
	            }
	            e.preventDefault();
	            editor.setContent('');
	            if (body.firstChild && dom.isBlock(body.firstChild)) {
	              editor.selection.setCursorLocation(body.firstChild, 0);
	            } else {
	              editor.selection.setCursorLocation(body, 0);
	            }
	            editor.nodeChanged();
	          }
	        });
	      };
	      var selectAll = function () {
	        editor.shortcuts.add('meta+a', null, 'SelectAll');
	      };
	      var inputMethodFocus = function () {
	        if (!editor.inline) {
	          dom.bind(editor.getDoc(), 'mousedown mouseup', function (e) {
	            var rng;
	            if (e.target === editor.getDoc().documentElement) {
	              rng = selection.getRng();
	              editor.getBody().focus();
	              if (e.type === 'mousedown') {
	                if (isCaretContainer(rng.startContainer)) {
	                  return;
	                }
	                selection.placeCaretAt(e.clientX, e.clientY);
	              } else {
	                selection.setRng(rng);
	              }
	            }
	          });
	        }
	      };
	      var removeHrOnBackspace = function () {
	        editor.on('keydown', function (e) {
	          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
	            if (!editor.getBody().getElementsByTagName('hr').length) {
	              return;
	            }
	            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
	              var node = selection.getNode();
	              var previousSibling = node.previousSibling;
	              if (node.nodeName === 'HR') {
	                dom.remove(node);
	                e.preventDefault();
	                return;
	              }
	              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'hr') {
	                dom.remove(previousSibling);
	                e.preventDefault();
	              }
	            }
	          }
	        });
	      };
	      var focusBody = function () {
	        if (!domGlobals.Range.prototype.getClientRects) {
	          editor.on('mousedown', function (e) {
	            if (!isDefaultPrevented(e) && e.target.nodeName === 'HTML') {
	              var body_1 = editor.getBody();
	              body_1.blur();
	              Delay.setEditorTimeout(editor, function () {
	                body_1.focus();
	              });
	            }
	          });
	        }
	      };
	      var selectControlElements = function () {
	        editor.on('click', function (e) {
	          var target = e.target;
	          if (/^(IMG|HR)$/.test(target.nodeName) && dom.getContentEditableParent(target) !== 'false') {
	            e.preventDefault();
	            editor.selection.select(target);
	            editor.nodeChanged();
	          }
	          if (target.nodeName === 'A' && dom.hasClass(target, 'mce-item-anchor')) {
	            e.preventDefault();
	            selection.select(target);
	          }
	        });
	      };
	      var removeStylesWhenDeletingAcrossBlockElements = function () {
	        var getAttributeApplyFunction = function () {
	          var template = dom.getAttribs(selection.getStart().cloneNode(false));
	          return function () {
	            var target = selection.getStart();
	            if (target !== editor.getBody()) {
	              dom.setAttrib(target, 'style', null);
	              each(template, function (attr) {
	                target.setAttributeNode(attr.cloneNode(true));
	              });
	            }
	          };
	        };
	        var isSelectionAcrossElements = function () {
	          return !selection.isCollapsed() && dom.getParent(selection.getStart(), dom.isBlock) !== dom.getParent(selection.getEnd(), dom.isBlock);
	        };
	        editor.on('keypress', function (e) {
	          var applyAttributes;
	          if (!isDefaultPrevented(e) && (e.keyCode === 8 || e.keyCode === 46) && isSelectionAcrossElements()) {
	            applyAttributes = getAttributeApplyFunction();
	            editor.getDoc().execCommand('delete', false, null);
	            applyAttributes();
	            e.preventDefault();
	            return false;
	          }
	        });
	        dom.bind(editor.getDoc(), 'cut', function (e) {
	          var applyAttributes;
	          if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {
	            applyAttributes = getAttributeApplyFunction();
	            Delay.setEditorTimeout(editor, function () {
	              applyAttributes();
	            });
	          }
	        });
	      };
	      var disableBackspaceIntoATable = function () {
	        editor.on('keydown', function (e) {
	          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
	            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
	              var previousSibling = selection.getNode().previousSibling;
	              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'table') {
	                e.preventDefault();
	                return false;
	              }
	            }
	          }
	        });
	      };
	      var removeBlockQuoteOnBackSpace = function () {
	        editor.on('keydown', function (e) {
	          var rng, container, offset, root, parent;
	          if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {
	            return;
	          }
	          rng = selection.getRng();
	          container = rng.startContainer;
	          offset = rng.startOffset;
	          root = dom.getRoot();
	          parent = container;
	          if (!rng.collapsed || offset !== 0) {
	            return;
	          }
	          while (parent && parent.parentNode && parent.parentNode.firstChild === parent && parent.parentNode !== root) {
	            parent = parent.parentNode;
	          }
	          if (parent.tagName === 'BLOCKQUOTE') {
	            editor.formatter.toggle('blockquote', null, parent);
	            rng = dom.createRng();
	            rng.setStart(container, 0);
	            rng.setEnd(container, 0);
	            selection.setRng(rng);
	          }
	        });
	      };
	      var setGeckoEditingOptions = function () {
	        var setOpts = function () {
	          setEditorCommandState('StyleWithCSS', false);
	          setEditorCommandState('enableInlineTableEditing', false);
	          if (!settings.object_resizing) {
	            setEditorCommandState('enableObjectResizing', false);
	          }
	        };
	        if (!settings.readonly) {
	          editor.on('BeforeExecCommand mousedown', setOpts);
	        }
	      };
	      var addBrAfterLastLinks = function () {
	        var fixLinks = function () {
	          each(dom.select('a'), function (node) {
	            var parentNode = node.parentNode;
	            var root = dom.getRoot();
	            if (parentNode.lastChild === node) {
	              while (parentNode && !dom.isBlock(parentNode)) {
	                if (parentNode.parentNode.lastChild !== parentNode || parentNode === root) {
	                  return;
	                }
	                parentNode = parentNode.parentNode;
	              }
	              dom.add(parentNode, 'br', { 'data-mce-bogus': 1 });
	            }
	          });
	        };
	        editor.on('SetContent ExecCommand', function (e) {
	          if (e.type === 'setcontent' || e.command === 'mceInsertLink') {
	            fixLinks();
	          }
	        });
	      };
	      var setDefaultBlockType = function () {
	        if (settings.forced_root_block) {
	          editor.on('init', function () {
	            setEditorCommandState('DefaultParagraphSeparator', Settings.getForcedRootBlock(editor));
	          });
	        }
	      };
	      var normalizeSelection = function () {
	        editor.on('keyup focusin mouseup', function (e) {
	          if (!VK.modifierPressed(e)) {
	            selection.normalize();
	          }
	        }, true);
	      };
	      var showBrokenImageIcon = function () {
	        editor.contentStyles.push('img:-moz-broken {' + '-moz-force-broken-image-icon:1;' + 'min-width:24px;' + 'min-height:24px' + '}');
	      };
	      var restoreFocusOnKeyDown = function () {
	        if (!editor.inline) {
	          editor.on('keydown', function () {
	            if (domGlobals.document.activeElement === domGlobals.document.body) {
	              editor.getWin().focus();
	            }
	          });
	        }
	      };
	      var bodyHeight = function () {
	        if (!editor.inline) {
	          editor.contentStyles.push('body {min-height: 150px}');
	          editor.on('click', function (e) {
	            var rng;
	            if (e.target.nodeName === 'HTML') {
	              if (Env.ie > 11) {
	                editor.getBody().focus();
	                return;
	              }
	              rng = editor.selection.getRng();
	              editor.getBody().focus();
	              editor.selection.setRng(rng);
	              editor.selection.normalize();
	              editor.nodeChanged();
	            }
	          });
	        }
	      };
	      var blockCmdArrowNavigation = function () {
	        if (Env.mac) {
	          editor.on('keydown', function (e) {
	            if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode === 37 || e.keyCode === 39)) {
	              e.preventDefault();
	              var selection_1 = editor.selection.getSel();
	              selection_1.modify('move', e.keyCode === 37 ? 'backward' : 'forward', 'lineboundary');
	            }
	          });
	        }
	      };
	      var disableAutoUrlDetect = function () {
	        setEditorCommandState('AutoUrlDetect', false);
	      };
	      var tapLinksAndImages = function () {
	        editor.on('click', function (e) {
	          var elm = e.target;
	          do {
	            if (elm.tagName === 'A') {
	              e.preventDefault();
	              return;
	            }
	          } while (elm = elm.parentNode);
	        });
	        editor.contentStyles.push('.mce-content-body {-webkit-touch-callout: none}');
	      };
	      var blockFormSubmitInsideEditor = function () {
	        editor.on('init', function () {
	          editor.dom.bind(editor.getBody(), 'submit', function (e) {
	            e.preventDefault();
	          });
	        });
	      };
	      var removeAppleInterchangeBrs = function () {
	        parser.addNodeFilter('br', function (nodes) {
	          var i = nodes.length;
	          while (i--) {
	            if (nodes[i].attr('class') === 'Apple-interchange-newline') {
	              nodes[i].remove();
	            }
	          }
	        });
	      };
	      var ieInternalDragAndDrop = function () {
	        editor.on('dragstart', function (e) {
	          setMceInternalContent(e);
	        });
	        editor.on('drop', function (e) {
	          if (!isDefaultPrevented(e)) {
	            var internalContent = getMceInternalContent(e);
	            if (internalContent && internalContent.id !== editor.id) {
	              e.preventDefault();
	              var rng = CaretRangeFromPoint.fromPoint(e.x, e.y, editor.getDoc());
	              selection.setRng(rng);
	              insertClipboardContents(internalContent.html, true);
	            }
	          }
	        });
	      };
	      var refreshContentEditable = function () {
	      };
	      var isHidden = function () {
	        var sel;
	        if (!isGecko || editor.removed) {
	          return false;
	        }
	        sel = editor.selection.getSel();
	        return !sel || !sel.rangeCount || sel.rangeCount === 0;
	      };
	      removeBlockQuoteOnBackSpace();
	      emptyEditorWhenDeleting();
	      if (!Env.windowsPhone) {
	        normalizeSelection();
	      }
	      if (isWebKit) {
	        inputMethodFocus();
	        selectControlElements();
	        setDefaultBlockType();
	        blockFormSubmitInsideEditor();
	        disableBackspaceIntoATable();
	        removeAppleInterchangeBrs();
	        if (Env.iOS) {
	          restoreFocusOnKeyDown();
	          bodyHeight();
	          tapLinksAndImages();
	        } else {
	          selectAll();
	        }
	      }
	      if (Env.ie >= 11) {
	        bodyHeight();
	        disableBackspaceIntoATable();
	      }
	      if (Env.ie) {
	        selectAll();
	        disableAutoUrlDetect();
	        ieInternalDragAndDrop();
	      }
	      if (isGecko) {
	        removeHrOnBackspace();
	        focusBody();
	        removeStylesWhenDeletingAcrossBlockElements();
	        setGeckoEditingOptions();
	        addBrAfterLastLinks();
	        showBrokenImageIcon();
	        blockCmdArrowNavigation();
	        disableBackspaceIntoATable();
	      }
	      return {
	        refreshContentEditable: refreshContentEditable,
	        isHidden: isHidden
	      };
	    };
	
	    var DOM$4 = DOMUtils$1.DOM;
	    var appendStyle = function (editor, text) {
	      var head = Element.fromDom(editor.getDoc().head);
	      var tag = Element.fromTag('style');
	      set(tag, 'type', 'text/css');
	      append(tag, Element.fromText(text));
	      append(head, tag);
	    };
	    var createParser = function (editor) {
	      var parser = DomParser(editor.settings, editor.schema);
	      parser.addAttributeFilter('src,href,style,tabindex', function (nodes, name) {
	        var i = nodes.length, node, value;
	        var dom = editor.dom;
	        var internalName = 'data-mce-' + name;
	        while (i--) {
	          node = nodes[i];
	          value = node.attr(name);
	          if (value && !node.attr(internalName)) {
	            if (value.indexOf('data:') === 0 || value.indexOf('blob:') === 0) {
	              continue;
	            }
	            if (name === 'style') {
	              value = dom.serializeStyle(dom.parseStyle(value), node.name);
	              if (!value.length) {
	                value = null;
	              }
	              node.attr(internalName, value);
	              node.attr(name, value);
	            } else if (name === 'tabindex') {
	              node.attr(internalName, value);
	              node.attr(name, null);
	            } else {
	              node.attr(internalName, editor.convertURL(value, name, node.name));
	            }
	          }
	        }
	      });
	      parser.addNodeFilter('script', function (nodes) {
	        var i = nodes.length, node, type;
	        while (i--) {
	          node = nodes[i];
	          type = node.attr('type') || 'no/type';
	          if (type.indexOf('mce-') !== 0) {
	            node.attr('type', 'mce-' + type);
	          }
	        }
	      });
	      if (editor.settings.preserve_cdata) {
	        parser.addNodeFilter('#cdata', function (nodes) {
	          var i = nodes.length, node;
	          while (i--) {
	            node = nodes[i];
	            node.type = 8;
	            node.name = '#comment';
	            node.value = '[CDATA[' + editor.dom.encode(node.value) + ']]';
	          }
	        });
	      }
	      parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', function (nodes) {
	        var i = nodes.length, node;
	        var nonEmptyElements = editor.schema.getNonEmptyElements();
	        while (i--) {
	          node = nodes[i];
	          if (node.isEmpty(nonEmptyElements) && node.getAll('br').length === 0) {
	            node.append(new Node$1('br', 1)).shortEnded = true;
	          }
	        }
	      });
	      return parser;
	    };
	    var autoFocus = function (editor) {
	      if (editor.settings.auto_focus) {
	        Delay.setEditorTimeout(editor, function () {
	          var focusEditor;
	          if (editor.settings.auto_focus === true) {
	            focusEditor = editor;
	          } else {
	            focusEditor = editor.editorManager.get(editor.settings.auto_focus);
	          }
	          if (!focusEditor.destroyed) {
	            focusEditor.focus();
	          }
	        }, 100);
	      }
	    };
	    var moveSelectionToFirstCaretPosition = function (editor) {
	      var root = editor.dom.getRoot();
	      if (!editor.inline && (!hasAnyRanges(editor) || editor.selection.getStart(true) === root)) {
	        CaretFinder.firstPositionIn(root).each(function (pos) {
	          var node = pos.getNode();
	          var caretPos = NodeType.isTable(node) ? CaretFinder.firstPositionIn(node).getOr(pos) : pos;
	          if (Env.browser.isIE()) {
	            SelectionBookmark.storeNative(editor, caretPos.toRange());
	          } else {
	            editor.selection.setRng(caretPos.toRange());
	          }
	        });
	      }
	    };
	    var initEditor = function (editor) {
	      editor.bindPendingEventDelegates();
	      editor.initialized = true;
	      fireInit(editor);
	      editor.focus(true);
	      moveSelectionToFirstCaretPosition(editor);
	      editor.nodeChanged({ initial: true });
	      editor.execCallback('init_instance_callback', editor);
	      autoFocus(editor);
	    };
	    var getStyleSheetLoader = function (editor) {
	      return editor.inline ? DOM$4.styleSheetLoader : editor.dom.styleSheetLoader;
	    };
	    var initContentBody = function (editor, skipWrite) {
	      var settings = editor.settings;
	      var targetElm = editor.getElement();
	      var doc = editor.getDoc(), body, contentCssText;
	      if (!settings.inline) {
	        editor.getElement().style.visibility = editor.orgVisibility;
	      }
	      if (!skipWrite && !editor.inline) {
	        doc.open();
	        doc.write(editor.iframeHTML);
	        doc.close();
	      }
	      if (editor.inline) {
	        editor.on('remove', function () {
	          var bodyEl = this.getBody();
	          DOM$4.removeClass(bodyEl, 'mce-content-body');
	          DOM$4.removeClass(bodyEl, 'mce-edit-focus');
	          DOM$4.setAttrib(bodyEl, 'contentEditable', null);
	        });
	        DOM$4.addClass(targetElm, 'mce-content-body');
	        editor.contentDocument = doc = domGlobals.document;
	        editor.contentWindow = domGlobals.window;
	        editor.bodyElement = targetElm;
	        editor.contentAreaContainer = targetElm;
	        settings.root_name = targetElm.nodeName.toLowerCase();
	      }
	      body = editor.getBody();
	      body.disabled = true;
	      editor.readonly = !!settings.readonly;
	      if (!editor.readonly) {
	        if (editor.inline && DOM$4.getStyle(body, 'position', true) === 'static') {
	          body.style.position = 'relative';
	        }
	        body.contentEditable = editor.getParam('content_editable_state', true);
	      }
	      body.disabled = false;
	      editor.editorUpload = EditorUpload(editor);
	      editor.schema = Schema(settings);
	      editor.dom = DOMUtils$1(doc, {
	        keep_values: true,
	        url_converter: editor.convertURL,
	        url_converter_scope: editor,
	        hex_colors: settings.force_hex_style_colors,
	        update_styles: true,
	        root_element: editor.inline ? editor.getBody() : null,
	        collect: function () {
	          return editor.inline;
	        },
	        schema: editor.schema,
	        contentCssCors: Settings.shouldUseContentCssCors(editor),
	        referrerPolicy: Settings.getReferrerPolicy(editor),
	        onSetAttrib: function (e) {
	          editor.fire('SetAttrib', e);
	        }
	      });
	      editor.parser = createParser(editor);
	      editor.serializer = Serializer$1(settings, editor);
	      editor.selection = Selection$1(editor.dom, editor.getWin(), editor.serializer, editor);
	      editor.annotator = Annotator(editor);
	      editor.formatter = Formatter(editor);
	      editor.undoManager = UndoManager(editor);
	      editor._nodeChangeDispatcher = new NodeChange(editor);
	      editor._selectionOverrides = SelectionOverrides(editor);
	      TouchEvents.setup(editor);
	      setup$h(editor);
	      setup$i(editor);
	      KeyboardOverrides.setup(editor);
	      ForceBlocks.setup(editor);
	      setup$6(editor);
	      firePreInit(editor);
	      if (!settings.browser_spellcheck && !settings.gecko_spellcheck) {
	        doc.body.spellcheck = false;
	        DOM$4.setAttrib(body, 'spellcheck', 'false');
	      }
	      editor.quirks = Quirks(editor);
	      firePostRender(editor);
	      var directionality = Settings.getDirectionality(editor);
	      if (directionality !== undefined) {
	        body.dir = directionality;
	      }
	      if (settings.protect) {
	        editor.on('BeforeSetContent', function (e) {
	          Tools.each(settings.protect, function (pattern) {
	            e.content = e.content.replace(pattern, function (str) {
	              return '<!--mce:protected ' + escape(str) + '-->';
	            });
	          });
	        });
	      }
	      editor.on('SetContent', function () {
	        editor.addVisual(editor.getBody());
	      });
	      editor.load({
	        initial: true,
	        format: 'html'
	      });
	      editor.startContent = editor.getContent({ format: 'raw' });
	      editor.on('compositionstart compositionend', function (e) {
	        editor.composing = e.type === 'compositionstart';
	      });
	      if (editor.contentStyles.length > 0) {
	        contentCssText = '';
	        Tools.each(editor.contentStyles, function (style) {
	          contentCssText += style + '\r\n';
	        });
	        editor.dom.addStyle(contentCssText);
	      }
	      getStyleSheetLoader(editor).loadAll(editor.contentCSS, function (_) {
	        initEditor(editor);
	      }, function (urls) {
	        initEditor(editor);
	      });
	      if (settings.content_style) {
	        appendStyle(editor, settings.content_style);
	      }
	    };
	    var InitContentBody = { initContentBody: initContentBody };
	
	    var DOM$5 = DOMUtils$1.DOM;
	    var relaxDomain = function (editor, ifr) {
	      if (domGlobals.document.domain !== domGlobals.window.location.hostname && Env.browser.isIE()) {
	        var bodyUuid = Uuid.uuid('mce');
	        editor[bodyUuid] = function () {
	          InitContentBody.initContentBody(editor);
	        };
	        var domainRelaxUrl = 'javascript:(function(){' + 'document.open();document.domain="' + domGlobals.document.domain + '";' + 'var ed = window.parent.tinymce.get("' + editor.id + '");document.write(ed.iframeHTML);' + 'document.close();ed.' + bodyUuid + '(true);})()';
	        DOM$5.setAttrib(ifr, 'src', domainRelaxUrl);
	        return true;
	      }
	      return false;
	    };
	    var createIframeElement = function (id, title, height, customAttrs) {
	      var iframe = Element.fromTag('iframe');
	      setAll(iframe, customAttrs);
	      setAll(iframe, {
	        id: id + '_ifr',
	        frameBorder: '0',
	        allowTransparency: 'true',
	        title: title
	      });
	      add$3(iframe, 'tox-edit-area__iframe');
	      return iframe;
	    };
	    var getIframeHtml = function (editor) {
	      var bodyId, bodyClass, iframeHTML;
	      iframeHTML = Settings.getDocType(editor) + '<html><head>';
	      if (Settings.getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {
	        iframeHTML += '<base href="' + editor.documentBaseURI.getURI() + '" />';
	      }
	      iframeHTML += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
	      bodyId = Settings.getBodyId(editor);
	      bodyClass = Settings.getBodyClass(editor);
	      if (Settings.getContentSecurityPolicy(editor)) {
	        iframeHTML += '<meta http-equiv="Content-Security-Policy" content="' + Settings.getContentSecurityPolicy(editor) + '" />';
	      }
	      iframeHTML += '</head><body id="' + bodyId + '" class="mce-content-body ' + bodyClass + '" data-id="' + editor.id + '"><br></body></html>';
	      return iframeHTML;
	    };
	    var createIframe = function (editor, o) {
	      var title = editor.editorManager.translate('Rich Text Area. Press ALT-0 for help.');
	      var ifr = createIframeElement(editor.id, title, o.height, Settings.getIframeAttrs(editor)).dom();
	      ifr.onload = function () {
	        ifr.onload = null;
	        editor.fire('load');
	      };
	      var isDomainRelaxed = relaxDomain(editor, ifr);
	      editor.contentAreaContainer = o.iframeContainer;
	      editor.iframeElement = ifr;
	      editor.iframeHTML = getIframeHtml(editor);
	      DOM$5.add(o.iframeContainer, ifr);
	      return isDomainRelaxed;
	    };
	    var init$1 = function (editor, boxInfo) {
	      var isDomainRelaxed = createIframe(editor, boxInfo);
	      if (boxInfo.editorContainer) {
	        DOM$5.get(boxInfo.editorContainer).style.display = editor.orgDisplay;
	        editor.hidden = DOM$5.isHidden(boxInfo.editorContainer);
	      }
	      editor.getElement().style.display = 'none';
	      DOM$5.setAttrib(editor.id, 'aria-hidden', 'true');
	      if (!isDomainRelaxed) {
	        InitContentBody.initContentBody(editor);
	      }
	    };
	    var InitIframe = { init: init$1 };
	
	    var DOM$6 = DOMUtils$1.DOM;
	    var initPlugin = function (editor, initializedPlugins, plugin) {
	      var Plugin = PluginManager.get(plugin);
	      var pluginUrl = PluginManager.urls[plugin] || editor.documentBaseUrl.replace(/\/$/, '');
	      plugin = Tools.trim(plugin);
	      if (Plugin && Tools.inArray(initializedPlugins, plugin) === -1) {
	        Tools.each(PluginManager.dependencies(plugin), function (dep) {
	          initPlugin(editor, initializedPlugins, dep);
	        });
	        if (editor.plugins[plugin]) {
	          return;
	        }
	        try {
	          var pluginInstance = new Plugin(editor, pluginUrl, editor.$);
	          editor.plugins[plugin] = pluginInstance;
	          if (pluginInstance.init) {
	            pluginInstance.init(editor, pluginUrl);
	            initializedPlugins.push(plugin);
	          }
	        } catch (e) {
	          ErrorReporter.pluginInitError(editor, plugin, e);
	        }
	      }
	    };
	    var trimLegacyPrefix = function (name) {
	      return name.replace(/^\-/, '');
	    };
	    var initPlugins = function (editor) {
	      var initializedPlugins = [];
	      Tools.each(editor.settings.plugins.split(/[ ,]/), function (name) {
	        initPlugin(editor, initializedPlugins, trimLegacyPrefix(name));
	      });
	    };
	    var initIcons = function (editor) {
	      var iconPackName = Tools.trim(editor.settings.icons);
	      var currentIcons = editor.ui.registry.getAll().icons;
	      var defaultIcons = getAll();
	      var loadIcons = __assign(__assign({}, defaultIcons), IconManager.get(iconPackName).icons);
	      each$1(loadIcons, function (svgData, icon) {
	        if (!has(currentIcons, icon)) {
	          editor.ui.registry.addIcon(icon, svgData);
	        }
	      });
	    };
	    var initTheme = function (editor) {
	      var theme = editor.settings.theme;
	      if (isString(theme)) {
	        editor.settings.theme = trimLegacyPrefix(theme);
	        var Theme = ThemeManager.get(theme);
	        editor.theme = new Theme(editor, ThemeManager.urls[theme]);
	        if (editor.theme.init) {
	          editor.theme.init(editor, ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\/$/, ''), editor.$);
	        }
	      } else {
	        editor.theme = {};
	      }
	    };
	    var renderFromLoadedTheme = function (editor) {
	      return editor.theme.renderUI();
	    };
	    var renderFromThemeFunc = function (editor) {
	      var elm = editor.getElement();
	      var theme = editor.settings.theme;
	      var info = theme(editor, elm);
	      if (info.editorContainer.nodeType) {
	        info.editorContainer.id = info.editorContainer.id || editor.id + '_parent';
	      }
	      if (info.iframeContainer && info.iframeContainer.nodeType) {
	        info.iframeContainer.id = info.iframeContainer.id || editor.id + '_iframecontainer';
	      }
	      info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;
	      return info;
	    };
	    var createThemeFalseResult = function (element) {
	      return {
	        editorContainer: element,
	        iframeContainer: element
	      };
	    };
	    var renderThemeFalseIframe = function (targetElement) {
	      var iframeContainer = DOM$6.create('div');
	      DOM$6.insertAfter(iframeContainer, targetElement);
	      return createThemeFalseResult(iframeContainer);
	    };
	    var renderThemeFalse = function (editor) {
	      var targetElement = editor.getElement();
	      return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);
	    };
	    var renderThemeUi = function (editor) {
	      var elm = editor.getElement();
	      editor.orgDisplay = elm.style.display;
	      if (isString(editor.settings.theme)) {
	        return renderFromLoadedTheme(editor);
	      } else if (isFunction(editor.settings.theme)) {
	        return renderFromThemeFunc(editor);
	      } else {
	        return renderThemeFalse(editor);
	      }
	    };
	    var init$2 = function (editor) {
	      editor.fire('ScriptsLoaded');
	      initIcons(editor);
	      initTheme(editor);
	      initPlugins(editor);
	      var boxInfo = renderThemeUi(editor);
	      editor.editorContainer = boxInfo.editorContainer ? boxInfo.editorContainer : null;
	      appendContentCssFromSettings(editor);
	      if (editor.inline) {
	        return InitContentBody.initContentBody(editor);
	      } else {
	        return InitIframe.init(editor, boxInfo);
	      }
	    };
	    var Init = { init: init$2 };
	
	    var DOM$7 = DOMUtils$1.DOM;
	    var hasSkipLoadPrefix = function (name) {
	      return name.charAt(0) === '-';
	    };
	    var loadLanguage = function (scriptLoader, editor) {
	      var languageCode = Settings.getLanguageCode(editor);
	      var languageUrl = Settings.getLanguageUrl(editor);
	      if (I18n.hasCode(languageCode) === false && languageCode !== 'en') {
	        var url_1 = languageUrl !== '' ? languageUrl : editor.editorManager.baseURL + '/langs/' + languageCode + '.js';
	        scriptLoader.add(url_1, noop, undefined, function () {
	          ErrorReporter.languageLoadError(editor, url_1, languageCode);
	        });
	      }
	    };
	    var loadTheme = function (scriptLoader, editor, suffix, callback) {
	      var settings = editor.settings, theme = settings.theme;
	      if (isString(theme)) {
	        if (!hasSkipLoadPrefix(theme) && !ThemeManager.urls.hasOwnProperty(theme)) {
	          var themeUrl = settings.theme_url;
	          if (themeUrl) {
	            ThemeManager.load(theme, editor.documentBaseURI.toAbsolute(themeUrl));
	          } else {
	            ThemeManager.load(theme, 'themes/' + theme + '/theme' + suffix + '.js');
	          }
	        }
	        scriptLoader.loadQueue(function () {
	          ThemeManager.waitFor(theme, callback);
	        });
	      } else {
	        callback();
	      }
	    };
	    var getIconsUrlMetaFromUrl = function (editor) {
	      return Option.from(Settings.getIconsUrl(editor)).filter(function (url) {
	        return url.length > 0;
	      }).map(function (url) {
	        return {
	          url: url,
	          name: Option.none()
	        };
	      });
	    };
	    var getIconsUrlMetaFromName = function (editor) {
	      return Option.from(Settings.getIconPackName(editor)).filter(function (name) {
	        return name.length > 0 && !IconManager.has(name);
	      }).map(function (name) {
	        return {
	          url: editor.editorManager.baseURL + '/icons/' + name + '/icons.js',
	          name: Option.some(name)
	        };
	      });
	    };
	    var loadIcons = function (scriptLoader, editor) {
	      getIconsUrlMetaFromUrl(editor).orThunk(function () {
	        return getIconsUrlMetaFromName(editor);
	      }).each(function (urlMeta) {
	        scriptLoader.add(urlMeta.url, noop, undefined, function () {
	          ErrorReporter.iconsLoadError(editor, urlMeta.url, urlMeta.name.getOrUndefined());
	        });
	      });
	    };
	    var loadPlugins = function (editor, settings, suffix) {
	      if (isArray(settings.plugins)) {
	        settings.plugins = settings.plugins.join(' ');
	      }
	      Tools.each(settings.external_plugins, function (url, name) {
	        PluginManager.load(name, url, noop, undefined, function () {
	          ErrorReporter.pluginLoadError(editor, url, name);
	        });
	        settings.plugins += ' ' + name;
	      });
	      Tools.each(settings.plugins.split(/[ ,]/), function (plugin) {
	        plugin = Tools.trim(plugin);
	        if (plugin && !PluginManager.urls[plugin]) {
	          if (hasSkipLoadPrefix(plugin)) {
	            plugin = plugin.substr(1, plugin.length);
	            var dependencies = PluginManager.dependencies(plugin);
	            Tools.each(dependencies, function (depPlugin) {
	              var defaultSettings = {
	                prefix: 'plugins/',
	                resource: depPlugin,
	                suffix: '/plugin' + suffix + '.js'
	              };
	              var dep = PluginManager.createUrl(defaultSettings, depPlugin);
	              PluginManager.load(dep.resource, dep, noop, undefined, function () {
	                ErrorReporter.pluginLoadError(editor, dep.prefix + dep.resource + dep.suffix, dep.resource);
	              });
	            });
	          } else {
	            var url_2 = {
	              prefix: 'plugins/',
	              resource: plugin,
	              suffix: '/plugin' + suffix + '.js'
	            };
	            PluginManager.load(plugin, url_2, noop, undefined, function () {
	              ErrorReporter.pluginLoadError(editor, url_2.prefix + url_2.resource + url_2.suffix, plugin);
	            });
	          }
	        }
	      });
	    };
	    var loadScripts = function (editor, suffix) {
	      var scriptLoader = ScriptLoader.ScriptLoader;
	      loadTheme(scriptLoader, editor, suffix, function () {
	        loadLanguage(scriptLoader, editor);
	        loadIcons(scriptLoader, editor);
	        loadPlugins(editor, editor.settings, suffix);
	        scriptLoader.loadQueue(function () {
	          if (!editor.removed) {
	            Init.init(editor);
	          }
	        }, editor, function () {
	          if (!editor.removed) {
	            Init.init(editor);
	          }
	        });
	      });
	    };
	    var render = function (editor) {
	      var settings = editor.settings, id = editor.id;
	      I18n.setCode(Settings.getLanguageCode(editor));
	      var readyHandler = function () {
	        DOM$7.unbind(domGlobals.window, 'ready', readyHandler);
	        editor.render();
	      };
	      if (!EventUtils.Event.domLoaded) {
	        DOM$7.bind(domGlobals.window, 'ready', readyHandler);
	        return;
	      }
	      if (!editor.getElement()) {
	        return;
	      }
	      if (!Env.contentEditable) {
	        return;
	      }
	      if (!settings.inline) {
	        editor.orgVisibility = editor.getElement().style.visibility;
	        editor.getElement().style.visibility = 'hidden';
	      } else {
	        editor.inline = true;
	      }
	      var form = editor.getElement().form || DOM$7.getParent(id, 'form');
	      if (form) {
	        editor.formElement = form;
	        if (settings.hidden_input && !NodeType.isTextareaOrInput(editor.getElement())) {
	          DOM$7.insertAfter(DOM$7.create('input', {
	            type: 'hidden',
	            name: id
	          }), id);
	          editor.hasHiddenInput = true;
	        }
	        editor.formEventDelegate = function (e) {
	          editor.fire(e.type, e);
	        };
	        DOM$7.bind(form, 'submit reset', editor.formEventDelegate);
	        editor.on('reset', function () {
	          editor.resetContent();
	        });
	        if (settings.submit_patch && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {
	          form._mceOldSubmit = form.submit;
	          form.submit = function () {
	            editor.editorManager.triggerSave();
	            editor.setDirty(false);
	            return form._mceOldSubmit(form);
	          };
	        }
	      }
	      editor.windowManager = WindowManager(editor);
	      editor.notificationManager = NotificationManager(editor);
	      if (settings.encoding === 'xml') {
	        editor.on('GetContent', function (e) {
	          if (e.save) {
	            e.content = DOM$7.encode(e.content);
	          }
	        });
	      }
	      if (settings.add_form_submit_trigger) {
	        editor.on('submit', function () {
	          if (editor.initialized) {
	            editor.save();
	          }
	        });
	      }
	      if (settings.add_unload_trigger) {
	        editor._beforeUnload = function () {
	          if (editor.initialized && !editor.destroyed && !editor.isHidden()) {
	            editor.save({
	              format: 'raw',
	              no_events: true,
	              set_dirty: false
	            });
	          }
	        };
	        editor.editorManager.on('BeforeUnload', editor._beforeUnload);
	      }
	      editor.editorManager.add(editor);
	      loadScripts(editor, editor.suffix);
	    };
	    var Render = { render: render };
	
	    var hasOnlyOneChild$1 = function (node) {
	      return node.firstChild && node.firstChild === node.lastChild;
	    };
	    var isPaddingNode = function (node) {
	      return node.name === 'br' || node.value === nbsp;
	    };
	    var isPaddedEmptyBlock = function (schema, node) {
	      var blockElements = schema.getBlockElements();
	      return blockElements[node.name] && hasOnlyOneChild$1(node) && isPaddingNode(node.firstChild);
	    };
	    var isEmptyFragmentElement = function (schema, node) {
	      var nonEmptyElements = schema.getNonEmptyElements();
	      return node && (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node));
	    };
	    var isListFragment = function (schema, fragment) {
	      var firstChild = fragment.firstChild;
	      var lastChild = fragment.lastChild;
	      if (firstChild && firstChild.name === 'meta') {
	        firstChild = firstChild.next;
	      }
	      if (lastChild && lastChild.attr('id') === 'mce_marker') {
	        lastChild = lastChild.prev;
	      }
	      if (isEmptyFragmentElement(schema, lastChild)) {
	        lastChild = lastChild.prev;
	      }
	      if (!firstChild || firstChild !== lastChild) {
	        return false;
	      }
	      return firstChild.name === 'ul' || firstChild.name === 'ol';
	    };
	    var cleanupDomFragment = function (domFragment) {
	      var firstChild = domFragment.firstChild;
	      var lastChild = domFragment.lastChild;
	      if (firstChild && firstChild.nodeName === 'META') {
	        firstChild.parentNode.removeChild(firstChild);
	      }
	      if (lastChild && lastChild.id === 'mce_marker') {
	        lastChild.parentNode.removeChild(lastChild);
	      }
	      return domFragment;
	    };
	    var toDomFragment = function (dom, serializer, fragment) {
	      var html = serializer.serialize(fragment);
	      var domFragment = dom.createFragment(html);
	      return cleanupDomFragment(domFragment);
	    };
	    var listItems$1 = function (elm) {
	      return Tools.grep(elm.childNodes, function (child) {
	        return child.nodeName === 'LI';
	      });
	    };
	    var isPadding = function (node) {
	      return node.data === nbsp || NodeType.isBr(node);
	    };
	    var isListItemPadded = function (node) {
	      return node && node.firstChild && node.firstChild === node.lastChild && isPadding(node.firstChild);
	    };
	    var isEmptyOrPadded = function (elm) {
	      return !elm.firstChild || isListItemPadded(elm);
	    };
	    var trimListItems = function (elms) {
	      return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;
	    };
	    var getParentLi = function (dom, node) {
	      var parentBlock = dom.getParent(node, dom.isBlock);
	      return parentBlock && parentBlock.nodeName === 'LI' ? parentBlock : null;
	    };
	    var isParentBlockLi = function (dom, node) {
	      return !!getParentLi(dom, node);
	    };
	    var getSplit = function (parentNode, rng) {
	      var beforeRng = rng.cloneRange();
	      var afterRng = rng.cloneRange();
	      beforeRng.setStartBefore(parentNode);
	      afterRng.setEndAfter(parentNode);
	      return [
	        beforeRng.cloneContents(),
	        afterRng.cloneContents()
	      ];
	    };
	    var findFirstIn = function (node, rootNode) {
	      var caretPos = CaretPosition$1.before(node);
	      var caretWalker = CaretWalker(rootNode);
	      var newCaretPos = caretWalker.next(caretPos);
	      return newCaretPos ? newCaretPos.toRange() : null;
	    };
	    var findLastOf = function (node, rootNode) {
	      var caretPos = CaretPosition$1.after(node);
	      var caretWalker = CaretWalker(rootNode);
	      var newCaretPos = caretWalker.prev(caretPos);
	      return newCaretPos ? newCaretPos.toRange() : null;
	    };
	    var insertMiddle = function (target, elms, rootNode, rng) {
	      var parts = getSplit(target, rng);
	      var parentElm = target.parentNode;
	      parentElm.insertBefore(parts[0], target);
	      Tools.each(elms, function (li) {
	        parentElm.insertBefore(li, target);
	      });
	      parentElm.insertBefore(parts[1], target);
	      parentElm.removeChild(target);
	      return findLastOf(elms[elms.length - 1], rootNode);
	    };
	    var insertBefore$1 = function (target, elms, rootNode) {
	      var parentElm = target.parentNode;
	      Tools.each(elms, function (elm) {
	        parentElm.insertBefore(elm, target);
	      });
	      return findFirstIn(target, rootNode);
	    };
	    var insertAfter$1 = function (target, elms, rootNode, dom) {
	      dom.insertAfter(elms.reverse(), target);
	      return findLastOf(elms[0], rootNode);
	    };
	    var insertAtCaret = function (serializer, dom, rng, fragment) {
	      var domFragment = toDomFragment(dom, serializer, fragment);
	      var liTarget = getParentLi(dom, rng.startContainer);
	      var liElms = trimListItems(listItems$1(domFragment.firstChild));
	      var BEGINNING = 1, END = 2;
	      var rootNode = dom.getRoot();
	      var isAt = function (location) {
	        var caretPos = CaretPosition$1.fromRangeStart(rng);
	        var caretWalker = CaretWalker(dom.getRoot());
	        var newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);
	        return newPos ? getParentLi(dom, newPos.getNode()) !== liTarget : true;
	      };
	      if (isAt(BEGINNING)) {
	        return insertBefore$1(liTarget, liElms, rootNode);
	      } else if (isAt(END)) {
	        return insertAfter$1(liTarget, liElms, rootNode, dom);
	      }
	      return insertMiddle(liTarget, liElms, rootNode, rng);
	    };
	    var InsertList = {
	      isListFragment: isListFragment,
	      insertAtCaret: insertAtCaret,
	      isParentBlockLi: isParentBlockLi,
	      trimListItems: trimListItems,
	      listItems: listItems$1
	    };
	
	    var isAfterNbsp = function (container, offset) {
	      return NodeType.isText(container) && container.nodeValue[offset - 1] === nbsp;
	    };
	    var trimOrPadLeftRight = function (rng, html) {
	      var container, offset;
	      container = rng.startContainer;
	      offset = rng.startOffset;
	      var hasSiblingText = function (siblingName) {
	        return container[siblingName] && container[siblingName].nodeType === 3;
	      };
	      if (container.nodeType === 3) {
	        if (offset > 0) {
	          html = html.replace(/^&nbsp;/, ' ');
	        } else if (!hasSiblingText('previousSibling')) {
	          html = html.replace(/^ /, '&nbsp;');
	        }
	        if (offset < container.length) {
	          html = html.replace(/&nbsp;(<br>|)$/, ' ');
	        } else if (!hasSiblingText('nextSibling')) {
	          html = html.replace(/(&nbsp;| )(<br>|)$/, '&nbsp;');
	        }
	      }
	      return html;
	    };
	    var trimNbspAfterDeleteAndPadValue = function (rng, value) {
	      var container, offset;
	      container = rng.startContainer;
	      offset = rng.startOffset;
	      if (container.nodeType === 3 && rng.collapsed) {
	        if (container.data[offset] === nbsp) {
	          container.deleteData(offset, 1);
	          if (!/[\u00a0| ]$/.test(value)) {
	            value += ' ';
	          }
	        } else if (container.data[offset - 1] === nbsp) {
	          container.deleteData(offset - 1, 1);
	          if (!/[\u00a0| ]$/.test(value)) {
	            value = ' ' + value;
	          }
	        }
	      }
	      return value;
	    };
	
	    var isTableCell$5 = NodeType.matchNodeNames([
	      'td',
	      'th'
	    ]);
	    var selectionSetContent = function (editor, content) {
	      var rng = editor.selection.getRng();
	      var container = rng.startContainer;
	      var offset = rng.startOffset;
	      if (rng.collapsed && isAfterNbsp(container, offset) && NodeType.isText(container)) {
	        container.insertData(offset - 1, ' ');
	        container.deleteData(offset, 1);
	        rng.setStart(container, offset);
	        rng.setEnd(container, offset);
	        editor.selection.setRng(rng);
	      }
	      editor.selection.setContent(content);
	    };
	    var validInsertion = function (editor, value, parentNode) {
	      if (parentNode.getAttribute('data-mce-bogus') === 'all') {
	        parentNode.parentNode.insertBefore(editor.dom.createFragment(value), parentNode);
	      } else {
	        var node = parentNode.firstChild;
	        var node2 = parentNode.lastChild;
	        if (!node || node === node2 && node.nodeName === 'BR') {
	          editor.dom.setHTML(parentNode, value);
	        } else {
	          selectionSetContent(editor, value);
	        }
	      }
	    };
	    var trimBrsFromTableCell = function (dom, elm) {
	      Option.from(dom.getParent(elm, 'td,th')).map(Element.fromDom).each(PaddingBr.trimBlockTrailingBr);
	    };
	    var reduceInlineTextElements = function (editor, merge) {
	      var textInlineElements = editor.schema.getTextInlineElements();
	      var dom = editor.dom;
	      if (merge) {
	        var root_1 = editor.getBody(), elementUtils_1 = new ElementUtils(dom);
	        Tools.each(dom.select('*[data-mce-fragment]'), function (node) {
	          for (var testNode = node.parentNode; testNode && testNode !== root_1; testNode = testNode.parentNode) {
	            if (textInlineElements[node.nodeName.toLowerCase()] && elementUtils_1.compare(testNode, node)) {
	              dom.remove(node, true);
	            }
	          }
	        });
	      }
	    };
	    var markFragmentElements = function (fragment) {
	      var node = fragment;
	      while (node = node.walk()) {
	        if (node.type === 1) {
	          node.attr('data-mce-fragment', '1');
	        }
	      }
	    };
	    var umarkFragmentElements = function (elm) {
	      Tools.each(elm.getElementsByTagName('*'), function (elm) {
	        elm.removeAttribute('data-mce-fragment');
	      });
	    };
	    var isPartOfFragment = function (node) {
	      return !!node.getAttribute('data-mce-fragment');
	    };
	    var canHaveChildren = function (editor, node) {
	      return node && !editor.schema.getShortEndedElements()[node.nodeName];
	    };
	    var moveSelectionToMarker = function (editor, marker) {
	      var parentEditableFalseElm, parentBlock, nextRng;
	      var dom = editor.dom, selection = editor.selection;
	      var node, node2;
	      var getContentEditableFalseParent = function (node) {
	        var root = editor.getBody();
	        for (; node && node !== root; node = node.parentNode) {
	          if (editor.dom.getContentEditable(node) === 'false') {
	            return node;
	          }
	        }
	        return null;
	      };
	      if (!marker) {
	        return;
	      }
	      editor.selection.scrollIntoView(marker);
	      parentEditableFalseElm = getContentEditableFalseParent(marker);
	      if (parentEditableFalseElm) {
	        dom.remove(marker);
	        selection.select(parentEditableFalseElm);
	        return;
	      }
	      var rng = dom.createRng();
	      node = marker.previousSibling;
	      if (node && node.nodeType === 3) {
	        rng.setStart(node, node.nodeValue.length);
	        if (!Env.ie) {
	          node2 = marker.nextSibling;
	          if (node2 && node2.nodeType === 3) {
	            node.appendData(node2.data);
	            node2.parentNode.removeChild(node2);
	          }
	        }
	      } else {
	        rng.setStartBefore(marker);
	        rng.setEndBefore(marker);
	      }
	      var findNextCaretRng = function (rng) {
	        var caretPos = CaretPosition$1.fromRangeStart(rng);
	        var caretWalker = CaretWalker(editor.getBody());
	        caretPos = caretWalker.next(caretPos);
	        if (caretPos) {
	          return caretPos.toRange();
	        }
	      };
	      parentBlock = dom.getParent(marker, dom.isBlock);
	      dom.remove(marker);
	      if (parentBlock && dom.isEmpty(parentBlock)) {
	        editor.$(parentBlock).empty();
	        rng.setStart(parentBlock, 0);
	        rng.setEnd(parentBlock, 0);
	        if (!isTableCell$5(parentBlock) && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {
	          rng = nextRng;
	          dom.remove(parentBlock);
	        } else {
	          dom.add(parentBlock, dom.create('br', { 'data-mce-bogus': '1' }));
	        }
	      }
	      selection.setRng(rng);
	    };
	    var insertHtmlAtCaret = function (editor, value, details) {
	      var parser, serializer, parentNode, rootNode, fragment, args;
	      var marker, rng, node, bookmarkHtml, merge;
	      var selection = editor.selection, dom = editor.dom;
	      if (/^ | $/.test(value)) {
	        value = trimOrPadLeftRight(selection.getRng(), value);
	      }
	      parser = editor.parser;
	      merge = details.merge;
	      serializer = Serializer({ validate: editor.settings.validate }, editor.schema);
	      bookmarkHtml = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;&#x200B;</span>';
	      args = {
	        content: value,
	        format: 'html',
	        selection: true,
	        paste: details.paste
	      };
	      args = editor.fire('BeforeSetContent', args);
	      if (args.isDefaultPrevented()) {
	        editor.fire('SetContent', {
	          content: args.content,
	          format: 'html',
	          selection: true,
	          paste: details.paste
	        });
	        return;
	      }
	      value = args.content;
	      if (value.indexOf('{$caret}') === -1) {
	        value += '{$caret}';
	      }
	      value = value.replace(/\{\$caret\}/, bookmarkHtml);
	      rng = selection.getRng();
	      var caretElement = rng.startContainer || (rng.parentElement ? rng.parentElement() : null);
	      var body = editor.getBody();
	      if (caretElement === body && selection.isCollapsed()) {
	        if (dom.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom.isEmpty(body.firstChild)) {
	          rng = dom.createRng();
	          rng.setStart(body.firstChild, 0);
	          rng.setEnd(body.firstChild, 0);
	          selection.setRng(rng);
	        }
	      }
	      if (!selection.isCollapsed()) {
	        editor.selection.setRng(RangeNormalizer.normalize(editor.selection.getRng()));
	        editor.getDoc().execCommand('Delete', false, null);
	        value = trimNbspAfterDeleteAndPadValue(editor.selection.getRng(), value);
	      }
	      parentNode = selection.getNode();
	      var parserArgs = {
	        context: parentNode.nodeName.toLowerCase(),
	        data: details.data,
	        insert: true
	      };
	      fragment = parser.parse(value, parserArgs);
	      if (details.paste === true && InsertList.isListFragment(editor.schema, fragment) && InsertList.isParentBlockLi(dom, parentNode)) {
	        rng = InsertList.insertAtCaret(serializer, dom, editor.selection.getRng(), fragment);
	        editor.selection.setRng(rng);
	        editor.fire('SetContent', args);
	        return;
	      }
	      markFragmentElements(fragment);
	      node = fragment.lastChild;
	      if (node.attr('id') === 'mce_marker') {
	        marker = node;
	        for (node = node.prev; node; node = node.walk(true)) {
	          if (node.type === 3 || !dom.isBlock(node.name)) {
	            if (editor.schema.isValidChild(node.parent.name, 'span')) {
	              node.parent.insert(marker, node, node.name === 'br');
	            }
	            break;
	          }
	        }
	      }
	      editor._selectionOverrides.showBlockCaretContainer(parentNode);
	      if (!parserArgs.invalid) {
	        value = serializer.serialize(fragment);
	        validInsertion(editor, value, parentNode);
	      } else {
	        selectionSetContent(editor, bookmarkHtml);
	        parentNode = selection.getNode();
	        rootNode = editor.getBody();
	        if (parentNode.nodeType === 9) {
	          parentNode = node = rootNode;
	        } else {
	          node = parentNode;
	        }
	        while (node !== rootNode) {
	          parentNode = node;
	          node = node.parentNode;
	        }
	        value = parentNode === rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);
	        value = serializer.serialize(parser.parse(value.replace(/<span (id="mce_marker"|id=mce_marker).+?<\/span>/i, function () {
	          return serializer.serialize(fragment);
	        })));
	        if (parentNode === rootNode) {
	          dom.setHTML(rootNode, value);
	        } else {
	          dom.setOuterHTML(parentNode, value);
	        }
	      }
	      reduceInlineTextElements(editor, merge);
	      moveSelectionToMarker(editor, dom.get('mce_marker'));
	      umarkFragmentElements(editor.getBody());
	      trimBrsFromTableCell(editor.dom, editor.selection.getStart());
	      editor.fire('SetContent', args);
	      editor.addVisual();
	    };
	    var processValue = function (value) {
	      var details;
	      if (typeof value !== 'string') {
	        details = Tools.extend({
	          paste: value.paste,
	          data: { paste: value.paste }
	        }, value);
	        return {
	          content: value.content,
	          details: details
	        };
	      }
	      return {
	        content: value,
	        details: {}
	      };
	    };
	    var insertAtCaret$1 = function (editor, value) {
	      var result = processValue(value);
	      insertHtmlAtCaret(editor, result.content, result.details);
	    };
	    var InsertContent = { insertAtCaret: insertAtCaret$1 };
	
	    var nativeCommand = function (editor, command) {
	      editor.getDoc().execCommand(command, false, null);
	    };
	    var deleteCommand = function (editor) {
	      if (Outdent.backspaceDelete(editor, false)) {
	        return;
	      } else if (CefDelete.backspaceDelete(editor, false)) {
	        return;
	      } else if (CefBoundaryDelete.backspaceDelete(editor, false)) {
	        return;
	      } else if (BoundaryDelete.backspaceDelete(editor, false)) {
	        return;
	      } else if (BlockBoundaryDelete.backspaceDelete(editor, false)) {
	        return;
	      } else if (TableDelete.backspaceDelete(editor)) {
	        return;
	      } else if (BlockRangeDelete.backspaceDelete(editor, false)) {
	        return;
	      } else if (InlineFormatDelete.backspaceDelete(editor, false)) {
	        return;
	      } else {
	        nativeCommand(editor, 'Delete');
	        DeleteUtils.paddEmptyBody(editor);
	      }
	    };
	    var forwardDeleteCommand = function (editor) {
	      if (CefDelete.backspaceDelete(editor, true)) {
	        return;
	      } else if (CefBoundaryDelete.backspaceDelete(editor, true)) {
	        return;
	      } else if (BoundaryDelete.backspaceDelete(editor, true)) {
	        return;
	      } else if (BlockBoundaryDelete.backspaceDelete(editor, true)) {
	        return;
	      } else if (TableDelete.backspaceDelete(editor)) {
	        return;
	      } else if (BlockRangeDelete.backspaceDelete(editor, true)) {
	        return;
	      } else if (InlineFormatDelete.backspaceDelete(editor, true)) {
	        return;
	      } else {
	        nativeCommand(editor, 'ForwardDelete');
	      }
	    };
	    var DeleteCommands = {
	      deleteCommand: deleteCommand,
	      forwardDeleteCommand: forwardDeleteCommand
	    };
	
	    var ancestor$3 = function (scope, transform, isRoot) {
	      var element = scope.dom();
	      var stop = isFunction(isRoot) ? isRoot : constant(false);
	      while (element.parentNode) {
	        element = element.parentNode;
	        var el = Element.fromDom(element);
	        var transformed = transform(el);
	        if (transformed.isSome()) {
	          return transformed;
	        } else if (stop(el)) {
	          break;
	        }
	      }
	      return Option.none();
	    };
	    var closest$2 = function (scope, transform, isRoot) {
	      var current = transform(scope);
	      return current.orThunk(function () {
	        return isRoot(scope) ? Option.none() : ancestor$3(scope, transform, isRoot);
	      });
	    };
	
	    var legacyPropNames = {
	      'font-size': 'size',
	      'font-family': 'face'
	    };
	    var getSpecifiedFontProp = function (propName, rootElm, elm) {
	      var getProperty = function (elm) {
	        return getRaw(elm, propName).orThunk(function () {
	          if (name(elm) === 'font') {
	            return get(legacyPropNames, propName).bind(function (legacyPropName) {
	              return getOpt(elm, legacyPropName);
	            });
	          } else {
	            return Option.none();
	          }
	        });
	      };
	      var isRoot = function (elm) {
	        return eq(Element.fromDom(rootElm), elm);
	      };
	      return closest$2(Element.fromDom(elm), function (elm) {
	        return getProperty(elm);
	      }, isRoot);
	    };
	    var round$1 = function (number, precision) {
	      var factor = Math.pow(10, precision);
	      return Math.round(number * factor) / factor;
	    };
	    var toPt = function (fontSize, precision) {
	      if (/[0-9.]+px$/.test(fontSize)) {
	        return round$1(parseInt(fontSize, 10) * 72 / 96, precision || 0) + 'pt';
	      }
	      return fontSize;
	    };
	    var normalizeFontFamily = function (fontFamily) {
	      return fontFamily.replace(/[\'\"\\]/g, '').replace(/,\s+/g, ',');
	    };
	    var getComputedFontProp = function (propName, elm) {
	      return Option.from(DOMUtils$1.DOM.getStyle(elm, propName, true));
	    };
	    var getFontProp = function (propName) {
	      return function (rootElm, elm) {
	        return Option.from(elm).map(Element.fromDom).filter(isElement).bind(function (element) {
	          return getSpecifiedFontProp(propName, rootElm, element.dom()).or(getComputedFontProp(propName, element.dom()));
	        }).getOr('');
	      };
	    };
	    var FontInfo = {
	      getFontSize: getFontProp('font-size'),
	      getFontFamily: compose(normalizeFontFamily, getFontProp('font-family')),
	      toPt: toPt
	    };
	
	    var findFirstCaretElement = function (editor) {
	      return CaretFinder.firstPositionIn(editor.getBody()).map(function (caret) {
	        var container = caret.container();
	        return NodeType.isText(container) ? container.parentNode : container;
	      });
	    };
	    var isRangeAtStartOfNode = function (rng, root) {
	      return rng.startContainer === root && rng.startOffset === 0;
	    };
	    var getCaretElement = function (editor) {
	      return Option.from(editor.selection.getRng()).bind(function (rng) {
	        var root = editor.getBody();
	        return isRangeAtStartOfNode(rng, root) ? Option.none() : Option.from(editor.selection.getStart(true));
	      });
	    };
	    var fromFontSizeNumber = function (editor, value) {
	      if (/^[0-9\.]+$/.test(value)) {
	        var fontSizeNumber = parseInt(value, 10);
	        if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {
	          var fontSizes = Settings.getFontStyleValues(editor);
	          var fontClasses = Settings.getFontSizeClasses(editor);
	          if (fontClasses) {
	            return fontClasses[fontSizeNumber - 1] || value;
	          } else {
	            return fontSizes[fontSizeNumber - 1] || value;
	          }
	        } else {
	          return value;
	        }
	      } else {
	        return value;
	      }
	    };
	    var normalizeFontNames = function (font) {
	      var fonts = font.split(/\s*,\s*/);
	      return map(fonts, function (font) {
	        if (font.indexOf(' ') !== -1 && !(startsWith(font, '"') || startsWith(font, '\''))) {
	          return '\'' + font + '\'';
	        } else {
	          return font;
	        }
	      }).join(',');
	    };
	    var fontNameAction = function (editor, value) {
	      var font = fromFontSizeNumber(editor, value);
	      editor.formatter.toggle('fontname', { value: normalizeFontNames(font) });
	      editor.nodeChanged();
	    };
	    var fontNameQuery = function (editor) {
	      return getCaretElement(editor).fold(function () {
	        return findFirstCaretElement(editor).map(function (caretElement) {
	          return FontInfo.getFontFamily(editor.getBody(), caretElement);
	        }).getOr('');
	      }, function (caretElement) {
	        return FontInfo.getFontFamily(editor.getBody(), caretElement);
	      });
	    };
	    var fontSizeAction = function (editor, value) {
	      editor.formatter.toggle('fontsize', { value: fromFontSizeNumber(editor, value) });
	      editor.nodeChanged();
	    };
	    var fontSizeQuery = function (editor) {
	      return getCaretElement(editor).fold(function () {
	        return findFirstCaretElement(editor).map(function (caretElement) {
	          return FontInfo.getFontSize(editor.getBody(), caretElement);
	        }).getOr('');
	      }, function (caretElement) {
	        return FontInfo.getFontSize(editor.getBody(), caretElement);
	      });
	    };
	
	    var each$f = Tools.each;
	    var map$3 = Tools.map, inArray$2 = Tools.inArray;
	    var EditorCommands = function () {
	      function EditorCommands(editor) {
	        this.commands = {
	          state: {},
	          exec: {},
	          value: {}
	        };
	        this.editor = editor;
	        this.setupCommands(editor);
	      }
	      EditorCommands.prototype.execCommand = function (command, ui, value, args) {
	        var func, customCommand, state = false;
	        var self = this;
	        if (self.editor.removed) {
	          return;
	        }
	        if (!/^(mceAddUndoLevel|mceEndUndoLevel|mceBeginUndoLevel|mceRepaint)$/.test(command) && (!args || !args.skip_focus)) {
	          self.editor.focus();
	        } else {
	          SelectionBookmark.restore(self.editor);
	        }
	        args = self.editor.fire('BeforeExecCommand', {
	          command: command,
	          ui: ui,
	          value: value
	        });
	        if (args.isDefaultPrevented()) {
	          return false;
	        }
	        customCommand = command.toLowerCase();
	        if (func = self.commands.exec[customCommand]) {
	          func(customCommand, ui, value);
	          self.editor.fire('ExecCommand', {
	            command: command,
	            ui: ui,
	            value: value
	          });
	          return true;
	        }
	        each$f(this.editor.plugins, function (p) {
	          if (p.execCommand && p.execCommand(command, ui, value)) {
	            self.editor.fire('ExecCommand', {
	              command: command,
	              ui: ui,
	              value: value
	            });
	            state = true;
	            return false;
	          }
	        });
	        if (state) {
	          return state;
	        }
	        if (self.editor.theme && self.editor.theme.execCommand && self.editor.theme.execCommand(command, ui, value)) {
	          self.editor.fire('ExecCommand', {
	            command: command,
	            ui: ui,
	            value: value
	          });
	          return true;
	        }
	        try {
	          state = self.editor.getDoc().execCommand(command, ui, value);
	        } catch (ex) {
	        }
	        if (state) {
	          self.editor.fire('ExecCommand', {
	            command: command,
	            ui: ui,
	            value: value
	          });
	          return true;
	        }
	        return false;
	      };
	      EditorCommands.prototype.queryCommandState = function (command) {
	        var func;
	        if (this.editor.quirks.isHidden() || this.editor.removed) {
	          return;
	        }
	        command = command.toLowerCase();
	        if (func = this.commands.state[command]) {
	          return func(command);
	        }
	        try {
	          return this.editor.getDoc().queryCommandState(command);
	        } catch (ex) {
	        }
	        return false;
	      };
	      EditorCommands.prototype.queryCommandValue = function (command) {
	        var func;
	        if (this.editor.quirks.isHidden() || this.editor.removed) {
	          return;
	        }
	        command = command.toLowerCase();
	        if (func = this.commands.value[command]) {
	          return func(command);
	        }
	        try {
	          return this.editor.getDoc().queryCommandValue(command);
	        } catch (ex) {
	        }
	      };
	      EditorCommands.prototype.addCommands = function (commandList, type) {
	        var self = this;
	        type = type || 'exec';
	        each$f(commandList, function (callback, command) {
	          each$f(command.toLowerCase().split(','), function (command) {
	            self.commands[type][command] = callback;
	          });
	        });
	      };
	      EditorCommands.prototype.addCommand = function (command, callback, scope) {
	        var _this = this;
	        command = command.toLowerCase();
	        this.commands.exec[command] = function (command, ui, value, args) {
	          return callback.call(scope || _this.editor, ui, value, args);
	        };
	      };
	      EditorCommands.prototype.queryCommandSupported = function (command) {
	        command = command.toLowerCase();
	        if (this.commands.exec[command]) {
	          return true;
	        }
	        try {
	          return this.editor.getDoc().queryCommandSupported(command);
	        } catch (ex) {
	        }
	        return false;
	      };
	      EditorCommands.prototype.addQueryStateHandler = function (command, callback, scope) {
	        var _this = this;
	        command = command.toLowerCase();
	        this.commands.state[command] = function () {
	          return callback.call(scope || _this.editor);
	        };
	      };
	      EditorCommands.prototype.addQueryValueHandler = function (command, callback, scope) {
	        var _this = this;
	        command = command.toLowerCase();
	        this.commands.value[command] = function () {
	          return callback.call(scope || _this.editor);
	        };
	      };
	      EditorCommands.prototype.hasCustomCommand = function (command) {
	        command = command.toLowerCase();
	        return !!this.commands.exec[command];
	      };
	      EditorCommands.prototype.execNativeCommand = function (command, ui, value) {
	        if (ui === undefined) {
	          ui = false;
	        }
	        if (value === undefined) {
	          value = null;
	        }
	        return this.editor.getDoc().execCommand(command, ui, value);
	      };
	      EditorCommands.prototype.isFormatMatch = function (name) {
	        return this.editor.formatter.match(name);
	      };
	      EditorCommands.prototype.toggleFormat = function (name, value) {
	        this.editor.formatter.toggle(name, value ? { value: value } : undefined);
	        this.editor.nodeChanged();
	      };
	      EditorCommands.prototype.storeSelection = function (type) {
	        this.selectionBookmark = this.editor.selection.getBookmark(type);
	      };
	      EditorCommands.prototype.restoreSelection = function () {
	        this.editor.selection.moveToBookmark(this.selectionBookmark);
	      };
	      EditorCommands.prototype.setupCommands = function (editor) {
	        var self = this;
	        this.addCommands({
	          'mceResetDesignMode,mceBeginUndoLevel': function () {
	          },
	          'mceEndUndoLevel,mceAddUndoLevel': function () {
	            editor.undoManager.add();
	          },
	          'Cut,Copy,Paste': function (command) {
	            var doc = editor.getDoc();
	            var failed;
	            try {
	              self.execNativeCommand(command);
	            } catch (ex) {
	              failed = true;
	            }
	            if (command === 'paste' && !doc.queryCommandEnabled(command)) {
	              failed = true;
	            }
	            if (failed || !doc.queryCommandSupported(command)) {
	              var msg = editor.translate('Your browser doesn\'t support direct access to the clipboard. ' + 'Please use the Ctrl+X/C/V keyboard shortcuts instead.');
	              if (Env.mac) {
	                msg = msg.replace(/Ctrl\+/g, '\u2318+');
	              }
	              editor.notificationManager.open({
	                text: msg,
	                type: 'error'
	              });
	            }
	          },
	          'unlink': function () {
	            if (editor.selection.isCollapsed()) {
	              var elm = editor.dom.getParent(editor.selection.getStart(), 'a');
	              if (elm) {
	                editor.dom.remove(elm, true);
	              }
	              return;
	            }
	            editor.formatter.remove('link');
	          },
	          'JustifyLeft,JustifyCenter,JustifyRight,JustifyFull,JustifyNone': function (command) {
	            var align = command.substring(7);
	            if (align === 'full') {
	              align = 'justify';
	            }
	            each$f('left,center,right,justify'.split(','), function (name) {
	              if (align !== name) {
	                editor.formatter.remove('align' + name);
	              }
	            });
	            if (align !== 'none') {
	              self.toggleFormat('align' + align);
	            }
	          },
	          'InsertUnorderedList,InsertOrderedList': function (command) {
	            var listElm, listParent;
	            self.execNativeCommand(command);
	            listElm = editor.dom.getParent(editor.selection.getNode(), 'ol,ul');
	            if (listElm) {
	              listParent = listElm.parentNode;
	              if (/^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {
	                self.storeSelection();
	                editor.dom.split(listParent, listElm);
	                self.restoreSelection();
	              }
	            }
	          },
	          'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': function (command) {
	            self.toggleFormat(command);
	          },
	          'ForeColor,HiliteColor': function (command, ui, value) {
	            self.toggleFormat(command, value);
	          },
	          'FontName': function (command, ui, value) {
	            fontNameAction(editor, value);
	          },
	          'FontSize': function (command, ui, value) {
	            fontSizeAction(editor, value);
	          },
	          'RemoveFormat': function (command) {
	            editor.formatter.remove(command);
	          },
	          'mceBlockQuote': function () {
	            self.toggleFormat('blockquote');
	          },
	          'FormatBlock': function (command, ui, value) {
	            return self.toggleFormat(value || 'p');
	          },
	          'mceCleanup': function () {
	            var bookmark = editor.selection.getBookmark();
	            editor.setContent(editor.getContent());
	            editor.selection.moveToBookmark(bookmark);
	          },
	          'mceRemoveNode': function (command, ui, value) {
	            var node = value || editor.selection.getNode();
	            if (node !== editor.getBody()) {
	              self.storeSelection();
	              editor.dom.remove(node, true);
	              self.restoreSelection();
	            }
	          },
	          'mceSelectNodeDepth': function (command, ui, value) {
	            var counter = 0;
	            editor.dom.getParent(editor.selection.getNode(), function (node) {
	              if (node.nodeType === 1 && counter++ === value) {
	                editor.selection.select(node);
	                return false;
	              }
	            }, editor.getBody());
	          },
	          'mceSelectNode': function (command, ui, value) {
	            editor.selection.select(value);
	          },
	          'mceInsertContent': function (command, ui, value) {
	            InsertContent.insertAtCaret(editor, value);
	          },
	          'mceInsertRawHTML': function (command, ui, value) {
	            editor.selection.setContent('tiny_mce_marker');
	            var content = editor.getContent();
	            editor.setContent(content.replace(/tiny_mce_marker/g, function () {
	              return value;
	            }));
	          },
	          'mceInsertNewLine': function (command, ui, value) {
	            InsertNewLine.insert(editor, value);
	          },
	          'mceToggleFormat': function (command, ui, value) {
	            self.toggleFormat(value);
	          },
	          'mceSetContent': function (command, ui, value) {
	            editor.setContent(value);
	          },
	          'Indent,Outdent': function (command) {
	            handle(editor, command);
	          },
	          'mceRepaint': function () {
	          },
	          'InsertHorizontalRule': function () {
	            editor.execCommand('mceInsertContent', false, '<hr />');
	          },
	          'mceToggleVisualAid': function () {
	            editor.hasVisual = !editor.hasVisual;
	            editor.addVisual();
	          },
	          'mceReplaceContent': function (command, ui, value) {
	            editor.execCommand('mceInsertContent', false, value.replace(/\{\$selection\}/g, editor.selection.getContent({ format: 'text' })));
	          },
	          'mceInsertLink': function (command, ui, value) {
	            var anchor;
	            if (typeof value === 'string') {
	              value = { href: value };
	            }
	            anchor = editor.dom.getParent(editor.selection.getNode(), 'a');
	            value.href = value.href.replace(/ /g, '%20');
	            if (!anchor || !value.href) {
	              editor.formatter.remove('link');
	            }
	            if (value.href) {
	              editor.formatter.apply('link', value, anchor);
	            }
	          },
	          'selectAll': function () {
	            var editingHost = editor.dom.getParent(editor.selection.getStart(), NodeType.isContentEditableTrue);
	            if (editingHost) {
	              var rng = editor.dom.createRng();
	              rng.selectNodeContents(editingHost);
	              editor.selection.setRng(rng);
	            }
	          },
	          'delete': function () {
	            DeleteCommands.deleteCommand(editor);
	          },
	          'forwardDelete': function () {
	            DeleteCommands.forwardDeleteCommand(editor);
	          },
	          'mceNewDocument': function () {
	            editor.setContent('');
	          },
	          'InsertLineBreak': function (command, ui, value) {
	            InsertBr.insert(editor, value);
	            return true;
	          }
	        });
	        var alignStates = function (name) {
	          return function () {
	            var nodes = editor.selection.isCollapsed() ? [editor.dom.getParent(editor.selection.getNode(), editor.dom.isBlock)] : editor.selection.getSelectedBlocks();
	            var matches = map$3(nodes, function (node) {
	              return !!editor.formatter.matchNode(node, name);
	            });
	            return inArray$2(matches, true) !== -1;
	          };
	        };
	        self.addCommands({
	          'JustifyLeft': alignStates('alignleft'),
	          'JustifyCenter': alignStates('aligncenter'),
	          'JustifyRight': alignStates('alignright'),
	          'JustifyFull': alignStates('alignjustify'),
	          'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': function (command) {
	            return self.isFormatMatch(command);
	          },
	          'mceBlockQuote': function () {
	            return self.isFormatMatch('blockquote');
	          },
	          'Outdent': function () {
	            return canOutdent(editor);
	          },
	          'InsertUnorderedList,InsertOrderedList': function (command) {
	            var list = editor.dom.getParent(editor.selection.getNode(), 'ul,ol');
	            return list && (command === 'insertunorderedlist' && list.tagName === 'UL' || command === 'insertorderedlist' && list.tagName === 'OL');
	          }
	        }, 'state');
	        self.addCommands({
	          Undo: function () {
	            editor.undoManager.undo();
	          },
	          Redo: function () {
	            editor.undoManager.redo();
	          }
	        });
	        self.addQueryValueHandler('FontName', function () {
	          return fontNameQuery(editor);
	        }, this);
	        self.addQueryValueHandler('FontSize', function () {
	          return fontSizeQuery(editor);
	        }, this);
	      };
	      return EditorCommands;
	    }();
	
	    var nativeEvents = Tools.makeMap('focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange ' + 'mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover ' + 'draggesture dragdrop drop drag submit ' + 'compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel', ' ');
	    var EventDispatcher = function () {
	      function EventDispatcher(settings) {
	        this.bindings = {};
	        this.settings = settings || {};
	        this.scope = this.settings.scope || this;
	        this.toggleEvent = this.settings.toggleEvent || never;
	      }
	      EventDispatcher.isNative = function (name) {
	        return !!nativeEvents[name.toLowerCase()];
	      };
	      EventDispatcher.prototype.fire = function (name, args) {
	        var handlers, i, l, callback;
	        name = name.toLowerCase();
	        args = args || {};
	        args.type = name;
	        if (!args.target) {
	          args.target = this.scope;
	        }
	        if (!args.preventDefault) {
	          args.preventDefault = function () {
	            args.isDefaultPrevented = always;
	          };
	          args.stopPropagation = function () {
	            args.isPropagationStopped = always;
	          };
	          args.stopImmediatePropagation = function () {
	            args.isImmediatePropagationStopped = always;
	          };
	          args.isDefaultPrevented = never;
	          args.isPropagationStopped = never;
	          args.isImmediatePropagationStopped = never;
	        }
	        if (this.settings.beforeFire) {
	          this.settings.beforeFire(args);
	        }
	        handlers = this.bindings[name];
	        if (handlers) {
	          for (i = 0, l = handlers.length; i < l; i++) {
	            callback = handlers[i];
	            if (callback.once) {
	              this.off(name, callback.func);
	            }
	            if (args.isImmediatePropagationStopped()) {
	              args.stopPropagation();
	              return args;
	            }
	            if (callback.func.call(this.scope, args) === false) {
	              args.preventDefault();
	              return args;
	            }
	          }
	        }
	        return args;
	      };
	      EventDispatcher.prototype.on = function (name, callback, prepend, extra) {
	        var handlers, names, i;
	        if (callback === false) {
	          callback = never;
	        }
	        if (callback) {
	          var wrappedCallback = { func: callback };
	          if (extra) {
	            Tools.extend(wrappedCallback, extra);
	          }
	          names = name.toLowerCase().split(' ');
	          i = names.length;
	          while (i--) {
	            name = names[i];
	            handlers = this.bindings[name];
	            if (!handlers) {
	              handlers = this.bindings[name] = [];
	              this.toggleEvent(name, true);
	            }
	            if (prepend) {
	              handlers.unshift(wrappedCallback);
	            } else {
	              handlers.push(wrappedCallback);
	            }
	          }
	        }
	        return this;
	      };
	      EventDispatcher.prototype.off = function (name, callback) {
	        var i, handlers, bindingName, names, hi;
	        if (name) {
	          names = name.toLowerCase().split(' ');
	          i = names.length;
	          while (i--) {
	            name = names[i];
	            handlers = this.bindings[name];
	            if (!name) {
	              for (bindingName in this.bindings) {
	                this.toggleEvent(bindingName, false);
	                delete this.bindings[bindingName];
	              }
	              return this;
	            }
	            if (handlers) {
	              if (!callback) {
	                handlers.length = 0;
	              } else {
	                hi = handlers.length;
	                while (hi--) {
	                  if (handlers[hi].func === callback) {
	                    handlers = handlers.slice(0, hi).concat(handlers.slice(hi + 1));
	                    this.bindings[name] = handlers;
	                  }
	                }
	              }
	              if (!handlers.length) {
	                this.toggleEvent(name, false);
	                delete this.bindings[name];
	              }
	            }
	          }
	        } else {
	          for (name in this.bindings) {
	            this.toggleEvent(name, false);
	          }
	          this.bindings = {};
	        }
	        return this;
	      };
	      EventDispatcher.prototype.once = function (name, callback, prepend) {
	        return this.on(name, callback, prepend, { once: true });
	      };
	      EventDispatcher.prototype.has = function (name) {
	        name = name.toLowerCase();
	        return !(!this.bindings[name] || this.bindings[name].length === 0);
	      };
	      return EventDispatcher;
	    }();
	
	    var getEventDispatcher = function (obj) {
	      if (!obj._eventDispatcher) {
	        obj._eventDispatcher = new EventDispatcher({
	          scope: obj,
	          toggleEvent: function (name, state) {
	            if (EventDispatcher.isNative(name) && obj.toggleNativeEvent) {
	              obj.toggleNativeEvent(name, state);
	            }
	          }
	        });
	      }
	      return obj._eventDispatcher;
	    };
	    var Observable = {
	      fire: function (name, args, bubble) {
	        var self = this;
	        if (self.removed && name !== 'remove' && name !== 'detach') {
	          return args;
	        }
	        var dispatcherArgs = getEventDispatcher(self).fire(name, args);
	        if (bubble !== false && self.parent) {
	          var parent_1 = self.parent();
	          while (parent_1 && !dispatcherArgs.isPropagationStopped()) {
	            parent_1.fire(name, dispatcherArgs, false);
	            parent_1 = parent_1.parent();
	          }
	        }
	        return dispatcherArgs;
	      },
	      on: function (name, callback, prepend) {
	        return getEventDispatcher(this).on(name, callback, prepend);
	      },
	      off: function (name, callback) {
	        return getEventDispatcher(this).off(name, callback);
	      },
	      once: function (name, callback) {
	        return getEventDispatcher(this).once(name, callback);
	      },
	      hasEventListeners: function (name) {
	        return getEventDispatcher(this).has(name);
	      }
	    };
	
	    var internalContentEditableAttr = 'data-mce-contenteditable';
	    var toggleClass = function (elm, cls, state) {
	      if (has$2(elm, cls) && state === false) {
	        remove$4(elm, cls);
	      } else if (state) {
	        add$3(elm, cls);
	      }
	    };
	    var setEditorCommandState = function (editor, cmd, state) {
	      try {
	        editor.getDoc().execCommand(cmd, false, state);
	      } catch (ex) {
	      }
	    };
	    var setContentEditable = function (elm, state) {
	      elm.dom().contentEditable = state ? 'true' : 'false';
	    };
	    var switchOffContentEditableTrue = function (elm) {
	      each(descendants$1(elm, '*[contenteditable="true"]'), function (elm) {
	        set(elm, internalContentEditableAttr, 'true');
	        setContentEditable(elm, false);
	      });
	    };
	    var switchOnContentEditableTrue = function (elm) {
	      each(descendants$1(elm, '*[' + internalContentEditableAttr + '="true"]'), function (elm) {
	        remove$1(elm, internalContentEditableAttr);
	        setContentEditable(elm, true);
	      });
	    };
	    var removeFakeSelection = function (editor) {
	      Option.from(editor.selection.getNode()).each(function (elm) {
	        elm.removeAttribute('data-mce-selected');
	      });
	    };
	    var restoreFakeSelection = function (editor) {
	      editor.selection.setRng(editor.selection.getRng());
	    };
	    var toggleReadOnly = function (editor, state) {
	      var body = Element.fromDom(editor.getBody());
	      toggleClass(body, 'mce-content-readonly', state);
	      if (state) {
	        editor.selection.controlSelection.hideResizeRect();
	        editor._selectionOverrides.hideFakeCaret();
	        removeFakeSelection(editor);
	        editor.readonly = true;
	        setContentEditable(body, false);
	        switchOffContentEditableTrue(body);
	      } else {
	        editor.readonly = false;
	        setContentEditable(body, true);
	        switchOnContentEditableTrue(body);
	        setEditorCommandState(editor, 'StyleWithCSS', false);
	        setEditorCommandState(editor, 'enableInlineTableEditing', false);
	        setEditorCommandState(editor, 'enableObjectResizing', false);
	        if (EditorFocus.hasEditorOrUiFocus(editor)) {
	          editor.focus();
	        }
	        restoreFakeSelection(editor);
	        editor.nodeChanged();
	      }
	    };
	    var isReadOnly = function (editor) {
	      return editor.readonly;
	    };
	    var registerFilters = function (editor) {
	      editor.parser.addAttributeFilter('contenteditable', function (nodes) {
	        if (isReadOnly(editor)) {
	          each(nodes, function (node) {
	            node.attr(internalContentEditableAttr, node.attr('contenteditable'));
	            node.attr('contenteditable', 'false');
	          });
	        }
	      });
	      editor.serializer.addAttributeFilter(internalContentEditableAttr, function (nodes) {
	        if (isReadOnly(editor)) {
	          each(nodes, function (node) {
	            node.attr('contenteditable', node.attr(internalContentEditableAttr));
	          });
	        }
	      });
	      editor.serializer.addTempAttr(internalContentEditableAttr);
	    };
	    var registerReadOnlyContentFilters = function (editor) {
	      if (editor.serializer) {
	        registerFilters(editor);
	      } else {
	        editor.on('PreInit', function () {
	          registerFilters(editor);
	        });
	      }
	    };
	    var isClickEvent = function (e) {
	      return e.type === 'click';
	    };
	    var isInAnchor = function (editor, target) {
	      return editor.dom.getParent(target, 'a') !== null;
	    };
	    var preventReadOnlyEvents = function (editor, e) {
	      var target = e.target;
	      if (isClickEvent(e) && !VK.metaKeyPressed(e) && isInAnchor(editor, target)) {
	        e.preventDefault();
	      }
	    };
	    var registerReadOnlySelectionBlockers = function (editor) {
	      editor.on('ShowCaret', function (e) {
	        if (isReadOnly(editor)) {
	          e.preventDefault();
	        }
	      });
	      editor.on('ObjectSelected', function (e) {
	        if (isReadOnly(editor)) {
	          e.preventDefault();
	        }
	      });
	    };
	
	    var DOM$8 = DOMUtils$1.DOM;
	    var customEventRootDelegates;
	    var getEventTarget = function (editor, eventName) {
	      if (eventName === 'selectionchange') {
	        return editor.getDoc();
	      }
	      if (!editor.inline && /^mouse|touch|click|contextmenu|drop|dragover|dragend/.test(eventName)) {
	        return editor.getDoc().documentElement;
	      }
	      if (editor.settings.event_root) {
	        if (!editor.eventRoot) {
	          editor.eventRoot = DOM$8.select(editor.settings.event_root)[0];
	        }
	        return editor.eventRoot;
	      }
	      return editor.getBody();
	    };
	    var isListening = function (editor) {
	      return !editor.hidden && !isReadOnly(editor);
	    };
	    var fireEvent = function (editor, eventName, e) {
	      if (isListening(editor)) {
	        editor.fire(eventName, e);
	      } else if (isReadOnly(editor)) {
	        preventReadOnlyEvents(editor, e);
	      }
	    };
	    var bindEventDelegate = function (editor, eventName) {
	      var eventRootElm, delegate;
	      if (!editor.delegates) {
	        editor.delegates = {};
	      }
	      if (editor.delegates[eventName] || editor.removed) {
	        return;
	      }
	      eventRootElm = getEventTarget(editor, eventName);
	      if (editor.settings.event_root) {
	        if (!customEventRootDelegates) {
	          customEventRootDelegates = {};
	          editor.editorManager.on('removeEditor', function () {
	            var name;
	            if (!editor.editorManager.activeEditor) {
	              if (customEventRootDelegates) {
	                for (name in customEventRootDelegates) {
	                  editor.dom.unbind(getEventTarget(editor, name));
	                }
	                customEventRootDelegates = null;
	              }
	            }
	          });
	        }
	        if (customEventRootDelegates[eventName]) {
	          return;
	        }
	        delegate = function (e) {
	          var target = e.target;
	          var editors = editor.editorManager.get();
	          var i = editors.length;
	          while (i--) {
	            var body = editors[i].getBody();
	            if (body === target || DOM$8.isChildOf(target, body)) {
	              fireEvent(editors[i], eventName, e);
	            }
	          }
	        };
	        customEventRootDelegates[eventName] = delegate;
	        DOM$8.bind(eventRootElm, eventName, delegate);
	      } else {
	        delegate = function (e) {
	          fireEvent(editor, eventName, e);
	        };
	        DOM$8.bind(eventRootElm, eventName, delegate);
	        editor.delegates[eventName] = delegate;
	      }
	    };
	    var EditorObservable = __assign(__assign({}, Observable), {
	      bindPendingEventDelegates: function () {
	        var self = this;
	        Tools.each(self._pendingNativeEvents, function (name) {
	          bindEventDelegate(self, name);
	        });
	      },
	      toggleNativeEvent: function (name, state) {
	        var self = this;
	        if (name === 'focus' || name === 'blur') {
	          return;
	        }
	        if (state) {
	          if (self.initialized) {
	            bindEventDelegate(self, name);
	          } else {
	            if (!self._pendingNativeEvents) {
	              self._pendingNativeEvents = [name];
	            } else {
	              self._pendingNativeEvents.push(name);
	            }
	          }
	        } else if (self.initialized) {
	          self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);
	          delete self.delegates[name];
	        }
	      },
	      unbindAllNativeEvents: function () {
	        var self = this;
	        var body = self.getBody();
	        var dom = self.dom;
	        var name;
	        if (self.delegates) {
	          for (name in self.delegates) {
	            self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);
	          }
	          delete self.delegates;
	        }
	        if (!self.inline && body && dom) {
	          body.onload = null;
	          dom.unbind(self.getWin());
	          dom.unbind(self.getDoc());
	        }
	        if (dom) {
	          dom.unbind(body);
	          dom.unbind(self.getContainer());
	        }
	      }
	    });
	
	    var defaultModes = [
	      'design',
	      'readonly'
	    ];
	    var switchToMode = function (editor, activeMode, availableModes, mode) {
	      var oldMode = availableModes[activeMode.get()];
	      var newMode = availableModes[mode];
	      try {
	        newMode.activate();
	      } catch (e) {
	        domGlobals.console.error('problem while activating editor mode ' + mode + ':', e);
	        return;
	      }
	      oldMode.deactivate();
	      if (oldMode.editorReadOnly !== newMode.editorReadOnly) {
	        toggleReadOnly(editor, newMode.editorReadOnly);
	      }
	      activeMode.set(mode);
	      fireSwitchMode(editor, mode);
	    };
	    var setMode = function (editor, availableModes, activeMode, mode) {
	      if (mode === activeMode.get()) {
	        return;
	      } else if (!has(availableModes, mode)) {
	        throw new Error('Editor mode \'' + mode + '\' is invalid');
	      }
	      if (editor.initialized) {
	        switchToMode(editor, activeMode, availableModes, mode);
	      } else {
	        editor.on('init', function () {
	          return switchToMode(editor, activeMode, availableModes, mode);
	        });
	      }
	    };
	    var registerMode = function (availableModes, mode, api) {
	      var _a;
	      if (contains(defaultModes, mode)) {
	        throw new Error('Cannot override default mode ' + mode);
	      }
	      return __assign(__assign({}, availableModes), (_a = {}, _a[mode] = __assign(__assign({}, api), {
	        deactivate: function () {
	          try {
	            api.deactivate();
	          } catch (e) {
	            domGlobals.console.error('problem while deactivating editor mode ' + mode + ':', e);
	          }
	        }
	      }), _a));
	    };
	
	    var create$4 = function (editor) {
	      var activeMode = Cell('design');
	      var availableModes = Cell({
	        design: {
	          activate: noop,
	          deactivate: noop,
	          editorReadOnly: false
	        },
	        readonly: {
	          activate: noop,
	          deactivate: noop,
	          editorReadOnly: true
	        }
	      });
	      registerReadOnlyContentFilters(editor);
	      registerReadOnlySelectionBlockers(editor);
	      return {
	        isReadOnly: function () {
	          return isReadOnly(editor);
	        },
	        set: function (mode) {
	          return setMode(editor, availableModes.get(), activeMode, mode);
	        },
	        get: function () {
	          return activeMode.get();
	        },
	        register: function (mode, api) {
	          availableModes.set(registerMode(availableModes.get(), mode, api));
	        }
	      };
	    };
	
	    var each$g = Tools.each, explode$3 = Tools.explode;
	    var keyCodeLookup = {
	      f1: 112,
	      f2: 113,
	      f3: 114,
	      f4: 115,
	      f5: 116,
	      f6: 117,
	      f7: 118,
	      f8: 119,
	      f9: 120,
	      f10: 121,
	      f11: 122,
	      f12: 123
	    };
	    var modifierNames = Tools.makeMap('alt,ctrl,shift,meta,access');
	    var Shortcuts = function () {
	      function Shortcuts(editor) {
	        this.shortcuts = {};
	        this.pendingPatterns = [];
	        this.editor = editor;
	        var self = this;
	        editor.on('keyup keypress keydown', function (e) {
	          if ((self.hasModifier(e) || self.isFunctionKey(e)) && !e.isDefaultPrevented()) {
	            each$g(self.shortcuts, function (shortcut) {
	              if (self.matchShortcut(e, shortcut)) {
	                self.pendingPatterns = shortcut.subpatterns.slice(0);
	                if (e.type === 'keydown') {
	                  self.executeShortcutAction(shortcut);
	                }
	                return true;
	              }
	            });
	            if (self.matchShortcut(e, self.pendingPatterns[0])) {
	              if (self.pendingPatterns.length === 1) {
	                if (e.type === 'keydown') {
	                  self.executeShortcutAction(self.pendingPatterns[0]);
	                }
	              }
	              self.pendingPatterns.shift();
	            }
	          }
	        });
	      }
	      Shortcuts.prototype.add = function (pattern, desc, cmdFunc, scope) {
	        var self = this;
	        var cmd;
	        cmd = cmdFunc;
	        if (typeof cmdFunc === 'string') {
	          cmdFunc = function () {
	            self.editor.execCommand(cmd, false, null);
	          };
	        } else if (Tools.isArray(cmd)) {
	          cmdFunc = function () {
	            self.editor.execCommand(cmd[0], cmd[1], cmd[2]);
	          };
	        }
	        each$g(explode$3(Tools.trim(pattern)), function (pattern) {
	          var shortcut = self.createShortcut(pattern, desc, cmdFunc, scope);
	          self.shortcuts[shortcut.id] = shortcut;
	        });
	        return true;
	      };
	      Shortcuts.prototype.remove = function (pattern) {
	        var shortcut = this.createShortcut(pattern);
	        if (this.shortcuts[shortcut.id]) {
	          delete this.shortcuts[shortcut.id];
	          return true;
	        }
	        return false;
	      };
	      Shortcuts.prototype.parseShortcut = function (pattern) {
	        var id, key;
	        var shortcut = {};
	        each$g(explode$3(pattern.toLowerCase(), '+'), function (value) {
	          if (value in modifierNames) {
	            shortcut[value] = true;
	          } else {
	            if (/^[0-9]{2,}$/.test(value)) {
	              shortcut.keyCode = parseInt(value, 10);
	            } else {
	              shortcut.charCode = value.charCodeAt(0);
	              shortcut.keyCode = keyCodeLookup[value] || value.toUpperCase().charCodeAt(0);
	            }
	          }
	        });
	        id = [shortcut.keyCode];
	        for (key in modifierNames) {
	          if (shortcut[key]) {
	            id.push(key);
	          } else {
	            shortcut[key] = false;
	          }
	        }
	        shortcut.id = id.join(',');
	        if (shortcut.access) {
	          shortcut.alt = true;
	          if (Env.mac) {
	            shortcut.ctrl = true;
	          } else {
	            shortcut.shift = true;
	          }
	        }
	        if (shortcut.meta) {
	          if (Env.mac) {
	            shortcut.meta = true;
	          } else {
	            shortcut.ctrl = true;
	            shortcut.meta = false;
	          }
	        }
	        return shortcut;
	      };
	      Shortcuts.prototype.createShortcut = function (pattern, desc, cmdFunc, scope) {
	        var shortcuts;
	        shortcuts = Tools.map(explode$3(pattern, '>'), this.parseShortcut);
	        shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {
	          func: cmdFunc,
	          scope: scope || this.editor
	        });
	        return Tools.extend(shortcuts[0], {
	          desc: this.editor.translate(desc),
	          subpatterns: shortcuts.slice(1)
	        });
	      };
	      Shortcuts.prototype.hasModifier = function (e) {
	        return e.altKey || e.ctrlKey || e.metaKey;
	      };
	      Shortcuts.prototype.isFunctionKey = function (e) {
	        return e.type === 'keydown' && e.keyCode >= 112 && e.keyCode <= 123;
	      };
	      Shortcuts.prototype.matchShortcut = function (e, shortcut) {
	        if (!shortcut) {
	          return false;
	        }
	        if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {
	          return false;
	        }
	        if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {
	          return false;
	        }
	        if (e.keyCode === shortcut.keyCode || e.charCode && e.charCode === shortcut.charCode) {
	          e.preventDefault();
	          return true;
	        }
	        return false;
	      };
	      Shortcuts.prototype.executeShortcutAction = function (shortcut) {
	        return shortcut.func ? shortcut.func.call(shortcut.scope) : null;
	      };
	      return Shortcuts;
	    }();
	
	    var create$5 = function () {
	      var buttons = {};
	      var menuItems = {};
	      var popups = {};
	      var icons = {};
	      var contextMenus = {};
	      var contextToolbars = {};
	      var sidebars = {};
	      var add = function (collection, type) {
	        return function (name, spec) {
	          return collection[name.toLowerCase()] = __assign(__assign({}, spec), { type: type });
	        };
	      };
	      var addIcon = function (name, svgData) {
	        return icons[name.toLowerCase()] = svgData;
	      };
	      return {
	        addButton: add(buttons, 'button'),
	        addGroupToolbarButton: add(buttons, 'grouptoolbarbutton'),
	        addToggleButton: add(buttons, 'togglebutton'),
	        addMenuButton: add(buttons, 'menubutton'),
	        addSplitButton: add(buttons, 'splitbutton'),
	        addMenuItem: add(menuItems, 'menuitem'),
	        addNestedMenuItem: add(menuItems, 'nestedmenuitem'),
	        addToggleMenuItem: add(menuItems, 'togglemenuitem'),
	        addAutocompleter: add(popups, 'autocompleter'),
	        addContextMenu: add(contextMenus, 'contextmenu'),
	        addContextToolbar: add(contextToolbars, 'contexttoolbar'),
	        addContextForm: add(contextToolbars, 'contextform'),
	        addSidebar: add(sidebars, 'sidebar'),
	        addIcon: addIcon,
	        getAll: function () {
	          return {
	            buttons: buttons,
	            menuItems: menuItems,
	            icons: icons,
	            popups: popups,
	            contextMenus: contextMenus,
	            contextToolbars: contextToolbars,
	            sidebars: sidebars
	          };
	        }
	      };
	    };
	
	    var registry = function () {
	      var bridge = create$5();
	      return {
	        addAutocompleter: bridge.addAutocompleter,
	        addButton: bridge.addButton,
	        addContextForm: bridge.addContextForm,
	        addContextMenu: bridge.addContextMenu,
	        addContextToolbar: bridge.addContextToolbar,
	        addIcon: bridge.addIcon,
	        addMenuButton: bridge.addMenuButton,
	        addMenuItem: bridge.addMenuItem,
	        addNestedMenuItem: bridge.addNestedMenuItem,
	        addSidebar: bridge.addSidebar,
	        addSplitButton: bridge.addSplitButton,
	        addToggleButton: bridge.addToggleButton,
	        addGroupToolbarButton: bridge.addGroupToolbarButton,
	        addToggleMenuItem: bridge.addToggleMenuItem,
	        getAll: bridge.getAll
	      };
	    };
	
	    var each$h = Tools.each, trim$4 = Tools.trim;
	    var queryParts = 'source protocol authority userInfo user password host port relative path directory file query anchor'.split(' ');
	    var DEFAULT_PORTS = {
	      ftp: 21,
	      http: 80,
	      https: 443,
	      mailto: 25
	    };
	    var URI = function () {
	      function URI(url, settings) {
	        url = trim$4(url);
	        this.settings = settings || {};
	        var baseUri = this.settings.base_uri;
	        var self = this;
	        if (/^([\w\-]+):([^\/]{2})/i.test(url) || /^\s*#/.test(url)) {
	          self.source = url;
	          return;
	        }
	        var isProtocolRelative = url.indexOf('//') === 0;
	        if (url.indexOf('/') === 0 && !isProtocolRelative) {
	          url = (baseUri ? baseUri.protocol || 'http' : 'http') + '://mce_host' + url;
	        }
	        if (!/^[\w\-]*:?\/\//.test(url)) {
	          var baseUrl = this.settings.base_uri ? this.settings.base_uri.path : new URI(domGlobals.document.location.href).directory;
	          if (this.settings.base_uri && this.settings.base_uri.protocol == '') {
	            url = '//mce_host' + self.toAbsPath(baseUrl, url);
	          } else {
	            var match = /([^#?]*)([#?]?.*)/.exec(url);
	            url = (baseUri && baseUri.protocol || 'http') + '://mce_host' + self.toAbsPath(baseUrl, match[1]) + match[2];
	          }
	        }
	        url = url.replace(/@@/g, '(mce_at)');
	        var urlMatch = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(url);
	        each$h(queryParts, function (v, i) {
	          var part = urlMatch[i];
	          if (part) {
	            part = part.replace(/\(mce_at\)/g, '@@');
	          }
	          self[v] = part;
	        });
	        if (baseUri) {
	          if (!self.protocol) {
	            self.protocol = baseUri.protocol;
	          }
	          if (!self.userInfo) {
	            self.userInfo = baseUri.userInfo;
	          }
	          if (!self.port && self.host === 'mce_host') {
	            self.port = baseUri.port;
	          }
	          if (!self.host || self.host === 'mce_host') {
	            self.host = baseUri.host;
	          }
	          self.source = '';
	        }
	        if (isProtocolRelative) {
	          self.protocol = '';
	        }
	      }
	      URI.parseDataUri = function (uri) {
	        var type;
	        var uriComponents = decodeURIComponent(uri).split(',');
	        var matches = /data:([^;]+)/.exec(uriComponents[0]);
	        if (matches) {
	          type = matches[1];
	        }
	        return {
	          type: type,
	          data: uriComponents[1]
	        };
	      };
	      URI.getDocumentBaseUrl = function (loc) {
	        var baseUrl;
	        if (loc.protocol.indexOf('http') !== 0 && loc.protocol !== 'file:') {
	          baseUrl = loc.href;
	        } else {
	          baseUrl = loc.protocol + '//' + loc.host + loc.pathname;
	        }
	        if (/^[^:]+:\/\/\/?[^\/]+\//.test(baseUrl)) {
	          baseUrl = baseUrl.replace(/[\?#].*$/, '').replace(/[\/\\][^\/]+$/, '');
	          if (!/[\/\\]$/.test(baseUrl)) {
	            baseUrl += '/';
	          }
	        }
	        return baseUrl;
	      };
	      URI.prototype.setPath = function (path) {
	        var pathMatch = /^(.*?)\/?(\w+)?$/.exec(path);
	        this.path = pathMatch[0];
	        this.directory = pathMatch[1];
	        this.file = pathMatch[2];
	        this.source = '';
	        this.getURI();
	      };
	      URI.prototype.toRelative = function (uri) {
	        var output;
	        if (uri === './') {
	          return uri;
	        }
	        var relativeUri = new URI(uri, { base_uri: this });
	        if (relativeUri.host !== 'mce_host' && this.host !== relativeUri.host && relativeUri.host || this.port !== relativeUri.port || this.protocol !== relativeUri.protocol && relativeUri.protocol !== '') {
	          return relativeUri.getURI();
	        }
	        var tu = this.getURI(), uu = relativeUri.getURI();
	        if (tu === uu || tu.charAt(tu.length - 1) === '/' && tu.substr(0, tu.length - 1) === uu) {
	          return tu;
	        }
	        output = this.toRelPath(this.path, relativeUri.path);
	        if (relativeUri.query) {
	          output += '?' + relativeUri.query;
	        }
	        if (relativeUri.anchor) {
	          output += '#' + relativeUri.anchor;
	        }
	        return output;
	      };
	      URI.prototype.toAbsolute = function (uri, noHost) {
	        var absoluteUri = new URI(uri, { base_uri: this });
	        return absoluteUri.getURI(noHost && this.isSameOrigin(absoluteUri));
	      };
	      URI.prototype.isSameOrigin = function (uri) {
	        if (this.host == uri.host && this.protocol == uri.protocol) {
	          if (this.port == uri.port) {
	            return true;
	          }
	          var defaultPort = DEFAULT_PORTS[this.protocol];
	          if (defaultPort && (this.port || defaultPort) == (uri.port || defaultPort)) {
	            return true;
	          }
	        }
	        return false;
	      };
	      URI.prototype.toRelPath = function (base, path) {
	        var items, breakPoint = 0, out = '', i, l;
	        var normalizedBase = base.substring(0, base.lastIndexOf('/')).split('/');
	        items = path.split('/');
	        if (normalizedBase.length >= items.length) {
	          for (i = 0, l = normalizedBase.length; i < l; i++) {
	            if (i >= items.length || normalizedBase[i] !== items[i]) {
	              breakPoint = i + 1;
	              break;
	            }
	          }
	        }
	        if (normalizedBase.length < items.length) {
	          for (i = 0, l = items.length; i < l; i++) {
	            if (i >= normalizedBase.length || normalizedBase[i] !== items[i]) {
	              breakPoint = i + 1;
	              break;
	            }
	          }
	        }
	        if (breakPoint === 1) {
	          return path;
	        }
	        for (i = 0, l = normalizedBase.length - (breakPoint - 1); i < l; i++) {
	          out += '../';
	        }
	        for (i = breakPoint - 1, l = items.length; i < l; i++) {
	          if (i !== breakPoint - 1) {
	            out += '/' + items[i];
	          } else {
	            out += items[i];
	          }
	        }
	        return out;
	      };
	      URI.prototype.toAbsPath = function (base, path) {
	        var i, nb = 0, o = [], tr, outPath;
	        tr = /\/$/.test(path) ? '/' : '';
	        var normalizedBase = base.split('/');
	        var normalizedPath = path.split('/');
	        each$h(normalizedBase, function (k) {
	          if (k) {
	            o.push(k);
	          }
	        });
	        normalizedBase = o;
	        for (i = normalizedPath.length - 1, o = []; i >= 0; i--) {
	          if (normalizedPath[i].length === 0 || normalizedPath[i] === '.') {
	            continue;
	          }
	          if (normalizedPath[i] === '..') {
	            nb++;
	            continue;
	          }
	          if (nb > 0) {
	            nb--;
	            continue;
	          }
	          o.push(normalizedPath[i]);
	        }
	        i = normalizedBase.length - nb;
	        if (i <= 0) {
	          outPath = reverse(o).join('/');
	        } else {
	          outPath = normalizedBase.slice(0, i).join('/') + '/' + reverse(o).join('/');
	        }
	        if (outPath.indexOf('/') !== 0) {
	          outPath = '/' + outPath;
	        }
	        if (tr && outPath.lastIndexOf('/') !== outPath.length - 1) {
	          outPath += tr;
	        }
	        return outPath;
	      };
	      URI.prototype.getURI = function (noProtoHost) {
	        if (noProtoHost === void 0) {
	          noProtoHost = false;
	        }
	        var s;
	        if (!this.source || noProtoHost) {
	          s = '';
	          if (!noProtoHost) {
	            if (this.protocol) {
	              s += this.protocol + '://';
	            } else {
	              s += '//';
	            }
	            if (this.userInfo) {
	              s += this.userInfo + '@';
	            }
	            if (this.host) {
	              s += this.host;
	            }
	            if (this.port) {
	              s += ':' + this.port;
	            }
	          }
	          if (this.path) {
	            s += this.path;
	          }
	          if (this.query) {
	            s += '?' + this.query;
	          }
	          if (this.anchor) {
	            s += '#' + this.anchor;
	          }
	          this.source = s;
	        }
	        return this.source;
	      };
	      return URI;
	    }();
	
	    var DOM$9 = DOMUtils$1.DOM;
	    var extend$3 = Tools.extend, each$i = Tools.each;
	    var resolve$3 = Tools.resolve;
	    var ie$1 = Env.ie;
	    var Editor = function () {
	      function Editor(id, settings, editorManager) {
	        var _this = this;
	        this.plugins = {};
	        this.contentCSS = [];
	        this.contentStyles = [];
	        this.loadedCSS = {};
	        this.isNotDirty = false;
	        this.editorManager = editorManager;
	        this.documentBaseUrl = editorManager.documentBaseURL;
	        extend$3(this, EditorObservable);
	        this.settings = getEditorSettings(this, id, this.documentBaseUrl, editorManager.defaultSettings, settings);
	        if (this.settings.suffix) {
	          editorManager.suffix = this.settings.suffix;
	        }
	        this.suffix = editorManager.suffix;
	        if (this.settings.base_url) {
	          editorManager._setBaseUrl(this.settings.base_url);
	        }
	        this.baseUri = editorManager.baseURI;
	        if (this.settings.referrer_policy) {
	          ScriptLoader.ScriptLoader._setReferrerPolicy(this.settings.referrer_policy);
	          DOMUtils$1.DOM.styleSheetLoader._setReferrerPolicy(this.settings.referrer_policy);
	        }
	        AddOnManager$1.languageLoad = this.settings.language_load;
	        AddOnManager$1.baseURL = editorManager.baseURL;
	        this.id = id;
	        this.setDirty(false);
	        this.documentBaseURI = new URI(this.settings.document_base_url, { base_uri: this.baseUri });
	        this.baseURI = this.baseUri;
	        this.inline = !!this.settings.inline;
	        this.shortcuts = new Shortcuts(this);
	        this.editorCommands = new EditorCommands(this);
	        if (this.settings.cache_suffix) {
	          Env.cacheSuffix = this.settings.cache_suffix.replace(/^[\?\&]+/, '');
	        }
	        this.ui = { registry: registry() };
	        var self = this;
	        var modeInstance = create$4(self);
	        this.mode = modeInstance;
	        this.setMode = modeInstance.set;
	        editorManager.fire('SetupEditor', { editor: this });
	        this.execCallback('setup', this);
	        this.$ = DomQuery.overrideDefaults(function () {
	          return {
	            context: _this.inline ? _this.getBody() : _this.getDoc(),
	            element: _this.getBody()
	          };
	        });
	      }
	      Editor.prototype.render = function () {
	        Render.render(this);
	      };
	      Editor.prototype.focus = function (skipFocus) {
	        EditorFocus.focus(this, skipFocus);
	      };
	      Editor.prototype.hasFocus = function () {
	        return EditorFocus.hasFocus(this);
	      };
	      Editor.prototype.execCallback = function (name) {
	        var x = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	          x[_i - 1] = arguments[_i];
	        }
	        var self = this;
	        var callback = self.settings[name], scope;
	        if (!callback) {
	          return;
	        }
	        if (self.callbackLookup && (scope = self.callbackLookup[name])) {
	          callback = scope.func;
	          scope = scope.scope;
	        }
	        if (typeof callback === 'string') {
	          scope = callback.replace(/\.\w+$/, '');
	          scope = scope ? resolve$3(scope) : 0;
	          callback = resolve$3(callback);
	          self.callbackLookup = self.callbackLookup || {};
	          self.callbackLookup[name] = {
	            func: callback,
	            scope: scope
	          };
	        }
	        return callback.apply(scope || self, Array.prototype.slice.call(arguments, 1));
	      };
	      Editor.prototype.translate = function (text) {
	        return I18n.translate(text);
	      };
	      Editor.prototype.getParam = function (name, defaultVal, type) {
	        return getParam(this, name, defaultVal, type);
	      };
	      Editor.prototype.nodeChanged = function (args) {
	        this._nodeChangeDispatcher.nodeChanged(args);
	      };
	      Editor.prototype.addCommand = function (name, callback, scope) {
	        this.editorCommands.addCommand(name, callback, scope);
	      };
	      Editor.prototype.addQueryStateHandler = function (name, callback, scope) {
	        this.editorCommands.addQueryStateHandler(name, callback, scope);
	      };
	      Editor.prototype.addQueryValueHandler = function (name, callback, scope) {
	        this.editorCommands.addQueryValueHandler(name, callback, scope);
	      };
	      Editor.prototype.addShortcut = function (pattern, desc, cmdFunc, scope) {
	        this.shortcuts.add(pattern, desc, cmdFunc, scope);
	      };
	      Editor.prototype.execCommand = function (cmd, ui, value, args) {
	        return this.editorCommands.execCommand(cmd, ui, value, args);
	      };
	      Editor.prototype.queryCommandState = function (cmd) {
	        return this.editorCommands.queryCommandState(cmd);
	      };
	      Editor.prototype.queryCommandValue = function (cmd) {
	        return this.editorCommands.queryCommandValue(cmd);
	      };
	      Editor.prototype.queryCommandSupported = function (cmd) {
	        return this.editorCommands.queryCommandSupported(cmd);
	      };
	      Editor.prototype.show = function () {
	        var self = this;
	        if (self.hidden) {
	          self.hidden = false;
	          if (self.inline) {
	            self.getBody().contentEditable = 'true';
	          } else {
	            DOM$9.show(self.getContainer());
	            DOM$9.hide(self.id);
	          }
	          self.load();
	          self.fire('show');
	        }
	      };
	      Editor.prototype.hide = function () {
	        var self = this, doc = self.getDoc();
	        if (!self.hidden) {
	          if (ie$1 && doc && !self.inline) {
	            doc.execCommand('SelectAll');
	          }
	          self.save();
	          if (self.inline) {
	            self.getBody().contentEditable = 'false';
	            if (self === self.editorManager.focusedEditor) {
	              self.editorManager.focusedEditor = null;
	            }
	          } else {
	            DOM$9.hide(self.getContainer());
	            DOM$9.setStyle(self.id, 'display', self.orgDisplay);
	          }
	          self.hidden = true;
	          self.fire('hide');
	        }
	      };
	      Editor.prototype.isHidden = function () {
	        return !!this.hidden;
	      };
	      Editor.prototype.setProgressState = function (state, time) {
	        this.fire('ProgressState', {
	          state: state,
	          time: time
	        });
	      };
	      Editor.prototype.load = function (args) {
	        var self = this;
	        var elm = self.getElement(), html;
	        if (self.removed) {
	          return '';
	        }
	        if (elm) {
	          args = args || {};
	          args.load = true;
	          var value = NodeType.isTextareaOrInput(elm) ? elm.value : elm.innerHTML;
	          html = self.setContent(value, args);
	          args.element = elm;
	          if (!args.no_events) {
	            self.fire('LoadContent', args);
	          }
	          args.element = elm = null;
	          return html;
	        }
	      };
	      Editor.prototype.save = function (args) {
	        var self = this;
	        var elm = self.getElement(), html, form;
	        if (!elm || !self.initialized || self.removed) {
	          return;
	        }
	        args = args || {};
	        args.save = true;
	        args.element = elm;
	        html = args.content = self.getContent(args);
	        if (!args.no_events) {
	          self.fire('SaveContent', args);
	        }
	        if (args.format === 'raw') {
	          self.fire('RawSaveContent', args);
	        }
	        html = args.content;
	        if (!NodeType.isTextareaOrInput(elm)) {
	          if (args.is_removing || !self.inline) {
	            elm.innerHTML = html;
	          }
	          if (form = DOM$9.getParent(self.id, 'form')) {
	            each$i(form.elements, function (elm) {
	              if (elm.name === self.id) {
	                elm.value = html;
	                return false;
	              }
	            });
	          }
	        } else {
	          elm.value = html;
	        }
	        args.element = elm = null;
	        if (args.set_dirty !== false) {
	          self.setDirty(false);
	        }
	        return html;
	      };
	      Editor.prototype.setContent = function (content, args) {
	        return setContent(this, content, args);
	      };
	      Editor.prototype.getContent = function (args) {
	        return getContent(this, args);
	      };
	      Editor.prototype.insertContent = function (content, args) {
	        if (args) {
	          content = extend$3({ content: content }, args);
	        }
	        this.execCommand('mceInsertContent', false, content);
	      };
	      Editor.prototype.resetContent = function (initialContent) {
	        if (initialContent === undefined) {
	          setContent(this, this.startContent, { format: 'raw' });
	        } else {
	          setContent(this, initialContent);
	        }
	        this.undoManager.reset();
	        this.setDirty(false);
	        this.nodeChanged();
	      };
	      Editor.prototype.isDirty = function () {
	        return !this.isNotDirty;
	      };
	      Editor.prototype.setDirty = function (state) {
	        var oldState = !this.isNotDirty;
	        this.isNotDirty = !state;
	        if (state && state !== oldState) {
	          this.fire('dirty');
	        }
	      };
	      Editor.prototype.getContainer = function () {
	        var self = this;
	        if (!self.container) {
	          self.container = DOM$9.get(self.editorContainer || self.id + '_parent');
	        }
	        return self.container;
	      };
	      Editor.prototype.getContentAreaContainer = function () {
	        return this.contentAreaContainer;
	      };
	      Editor.prototype.getElement = function () {
	        if (!this.targetElm) {
	          this.targetElm = DOM$9.get(this.id);
	        }
	        return this.targetElm;
	      };
	      Editor.prototype.getWin = function () {
	        var self = this;
	        var elm;
	        if (!self.contentWindow) {
	          elm = self.iframeElement;
	          if (elm) {
	            self.contentWindow = elm.contentWindow;
	          }
	        }
	        return self.contentWindow;
	      };
	      Editor.prototype.getDoc = function () {
	        var self = this;
	        var win;
	        if (!self.contentDocument) {
	          win = self.getWin();
	          if (win) {
	            self.contentDocument = win.document;
	          }
	        }
	        return self.contentDocument;
	      };
	      Editor.prototype.getBody = function () {
	        var doc = this.getDoc();
	        return this.bodyElement || (doc ? doc.body : null);
	      };
	      Editor.prototype.convertURL = function (url, name, elm) {
	        var self = this, settings = self.settings;
	        if (settings.urlconverter_callback) {
	          return self.execCallback('urlconverter_callback', url, elm, true, name);
	        }
	        if (!settings.convert_urls || elm && elm.nodeName === 'LINK' || url.indexOf('file:') === 0 || url.length === 0) {
	          return url;
	        }
	        if (settings.relative_urls) {
	          return self.documentBaseURI.toRelative(url);
	        }
	        url = self.documentBaseURI.toAbsolute(url, settings.remove_script_host);
	        return url;
	      };
	      Editor.prototype.addVisual = function (elm) {
	        var self = this;
	        var settings = self.settings;
	        var dom = self.dom;
	        var cls;
	        elm = elm || self.getBody();
	        if (self.hasVisual === undefined) {
	          self.hasVisual = settings.visual;
	        }
	        each$i(dom.select('table,a', elm), function (elm) {
	          var value;
	          switch (elm.nodeName) {
	          case 'TABLE':
	            cls = settings.visual_table_class || 'mce-item-table';
	            value = dom.getAttrib(elm, 'border');
	            if ((!value || value === '0') && self.hasVisual) {
	              dom.addClass(elm, cls);
	            } else {
	              dom.removeClass(elm, cls);
	            }
	            return;
	          case 'A':
	            if (!dom.getAttrib(elm, 'href')) {
	              value = dom.getAttrib(elm, 'name') || elm.id;
	              cls = settings.visual_anchor_class || 'mce-item-anchor';
	              if (value && self.hasVisual) {
	                dom.addClass(elm, cls);
	              } else {
	                dom.removeClass(elm, cls);
	              }
	            }
	            return;
	          }
	        });
	        self.fire('VisualAid', {
	          element: elm,
	          hasVisual: self.hasVisual
	        });
	      };
	      Editor.prototype.remove = function () {
	        remove$6(this);
	      };
	      Editor.prototype.destroy = function (automatic) {
	        destroy(this, automatic);
	      };
	      Editor.prototype.uploadImages = function (callback) {
	        return this.editorUpload.uploadImages(callback);
	      };
	      Editor.prototype._scanForImages = function () {
	        return this.editorUpload.scanForImages();
	      };
	      Editor.prototype.addButton = function () {
	        throw new Error('editor.addButton has been removed in tinymce 5x, use editor.ui.registry.addButton or editor.ui.registry.addToggleButton or editor.ui.registry.addSplitButton instead');
	      };
	      Editor.prototype.addSidebar = function () {
	        throw new Error('editor.addSidebar has been removed in tinymce 5x, use editor.ui.registry.addSidebar instead');
	      };
	      Editor.prototype.addMenuItem = function () {
	        throw new Error('editor.addMenuItem has been removed in tinymce 5x, use editor.ui.registry.addMenuItem instead');
	      };
	      Editor.prototype.addContextToolbar = function () {
	        throw new Error('editor.addContextToolbar has been removed in tinymce 5x, use editor.ui.registry.addContextToolbar instead');
	      };
	      return Editor;
	    }();
	
	    var DOM$a = DOMUtils$1.DOM;
	    var explode$4 = Tools.explode, each$j = Tools.each, extend$4 = Tools.extend;
	    var instanceCounter = 0, boundGlobalEvents = false;
	    var beforeUnloadDelegate;
	    var legacyEditors = [];
	    var editors = [];
	    var isValidLegacyKey = function (id) {
	      return id !== 'length';
	    };
	    var globalEventDelegate = function (e) {
	      var type = e.type;
	      each$j(EditorManager.get(), function (editor) {
	        switch (type) {
	        case 'scroll':
	          editor.fire('ScrollWindow', e);
	          break;
	        case 'resize':
	          editor.fire('ResizeWindow', e);
	          break;
	        }
	      });
	    };
	    var toggleGlobalEvents = function (state) {
	      if (state !== boundGlobalEvents) {
	        if (state) {
	          DomQuery(window).on('resize scroll', globalEventDelegate);
	        } else {
	          DomQuery(window).off('resize scroll', globalEventDelegate);
	        }
	        boundGlobalEvents = state;
	      }
	    };
	    var removeEditorFromList = function (targetEditor) {
	      var oldEditors = editors;
	      delete legacyEditors[targetEditor.id];
	      for (var i = 0; i < legacyEditors.length; i++) {
	        if (legacyEditors[i] === targetEditor) {
	          legacyEditors.splice(i, 1);
	          break;
	        }
	      }
	      editors = filter(editors, function (editor) {
	        return targetEditor !== editor;
	      });
	      if (EditorManager.activeEditor === targetEditor) {
	        EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;
	      }
	      if (EditorManager.focusedEditor === targetEditor) {
	        EditorManager.focusedEditor = null;
	      }
	      return oldEditors.length !== editors.length;
	    };
	    var purgeDestroyedEditor = function (editor) {
	      if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {
	        removeEditorFromList(editor);
	        editor.unbindAllNativeEvents();
	        editor.destroy(true);
	        editor.removed = true;
	        editor = null;
	      }
	      return editor;
	    };
	    var isQuirksMode = domGlobals.document.compatMode !== 'CSS1Compat';
	    var EditorManager = __assign(__assign({}, Observable), {
	      baseURI: null,
	      baseURL: null,
	      defaultSettings: {},
	      documentBaseURL: null,
	      suffix: null,
	      $: DomQuery,
	      majorVersion: '5',
	      minorVersion: '2.1',
	      releaseDate: '2020-03-25',
	      editors: legacyEditors,
	      i18n: I18n,
	      activeEditor: null,
	      focusedEditor: null,
	      settings: {},
	      setup: function () {
	        var self = this;
	        var baseURL, documentBaseURL, suffix = '';
	        documentBaseURL = URI.getDocumentBaseUrl(domGlobals.document.location);
	        if (/^[^:]+:\/\/\/?[^\/]+\//.test(documentBaseURL)) {
	          documentBaseURL = documentBaseURL.replace(/[\?#].*$/, '').replace(/[\/\\][^\/]+$/, '');
	          if (!/[\/\\]$/.test(documentBaseURL)) {
	            documentBaseURL += '/';
	          }
	        }
	        var preInit = window.tinymce || window.tinyMCEPreInit;
	        if (preInit) {
	          baseURL = preInit.base || preInit.baseURL;
	          suffix = preInit.suffix;
	        } else {
	          var scripts = domGlobals.document.getElementsByTagName('script');
	          for (var i = 0; i < scripts.length; i++) {
	            var src = scripts[i].src || '';
	            if (src === '') {
	              continue;
	            }
	            var srcScript = src.substring(src.lastIndexOf('/'));
	            if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(src)) {
	              if (srcScript.indexOf('.min') !== -1) {
	                suffix = '.min';
	              }
	              baseURL = src.substring(0, src.lastIndexOf('/'));
	              break;
	            }
	          }
	          if (!baseURL && domGlobals.document.currentScript) {
	            var src = domGlobals.document.currentScript.src;
	            if (src.indexOf('.min') !== -1) {
	              suffix = '.min';
	            }
	            baseURL = src.substring(0, src.lastIndexOf('/'));
	          }
	        }
	        self.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);
	        self.documentBaseURL = documentBaseURL;
	        self.baseURI = new URI(self.baseURL);
	        self.suffix = suffix;
	        FocusController.setup(self);
	      },
	      overrideDefaults: function (defaultSettings) {
	        var baseUrl, suffix;
	        baseUrl = defaultSettings.base_url;
	        if (baseUrl) {
	          this._setBaseUrl(baseUrl);
	        }
	        suffix = defaultSettings.suffix;
	        if (defaultSettings.suffix) {
	          this.suffix = suffix;
	        }
	        this.defaultSettings = defaultSettings;
	        var pluginBaseUrls = defaultSettings.plugin_base_urls;
	        for (var name_1 in pluginBaseUrls) {
	          AddOnManager$1.PluginManager.urls[name_1] = pluginBaseUrls[name_1];
	        }
	      },
	      init: function (settings) {
	        var self = this;
	        var result, invalidInlineTargets;
	        invalidInlineTargets = Tools.makeMap('area base basefont br col frame hr img input isindex link meta param embed source wbr track ' + 'colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu', ' ');
	        var isInvalidInlineTarget = function (settings, elm) {
	          return settings.inline && elm.tagName.toLowerCase() in invalidInlineTargets;
	        };
	        var createId = function (elm) {
	          var id = elm.id;
	          if (!id) {
	            id = elm.name;
	            if (id && !DOM$a.get(id)) {
	              id = elm.name;
	            } else {
	              id = DOM$a.uniqueId();
	            }
	            elm.setAttribute('id', id);
	          }
	          return id;
	        };
	        var execCallback = function (name) {
	          var callback = settings[name];
	          if (!callback) {
	            return;
	          }
	          return callback.apply(self, Array.prototype.slice.call(arguments, 2));
	        };
	        var hasClass = function (elm, className) {
	          return className.constructor === RegExp ? className.test(elm.className) : DOM$a.hasClass(elm, className);
	        };
	        var findTargets = function (settings) {
	          var l, targets = [];
	          if (Env.browser.isIE() && Env.browser.version.major < 11) {
	            ErrorReporter.initError('TinyMCE does not support the browser you are using. For a list of supported' + ' browsers please see: https://www.tinymce.com/docs/get-started/system-requirements/');
	            return [];
	          } else if (isQuirksMode) {
	            ErrorReporter.initError('Failed to initialize the editor as the document is not in standards mode. ' + 'TinyMCE requires standards mode.');
	            return [];
	          }
	          if (settings.types) {
	            each$j(settings.types, function (type) {
	              targets = targets.concat(DOM$a.select(type.selector));
	            });
	            return targets;
	          } else if (settings.selector) {
	            return DOM$a.select(settings.selector);
	          } else if (settings.target) {
	            return [settings.target];
	          }
	          switch (settings.mode) {
	          case 'exact':
	            l = settings.elements || '';
	            if (l.length > 0) {
	              each$j(explode$4(l), function (id) {
	                var elm;
	                if (elm = DOM$a.get(id)) {
	                  targets.push(elm);
	                } else {
	                  each$j(domGlobals.document.forms, function (f) {
	                    each$j(f.elements, function (e) {
	                      if (e.name === id) {
	                        id = 'mce_editor_' + instanceCounter++;
	                        DOM$a.setAttrib(e, 'id', id);
	                        targets.push(e);
	                      }
	                    });
	                  });
	                }
	              });
	            }
	            break;
	          case 'textareas':
	          case 'specific_textareas':
	            each$j(DOM$a.select('textarea'), function (elm) {
	              if (settings.editor_deselector && hasClass(elm, settings.editor_deselector)) {
	                return;
	              }
	              if (!settings.editor_selector || hasClass(elm, settings.editor_selector)) {
	                targets.push(elm);
	              }
	            });
	            break;
	          }
	          return targets;
	        };
	        var provideResults = function (editors) {
	          result = editors;
	        };
	        var initEditors = function () {
	          var initCount = 0;
	          var editors = [];
	          var targets;
	          var createEditor = function (id, settings, targetElm) {
	            var editor = new Editor(id, settings, self);
	            editors.push(editor);
	            editor.on('init', function () {
	              if (++initCount === targets.length) {
	                provideResults(editors);
	              }
	            });
	            editor.targetElm = editor.targetElm || targetElm;
	            editor.render();
	          };
	          DOM$a.unbind(window, 'ready', initEditors);
	          execCallback('onpageload');
	          targets = DomQuery.unique(findTargets(settings));
	          if (settings.types) {
	            each$j(settings.types, function (type) {
	              Tools.each(targets, function (elm) {
	                if (DOM$a.is(elm, type.selector)) {
	                  createEditor(createId(elm), extend$4({}, settings, type), elm);
	                  return false;
	                }
	                return true;
	              });
	            });
	            return;
	          }
	          Tools.each(targets, function (elm) {
	            purgeDestroyedEditor(self.get(elm.id));
	          });
	          targets = Tools.grep(targets, function (elm) {
	            return !self.get(elm.id);
	          });
	          if (targets.length === 0) {
	            provideResults([]);
	          } else {
	            each$j(targets, function (elm) {
	              if (isInvalidInlineTarget(settings, elm)) {
	                ErrorReporter.initError('Could not initialize inline editor on invalid inline target element', elm);
	              } else {
	                createEditor(createId(elm), settings, elm);
	              }
	            });
	          }
	        };
	        self.settings = settings;
	        DOM$a.bind(window, 'ready', initEditors);
	        return new promiseObj(function (resolve) {
	          if (result) {
	            resolve(result);
	          } else {
	            provideResults = function (editors) {
	              resolve(editors);
	            };
	          }
	        });
	      },
	      get: function (id) {
	        if (arguments.length === 0) {
	          return editors.slice(0);
	        } else if (isString(id)) {
	          return find(editors, function (editor) {
	            return editor.id === id;
	          }).getOr(null);
	        } else if (isNumber(id)) {
	          return editors[id] ? editors[id] : null;
	        } else {
	          return null;
	        }
	      },
	      add: function (editor) {
	        var self = this;
	        var existingEditor;
	        existingEditor = legacyEditors[editor.id];
	        if (existingEditor === editor) {
	          return editor;
	        }
	        if (self.get(editor.id) === null) {
	          if (isValidLegacyKey(editor.id)) {
	            legacyEditors[editor.id] = editor;
	          }
	          legacyEditors.push(editor);
	          editors.push(editor);
	        }
	        toggleGlobalEvents(true);
	        self.activeEditor = editor;
	        self.fire('AddEditor', { editor: editor });
	        if (!beforeUnloadDelegate) {
	          beforeUnloadDelegate = function (e) {
	            var event = self.fire('BeforeUnload');
	            if (event.returnValue) {
	              e.preventDefault();
	              e.returnValue = event.returnValue;
	              return event.returnValue;
	            }
	          };
	          window.addEventListener('beforeunload', beforeUnloadDelegate);
	        }
	        return editor;
	      },
	      createEditor: function (id, settings) {
	        return this.add(new Editor(id, settings, this));
	      },
	      remove: function (selector) {
	        var self = this;
	        var i, editor;
	        if (!selector) {
	          for (i = editors.length - 1; i >= 0; i--) {
	            self.remove(editors[i]);
	          }
	          return;
	        }
	        if (isString(selector)) {
	          each$j(DOM$a.select(selector), function (elm) {
	            editor = self.get(elm.id);
	            if (editor) {
	              self.remove(editor);
	            }
	          });
	          return;
	        }
	        editor = selector;
	        if (isNull(self.get(editor.id))) {
	          return null;
	        }
	        if (removeEditorFromList(editor)) {
	          self.fire('RemoveEditor', { editor: editor });
	        }
	        if (editors.length === 0) {
	          window.removeEventListener('beforeunload', beforeUnloadDelegate);
	        }
	        editor.remove();
	        toggleGlobalEvents(editors.length > 0);
	        return editor;
	      },
	      execCommand: function (cmd, ui, value) {
	        var self = this, editor = self.get(value);
	        switch (cmd) {
	        case 'mceAddEditor':
	          if (!self.get(value)) {
	            new Editor(value, self.settings, self).render();
	          }
	          return true;
	        case 'mceRemoveEditor':
	          if (editor) {
	            editor.remove();
	          }
	          return true;
	        case 'mceToggleEditor':
	          if (!editor) {
	            self.execCommand('mceAddEditor', 0, value);
	            return true;
	          }
	          if (editor.isHidden()) {
	            editor.show();
	          } else {
	            editor.hide();
	          }
	          return true;
	        }
	        if (self.activeEditor) {
	          return self.activeEditor.execCommand(cmd, ui, value);
	        }
	        return false;
	      },
	      triggerSave: function () {
	        each$j(editors, function (editor) {
	          editor.save();
	        });
	      },
	      addI18n: function (code, items) {
	        I18n.add(code, items);
	      },
	      translate: function (text) {
	        return I18n.translate(text);
	      },
	      setActive: function (editor) {
	        var activeEditor = this.activeEditor;
	        if (this.activeEditor !== editor) {
	          if (activeEditor) {
	            activeEditor.fire('deactivate', { relatedTarget: editor });
	          }
	          editor.fire('activate', { relatedTarget: activeEditor });
	        }
	        this.activeEditor = editor;
	      },
	      _setBaseUrl: function (baseUrl) {
	        this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\/+$/, ''));
	        this.baseURI = new URI(this.baseURL);
	      }
	    });
	    EditorManager.setup();
	
	    function RangeUtils(dom) {
	      var walk = function (rng, callback) {
	        return RangeWalk.walk(dom, rng, callback);
	      };
	      var split = split$1;
	      var normalize = function (rng) {
	        return NormalizeRange.normalize(dom, rng).fold(constant(false), function (normalizedRng) {
	          rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);
	          rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);
	          return true;
	        });
	      };
	      return {
	        walk: walk,
	        split: split,
	        normalize: normalize
	      };
	    }
	    (function (RangeUtils) {
	      RangeUtils.compareRanges = RangeCompare.isEq;
	      RangeUtils.getCaretRangeFromPoint = CaretRangeFromPoint.fromPoint;
	      RangeUtils.getSelectedNode = getSelectedNode;
	      RangeUtils.getNode = getNode;
	    }(RangeUtils || (RangeUtils = {})));
	    var RangeUtils$1 = RangeUtils;
	
	    var awaiter = function (resolveCb, rejectCb, timeout) {
	      if (timeout === void 0) {
	        timeout = 1000;
	      }
	      var done = false;
	      var timer = null;
	      var complete = function (completer) {
	        return function () {
	          var args = [];
	          for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	          }
	          if (!done) {
	            done = true;
	            if (timer !== null) {
	              domGlobals.clearTimeout(timer);
	              timer = null;
	            }
	            completer.apply(null, args);
	          }
	        };
	      };
	      var resolve = complete(resolveCb);
	      var reject = complete(rejectCb);
	      var start = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	          args[_i] = arguments[_i];
	        }
	        if (!done && timer === null) {
	          timer = domGlobals.setTimeout(function () {
	            return reject.apply(null, args);
	          }, timeout);
	        }
	      };
	      return {
	        start: start,
	        resolve: resolve,
	        reject: reject
	      };
	    };
	    var create$6 = function () {
	      var tasks = {};
	      var resultFns = {};
	      var load = function (id, url) {
	        var loadErrMsg = 'Script at URL "' + url + '" failed to load';
	        var runErrMsg = 'Script at URL "' + url + '" did not call `tinymce.Resource.add(\'' + id + '\', data)` within 1 second';
	        if (tasks[id] !== undefined) {
	          return tasks[id];
	        } else {
	          var task = new promiseObj(function (resolve, reject) {
	            var waiter = awaiter(resolve, reject);
	            resultFns[id] = waiter.resolve;
	            ScriptLoader.ScriptLoader.loadScript(url, function () {
	              return waiter.start(runErrMsg);
	            }, function () {
	              return waiter.reject(loadErrMsg);
	            });
	          });
	          tasks[id] = task;
	          return task;
	        }
	      };
	      var add = function (id, data) {
	        if (resultFns[id] !== undefined) {
	          resultFns[id](data);
	          delete resultFns[id];
	        }
	        tasks[id] = promiseObj.resolve(data);
	      };
	      return {
	        load: load,
	        add: add
	      };
	    };
	    var Resource = create$6();
	
	    var min = Math.min, max = Math.max, round$2 = Math.round;
	    var relativePosition = function (rect, targetRect, rel) {
	      var x, y, w, h, targetW, targetH;
	      x = targetRect.x;
	      y = targetRect.y;
	      w = rect.w;
	      h = rect.h;
	      targetW = targetRect.w;
	      targetH = targetRect.h;
	      rel = (rel || '').split('');
	      if (rel[0] === 'b') {
	        y += targetH;
	      }
	      if (rel[1] === 'r') {
	        x += targetW;
	      }
	      if (rel[0] === 'c') {
	        y += round$2(targetH / 2);
	      }
	      if (rel[1] === 'c') {
	        x += round$2(targetW / 2);
	      }
	      if (rel[3] === 'b') {
	        y -= h;
	      }
	      if (rel[4] === 'r') {
	        x -= w;
	      }
	      if (rel[3] === 'c') {
	        y -= round$2(h / 2);
	      }
	      if (rel[4] === 'c') {
	        x -= round$2(w / 2);
	      }
	      return create$7(x, y, w, h);
	    };
	    var findBestRelativePosition = function (rect, targetRect, constrainRect, rels) {
	      var pos, i;
	      for (i = 0; i < rels.length; i++) {
	        pos = relativePosition(rect, targetRect, rels[i]);
	        if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x && pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {
	          return rels[i];
	        }
	      }
	      return null;
	    };
	    var inflate = function (rect, w, h) {
	      return create$7(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);
	    };
	    var intersect = function (rect, cropRect) {
	      var x1, y1, x2, y2;
	      x1 = max(rect.x, cropRect.x);
	      y1 = max(rect.y, cropRect.y);
	      x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);
	      y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);
	      if (x2 - x1 < 0 || y2 - y1 < 0) {
	        return null;
	      }
	      return create$7(x1, y1, x2 - x1, y2 - y1);
	    };
	    var clamp$1 = function (rect, clampRect, fixedSize) {
	      var underflowX1, underflowY1, overflowX2, overflowY2, x1, y1, x2, y2, cx2, cy2;
	      x1 = rect.x;
	      y1 = rect.y;
	      x2 = rect.x + rect.w;
	      y2 = rect.y + rect.h;
	      cx2 = clampRect.x + clampRect.w;
	      cy2 = clampRect.y + clampRect.h;
	      underflowX1 = max(0, clampRect.x - x1);
	      underflowY1 = max(0, clampRect.y - y1);
	      overflowX2 = max(0, x2 - cx2);
	      overflowY2 = max(0, y2 - cy2);
	      x1 += underflowX1;
	      y1 += underflowY1;
	      if (fixedSize) {
	        x2 += underflowX1;
	        y2 += underflowY1;
	        x1 -= overflowX2;
	        y1 -= overflowY2;
	      }
	      x2 -= overflowX2;
	      y2 -= overflowY2;
	      return create$7(x1, y1, x2 - x1, y2 - y1);
	    };
	    var create$7 = function (x, y, w, h) {
	      return {
	        x: x,
	        y: y,
	        w: w,
	        h: h
	      };
	    };
	    var fromClientRect = function (clientRect) {
	      return create$7(clientRect.left, clientRect.top, clientRect.width, clientRect.height);
	    };
	    var Rect = {
	      inflate: inflate,
	      relativePosition: relativePosition,
	      findBestRelativePosition: findBestRelativePosition,
	      intersect: intersect,
	      clamp: clamp$1,
	      create: create$7,
	      fromClientRect: fromClientRect
	    };
	
	    var each$k = Tools.each, extend$5 = Tools.extend;
	    var extendClass, initializing;
	    var Class = function () {
	    };
	    Class.extend = extendClass = function (prop) {
	      var self = this;
	      var _super = self.prototype;
	      var prototype, name, member;
	      var Class = function () {
	        var i, mixins, mixin;
	        var self = this;
	        if (!initializing) {
	          if (self.init) {
	            self.init.apply(self, arguments);
	          }
	          mixins = self.Mixins;
	          if (mixins) {
	            i = mixins.length;
	            while (i--) {
	              mixin = mixins[i];
	              if (mixin.init) {
	                mixin.init.apply(self, arguments);
	              }
	            }
	          }
	        }
	      };
	      var dummy = function () {
	        return this;
	      };
	      var createMethod = function (name, fn) {
	        return function () {
	          var self = this;
	          var tmp = self._super;
	          var ret;
	          self._super = _super[name];
	          ret = fn.apply(self, arguments);
	          self._super = tmp;
	          return ret;
	        };
	      };
	      initializing = true;
	      prototype = new self();
	      initializing = false;
	      if (prop.Mixins) {
	        each$k(prop.Mixins, function (mixin) {
	          for (var name_1 in mixin) {
	            if (name_1 !== 'init') {
	              prop[name_1] = mixin[name_1];
	            }
	          }
	        });
	        if (_super.Mixins) {
	          prop.Mixins = _super.Mixins.concat(prop.Mixins);
	        }
	      }
	      if (prop.Methods) {
	        each$k(prop.Methods.split(','), function (name) {
	          prop[name] = dummy;
	        });
	      }
	      if (prop.Properties) {
	        each$k(prop.Properties.split(','), function (name) {
	          var fieldName = '_' + name;
	          prop[name] = function (value) {
	            var self = this;
	            if (value !== undefined) {
	              self[fieldName] = value;
	              return self;
	            }
	            return self[fieldName];
	          };
	        });
	      }
	      if (prop.Statics) {
	        each$k(prop.Statics, function (func, name) {
	          Class[name] = func;
	        });
	      }
	      if (prop.Defaults && _super.Defaults) {
	        prop.Defaults = extend$5({}, _super.Defaults, prop.Defaults);
	      }
	      for (name in prop) {
	        member = prop[name];
	        if (typeof member === 'function' && _super[name]) {
	          prototype[name] = createMethod(name, member);
	        } else {
	          prototype[name] = member;
	        }
	      }
	      Class.prototype = prototype;
	      Class.constructor = Class;
	      Class.extend = extendClass;
	      return Class;
	    };
	
	    var min$1 = Math.min, max$1 = Math.max, round$3 = Math.round;
	    var Color = function (value) {
	      var self = {};
	      var r = 0, g = 0, b = 0;
	      var rgb2hsv = function (r, g, b) {
	        var h, s, v, d, minRGB, maxRGB;
	        h = 0;
	        s = 0;
	        v = 0;
	        r = r / 255;
	        g = g / 255;
	        b = b / 255;
	        minRGB = min$1(r, min$1(g, b));
	        maxRGB = max$1(r, max$1(g, b));
	        if (minRGB === maxRGB) {
	          v = minRGB;
	          return {
	            h: 0,
	            s: 0,
	            v: v * 100
	          };
	        }
	        d = r === minRGB ? g - b : b === minRGB ? r - g : b - r;
	        h = r === minRGB ? 3 : b === minRGB ? 1 : 5;
	        h = 60 * (h - d / (maxRGB - minRGB));
	        s = (maxRGB - minRGB) / maxRGB;
	        v = maxRGB;
	        return {
	          h: round$3(h),
	          s: round$3(s * 100),
	          v: round$3(v * 100)
	        };
	      };
	      var hsvToRgb = function (hue, saturation, brightness) {
	        var side, chroma, x, match;
	        hue = (parseInt(hue, 10) || 0) % 360;
	        saturation = parseInt(saturation, 10) / 100;
	        brightness = parseInt(brightness, 10) / 100;
	        saturation = max$1(0, min$1(saturation, 1));
	        brightness = max$1(0, min$1(brightness, 1));
	        if (saturation === 0) {
	          r = g = b = round$3(255 * brightness);
	          return;
	        }
	        side = hue / 60;
	        chroma = brightness * saturation;
	        x = chroma * (1 - Math.abs(side % 2 - 1));
	        match = brightness - chroma;
	        switch (Math.floor(side)) {
	        case 0:
	          r = chroma;
	          g = x;
	          b = 0;
	          break;
	        case 1:
	          r = x;
	          g = chroma;
	          b = 0;
	          break;
	        case 2:
	          r = 0;
	          g = chroma;
	          b = x;
	          break;
	        case 3:
	          r = 0;
	          g = x;
	          b = chroma;
	          break;
	        case 4:
	          r = x;
	          g = 0;
	          b = chroma;
	          break;
	        case 5:
	          r = chroma;
	          g = 0;
	          b = x;
	          break;
	        default:
	          r = g = b = 0;
	        }
	        r = round$3(255 * (r + match));
	        g = round$3(255 * (g + match));
	        b = round$3(255 * (b + match));
	      };
	      var toHex = function () {
	        var hex = function (val) {
	          val = parseInt(val, 10).toString(16);
	          return val.length > 1 ? val : '0' + val;
	        };
	        return '#' + hex(r) + hex(g) + hex(b);
	      };
	      var toRgb = function () {
	        return {
	          r: r,
	          g: g,
	          b: b
	        };
	      };
	      var toHsv = function () {
	        return rgb2hsv(r, g, b);
	      };
	      var parse = function (value) {
	        var matches;
	        if (typeof value === 'object') {
	          if ('r' in value) {
	            r = value.r;
	            g = value.g;
	            b = value.b;
	          } else if ('v' in value) {
	            hsvToRgb(value.h, value.s, value.v);
	          }
	        } else {
	          if (matches = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)[^\)]*\)/gi.exec(value)) {
	            r = parseInt(matches[1], 10);
	            g = parseInt(matches[2], 10);
	            b = parseInt(matches[3], 10);
	          } else if (matches = /#([0-F]{2})([0-F]{2})([0-F]{2})/gi.exec(value)) {
	            r = parseInt(matches[1], 16);
	            g = parseInt(matches[2], 16);
	            b = parseInt(matches[3], 16);
	          } else if (matches = /#([0-F])([0-F])([0-F])/gi.exec(value)) {
	            r = parseInt(matches[1] + matches[1], 16);
	            g = parseInt(matches[2] + matches[2], 16);
	            b = parseInt(matches[3] + matches[3], 16);
	          }
	        }
	        r = r < 0 ? 0 : r > 255 ? 255 : r;
	        g = g < 0 ? 0 : g > 255 ? 255 : g;
	        b = b < 0 ? 0 : b > 255 ? 255 : b;
	        return self;
	      };
	      if (value) {
	        parse(value);
	      }
	      self.toRgb = toRgb;
	      self.toHsv = toHsv;
	      self.toHex = toHex;
	      self.parse = parse;
	      return self;
	    };
	
	    var serialize = function (obj) {
	      var data = JSON.stringify(obj);
	      if (!isString(data)) {
	        return data;
	      }
	      return data.replace(/[\u0080-\uFFFF]/g, function (match) {
	        var hexCode = match.charCodeAt(0).toString(16);
	        return '\\u' + '0000'.substring(hexCode.length) + hexCode;
	      });
	    };
	    var JSONUtils = {
	      serialize: serialize,
	      parse: function (text) {
	        try {
	          return JSON.parse(text);
	        } catch (ex) {
	        }
	      }
	    };
	
	    var JSONP = {
	      callbacks: {},
	      count: 0,
	      send: function (settings) {
	        var self = this, dom = DOMUtils$1.DOM, count = settings.count !== undefined ? settings.count : self.count;
	        var id = 'tinymce_jsonp_' + count;
	        self.callbacks[count] = function (json) {
	          dom.remove(id);
	          delete self.callbacks[count];
	          settings.callback(json);
	        };
	        dom.add(dom.doc.body, 'script', {
	          id: id,
	          src: settings.url,
	          type: 'text/javascript'
	        });
	        self.count++;
	      }
	    };
	
	    var XHR = __assign(__assign({}, Observable), {
	      send: function (settings) {
	        var xhr, count = 0;
	        var ready = function () {
	          if (!settings.async || xhr.readyState === 4 || count++ > 10000) {
	            if (settings.success && count < 10000 && xhr.status === 200) {
	              settings.success.call(settings.success_scope, '' + xhr.responseText, xhr, settings);
	            } else if (settings.error) {
	              settings.error.call(settings.error_scope, count > 10000 ? 'TIMED_OUT' : 'GENERAL', xhr, settings);
	            }
	            xhr = null;
	          } else {
	            Delay.setTimeout(ready, 10);
	          }
	        };
	        settings.scope = settings.scope || this;
	        settings.success_scope = settings.success_scope || settings.scope;
	        settings.error_scope = settings.error_scope || settings.scope;
	        settings.async = settings.async !== false;
	        settings.data = settings.data || '';
	        XHR.fire('beforeInitialize', { settings: settings });
	        xhr = new domGlobals.XMLHttpRequest();
	        if (xhr) {
	          if (xhr.overrideMimeType) {
	            xhr.overrideMimeType(settings.content_type);
	          }
	          xhr.open(settings.type || (settings.data ? 'POST' : 'GET'), settings.url, settings.async);
	          if (settings.crossDomain) {
	            xhr.withCredentials = true;
	          }
	          if (settings.content_type) {
	            xhr.setRequestHeader('Content-Type', settings.content_type);
	          }
	          if (settings.requestheaders) {
	            Tools.each(settings.requestheaders, function (header) {
	              xhr.setRequestHeader(header.key, header.value);
	            });
	          }
	          xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
	          xhr = XHR.fire('beforeSend', {
	            xhr: xhr,
	            settings: settings
	          }).xhr;
	          xhr.send(settings.data);
	          if (!settings.async) {
	            return ready();
	          }
	          Delay.setTimeout(ready, 10);
	        }
	      }
	    });
	
	    var extend$6 = Tools.extend;
	    var JSONRequest = function () {
	      function JSONRequest(settings) {
	        this.settings = extend$6({}, settings);
	        this.count = 0;
	      }
	      JSONRequest.sendRPC = function (o) {
	        return new JSONRequest().send(o);
	      };
	      JSONRequest.prototype.send = function (args) {
	        var ecb = args.error, scb = args.success;
	        var xhrArgs = extend$6(this.settings, args);
	        xhrArgs.success = function (c, x) {
	          c = JSONUtils.parse(c);
	          if (typeof c === 'undefined') {
	            c = { error: 'JSON Parse error.' };
	          }
	          if (c.error) {
	            ecb.call(xhrArgs.error_scope || xhrArgs.scope, c.error, x);
	          } else {
	            scb.call(xhrArgs.success_scope || xhrArgs.scope, c.result);
	          }
	        };
	        xhrArgs.error = function (ty, x) {
	          if (ecb) {
	            ecb.call(xhrArgs.error_scope || xhrArgs.scope, ty, x);
	          }
	        };
	        xhrArgs.data = JSONUtils.serialize({
	          id: args.id || 'c' + this.count++,
	          method: args.method,
	          params: args.params
	        });
	        xhrArgs.content_type = 'application/json';
	        XHR.send(xhrArgs);
	      };
	      return JSONRequest;
	    }();
	
	    var create$8 = function () {
	      return function () {
	        var data = {};
	        var keys = [];
	        var storage = {
	          getItem: function (key) {
	            var item = data[key];
	            return item ? item : null;
	          },
	          setItem: function (key, value) {
	            keys.push(key);
	            data[key] = String(value);
	          },
	          key: function (index) {
	            return keys[index];
	          },
	          removeItem: function (key) {
	            keys = keys.filter(function (k) {
	              return k === key;
	            });
	            delete data[key];
	          },
	          clear: function () {
	            keys = [];
	            data = {};
	          },
	          length: 0
	        };
	        Object.defineProperty(storage, 'length', {
	          get: function () {
	            return keys.length;
	          },
	          configurable: false,
	          enumerable: false
	        });
	        return storage;
	      }();
	    };
	
	    var localStorage;
	    try {
	      localStorage = domGlobals.window.localStorage;
	    } catch (e) {
	      localStorage = create$8();
	    }
	    var LocalStorage = localStorage;
	
	    var publicApi = {
	      geom: { Rect: Rect },
	      util: {
	        Promise: promiseObj,
	        Delay: Delay,
	        Tools: Tools,
	        VK: VK,
	        URI: URI,
	        Class: Class,
	        EventDispatcher: EventDispatcher,
	        Observable: Observable,
	        I18n: I18n,
	        XHR: XHR,
	        JSON: JSONUtils,
	        JSONRequest: JSONRequest,
	        JSONP: JSONP,
	        LocalStorage: LocalStorage,
	        Color: Color
	      },
	      dom: {
	        EventUtils: EventUtils,
	        Sizzle: Sizzle,
	        DomQuery: DomQuery,
	        TreeWalker: TreeWalker,
	        TextSeeker: TextSeeker,
	        DOMUtils: DOMUtils$1,
	        ScriptLoader: ScriptLoader,
	        RangeUtils: RangeUtils$1,
	        Serializer: Serializer$1,
	        ControlSelection: ControlSelection,
	        BookmarkManager: BookmarkManager$1,
	        Selection: Selection$1,
	        Event: EventUtils.Event
	      },
	      html: {
	        Styles: Styles,
	        Entities: Entities,
	        Node: Node$1,
	        Schema: Schema,
	        SaxParser: SaxParser$1,
	        DomParser: DomParser,
	        Writer: Writer,
	        Serializer: Serializer
	      },
	      Env: Env,
	      AddOnManager: AddOnManager$1,
	      Annotator: Annotator,
	      Formatter: Formatter,
	      UndoManager: UndoManager,
	      EditorCommands: EditorCommands,
	      WindowManager: WindowManager,
	      NotificationManager: NotificationManager,
	      EditorObservable: EditorObservable,
	      Shortcuts: Shortcuts,
	      Editor: Editor,
	      FocusManager: FocusManager,
	      EditorManager: EditorManager,
	      DOM: DOMUtils$1.DOM,
	      ScriptLoader: ScriptLoader.ScriptLoader,
	      PluginManager: AddOnManager$1.PluginManager,
	      ThemeManager: AddOnManager$1.ThemeManager,
	      IconManager: IconManager,
	      Resource: Resource,
	      trim: Tools.trim,
	      isArray: Tools.isArray,
	      is: Tools.is,
	      toArray: Tools.toArray,
	      makeMap: Tools.makeMap,
	      each: Tools.each,
	      map: Tools.map,
	      grep: Tools.grep,
	      inArray: Tools.inArray,
	      extend: Tools.extend,
	      create: Tools.create,
	      walk: Tools.walk,
	      createNS: Tools.createNS,
	      resolve: Tools.resolve,
	      explode: Tools.explode,
	      _addCacheSuffix: Tools._addCacheSuffix,
	      isOpera: Env.opera,
	      isWebKit: Env.webkit,
	      isIE: Env.ie,
	      isGecko: Env.gecko,
	      isMac: Env.mac
	    };
	    var tinymce = Tools.extend(EditorManager, publicApi);
	
	    var exportToModuleLoaders = function (tinymce) {
	      if (true) {
	        try {
	          module.exports = tinymce;
	        } catch (_) {
	        }
	      }
	    };
	    var exportToWindowGlobal = function (tinymce) {
	      window.tinymce = tinymce;
	      window.tinyMCE = tinymce;
	    };
	    exportToWindowGlobal(tinymce);
	    exportToModuleLoaders(tinymce);
	
	}(window));
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 6 */
/***/ (function(module, exports) {

	module.exports = Injector;

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	module.exports = ShortcodeSerialiser;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Component = undefined;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _i18n = __webpack_require__(9);
	
	var _i18n2 = _interopRequireDefault(_i18n);
	
	var _react = __webpack_require__(3);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _redux = __webpack_require__(10);
	
	var _reactRedux = __webpack_require__(11);
	
	var _FormBuilderModal = __webpack_require__(12);
	
	var _FormBuilderModal2 = _interopRequireDefault(_FormBuilderModal);
	
	var _SchemaActions = __webpack_require__(13);
	
	var schemaActions = _interopRequireWildcard(_SchemaActions);
	
	var _propTypes = __webpack_require__(14);
	
	var _propTypes2 = _interopRequireDefault(_propTypes);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var sectionConfigKey = 'SilverStripe\\AssetAdmin\\Controller\\AssetAdmin';
	
	var InsertEmbedModal = function (_Component) {
	  _inherits(InsertEmbedModal, _Component);
	
	  function InsertEmbedModal(props) {
	    _classCallCheck(this, InsertEmbedModal);
	
	    var _this = _possibleConstructorReturn(this, (InsertEmbedModal.__proto__ || Object.getPrototypeOf(InsertEmbedModal)).call(this, props));
	
	    _this.handleSubmit = _this.handleSubmit.bind(_this);
	    return _this;
	  }
	
	  _createClass(InsertEmbedModal, [{
	    key: 'componentWillMount',
	    value: function componentWillMount() {
	      this.setOverrides(this.props);
	    }
	  }, {
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(props) {
	      if (props.isOpen && !this.props.isOpen) {
	        this.setOverrides(props);
	      }
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      this.clearOverrides();
	    }
	
	    /**
	     * Compares the current properties with received properties and determines if overrides need to be
	     * cleared or added.
	     *
	     * @param {object} props
	     */
	
	  }, {
	    key: 'setOverrides',
	    value: function setOverrides(props) {
	      if (this.props.schemaUrl !== props.schemaUrl) {
	        this.clearOverrides();
	      }
	      if (props.schemaUrl) {
	        var attrs = Object.assign({}, props.fileAttributes);
	        delete attrs.ID;
	
	        var overrides = {
	          fields: Object.entries(attrs).map(function (field) {
	            var _field = _slicedToArray(field, 2),
	                name = _field[0],
	                value = _field[1];
	
	            return { name: name, value: value };
	          })
	        };
	        // set overrides into redux store, so that it can be accessed by FormBuilder with the same
	        // schemaUrl.
	        this.props.actions.schema.setSchemaStateOverrides(props.schemaUrl, overrides);
	      }
	    }
	
	    /**
	     * Generates the properties for the modal
	     *
	     * @returns {object}
	     */
	
	  }, {
	    key: 'getModalProps',
	    value: function getModalProps() {
	      var props = Object.assign({
	        onSubmit: this.handleSubmit,
	        onLoadingError: this.handleLoadingError,
	        showErrorMessage: true,
	        responseClassBad: 'alert alert-danger',
	        identifier: 'AssetAdmin.InsertEmbedModal'
	      }, this.props, {
	        className: 'insert-embed-modal ' + this.props.className,
	        size: 'lg',
	        onClosed: this.props.onClosed,
	        title: this.props.targetUrl ? _i18n2.default._t('AssetAdmin.EditTitle', 'Media from the web') : _i18n2.default._t('AssetAdmin.CreateTitle', 'Insert new media from the web')
	      });
	      delete props.sectionConfig;
	      delete props.onInsert;
	      delete props.fileAttributes;
	
	      return props;
	    }
	
	    /**
	     * Clear any overrides that may be in place
	     */
	
	  }, {
	    key: 'clearOverrides',
	    value: function clearOverrides() {
	      this.props.actions.schema.setSchemaStateOverrides(this.props.schemaUrl, null);
	    }
	
	    /**
	     * Handler for when loading the form returns an error
	     *
	     * @param error
	     */
	
	  }, {
	    key: 'handleLoadingError',
	    value: function handleLoadingError(error) {
	      if (typeof this.props.onLoadingError === 'function') {
	        this.props.onLoadingError(error);
	      }
	    }
	
	    /**
	     * Capture submission in the form and stop the default submit behaviour
	     *
	     * @param data
	     * @param action
	     * @returns {Promise}
	     */
	
	  }, {
	    key: 'handleSubmit',
	    value: function handleSubmit(data, action) {
	      switch (action) {
	        case 'action_addmedia':
	          {
	            this.props.onCreate(data);
	            break;
	          }
	        case 'action_insertmedia':
	          {
	            this.props.onInsert(data);
	            break;
	          }
	        case 'action_cancel':
	          {
	            this.props.onClosed();
	            break;
	          }
	        default:
	          {
	            // noop
	          }
	      }
	
	      return Promise.resolve();
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement(_FormBuilderModal2.default, this.getModalProps());
	    }
	  }]);
	
	  return InsertEmbedModal;
	}(_react.Component);
	
	InsertEmbedModal.propTypes = {
	  sectionConfig: _propTypes2.default.shape({
	    url: _propTypes2.default.string,
	    form: _propTypes2.default.object
	  }),
	  isOpen: _propTypes2.default.bool,
	  onInsert: _propTypes2.default.func.isRequired,
	  onCreate: _propTypes2.default.func.isRequired,
	  fileAttributes: _propTypes2.default.shape({
	    Url: _propTypes2.default.string,
	    CaptionText: _propTypes2.default.string,
	    PreviewUrl: _propTypes2.default.string,
	    Placement: _propTypes2.default.string,
	    Width: _propTypes2.default.number,
	    Height: _propTypes2.default.number
	  }),
	  onClosed: _propTypes2.default.func.isRequired,
	  className: _propTypes2.default.string,
	  actions: _propTypes2.default.object,
	  schemaUrl: _propTypes2.default.string.isRequired,
	  targetUrl: _propTypes2.default.string,
	  onLoadingError: _propTypes2.default.func
	};
	
	InsertEmbedModal.defaultProps = {
	  className: '',
	  fileAttributes: {}
	};
	
	function mapStateToProps(state, ownProps) {
	  var sectionConfig = state.config.sections.find(function (section) {
	    return section.name === sectionConfigKey;
	  });
	
	  // get the schemaUrl to use as a key for overrides
	  var targetUrl = ownProps.fileAttributes ? ownProps.fileAttributes.Url : '';
	  var baseEditUrl = sectionConfig.form.remoteEditForm.schemaUrl;
	
	  var editUrl = targetUrl && baseEditUrl + '/?embedurl=' + encodeURIComponent(targetUrl);
	  var createUrl = sectionConfig.form.remoteCreateForm.schemaUrl;
	
	  var schemaUrl = editUrl || createUrl;
	
	  return {
	    sectionConfig: sectionConfig,
	    schemaUrl: schemaUrl,
	    targetUrl: targetUrl
	  };
	}
	
	function mapDispatchToProps(dispatch) {
	  return {
	    actions: {
	      schema: (0, _redux.bindActionCreators)(schemaActions, dispatch)
	    }
	  };
	}
	
	exports.Component = InsertEmbedModal;
	exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(InsertEmbedModal);

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	module.exports = i18n;

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	module.exports = Redux;

/***/ }),
/* 11 */
/***/ (function(module, exports) {

	module.exports = ReactRedux;

/***/ }),
/* 12 */
/***/ (function(module, exports) {

	module.exports = FormBuilderModal;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

	module.exports = SchemaActions;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactIs = __webpack_require__(16);
	
	  // By explicitly using `prop-types` you are opting into new development behavior.
	  // http://fb.me/prop-types-in-prod
	  var throwOnDirectAccess = true;
	  module.exports = __webpack_require__(19)(ReactIs.isElement, throwOnDirectAccess);
	} else {
	  // By explicitly using `prop-types` you are opting into new production behavior.
	  // http://fb.me/prop-types-in-prod
	  module.exports = __webpack_require__(23)();
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)))

/***/ }),
/* 15 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;
	
	process.listeners = function (name) { return [] }
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	if (process.env.NODE_ENV === 'production') {
	  module.exports = __webpack_require__(17);
	} else {
	  module.exports = __webpack_require__(18);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)))

/***/ }),
/* 17 */
/***/ (function(module, exports) {

	/** @license React v16.13.1
	 * react-is.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	
	'use strict';var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
	Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
	function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;exports.Lazy=t;exports.Memo=r;exports.Portal=d;
	exports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isAsyncMode=function(a){return A(a)||z(a)===l};exports.isConcurrentMode=A;exports.isContextConsumer=function(a){return z(a)===k};exports.isContextProvider=function(a){return z(a)===h};exports.isElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return z(a)===n};exports.isFragment=function(a){return z(a)===e};exports.isLazy=function(a){return z(a)===t};
	exports.isMemo=function(a){return z(a)===r};exports.isPortal=function(a){return z(a)===d};exports.isProfiler=function(a){return z(a)===g};exports.isStrictMode=function(a){return z(a)===f};exports.isSuspense=function(a){return z(a)===p};
	exports.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};exports.typeOf=z;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.13.1
	 * react-is.development.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	
	'use strict';
	
	
	
	if (process.env.NODE_ENV !== "production") {
	  (function() {
	'use strict';
	
	// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var hasSymbol = typeof Symbol === 'function' && Symbol.for;
	var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
	var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
	var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
	var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
	var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
	var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
	var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
	// (unstable) APIs that have been removed. Can we remove the symbols?
	
	var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
	var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
	var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
	var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
	var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
	var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
	var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
	var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
	var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
	var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
	var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;
	
	function isValidElementType(type) {
	  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
	  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
	}
	
	function typeOf(object) {
	  if (typeof object === 'object' && object !== null) {
	    var $$typeof = object.$$typeof;
	
	    switch ($$typeof) {
	      case REACT_ELEMENT_TYPE:
	        var type = object.type;
	
	        switch (type) {
	          case REACT_ASYNC_MODE_TYPE:
	          case REACT_CONCURRENT_MODE_TYPE:
	          case REACT_FRAGMENT_TYPE:
	          case REACT_PROFILER_TYPE:
	          case REACT_STRICT_MODE_TYPE:
	          case REACT_SUSPENSE_TYPE:
	            return type;
	
	          default:
	            var $$typeofType = type && type.$$typeof;
	
	            switch ($$typeofType) {
	              case REACT_CONTEXT_TYPE:
	              case REACT_FORWARD_REF_TYPE:
	              case REACT_LAZY_TYPE:
	              case REACT_MEMO_TYPE:
	              case REACT_PROVIDER_TYPE:
	                return $$typeofType;
	
	              default:
	                return $$typeof;
	            }
	
	        }
	
	      case REACT_PORTAL_TYPE:
	        return $$typeof;
	    }
	  }
	
	  return undefined;
	} // AsyncMode is deprecated along with isAsyncMode
	
	var AsyncMode = REACT_ASYNC_MODE_TYPE;
	var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
	var ContextConsumer = REACT_CONTEXT_TYPE;
	var ContextProvider = REACT_PROVIDER_TYPE;
	var Element = REACT_ELEMENT_TYPE;
	var ForwardRef = REACT_FORWARD_REF_TYPE;
	var Fragment = REACT_FRAGMENT_TYPE;
	var Lazy = REACT_LAZY_TYPE;
	var Memo = REACT_MEMO_TYPE;
	var Portal = REACT_PORTAL_TYPE;
	var Profiler = REACT_PROFILER_TYPE;
	var StrictMode = REACT_STRICT_MODE_TYPE;
	var Suspense = REACT_SUSPENSE_TYPE;
	var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated
	
	function isAsyncMode(object) {
	  {
	    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
	      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint
	
	      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
	    }
	  }
	
	  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
	}
	function isConcurrentMode(object) {
	  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
	}
	function isContextConsumer(object) {
	  return typeOf(object) === REACT_CONTEXT_TYPE;
	}
	function isContextProvider(object) {
	  return typeOf(object) === REACT_PROVIDER_TYPE;
	}
	function isElement(object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	}
	function isForwardRef(object) {
	  return typeOf(object) === REACT_FORWARD_REF_TYPE;
	}
	function isFragment(object) {
	  return typeOf(object) === REACT_FRAGMENT_TYPE;
	}
	function isLazy(object) {
	  return typeOf(object) === REACT_LAZY_TYPE;
	}
	function isMemo(object) {
	  return typeOf(object) === REACT_MEMO_TYPE;
	}
	function isPortal(object) {
	  return typeOf(object) === REACT_PORTAL_TYPE;
	}
	function isProfiler(object) {
	  return typeOf(object) === REACT_PROFILER_TYPE;
	}
	function isStrictMode(object) {
	  return typeOf(object) === REACT_STRICT_MODE_TYPE;
	}
	function isSuspense(object) {
	  return typeOf(object) === REACT_SUSPENSE_TYPE;
	}
	
	exports.AsyncMode = AsyncMode;
	exports.ConcurrentMode = ConcurrentMode;
	exports.ContextConsumer = ContextConsumer;
	exports.ContextProvider = ContextProvider;
	exports.Element = Element;
	exports.ForwardRef = ForwardRef;
	exports.Fragment = Fragment;
	exports.Lazy = Lazy;
	exports.Memo = Memo;
	exports.Portal = Portal;
	exports.Profiler = Profiler;
	exports.StrictMode = StrictMode;
	exports.Suspense = Suspense;
	exports.isAsyncMode = isAsyncMode;
	exports.isConcurrentMode = isConcurrentMode;
	exports.isContextConsumer = isContextConsumer;
	exports.isContextProvider = isContextProvider;
	exports.isElement = isElement;
	exports.isForwardRef = isForwardRef;
	exports.isFragment = isFragment;
	exports.isLazy = isLazy;
	exports.isMemo = isMemo;
	exports.isPortal = isPortal;
	exports.isProfiler = isProfiler;
	exports.isStrictMode = isStrictMode;
	exports.isSuspense = isSuspense;
	exports.isValidElementType = isValidElementType;
	exports.typeOf = typeOf;
	  })();
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)))

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	
	'use strict';
	
	var ReactIs = __webpack_require__(16);
	var assign = __webpack_require__(20);
	
	var ReactPropTypesSecret = __webpack_require__(21);
	var checkPropTypes = __webpack_require__(22);
	
	var has = Function.call.bind(Object.prototype.hasOwnProperty);
	var printWarning = function() {};
	
	if (process.env.NODE_ENV !== 'production') {
	  printWarning = function(text) {
	    var message = 'Warning: ' + text;
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };
	}
	
	function emptyFunctionThatReturnsNull() {
	  return null;
	}
	
	module.exports = function(isValidElement, throwOnDirectAccess) {
	  /* global Symbol */
	  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	  /**
	   * Returns the iterator method function contained on the iterable object.
	   *
	   * Be sure to invoke the function with the iterable as context:
	   *
	   *     var iteratorFn = getIteratorFn(myIterable);
	   *     if (iteratorFn) {
	   *       var iterator = iteratorFn.call(myIterable);
	   *       ...
	   *     }
	   *
	   * @param {?object} maybeIterable
	   * @return {?function}
	   */
	  function getIteratorFn(maybeIterable) {
	    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }
	
	  /**
	   * Collection of methods that allow declaration and validation of props that are
	   * supplied to React components. Example usage:
	   *
	   *   var Props = require('ReactPropTypes');
	   *   var MyArticle = React.createClass({
	   *     propTypes: {
	   *       // An optional string prop named "description".
	   *       description: Props.string,
	   *
	   *       // A required enum prop named "category".
	   *       category: Props.oneOf(['News','Photos']).isRequired,
	   *
	   *       // A prop named "dialog" that requires an instance of Dialog.
	   *       dialog: Props.instanceOf(Dialog).isRequired
	   *     },
	   *     render: function() { ... }
	   *   });
	   *
	   * A more formal specification of how these methods are used:
	   *
	   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	   *   decl := ReactPropTypes.{type}(.isRequired)?
	   *
	   * Each and every declaration produces a function with the same signature. This
	   * allows the creation of custom validation functions. For example:
	   *
	   *  var MyLink = React.createClass({
	   *    propTypes: {
	   *      // An optional string or URI prop named "href".
	   *      href: function(props, propName, componentName) {
	   *        var propValue = props[propName];
	   *        if (propValue != null && typeof propValue !== 'string' &&
	   *            !(propValue instanceof URI)) {
	   *          return new Error(
	   *            'Expected a string or an URI for ' + propName + ' in ' +
	   *            componentName
	   *          );
	   *        }
	   *      }
	   *    },
	   *    render: function() {...}
	   *  });
	   *
	   * @internal
	   */
	
	  var ANONYMOUS = '<<anonymous>>';
	
	  // Important!
	  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
	  var ReactPropTypes = {
	    array: createPrimitiveTypeChecker('array'),
	    bool: createPrimitiveTypeChecker('boolean'),
	    func: createPrimitiveTypeChecker('function'),
	    number: createPrimitiveTypeChecker('number'),
	    object: createPrimitiveTypeChecker('object'),
	    string: createPrimitiveTypeChecker('string'),
	    symbol: createPrimitiveTypeChecker('symbol'),
	
	    any: createAnyTypeChecker(),
	    arrayOf: createArrayOfTypeChecker,
	    element: createElementTypeChecker(),
	    elementType: createElementTypeTypeChecker(),
	    instanceOf: createInstanceTypeChecker,
	    node: createNodeChecker(),
	    objectOf: createObjectOfTypeChecker,
	    oneOf: createEnumTypeChecker,
	    oneOfType: createUnionTypeChecker,
	    shape: createShapeTypeChecker,
	    exact: createStrictShapeTypeChecker,
	  };
	
	  /**
	   * inlined Object.is polyfill to avoid requiring consumers ship their own
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	   */
	  /*eslint-disable no-self-compare*/
	  function is(x, y) {
	    // SameValue algorithm
	    if (x === y) {
	      // Steps 1-5, 7-10
	      // Steps 6.b-6.e: +0 != -0
	      return x !== 0 || 1 / x === 1 / y;
	    } else {
	      // Step 6.a: NaN == NaN
	      return x !== x && y !== y;
	    }
	  }
	  /*eslint-enable no-self-compare*/
	
	  /**
	   * We use an Error-like object for backward compatibility as people may call
	   * PropTypes directly and inspect their output. However, we don't use real
	   * Errors anymore. We don't inspect their stack anyway, and creating them
	   * is prohibitively expensive if they are created too often, such as what
	   * happens in oneOfType() for any type before the one that matched.
	   */
	  function PropTypeError(message) {
	    this.message = message;
	    this.stack = '';
	  }
	  // Make `instanceof Error` still work for returned errors.
	  PropTypeError.prototype = Error.prototype;
	
	  function createChainableTypeChecker(validate) {
	    if (process.env.NODE_ENV !== 'production') {
	      var manualPropTypeCallCache = {};
	      var manualPropTypeWarningCount = 0;
	    }
	    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	      componentName = componentName || ANONYMOUS;
	      propFullName = propFullName || propName;
	
	      if (secret !== ReactPropTypesSecret) {
	        if (throwOnDirectAccess) {
	          // New behavior only for users of `prop-types` package
	          var err = new Error(
	            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	            'Use `PropTypes.checkPropTypes()` to call them. ' +
	            'Read more at http://fb.me/use-check-prop-types'
	          );
	          err.name = 'Invariant Violation';
	          throw err;
	        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
	          // Old behavior for people using React.PropTypes
	          var cacheKey = componentName + ':' + propName;
	          if (
	            !manualPropTypeCallCache[cacheKey] &&
	            // Avoid spamming the console because they are often not actionable except for lib authors
	            manualPropTypeWarningCount < 3
	          ) {
	            printWarning(
	              'You are manually calling a React.PropTypes validation ' +
	              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
	              'and will throw in the standalone `prop-types` package. ' +
	              'You may be seeing this warning due to a third-party PropTypes ' +
	              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
	            );
	            manualPropTypeCallCache[cacheKey] = true;
	            manualPropTypeWarningCount++;
	          }
	        }
	      }
	      if (props[propName] == null) {
	        if (isRequired) {
	          if (props[propName] === null) {
	            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	          }
	          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	        }
	        return null;
	      } else {
	        return validate(props, propName, componentName, location, propFullName);
	      }
	    }
	
	    var chainedCheckType = checkType.bind(null, false);
	    chainedCheckType.isRequired = checkType.bind(null, true);
	
	    return chainedCheckType;
	  }
	
	  function createPrimitiveTypeChecker(expectedType) {
	    function validate(props, propName, componentName, location, propFullName, secret) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== expectedType) {
	        // `propValue` being instance of, say, date/regexp, pass the 'object'
	        // check, but we can offer a more precise error message here rather than
	        // 'of type `object`'.
	        var preciseType = getPreciseType(propValue);
	
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createAnyTypeChecker() {
	    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
	  }
	
	  function createArrayOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	      }
	      var propValue = props[propName];
	      if (!Array.isArray(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	      }
	      for (var i = 0; i < propValue.length; i++) {
	        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createElementTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!isValidElement(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createElementTypeTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!ReactIs.isValidElementType(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createInstanceTypeChecker(expectedClass) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!(props[propName] instanceof expectedClass)) {
	        var expectedClassName = expectedClass.name || ANONYMOUS;
	        var actualClassName = getClassName(props[propName]);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createEnumTypeChecker(expectedValues) {
	    if (!Array.isArray(expectedValues)) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (arguments.length > 1) {
	          printWarning(
	            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
	            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
	          );
	        } else {
	          printWarning('Invalid argument supplied to oneOf, expected an array.');
	        }
	      }
	      return emptyFunctionThatReturnsNull;
	    }
	
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      for (var i = 0; i < expectedValues.length; i++) {
	        if (is(propValue, expectedValues[i])) {
	          return null;
	        }
	      }
	
	      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
	        var type = getPreciseType(value);
	        if (type === 'symbol') {
	          return String(value);
	        }
	        return value;
	      });
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createObjectOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	      }
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	      }
	      for (var key in propValue) {
	        if (has(propValue, key)) {
	          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	          if (error instanceof Error) {
	            return error;
	          }
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createUnionTypeChecker(arrayOfTypeCheckers) {
	    if (!Array.isArray(arrayOfTypeCheckers)) {
	      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	      return emptyFunctionThatReturnsNull;
	    }
	
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (typeof checker !== 'function') {
	        printWarning(
	          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
	          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
	        );
	        return emptyFunctionThatReturnsNull;
	      }
	    }
	
	    function validate(props, propName, componentName, location, propFullName) {
	      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	        var checker = arrayOfTypeCheckers[i];
	        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
	          return null;
	        }
	      }
	
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createNodeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!isNode(props[propName])) {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      for (var key in shapeTypes) {
	        var checker = shapeTypes[key];
	        if (!checker) {
	          continue;
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }
	
	  function createStrictShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      // We need to check all keys in case some are required but missing from
	      // props.
	      var allKeys = assign({}, props[propName], shapeTypes);
	      for (var key in allKeys) {
	        var checker = shapeTypes[key];
	        if (!checker) {
	          return new PropTypeError(
	            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
	            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
	            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
	          );
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }
	
	    return createChainableTypeChecker(validate);
	  }
	
	  function isNode(propValue) {
	    switch (typeof propValue) {
	      case 'number':
	      case 'string':
	      case 'undefined':
	        return true;
	      case 'boolean':
	        return !propValue;
	      case 'object':
	        if (Array.isArray(propValue)) {
	          return propValue.every(isNode);
	        }
	        if (propValue === null || isValidElement(propValue)) {
	          return true;
	        }
	
	        var iteratorFn = getIteratorFn(propValue);
	        if (iteratorFn) {
	          var iterator = iteratorFn.call(propValue);
	          var step;
	          if (iteratorFn !== propValue.entries) {
	            while (!(step = iterator.next()).done) {
	              if (!isNode(step.value)) {
	                return false;
	              }
	            }
	          } else {
	            // Iterator will provide entry [k,v] tuples rather than values.
	            while (!(step = iterator.next()).done) {
	              var entry = step.value;
	              if (entry) {
	                if (!isNode(entry[1])) {
	                  return false;
	                }
	              }
	            }
	          }
	        } else {
	          return false;
	        }
	
	        return true;
	      default:
	        return false;
	    }
	  }
	
	  function isSymbol(propType, propValue) {
	    // Native Symbol.
	    if (propType === 'symbol') {
	      return true;
	    }
	
	    // falsy value can't be a Symbol
	    if (!propValue) {
	      return false;
	    }
	
	    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	    if (propValue['@@toStringTag'] === 'Symbol') {
	      return true;
	    }
	
	    // Fallback for non-spec compliant Symbols which are polyfilled.
	    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	      return true;
	    }
	
	    return false;
	  }
	
	  // Equivalent of `typeof` but with special handling for array and regexp.
	  function getPropType(propValue) {
	    var propType = typeof propValue;
	    if (Array.isArray(propValue)) {
	      return 'array';
	    }
	    if (propValue instanceof RegExp) {
	      // Old webkits (at least until Android 4.0) return 'function' rather than
	      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	      // passes PropTypes.object.
	      return 'object';
	    }
	    if (isSymbol(propType, propValue)) {
	      return 'symbol';
	    }
	    return propType;
	  }
	
	  // This handles more types than `getPropType`. Only used for error messages.
	  // See `createPrimitiveTypeChecker`.
	  function getPreciseType(propValue) {
	    if (typeof propValue === 'undefined' || propValue === null) {
	      return '' + propValue;
	    }
	    var propType = getPropType(propValue);
	    if (propType === 'object') {
	      if (propValue instanceof Date) {
	        return 'date';
	      } else if (propValue instanceof RegExp) {
	        return 'regexp';
	      }
	    }
	    return propType;
	  }
	
	  // Returns a string that is postfixed to a warning about an invalid type.
	  // For example, "undefined" or "of type array"
	  function getPostfixForTypeWarning(value) {
	    var type = getPreciseType(value);
	    switch (type) {
	      case 'array':
	      case 'object':
	        return 'an ' + type;
	      case 'boolean':
	      case 'date':
	      case 'regexp':
	        return 'a ' + type;
	      default:
	        return type;
	    }
	  }
	
	  // Returns class name of the object, if any.
	  function getClassName(propValue) {
	    if (!propValue.constructor || !propValue.constructor.name) {
	      return ANONYMOUS;
	    }
	    return propValue.constructor.name;
	  }
	
	  ReactPropTypes.checkPropTypes = checkPropTypes;
	  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
	  ReactPropTypes.PropTypes = ReactPropTypes;
	
	  return ReactPropTypes;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)))

/***/ }),
/* 20 */
/***/ (function(module, exports) {

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/
	
	'use strict';
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}
	
			// Detect buggy property enumeration order in older V8 versions.
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}
	
			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}
	
	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;
	
		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);
	
			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}
	
			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}
	
		return to;
	};


/***/ }),
/* 21 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	
	'use strict';
	
	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	
	module.exports = ReactPropTypesSecret;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	
	'use strict';
	
	var printWarning = function() {};
	
	if (process.env.NODE_ENV !== 'production') {
	  var ReactPropTypesSecret = __webpack_require__(21);
	  var loggedTypeFailures = {};
	  var has = Function.call.bind(Object.prototype.hasOwnProperty);
	
	  printWarning = function(text) {
	    var message = 'Warning: ' + text;
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };
	}
	
	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 * @private
	 */
	function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
	  if (process.env.NODE_ENV !== 'production') {
	    for (var typeSpecName in typeSpecs) {
	      if (has(typeSpecs, typeSpecName)) {
	        var error;
	        // Prop type validation may throw. In case they do, we don't want to
	        // fail the render phase where it didn't fail before. So we log it.
	        // After these have been cleaned up, we'll let them throw.
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          if (typeof typeSpecs[typeSpecName] !== 'function') {
	            var err = Error(
	              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
	              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
	            );
	            err.name = 'Invariant Violation';
	            throw err;
	          }
	          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	        } catch (ex) {
	          error = ex;
	        }
	        if (error && !(error instanceof Error)) {
	          printWarning(
	            (componentName || 'React class') + ': type specification of ' +
	            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
	            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
	            'You may have forgotten to pass an argument to the type checker ' +
	            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
	            'shape all require an argument).'
	          );
	        }
	        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	          // Only monitor this failure once because there tends to be a lot of the
	          // same error.
	          loggedTypeFailures[error.message] = true;
	
	          var stack = getStack ? getStack() : '';
	
	          printWarning(
	            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
	          );
	        }
	      }
	    }
	  }
	}
	
	/**
	 * Resets warning cache when testing.
	 *
	 * @private
	 */
	checkPropTypes.resetWarningCache = function() {
	  if (process.env.NODE_ENV !== 'production') {
	    loggedTypeFailures = {};
	  }
	}
	
	module.exports = checkPropTypes;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(15)))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	
	'use strict';
	
	var ReactPropTypesSecret = __webpack_require__(21);
	
	function emptyFunction() {}
	function emptyFunctionWithReset() {}
	emptyFunctionWithReset.resetWarningCache = emptyFunction;
	
	module.exports = function() {
	  function shim(props, propName, componentName, location, propFullName, secret) {
	    if (secret === ReactPropTypesSecret) {
	      // It is still safe when called from React.
	      return;
	    }
	    var err = new Error(
	      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	      'Use PropTypes.checkPropTypes() to call them. ' +
	      'Read more at http://fb.me/use-check-prop-types'
	    );
	    err.name = 'Invariant Violation';
	    throw err;
	  };
	  shim.isRequired = shim;
	  function getShim() {
	    return shim;
	  };
	  // Important!
	  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
	  var ReactPropTypes = {
	    array: shim,
	    bool: shim,
	    func: shim,
	    number: shim,
	    object: shim,
	    string: shim,
	    symbol: shim,
	
	    any: shim,
	    arrayOf: getShim,
	    element: shim,
	    elementType: shim,
	    instanceOf: getShim,
	    node: shim,
	    objectOf: getShim,
	    oneOf: getShim,
	    oneOfType: getShim,
	    shape: getShim,
	    exact: getShim,
	
	    checkPropTypes: emptyFunctionWithReset,
	    resetWarningCache: emptyFunction
	  };
	
	  ReactPropTypes.PropTypes = ReactPropTypes;
	
	  return ReactPropTypes;
	};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _jquery = __webpack_require__(2);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _react = __webpack_require__(3);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(4);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _reactApollo = __webpack_require__(25);
	
	var _Injector = __webpack_require__(6);
	
	var _InsertMediaModal = __webpack_require__(26);
	
	var _InsertMediaModal2 = _interopRequireDefault(_InsertMediaModal);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var InjectableInsertMediaModal = (0, _Injector.loadComponent)(_InsertMediaModal2.default);
	
	_jquery2.default.entwine('ss', function ($) {
	
	    $('#insert-md-media-react__dialog-wrapper').entwine({
	
	        Element: null,
	        Data: {},
	        onunmatch: function onunmatch() {
	            // solves errors given by ReactDOM "no matched root found" error.
	            this._clearModal();
	        },
	        _clearModal: function _clearModal() {
	            _reactDom2.default.unmountComponentAtNode(this[0]);
	        },
	        open: function open() {
	            this._renderModal(true);
	        },
	        close: function close() {
	            this._renderModal(false);
	        },
	
	
	        /**
	         * Renders the react modal component
	         *
	         * @param {boolean} show
	         * @private
	         */
	        _renderModal: function _renderModal(isOpen) {
	            var _this = this;
	
	            if (!InjectableInsertMediaModal) {
	                throw new Error('Embed is not supported, Install silverstripe/asset-admin');
	            }
	            var handleHide = function handleHide() {
	                return _this.close();
	            };
	            var handleInsert = function handleInsert() {
	                return _this._handleInsert.apply(_this, arguments);
	            };
	            var store = window.ss.store;
	            var client = window.ss.apolloClient;
	            var attrs = this.getOriginalAttributes();
	
	            delete attrs.url;
	
	            // create/update the react component
	            _reactDom2.default.render(_react2.default.createElement(
	                _reactApollo.ApolloProvider,
	                { store: store, client: client },
	                _react2.default.createElement(InjectableInsertMediaModal, {
	                    isOpen: isOpen,
	                    title: false,
	                    type: 'insert-media',
	                    onInsert: handleInsert,
	                    onClosed: handleHide,
	                    bodyClassName: 'modal__dialog',
	                    className: 'insert-media-react__dialog-wrapper',
	                    requireLinkText: false,
	                    fileAttributes: attrs
	                })
	            ), this[0]);
	        },
	
	
	        /**
	         * Handles inserting the selected file in the modal
	         *
	         * @param {object} data
	         * @param {object} file
	         * @returns {Promise}
	         * @private
	         */
	        _handleInsert: function _handleInsert(data, file) {
	            var result = false;
	            this.setData(Object.assign({}, data, file));
	
	            // Sometimes AssetAdmin.js handleSubmitEditor() can't find the file
	            // @todo Ensure that we always return a file for any valid ID
	
	            // in case of any errors, better to catch them than let them go silent
	            try {
	                var category = null;
	                if (file) {
	                    category = file.category;
	                } else {
	                    category = 'image';
	                }
	                switch (category) {
	                    case 'image':
	                        result = this.insertImage();
	                        break;
	                    default:
	                        result = this.insertFile();
	                }
	            } catch (e) {
	                this.statusMessage(e, 'bad');
	            }
	
	            if (result) {
	                this.close();
	            }
	            return Promise.resolve();
	        },
	
	
	        /**
	         * Find the selected node and get attributes associated to attach the data to the form
	         *
	         * @returns {object}
	         */
	        getOriginalAttributes: function getOriginalAttributes() {
	            return {};
	        },
	
	
	        /**
	         * Calculate placement from css class
	         */
	        findPosition: function findPosition(cssClass) {
	            var alignments = ['leftAlone', 'center', 'rightAlone', 'left', 'right'];
	            return alignments.find(function (alignment) {
	                var expr = new RegExp('\\b' + alignment + '\\b');
	                return expr.test(cssClass);
	            });
	        },
	
	
	        /**
	         * Get html attributes from the Form data
	         *
	         * @returns {object}
	         */
	        getAttributes: function getAttributes() {
	            var data = this.getData();
	
	            return {
	                src: data.url,
	                alt: data.AltText,
	                width: data.InsertWidth,
	                height: data.InsertHeight,
	                title: data.TitleTooltip,
	                class: data.Alignment,
	                'data-id': data.ID,
	                'data-shortcode': 'image'
	            };
	        },
	
	
	        /**
	         * Get extra data not part of the actual element we're adding/modifying (e.g. Caption)
	         * @returns {object}
	         */
	        getExtraData: function getExtraData() {
	            var data = this.getData();
	            return {
	                CaptionText: data && data.Caption
	            };
	        },
	
	
	        /**
	         * Generic handler for inserting a file
	         *
	         * NOTE: currently not supported
	         *
	         * @returns {boolean} success
	         */
	        insertFile: function insertFile() {
	            var $field = this.getElement();
	            var data = this.getData();
	            var linkText = data.title || data.filename;
	            var markdown = '[' + linkText + ']([file_link,id=' + data.ID + '])';
	
	            var pos = $field.codemirror.getCursor();
	            $field.codemirror.setSelection(pos, pos);
	            $field.codemirror.replaceSelection("\n" + markdown + "\n");
	            this.updateTextarea();
	            return true;
	        },
	
	
	        /**
	         * Handler for inserting an image
	         *
	         * @returns {boolean} success
	         */
	        insertImage: function insertImage() {
	            var $field = this.getElement();
	            if (!$field) {
	                return false;
	            }
	            var data = this.getData();
	            var extraData = this.getExtraData();
	            var markdown = '![' + (extraData.CaptionText ? extraData.CaptionText : data.title) + ']([image_link id=' + data.ID + ' width=' + data.InsertWidth + ' height=' + data.InsertHeight + ' url=\'' + data.url + '\'] "' + data.title + '")';
	
	            var pos = $field.codemirror.getCursor();
	            $field.codemirror.setSelection(pos, pos);
	            $field.codemirror.replaceSelection("\n" + markdown + "\n");
	            this.updateTextarea();
	            return true;
	        },
	
	
	        /**
	         * Pop up a status message if required to notify the user what is happening
	         *
	         * @param text
	         * @param type
	         */
	        statusMessage: function statusMessage(text, type) {
	            var content = $('<div/>').text(text).html(); // Escape HTML entities in text
	            $.noticeAdd({
	                text: content,
	                type: type,
	                stayTime: 5000,
	                inEffect: { left: '0', opacity: 'show' }
	            });
	        },
	        updateTextarea: function updateTextarea() {
	            var $field = this.getElement();
	            $($field.element).closest('.js-markdown-holder').find('textarea.markdowneditor').val($field.value());
	        }
	    });
	});

/***/ }),
/* 25 */
/***/ (function(module, exports) {

	module.exports = ReactApollo;

/***/ }),
/* 26 */
/***/ (function(module, exports) {

	module.exports = InsertMediaModal;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(3);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(4);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _reactSimplemdeEditor = __webpack_require__(28);
	
	var _reactSimplemdeEditor2 = _interopRequireDefault(_reactSimplemdeEditor);
	
	var _Injector = __webpack_require__(6);
	
	var _jquery = __webpack_require__(2);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _ShortcodeParser = __webpack_require__(33);
	
	var _ShortcodeParser2 = _interopRequireDefault(_ShortcodeParser);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var SimpleMDE = __webpack_require__(37);
	
	var parser = new _ShortcodeParser2.default();
	
	var ss = typeof window.ss !== 'undefined' ? window.ss : {};
	if (typeof ss.markdownConfigs == 'undefined') {
	    ss.markdownConfigs = {};
	}
	
	ss.markdownConfigs.readToolbarConfigs = function (data) {
	    var toolbar = [];
	    for (var key in data) {
	        var element = data[key];
	        if (typeof element == 'string') {
	            toolbar.push(element);
	        } else {
	            (function () {
	                var _action = element.action;
	                if (typeof SimpleMDE[element.action] !== 'undefined') {
	                    toolbar.push({
	                        name: element.name,
	                        action: SimpleMDE[element.action],
	                        className: element.className,
	                        title: element.title
	                    });
	                } else if (typeof ss.markdownConfigs[element.action] !== 'undefined') {
	                    toolbar.push({
	                        name: element.name,
	                        action: function action(editor) {
	                            ss.markdownConfigs[_action](editor);
	                        },
	                        className: element.className,
	                        title: element.title
	                    });
	                }
	            })();
	        }
	    }
	    return toolbar;
	};
	
	parser.registerShortCode('image_link', function (buffer, opts) {
	    return opts.url;
	});
	
	parser.registerShortCode('embed', function (buffer, opts) {
	    return '<img src="' + opts.thumbnail + '" width="' + opts.width + '" height="' + opts.height + '">';
	});
	
	var MarkdownEditorField = function (_React$Component) {
	    _inherits(MarkdownEditorField, _React$Component);
	
	    function MarkdownEditorField(props) {
	        _classCallCheck(this, MarkdownEditorField);
	
	        var _this = _possibleConstructorReturn(this, (MarkdownEditorField.__proto__ || Object.getPrototypeOf(MarkdownEditorField)).call(this, props));
	
	        _this.state = ss.markdownConfigs;
	        return _this;
	    }
	
	    _createClass(MarkdownEditorField, [{
	        key: 'handleChange',
	        value: function handleChange(value) {
	            this.props.textarea.value = value;
	        }
	    }, {
	        key: 'previewRender',
	        value: function previewRender(plainText, preview) {
	            preview.classList.add('markdown-preview');
	            preview.classList.add(this.identifier);
	            var parsedText = parser.parse(plainText);
	            return this.parent.markdown(parsedText);
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { className: 'editor-container' },
	                _react2.default.createElement(_reactSimplemdeEditor2.default, {
	                    value: this.props.textarea.value,
	                    onChange: this.handleChange.bind(this),
	                    options: {
	                        spellChecker: true,
	                        dragDrop: false,
	                        keyMap: "sublime",
	                        toolbar: this.props.toolbar,
	                        previewRender: this.previewRender,
	                        identifier: this.props.identifier,
	                        showIcons: ["code", "table"]
	                    }
	                })
	            );
	        }
	    }], [{
	        key: 'addCustomAction',
	        value: function addCustomAction(key, action) {
	            ss.markdownConfigs[key] = action;
	        }
	    }, {
	        key: 'registerShortCodes',
	        value: function registerShortCodes(key, callback) {}
	    }]);
	
	    return MarkdownEditorField;
	}(_react2.default.Component);
	
	window.MarkdownEditorField = MarkdownEditorField;
	
	_jquery2.default.entwine('ss', function ($) {
	
	    MarkdownEditorField.addCustomAction('ssEmbed', function (editor) {
	        if (window.InsertEmbedModal) {
	            var dialog = $('#insert-md-embed-react__dialog-wrapper');
	            if (!dialog.length) {
	                dialog = $('<div id="insert-md-embed-react__dialog-wrapper" />');
	                $('body').append(dialog);
	            }
	            dialog.setElement(editor);
	            dialog.open();
	        } else {
	            alert('Media embed is not supported');
	        }
	    });
	
	    MarkdownEditorField.addCustomAction('ssImage', function (editor) {
	        if (window.InsertMediaModal) {
	            var dialog = $('#insert-md-media-react__dialog-wrapper');
	            if (!dialog.length) {
	                dialog = $('<div id="insert-md-media-react__dialog-wrapper" />');
	                $('body').append(dialog);
	            }
	            dialog.setElement(editor);
	            dialog.open();
	        } else {
	            SimpleMDE.drawImage(editor);
	        }
	    });
	
	    $('.js-markdown-container:visible').entwine({
	        onunmatch: function onunmatch() {
	            this._super();
	            _reactDom2.default.unmountComponentAtNode(this[0]);
	        },
	        onmatch: function onmatch() {
	            this._super();
	            this.refresh();
	        },
	        refresh: function refresh() {
	            var textArea = $(this).parent().find('textarea')[0];
	            var data = JSON.parse(textArea.dataset.config);
	            var toolbar = ss.markdownConfigs.readToolbarConfigs(data.toolbar);
	
	            _reactDom2.default.render(_react2.default.createElement(MarkdownEditorField, { textarea: textArea, toolbar: toolbar, identifier: data.identifier }), this[0]);
	        }
	    });
	});
	
	exports.default = { MarkdownEditorField: MarkdownEditorField };

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else {
			var a = factory();
			for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
		}
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var React = __webpack_require__(1);
		var generateId = __webpack_require__(158);
		var NOOP = __webpack_require__(159);
		
		module.exports = React.createClass({
		  displayName: 'exports',
		
		
		  getInitialState: function getInitialState() {
		    return {
		      keyChange: false
		    };
		  },
		
		  getDefaultProps: function getDefaultProps() {
		    return {
		      onChange: NOOP,
		      options: {}
		    };
		  },
		
		  componentWillMount: function componentWillMount() {
		    var id = this.props.id;
		    if (id) {
		      this.id = id;
		    } else {
		      this.id = generateId();
		    }
		  },
		
		  componentDidMount: function componentDidMount() {
		    this.createEditor();
		    this.addEvents();
		    this.addExtraKeys();
		  },
		
		  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
		    if (!this.state.keyChange && nextProps.value !== this.simplemde.value()) {
		      this.simplemde.value(nextProps.value);
		    }
		
		    this.setState({
		      keyChange: false
		    });
		  },
		
		  componentWillUnmount: function componentWillUnmount() {
		    this.removeEvents();
		  },
		
		  createEditor: function createEditor() {
		    var SimpleMDE = __webpack_require__(160);
		    var initialOptions = {
		      element: document.getElementById(this.id),
		      initialValue: this.props.value
		    };
		
		    var allOptions = Object.assign({}, initialOptions, this.props.options);
		    this.simplemde = new SimpleMDE(allOptions);
		  },
		
		  eventWrapper: function eventWrapper() {
		    this.setState({
		      keyChange: true
		    });
		    this.props.onChange(this.simplemde.value());
		  },
		
		  removeEvents: function removeEvents() {
		    this.editorEl.removeEventListener('keyup', this.eventWrapper);
		    this.editorToolbarEl && this.editorToolbarEl.removeEventListener('click', this.eventWrapper);
		  },
		
		  addEvents: function addEvents() {
		    var wrapperId = this.id + '-wrapper';
		    var wrapperEl = document.getElementById('' + wrapperId);
		
		    this.editorEl = wrapperEl.getElementsByClassName('CodeMirror')[0];
		    this.editorToolbarEl = wrapperEl.getElementsByClassName('editor-toolbar')[0];
		
		    this.editorEl.addEventListener('keyup', this.eventWrapper);
		    this.editorToolbarEl && this.editorToolbarEl.addEventListener('click', this.eventWrapper);
		  },
		
		  addExtraKeys: function addExtraKeys() {
		    // https://codemirror.net/doc/manual.html#option_extraKeys
		    if (this.props.extraKeys) {
		      this.simplemde.codemirror.setOption('extraKeys', this.props.extraKeys);
		    }
		  },
		
		  render: function render() {
		    var textarea = React.createElement('textarea', { id: this.id });
		    return React.createElement('div', { id: this.id + '-wrapper', className: this.props.className }, textarea);
		  }
		});
	
	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		module.exports = __webpack_require__(2);
	
	
	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule React
		 */
		
		'use strict';
		
		var ReactDOM = __webpack_require__(3);
		var ReactDOMServer = __webpack_require__(148);
		var ReactIsomorphic = __webpack_require__(152);
		
		var assign = __webpack_require__(39);
		var deprecated = __webpack_require__(157);
		
		// `version` will be added here by ReactIsomorphic.
		var React = {};
		
		assign(React, ReactIsomorphic);
		
		assign(React, {
		  // ReactDOM
		  findDOMNode: deprecated('findDOMNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.findDOMNode),
		  render: deprecated('render', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.render),
		  unmountComponentAtNode: deprecated('unmountComponentAtNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.unmountComponentAtNode),
		
		  // ReactDOMServer
		  renderToString: deprecated('renderToString', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToString),
		  renderToStaticMarkup: deprecated('renderToStaticMarkup', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToStaticMarkup)
		});
		
		React.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOM;
		React.__SECRET_DOM_SERVER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOMServer;
		
		module.exports = React;
	
	/***/ },
	/* 3 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactDOM
		 */
		
		/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/
		
		'use strict';
		
		var ReactCurrentOwner = __webpack_require__(5);
		var ReactDOMTextComponent = __webpack_require__(6);
		var ReactDefaultInjection = __webpack_require__(71);
		var ReactInstanceHandles = __webpack_require__(45);
		var ReactMount = __webpack_require__(28);
		var ReactPerf = __webpack_require__(18);
		var ReactReconciler = __webpack_require__(50);
		var ReactUpdates = __webpack_require__(54);
		var ReactVersion = __webpack_require__(146);
		
		var findDOMNode = __webpack_require__(91);
		var renderSubtreeIntoContainer = __webpack_require__(147);
		var warning = __webpack_require__(25);
		
		ReactDefaultInjection.inject();
		
		var render = ReactPerf.measure('React', 'render', ReactMount.render);
		
		var React = {
		  findDOMNode: findDOMNode,
		  render: render,
		  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
		  version: ReactVersion,
		
		  /* eslint-disable camelcase */
		  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
		  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
		};
		
		// Inject the runtime into a devtools global hook regardless of browser.
		// Allows for debugging when the hook is injected on the page.
		/* eslint-enable camelcase */
		if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
		  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
		    CurrentOwner: ReactCurrentOwner,
		    InstanceHandles: ReactInstanceHandles,
		    Mount: ReactMount,
		    Reconciler: ReactReconciler,
		    TextComponent: ReactDOMTextComponent
		  });
		}
		
		if (process.env.NODE_ENV !== 'production') {
		  var ExecutionEnvironment = __webpack_require__(9);
		  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
		
		    // First check if devtools is not installed
		    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
		      // If we're in Chrome or Firefox, provide a download link if not installed.
		      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
		        console.debug('Download the React DevTools for a better development experience: ' + 'https://fb.me/react-devtools');
		      }
		    }
		
		    // If we're in IE8, check to see if we are in compatibility mode and provide
		    // information on preventing compatibility mode
		    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
		
		    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : undefined;
		
		    var expectedFeatures = [
		    // shims
		    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim,
		
		    // shams
		    Object.create, Object.freeze];
		
		    for (var i = 0; i < expectedFeatures.length; i++) {
		      if (!expectedFeatures[i]) {
		        console.error('One or more ES5 shim/shams expected by React are not available: ' + 'https://fb.me/react-warning-polyfills');
		        break;
		      }
		    }
		  }
		}
		
		module.exports = React;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 4 */
	/***/ function(module, exports) {
	
		// shim for using process in browser
		var process = module.exports = {};
		
		// cached from whatever global is present so that test runners that stub it
		// don't break things.  But we need to wrap it in a try catch in case it is
		// wrapped in strict mode code which doesn't define any globals.  It's inside a
		// function because try/catches deoptimize in certain engines.
		
		var cachedSetTimeout;
		var cachedClearTimeout;
		
		function defaultSetTimout() {
		    throw new Error('setTimeout has not been defined');
		}
		function defaultClearTimeout () {
		    throw new Error('clearTimeout has not been defined');
		}
		(function () {
		    try {
		        if (typeof setTimeout === 'function') {
		            cachedSetTimeout = setTimeout;
		        } else {
		            cachedSetTimeout = defaultSetTimout;
		        }
		    } catch (e) {
		        cachedSetTimeout = defaultSetTimout;
		    }
		    try {
		        if (typeof clearTimeout === 'function') {
		            cachedClearTimeout = clearTimeout;
		        } else {
		            cachedClearTimeout = defaultClearTimeout;
		        }
		    } catch (e) {
		        cachedClearTimeout = defaultClearTimeout;
		    }
		} ())
		function runTimeout(fun) {
		    if (cachedSetTimeout === setTimeout) {
		        //normal enviroments in sane situations
		        return setTimeout(fun, 0);
		    }
		    // if setTimeout wasn't available but was latter defined
		    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
		        cachedSetTimeout = setTimeout;
		        return setTimeout(fun, 0);
		    }
		    try {
		        // when when somebody has screwed with setTimeout but no I.E. maddness
		        return cachedSetTimeout(fun, 0);
		    } catch(e){
		        try {
		            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
		            return cachedSetTimeout.call(null, fun, 0);
		        } catch(e){
		            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
		            return cachedSetTimeout.call(this, fun, 0);
		        }
		    }
		
		
		}
		function runClearTimeout(marker) {
		    if (cachedClearTimeout === clearTimeout) {
		        //normal enviroments in sane situations
		        return clearTimeout(marker);
		    }
		    // if clearTimeout wasn't available but was latter defined
		    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
		        cachedClearTimeout = clearTimeout;
		        return clearTimeout(marker);
		    }
		    try {
		        // when when somebody has screwed with setTimeout but no I.E. maddness
		        return cachedClearTimeout(marker);
		    } catch (e){
		        try {
		            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
		            return cachedClearTimeout.call(null, marker);
		        } catch (e){
		            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
		            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
		            return cachedClearTimeout.call(this, marker);
		        }
		    }
		
		
		
		}
		var queue = [];
		var draining = false;
		var currentQueue;
		var queueIndex = -1;
		
		function cleanUpNextTick() {
		    if (!draining || !currentQueue) {
		        return;
		    }
		    draining = false;
		    if (currentQueue.length) {
		        queue = currentQueue.concat(queue);
		    } else {
		        queueIndex = -1;
		    }
		    if (queue.length) {
		        drainQueue();
		    }
		}
		
		function drainQueue() {
		    if (draining) {
		        return;
		    }
		    var timeout = runTimeout(cleanUpNextTick);
		    draining = true;
		
		    var len = queue.length;
		    while(len) {
		        currentQueue = queue;
		        queue = [];
		        while (++queueIndex < len) {
		            if (currentQueue) {
		                currentQueue[queueIndex].run();
		            }
		        }
		        queueIndex = -1;
		        len = queue.length;
		    }
		    currentQueue = null;
		    draining = false;
		    runClearTimeout(timeout);
		}
		
		process.nextTick = function (fun) {
		    var args = new Array(arguments.length - 1);
		    if (arguments.length > 1) {
		        for (var i = 1; i < arguments.length; i++) {
		            args[i - 1] = arguments[i];
		        }
		    }
		    queue.push(new Item(fun, args));
		    if (queue.length === 1 && !draining) {
		        runTimeout(drainQueue);
		    }
		};
		
		// v8 likes predictible objects
		function Item(fun, array) {
		    this.fun = fun;
		    this.array = array;
		}
		Item.prototype.run = function () {
		    this.fun.apply(null, this.array);
		};
		process.title = 'browser';
		process.browser = true;
		process.env = {};
		process.argv = [];
		process.version = ''; // empty string to avoid regexp issues
		process.versions = {};
		
		function noop() {}
		
		process.on = noop;
		process.addListener = noop;
		process.once = noop;
		process.off = noop;
		process.removeListener = noop;
		process.removeAllListeners = noop;
		process.emit = noop;
		
		process.binding = function (name) {
		    throw new Error('process.binding is not supported');
		};
		
		process.cwd = function () { return '/' };
		process.chdir = function (dir) {
		    throw new Error('process.chdir is not supported');
		};
		process.umask = function() { return 0; };
	
	
	/***/ },
	/* 5 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactCurrentOwner
		 */
		
		'use strict';
		
		/**
		 * Keeps track of the current owner.
		 *
		 * The current owner is the component who should own any components that are
		 * currently being constructed.
		 */
		var ReactCurrentOwner = {
		
		  /**
		   * @internal
		   * @type {ReactComponent}
		   */
		  current: null
		
		};
		
		module.exports = ReactCurrentOwner;
	
	/***/ },
	/* 6 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactDOMTextComponent
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var DOMChildrenOperations = __webpack_require__(7);
		var DOMPropertyOperations = __webpack_require__(22);
		var ReactComponentBrowserEnvironment = __webpack_require__(26);
		var ReactMount = __webpack_require__(28);
		
		var assign = __webpack_require__(39);
		var escapeTextContentForBrowser = __webpack_require__(21);
		var setTextContent = __webpack_require__(20);
		var validateDOMNesting = __webpack_require__(70);
		
		/**
		 * Text nodes violate a couple assumptions that React makes about components:
		 *
		 *  - When mounting text into the DOM, adjacent text nodes are merged.
		 *  - Text nodes cannot be assigned a React root ID.
		 *
		 * This component is used to wrap strings in elements so that they can undergo
		 * the same reconciliation that is applied to elements.
		 *
		 * TODO: Investigate representing React components in the DOM with text nodes.
		 *
		 * @class ReactDOMTextComponent
		 * @extends ReactComponent
		 * @internal
		 */
		var ReactDOMTextComponent = function (props) {
		  // This constructor and its argument is currently used by mocks.
		};
		
		assign(ReactDOMTextComponent.prototype, {
		
		  /**
		   * @param {ReactText} text
		   * @internal
		   */
		  construct: function (text) {
		    // TODO: This is really a ReactText (ReactNode), not a ReactElement
		    this._currentElement = text;
		    this._stringText = '' + text;
		
		    // Properties
		    this._rootNodeID = null;
		    this._mountIndex = 0;
		  },
		
		  /**
		   * Creates the markup for this text node. This node is not intended to have
		   * any features besides containing text content.
		   *
		   * @param {string} rootID DOM ID of the root node.
		   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
		   * @return {string} Markup for this text node.
		   * @internal
		   */
		  mountComponent: function (rootID, transaction, context) {
		    if (process.env.NODE_ENV !== 'production') {
		      if (context[validateDOMNesting.ancestorInfoContextKey]) {
		        validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);
		      }
		    }
		
		    this._rootNodeID = rootID;
		    if (transaction.useCreateElement) {
		      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
		      var el = ownerDocument.createElement('span');
		      DOMPropertyOperations.setAttributeForID(el, rootID);
		      // Populate node cache
		      ReactMount.getID(el);
		      setTextContent(el, this._stringText);
		      return el;
		    } else {
		      var escapedText = escapeTextContentForBrowser(this._stringText);
		
		      if (transaction.renderToStaticMarkup) {
		        // Normally we'd wrap this in a `span` for the reasons stated above, but
		        // since this is a situation where React won't take over (static pages),
		        // we can simply return the text as it is.
		        return escapedText;
		      }
		
		      return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';
		    }
		  },
		
		  /**
		   * Updates this component by updating the text content.
		   *
		   * @param {ReactText} nextText The next text content
		   * @param {ReactReconcileTransaction} transaction
		   * @internal
		   */
		  receiveComponent: function (nextText, transaction) {
		    if (nextText !== this._currentElement) {
		      this._currentElement = nextText;
		      var nextStringText = '' + nextText;
		      if (nextStringText !== this._stringText) {
		        // TODO: Save this as pending props and use performUpdateIfNecessary
		        // and/or updateComponent to do the actual update for consistency with
		        // other component types?
		        this._stringText = nextStringText;
		        var node = ReactMount.getNode(this._rootNodeID);
		        DOMChildrenOperations.updateTextContent(node, nextStringText);
		      }
		    }
		  },
		
		  unmountComponent: function () {
		    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
		  }
		
		});
		
		module.exports = ReactDOMTextComponent;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 7 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule DOMChildrenOperations
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var Danger = __webpack_require__(8);
		var ReactMultiChildUpdateTypes = __webpack_require__(16);
		var ReactPerf = __webpack_require__(18);
		
		var setInnerHTML = __webpack_require__(19);
		var setTextContent = __webpack_require__(20);
		var invariant = __webpack_require__(13);
		
		/**
		 * Inserts `childNode` as a child of `parentNode` at the `index`.
		 *
		 * @param {DOMElement} parentNode Parent node in which to insert.
		 * @param {DOMElement} childNode Child node to insert.
		 * @param {number} index Index at which to insert the child.
		 * @internal
		 */
		function insertChildAt(parentNode, childNode, index) {
		  // By exploiting arrays returning `undefined` for an undefined index, we can
		  // rely exclusively on `insertBefore(node, null)` instead of also using
		  // `appendChild(node)`. However, using `undefined` is not allowed by all
		  // browsers so we must replace it with `null`.
		
		  // fix render order error in safari
		  // IE8 will throw error when index out of list size.
		  var beforeChild = index >= parentNode.childNodes.length ? null : parentNode.childNodes.item(index);
		
		  parentNode.insertBefore(childNode, beforeChild);
		}
		
		/**
		 * Operations for updating with DOM children.
		 */
		var DOMChildrenOperations = {
		
		  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,
		
		  updateTextContent: setTextContent,
		
		  /**
		   * Updates a component's children by processing a series of updates. The
		   * update configurations are each expected to have a `parentNode` property.
		   *
		   * @param {array<object>} updates List of update configurations.
		   * @param {array<string>} markupList List of markup strings.
		   * @internal
		   */
		  processUpdates: function (updates, markupList) {
		    var update;
		    // Mapping from parent IDs to initial child orderings.
		    var initialChildren = null;
		    // List of children that will be moved or removed.
		    var updatedChildren = null;
		
		    for (var i = 0; i < updates.length; i++) {
		      update = updates[i];
		      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
		        var updatedIndex = update.fromIndex;
		        var updatedChild = update.parentNode.childNodes[updatedIndex];
		        var parentID = update.parentID;
		
		        !updatedChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(false) : undefined;
		
		        initialChildren = initialChildren || {};
		        initialChildren[parentID] = initialChildren[parentID] || [];
		        initialChildren[parentID][updatedIndex] = updatedChild;
		
		        updatedChildren = updatedChildren || [];
		        updatedChildren.push(updatedChild);
		      }
		    }
		
		    var renderedMarkup;
		    // markupList is either a list of markup or just a list of elements
		    if (markupList.length && typeof markupList[0] === 'string') {
		      renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
		    } else {
		      renderedMarkup = markupList;
		    }
		
		    // Remove updated children first so that `toIndex` is consistent.
		    if (updatedChildren) {
		      for (var j = 0; j < updatedChildren.length; j++) {
		        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
		      }
		    }
		
		    for (var k = 0; k < updates.length; k++) {
		      update = updates[k];
		      switch (update.type) {
		        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
		          insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
		          break;
		        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
		          insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
		          break;
		        case ReactMultiChildUpdateTypes.SET_MARKUP:
		          setInnerHTML(update.parentNode, update.content);
		          break;
		        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
		          setTextContent(update.parentNode, update.content);
		          break;
		        case ReactMultiChildUpdateTypes.REMOVE_NODE:
		          // Already removed by the for-loop above.
		          break;
		      }
		    }
		  }
		
		};
		
		ReactPerf.measureMethods(DOMChildrenOperations, 'DOMChildrenOperations', {
		  updateTextContent: 'updateTextContent'
		});
		
		module.exports = DOMChildrenOperations;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 8 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule Danger
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var ExecutionEnvironment = __webpack_require__(9);
		
		var createNodesFromMarkup = __webpack_require__(10);
		var emptyFunction = __webpack_require__(15);
		var getMarkupWrap = __webpack_require__(14);
		var invariant = __webpack_require__(13);
		
		var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
		var RESULT_INDEX_ATTR = 'data-danger-index';
		
		/**
		 * Extracts the `nodeName` from a string of markup.
		 *
		 * NOTE: Extracting the `nodeName` does not require a regular expression match
		 * because we make assumptions about React-generated markup (i.e. there are no
		 * spaces surrounding the opening tag and there is at least one attribute).
		 *
		 * @param {string} markup String of markup.
		 * @return {string} Node name of the supplied markup.
		 * @see http://jsperf.com/extract-nodename
		 */
		function getNodeName(markup) {
		  return markup.substring(1, markup.indexOf(' '));
		}
		
		var Danger = {
		
		  /**
		   * Renders markup into an array of nodes. The markup is expected to render
		   * into a list of root nodes. Also, the length of `resultList` and
		   * `markupList` should be the same.
		   *
		   * @param {array<string>} markupList List of markup strings to render.
		   * @return {array<DOMElement>} List of rendered nodes.
		   * @internal
		   */
		  dangerouslyRenderMarkup: function (markupList) {
		    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString for server rendering.') : invariant(false) : undefined;
		    var nodeName;
		    var markupByNodeName = {};
		    // Group markup by `nodeName` if a wrap is necessary, else by '*'.
		    for (var i = 0; i < markupList.length; i++) {
		      !markupList[i] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(false) : undefined;
		      nodeName = getNodeName(markupList[i]);
		      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
		      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
		      markupByNodeName[nodeName][i] = markupList[i];
		    }
		    var resultList = [];
		    var resultListAssignmentCount = 0;
		    for (nodeName in markupByNodeName) {
		      if (!markupByNodeName.hasOwnProperty(nodeName)) {
		        continue;
		      }
		      var markupListByNodeName = markupByNodeName[nodeName];
		
		      // This for-in loop skips the holes of the sparse array. The order of
		      // iteration should follow the order of assignment, which happens to match
		      // numerical index order, but we don't rely on that.
		      var resultIndex;
		      for (resultIndex in markupListByNodeName) {
		        if (markupListByNodeName.hasOwnProperty(resultIndex)) {
		          var markup = markupListByNodeName[resultIndex];
		
		          // Push the requested markup with an additional RESULT_INDEX_ATTR
		          // attribute.  If the markup does not start with a < character, it
		          // will be discarded below (with an appropriate console.error).
		          markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP,
		          // This index will be parsed back out below.
		          '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
		        }
		      }
		
		      // Render each group of markup with similar wrapping `nodeName`.
		      var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction // Do nothing special with <script> tags.
		      );
		
		      for (var j = 0; j < renderNodes.length; ++j) {
		        var renderNode = renderNodes[j];
		        if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {
		
		          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
		          renderNode.removeAttribute(RESULT_INDEX_ATTR);
		
		          !!resultList.hasOwnProperty(resultIndex) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Assigning to an already-occupied result index.') : invariant(false) : undefined;
		
		          resultList[resultIndex] = renderNode;
		
		          // This should match resultList.length and markupList.length when
		          // we're done.
		          resultListAssignmentCount += 1;
		        } else if (process.env.NODE_ENV !== 'production') {
		          console.error('Danger: Discarding unexpected node:', renderNode);
		        }
		      }
		    }
		
		    // Although resultList was populated out of order, it should now be a dense
		    // array.
		    !(resultListAssignmentCount === resultList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Did not assign to every index of resultList.') : invariant(false) : undefined;
		
		    !(resultList.length === markupList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(false) : undefined;
		
		    return resultList;
		  },
		
		  /**
		   * Replaces a node with a string of markup at its current position within its
		   * parent. The markup must render into a single root node.
		   *
		   * @param {DOMElement} oldChild Child node to replace.
		   * @param {string} markup Markup to render in place of the child node.
		   * @internal
		   */
		  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
		    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
		    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(false) : undefined;
		    !(oldChild.tagName.toLowerCase() !== 'html') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See ReactDOMServer.renderToString().') : invariant(false) : undefined;
		
		    var newChild;
		    if (typeof markup === 'string') {
		      newChild = createNodesFromMarkup(markup, emptyFunction)[0];
		    } else {
		      newChild = markup;
		    }
		    oldChild.parentNode.replaceChild(newChild, oldChild);
		  }
		
		};
		
		module.exports = Danger;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 9 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ExecutionEnvironment
		 */
		
		'use strict';
		
		var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
		
		/**
		 * Simple, lightweight module assisting with the detection and context of
		 * Worker. Helps avoid circular dependencies and allows code to reason about
		 * whether or not they are in a Worker, even if they never include the main
		 * `ReactWorker` dependency.
		 */
		var ExecutionEnvironment = {
		
		  canUseDOM: canUseDOM,
		
		  canUseWorkers: typeof Worker !== 'undefined',
		
		  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
		
		  canUseViewport: canUseDOM && !!window.screen,
		
		  isInWorker: !canUseDOM // For now, this is true - might change in the future.
		
		};
		
		module.exports = ExecutionEnvironment;
	
	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule createNodesFromMarkup
		 * @typechecks
		 */
		
		/*eslint-disable fb-www/unsafe-html*/
		
		'use strict';
		
		var ExecutionEnvironment = __webpack_require__(9);
		
		var createArrayFromMixed = __webpack_require__(11);
		var getMarkupWrap = __webpack_require__(14);
		var invariant = __webpack_require__(13);
		
		/**
		 * Dummy container used to render all markup.
		 */
		var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
		
		/**
		 * Pattern used by `getNodeName`.
		 */
		var nodeNamePattern = /^\s*<(\w+)/;
		
		/**
		 * Extracts the `nodeName` of the first element in a string of markup.
		 *
		 * @param {string} markup String of markup.
		 * @return {?string} Node name of the supplied markup.
		 */
		function getNodeName(markup) {
		  var nodeNameMatch = markup.match(nodeNamePattern);
		  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
		}
		
		/**
		 * Creates an array containing the nodes rendered from the supplied markup. The
		 * optionally supplied `handleScript` function will be invoked once for each
		 * <script> element that is rendered. If no `handleScript` function is supplied,
		 * an exception is thrown if any <script> elements are rendered.
		 *
		 * @param {string} markup A string of valid HTML markup.
		 * @param {?function} handleScript Invoked once for each rendered <script>.
		 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
		 */
		function createNodesFromMarkup(markup, handleScript) {
		  var node = dummyNode;
		  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : undefined;
		  var nodeName = getNodeName(markup);
		
		  var wrap = nodeName && getMarkupWrap(nodeName);
		  if (wrap) {
		    node.innerHTML = wrap[1] + markup + wrap[2];
		
		    var wrapDepth = wrap[0];
		    while (wrapDepth--) {
		      node = node.lastChild;
		    }
		  } else {
		    node.innerHTML = markup;
		  }
		
		  var scripts = node.getElementsByTagName('script');
		  if (scripts.length) {
		    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : undefined;
		    createArrayFromMixed(scripts).forEach(handleScript);
		  }
		
		  var nodes = createArrayFromMixed(node.childNodes);
		  while (node.lastChild) {
		    node.removeChild(node.lastChild);
		  }
		  return nodes;
		}
		
		module.exports = createNodesFromMarkup;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 11 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule createArrayFromMixed
		 * @typechecks
		 */
		
		'use strict';
		
		var toArray = __webpack_require__(12);
		
		/**
		 * Perform a heuristic test to determine if an object is "array-like".
		 *
		 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
		 *   Joshu replied: "Mu."
		 *
		 * This function determines if its argument has "array nature": it returns
		 * true if the argument is an actual array, an `arguments' object, or an
		 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
		 *
		 * It will return false for other array-like objects like Filelist.
		 *
		 * @param {*} obj
		 * @return {boolean}
		 */
		function hasArrayNature(obj) {
		  return(
		    // not null/false
		    !!obj && (
		    // arrays are objects, NodeLists are functions in Safari
		    typeof obj == 'object' || typeof obj == 'function') &&
		    // quacks like an array
		    'length' in obj &&
		    // not window
		    !('setInterval' in obj) &&
		    // no DOM node should be considered an array-like
		    // a 'select' element has 'length' and 'item' properties on IE8
		    typeof obj.nodeType != 'number' && (
		    // a real array
		    Array.isArray(obj) ||
		    // arguments
		    'callee' in obj ||
		    // HTMLCollection/NodeList
		    'item' in obj)
		  );
		}
		
		/**
		 * Ensure that the argument is an array by wrapping it in an array if it is not.
		 * Creates a copy of the argument if it is already an array.
		 *
		 * This is mostly useful idiomatically:
		 *
		 *   var createArrayFromMixed = require('createArrayFromMixed');
		 *
		 *   function takesOneOrMoreThings(things) {
		 *     things = createArrayFromMixed(things);
		 *     ...
		 *   }
		 *
		 * This allows you to treat `things' as an array, but accept scalars in the API.
		 *
		 * If you need to convert an array-like object, like `arguments`, into an array
		 * use toArray instead.
		 *
		 * @param {*} obj
		 * @return {array}
		 */
		function createArrayFromMixed(obj) {
		  if (!hasArrayNature(obj)) {
		    return [obj];
		  } else if (Array.isArray(obj)) {
		    return obj.slice();
		  } else {
		    return toArray(obj);
		  }
		}
		
		module.exports = createArrayFromMixed;
	
	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule toArray
		 * @typechecks
		 */
		
		'use strict';
		
		var invariant = __webpack_require__(13);
		
		/**
		 * Convert array-like objects to arrays.
		 *
		 * This API assumes the caller knows the contents of the data type. For less
		 * well defined inputs use createArrayFromMixed.
		 *
		 * @param {object|function|filelist} obj
		 * @return {array}
		 */
		function toArray(obj) {
		  var length = obj.length;
		
		  // Some browse builtin objects can report typeof 'function' (e.g. NodeList in
		  // old versions of Safari).
		  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : undefined;
		
		  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : undefined;
		
		  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : undefined;
		
		  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
		  // without method will throw during the slice call and skip straight to the
		  // fallback.
		  if (obj.hasOwnProperty) {
		    try {
		      return Array.prototype.slice.call(obj);
		    } catch (e) {
		      // IE < 9 does not support Array#slice on collections objects
		    }
		  }
		
		  // Fall back to copying key by key. This assumes all keys have a value,
		  // so will not preserve sparsely populated inputs.
		  var ret = Array(length);
		  for (var ii = 0; ii < length; ii++) {
		    ret[ii] = obj[ii];
		  }
		  return ret;
		}
		
		module.exports = toArray;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule invariant
		 */
		
		'use strict';
		
		/**
		 * Use invariant() to assert state which your program assumes to be true.
		 *
		 * Provide sprintf-style format (only %s is supported) and arguments
		 * to provide information about what broke and what you were
		 * expecting.
		 *
		 * The invariant message will be stripped in production, but the invariant
		 * will remain to ensure logic does not differ in production.
		 */
		
		function invariant(condition, format, a, b, c, d, e, f) {
		  if (process.env.NODE_ENV !== 'production') {
		    if (format === undefined) {
		      throw new Error('invariant requires an error message argument');
		    }
		  }
		
		  if (!condition) {
		    var error;
		    if (format === undefined) {
		      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
		    } else {
		      var args = [a, b, c, d, e, f];
		      var argIndex = 0;
		      error = new Error(format.replace(/%s/g, function () {
		        return args[argIndex++];
		      }));
		      error.name = 'Invariant Violation';
		    }
		
		    error.framesToPop = 1; // we don't care about invariant's own frame
		    throw error;
		  }
		}
		
		module.exports = invariant;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 14 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule getMarkupWrap
		 */
		
		/*eslint-disable fb-www/unsafe-html */
		
		'use strict';
		
		var ExecutionEnvironment = __webpack_require__(9);
		
		var invariant = __webpack_require__(13);
		
		/**
		 * Dummy container used to detect which wraps are necessary.
		 */
		var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
		
		/**
		 * Some browsers cannot use `innerHTML` to render certain elements standalone,
		 * so we wrap them, render the wrapped nodes, then extract the desired node.
		 *
		 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
		 */
		
		var shouldWrap = {};
		
		var selectWrap = [1, '<select multiple="true">', '</select>'];
		var tableWrap = [1, '<table>', '</table>'];
		var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
		
		var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
		
		var markupWrap = {
		  '*': [1, '?<div>', '</div>'],
		
		  'area': [1, '<map>', '</map>'],
		  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
		  'legend': [1, '<fieldset>', '</fieldset>'],
		  'param': [1, '<object>', '</object>'],
		  'tr': [2, '<table><tbody>', '</tbody></table>'],
		
		  'optgroup': selectWrap,
		  'option': selectWrap,
		
		  'caption': tableWrap,
		  'colgroup': tableWrap,
		  'tbody': tableWrap,
		  'tfoot': tableWrap,
		  'thead': tableWrap,
		
		  'td': trWrap,
		  'th': trWrap
		};
		
		// Initialize the SVG elements since we know they'll always need to be wrapped
		// consistently. If they are created inside a <div> they will be initialized in
		// the wrong namespace (and will not display).
		var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
		svgElements.forEach(function (nodeName) {
		  markupWrap[nodeName] = svgWrap;
		  shouldWrap[nodeName] = true;
		});
		
		/**
		 * Gets the markup wrap configuration for the supplied `nodeName`.
		 *
		 * NOTE: This lazily detects which wraps are necessary for the current browser.
		 *
		 * @param {string} nodeName Lowercase `nodeName`.
		 * @return {?array} Markup wrap configuration, if applicable.
		 */
		function getMarkupWrap(nodeName) {
		  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : undefined;
		  if (!markupWrap.hasOwnProperty(nodeName)) {
		    nodeName = '*';
		  }
		  if (!shouldWrap.hasOwnProperty(nodeName)) {
		    if (nodeName === '*') {
		      dummyNode.innerHTML = '<link />';
		    } else {
		      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
		    }
		    shouldWrap[nodeName] = !dummyNode.firstChild;
		  }
		  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
		}
		
		module.exports = getMarkupWrap;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 15 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule emptyFunction
		 */
		
		"use strict";
		
		function makeEmptyFunction(arg) {
		  return function () {
		    return arg;
		  };
		}
		
		/**
		 * This function accepts and discards inputs; it has no side effects. This is
		 * primarily useful idiomatically for overridable function endpoints which
		 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
		 */
		function emptyFunction() {}
		
		emptyFunction.thatReturns = makeEmptyFunction;
		emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
		emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
		emptyFunction.thatReturnsNull = makeEmptyFunction(null);
		emptyFunction.thatReturnsThis = function () {
		  return this;
		};
		emptyFunction.thatReturnsArgument = function (arg) {
		  return arg;
		};
		
		module.exports = emptyFunction;
	
	/***/ },
	/* 16 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactMultiChildUpdateTypes
		 */
		
		'use strict';
		
		var keyMirror = __webpack_require__(17);
		
		/**
		 * When a component's children are updated, a series of update configuration
		 * objects are created in order to batch and serialize the required changes.
		 *
		 * Enumerates all the possible types of update configurations.
		 *
		 * @internal
		 */
		var ReactMultiChildUpdateTypes = keyMirror({
		  INSERT_MARKUP: null,
		  MOVE_EXISTING: null,
		  REMOVE_NODE: null,
		  SET_MARKUP: null,
		  TEXT_CONTENT: null
		});
		
		module.exports = ReactMultiChildUpdateTypes;
	
	/***/ },
	/* 17 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule keyMirror
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var invariant = __webpack_require__(13);
		
		/**
		 * Constructs an enumeration with keys equal to their value.
		 *
		 * For example:
		 *
		 *   var COLORS = keyMirror({blue: null, red: null});
		 *   var myColor = COLORS.blue;
		 *   var isColorValid = !!COLORS[myColor];
		 *
		 * The last line could not be performed if the values of the generated enum were
		 * not equal to their keys.
		 *
		 *   Input:  {key1: val1, key2: val2}
		 *   Output: {key1: key1, key2: key2}
		 *
		 * @param {object} obj
		 * @return {object}
		 */
		var keyMirror = function (obj) {
		  var ret = {};
		  var key;
		  !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : undefined;
		  for (key in obj) {
		    if (!obj.hasOwnProperty(key)) {
		      continue;
		    }
		    ret[key] = key;
		  }
		  return ret;
		};
		
		module.exports = keyMirror;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 18 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactPerf
		 * @typechecks static-only
		 */
		
		'use strict';
		
		/**
		 * ReactPerf is a general AOP system designed to measure performance. This
		 * module only has the hooks: see ReactDefaultPerf for the analysis tool.
		 */
		var ReactPerf = {
		  /**
		   * Boolean to enable/disable measurement. Set to false by default to prevent
		   * accidental logging and perf loss.
		   */
		  enableMeasure: false,
		
		  /**
		   * Holds onto the measure function in use. By default, don't measure
		   * anything, but we'll override this if we inject a measure function.
		   */
		  storedMeasure: _noMeasure,
		
		  /**
		   * @param {object} object
		   * @param {string} objectName
		   * @param {object<string>} methodNames
		   */
		  measureMethods: function (object, objectName, methodNames) {
		    if (process.env.NODE_ENV !== 'production') {
		      for (var key in methodNames) {
		        if (!methodNames.hasOwnProperty(key)) {
		          continue;
		        }
		        object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]);
		      }
		    }
		  },
		
		  /**
		   * Use this to wrap methods you want to measure. Zero overhead in production.
		   *
		   * @param {string} objName
		   * @param {string} fnName
		   * @param {function} func
		   * @return {function}
		   */
		  measure: function (objName, fnName, func) {
		    if (process.env.NODE_ENV !== 'production') {
		      var measuredFunc = null;
		      var wrapper = function () {
		        if (ReactPerf.enableMeasure) {
		          if (!measuredFunc) {
		            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
		          }
		          return measuredFunc.apply(this, arguments);
		        }
		        return func.apply(this, arguments);
		      };
		      wrapper.displayName = objName + '_' + fnName;
		      return wrapper;
		    }
		    return func;
		  },
		
		  injection: {
		    /**
		     * @param {function} measure
		     */
		    injectMeasure: function (measure) {
		      ReactPerf.storedMeasure = measure;
		    }
		  }
		};
		
		/**
		 * Simply passes through the measured function, without measuring it.
		 *
		 * @param {string} objName
		 * @param {string} fnName
		 * @param {function} func
		 * @return {function}
		 */
		function _noMeasure(objName, fnName, func) {
		  return func;
		}
		
		module.exports = ReactPerf;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 19 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule setInnerHTML
		 */
		
		/* globals MSApp */
		
		'use strict';
		
		var ExecutionEnvironment = __webpack_require__(9);
		
		var WHITESPACE_TEST = /^[ \r\n\t\f]/;
		var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
		
		/**
		 * Set the innerHTML property of a node, ensuring that whitespace is preserved
		 * even in IE8.
		 *
		 * @param {DOMElement} node
		 * @param {string} html
		 * @internal
		 */
		var setInnerHTML = function (node, html) {
		  node.innerHTML = html;
		};
		
		// Win8 apps: Allow all html to be inserted
		if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
		  setInnerHTML = function (node, html) {
		    MSApp.execUnsafeLocalFunction(function () {
		      node.innerHTML = html;
		    });
		  };
		}
		
		if (ExecutionEnvironment.canUseDOM) {
		  // IE8: When updating a just created node with innerHTML only leading
		  // whitespace is removed. When updating an existing node with innerHTML
		  // whitespace in root TextNodes is also collapsed.
		  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html
		
		  // Feature detection; only IE8 is known to behave improperly like this.
		  var testElement = document.createElement('div');
		  testElement.innerHTML = ' ';
		  if (testElement.innerHTML === '') {
		    setInnerHTML = function (node, html) {
		      // Magic theory: IE8 supposedly differentiates between added and updated
		      // nodes when processing innerHTML, innerHTML on updated nodes suffers
		      // from worse whitespace behavior. Re-adding a node like this triggers
		      // the initial and more favorable whitespace behavior.
		      // TODO: What to do on a detached node?
		      if (node.parentNode) {
		        node.parentNode.replaceChild(node, node);
		      }
		
		      // We also implement a workaround for non-visible tags disappearing into
		      // thin air on IE8, this only happens if there is no visible text
		      // in-front of the non-visible tags. Piggyback on the whitespace fix
		      // and simply check if any non-visible tags appear in the source.
		      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
		        // Recover leading whitespace by temporarily prepending any character.
		        // \uFEFF has the potential advantage of being zero-width/invisible.
		        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
		        // in hopes that this is preserved even if "\uFEFF" is transformed to
		        // the actual Unicode character (by Babel, for example).
		        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
		        node.innerHTML = String.fromCharCode(0xFEFF) + html;
		
		        // deleteData leaves an empty `TextNode` which offsets the index of all
		        // children. Definitely want to avoid this.
		        var textNode = node.firstChild;
		        if (textNode.data.length === 1) {
		          node.removeChild(textNode);
		        } else {
		          textNode.deleteData(0, 1);
		        }
		      } else {
		        node.innerHTML = html;
		      }
		    };
		  }
		}
		
		module.exports = setInnerHTML;
	
	/***/ },
	/* 20 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule setTextContent
		 */
		
		'use strict';
		
		var ExecutionEnvironment = __webpack_require__(9);
		var escapeTextContentForBrowser = __webpack_require__(21);
		var setInnerHTML = __webpack_require__(19);
		
		/**
		 * Set the textContent property of a node, ensuring that whitespace is preserved
		 * even in IE8. innerText is a poor substitute for textContent and, among many
		 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
		 * as it should.
		 *
		 * @param {DOMElement} node
		 * @param {string} text
		 * @internal
		 */
		var setTextContent = function (node, text) {
		  node.textContent = text;
		};
		
		if (ExecutionEnvironment.canUseDOM) {
		  if (!('textContent' in document.documentElement)) {
		    setTextContent = function (node, text) {
		      setInnerHTML(node, escapeTextContentForBrowser(text));
		    };
		  }
		}
		
		module.exports = setTextContent;
	
	/***/ },
	/* 21 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule escapeTextContentForBrowser
		 */
		
		'use strict';
		
		var ESCAPE_LOOKUP = {
		  '&': '&amp;',
		  '>': '&gt;',
		  '<': '&lt;',
		  '"': '&quot;',
		  '\'': '&#x27;'
		};
		
		var ESCAPE_REGEX = /[&><"']/g;
		
		function escaper(match) {
		  return ESCAPE_LOOKUP[match];
		}
		
		/**
		 * Escapes text to prevent scripting attacks.
		 *
		 * @param {*} text Text value to escape.
		 * @return {string} An escaped string.
		 */
		function escapeTextContentForBrowser(text) {
		  return ('' + text).replace(ESCAPE_REGEX, escaper);
		}
		
		module.exports = escapeTextContentForBrowser;
	
	/***/ },
	/* 22 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule DOMPropertyOperations
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var DOMProperty = __webpack_require__(23);
		var ReactPerf = __webpack_require__(18);
		
		var quoteAttributeValueForBrowser = __webpack_require__(24);
		var warning = __webpack_require__(25);
		
		// Simplified subset
		var VALID_ATTRIBUTE_NAME_REGEX = /^[a-zA-Z_][\w\.\-]*$/;
		var illegalAttributeNameCache = {};
		var validatedAttributeNameCache = {};
		
		function isAttributeNameSafe(attributeName) {
		  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
		    return true;
		  }
		  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
		    return false;
		  }
		  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
		    validatedAttributeNameCache[attributeName] = true;
		    return true;
		  }
		  illegalAttributeNameCache[attributeName] = true;
		  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : undefined;
		  return false;
		}
		
		function shouldIgnoreValue(propertyInfo, value) {
		  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
		}
		
		if (process.env.NODE_ENV !== 'production') {
		  var reactProps = {
		    children: true,
		    dangerouslySetInnerHTML: true,
		    key: true,
		    ref: true
		  };
		  var warnedProperties = {};
		
		  var warnUnknownProperty = function (name) {
		    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
		      return;
		    }
		
		    warnedProperties[name] = true;
		    var lowerCasedName = name.toLowerCase();
		
		    // data-* attributes should be lowercase; suggest the lowercase version
		    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
		
		    // For now, only warn when we have a suggested correction. This prevents
		    // logging too much when using transferPropsTo.
		    process.env.NODE_ENV !== 'production' ? warning(standardName == null, 'Unknown DOM property %s. Did you mean %s?', name, standardName) : undefined;
		  };
		}
		
		/**
		 * Operations for dealing with DOM properties.
		 */
		var DOMPropertyOperations = {
		
		  /**
		   * Creates markup for the ID property.
		   *
		   * @param {string} id Unescaped ID.
		   * @return {string} Markup string.
		   */
		  createMarkupForID: function (id) {
		    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
		  },
		
		  setAttributeForID: function (node, id) {
		    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
		  },
		
		  /**
		   * Creates markup for a property.
		   *
		   * @param {string} name
		   * @param {*} value
		   * @return {?string} Markup string, or null if the property was invalid.
		   */
		  createMarkupForProperty: function (name, value) {
		    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
		    if (propertyInfo) {
		      if (shouldIgnoreValue(propertyInfo, value)) {
		        return '';
		      }
		      var attributeName = propertyInfo.attributeName;
		      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
		        return attributeName + '=""';
		      }
		      return attributeName + '=' + quoteAttributeValueForBrowser(value);
		    } else if (DOMProperty.isCustomAttribute(name)) {
		      if (value == null) {
		        return '';
		      }
		      return name + '=' + quoteAttributeValueForBrowser(value);
		    } else if (process.env.NODE_ENV !== 'production') {
		      warnUnknownProperty(name);
		    }
		    return null;
		  },
		
		  /**
		   * Creates markup for a custom property.
		   *
		   * @param {string} name
		   * @param {*} value
		   * @return {string} Markup string, or empty string if the property was invalid.
		   */
		  createMarkupForCustomAttribute: function (name, value) {
		    if (!isAttributeNameSafe(name) || value == null) {
		      return '';
		    }
		    return name + '=' + quoteAttributeValueForBrowser(value);
		  },
		
		  /**
		   * Sets the value for a property on a node.
		   *
		   * @param {DOMElement} node
		   * @param {string} name
		   * @param {*} value
		   */
		  setValueForProperty: function (node, name, value) {
		    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
		    if (propertyInfo) {
		      var mutationMethod = propertyInfo.mutationMethod;
		      if (mutationMethod) {
		        mutationMethod(node, value);
		      } else if (shouldIgnoreValue(propertyInfo, value)) {
		        this.deleteValueForProperty(node, name);
		      } else if (propertyInfo.mustUseAttribute) {
		        var attributeName = propertyInfo.attributeName;
		        var namespace = propertyInfo.attributeNamespace;
		        // `setAttribute` with objects becomes only `[object]` in IE8/9,
		        // ('' + value) makes it output the correct toString()-value.
		        if (namespace) {
		          node.setAttributeNS(namespace, attributeName, '' + value);
		        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
		          node.setAttribute(attributeName, '');
		        } else {
		          node.setAttribute(attributeName, '' + value);
		        }
		      } else {
		        var propName = propertyInfo.propertyName;
		        // Must explicitly cast values for HAS_SIDE_EFFECTS-properties to the
		        // property type before comparing; only `value` does and is string.
		        if (!propertyInfo.hasSideEffects || '' + node[propName] !== '' + value) {
		          // Contrary to `setAttribute`, object properties are properly
		          // `toString`ed by IE8/9.
		          node[propName] = value;
		        }
		      }
		    } else if (DOMProperty.isCustomAttribute(name)) {
		      DOMPropertyOperations.setValueForAttribute(node, name, value);
		    } else if (process.env.NODE_ENV !== 'production') {
		      warnUnknownProperty(name);
		    }
		  },
		
		  setValueForAttribute: function (node, name, value) {
		    if (!isAttributeNameSafe(name)) {
		      return;
		    }
		    if (value == null) {
		      node.removeAttribute(name);
		    } else {
		      node.setAttribute(name, '' + value);
		    }
		  },
		
		  /**
		   * Deletes the value for a property on a node.
		   *
		   * @param {DOMElement} node
		   * @param {string} name
		   */
		  deleteValueForProperty: function (node, name) {
		    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
		    if (propertyInfo) {
		      var mutationMethod = propertyInfo.mutationMethod;
		      if (mutationMethod) {
		        mutationMethod(node, undefined);
		      } else if (propertyInfo.mustUseAttribute) {
		        node.removeAttribute(propertyInfo.attributeName);
		      } else {
		        var propName = propertyInfo.propertyName;
		        var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
		        if (!propertyInfo.hasSideEffects || '' + node[propName] !== defaultValue) {
		          node[propName] = defaultValue;
		        }
		      }
		    } else if (DOMProperty.isCustomAttribute(name)) {
		      node.removeAttribute(name);
		    } else if (process.env.NODE_ENV !== 'production') {
		      warnUnknownProperty(name);
		    }
		  }
		
		};
		
		ReactPerf.measureMethods(DOMPropertyOperations, 'DOMPropertyOperations', {
		  setValueForProperty: 'setValueForProperty',
		  setValueForAttribute: 'setValueForAttribute',
		  deleteValueForProperty: 'deleteValueForProperty'
		});
		
		module.exports = DOMPropertyOperations;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 23 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule DOMProperty
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var invariant = __webpack_require__(13);
		
		function checkMask(value, bitmask) {
		  return (value & bitmask) === bitmask;
		}
		
		var DOMPropertyInjection = {
		  /**
		   * Mapping from normalized, camelcased property names to a configuration that
		   * specifies how the associated DOM property should be accessed or rendered.
		   */
		  MUST_USE_ATTRIBUTE: 0x1,
		  MUST_USE_PROPERTY: 0x2,
		  HAS_SIDE_EFFECTS: 0x4,
		  HAS_BOOLEAN_VALUE: 0x8,
		  HAS_NUMERIC_VALUE: 0x10,
		  HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
		  HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,
		
		  /**
		   * Inject some specialized knowledge about the DOM. This takes a config object
		   * with the following properties:
		   *
		   * isCustomAttribute: function that given an attribute name will return true
		   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
		   * attributes where it's impossible to enumerate all of the possible
		   * attribute names,
		   *
		   * Properties: object mapping DOM property name to one of the
		   * DOMPropertyInjection constants or null. If your attribute isn't in here,
		   * it won't get written to the DOM.
		   *
		   * DOMAttributeNames: object mapping React attribute name to the DOM
		   * attribute name. Attribute names not specified use the **lowercase**
		   * normalized name.
		   *
		   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
		   * attribute namespace URL. (Attribute names not specified use no namespace.)
		   *
		   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
		   * Property names not specified use the normalized name.
		   *
		   * DOMMutationMethods: Properties that require special mutation methods. If
		   * `value` is undefined, the mutation method should unset the property.
		   *
		   * @param {object} domPropertyConfig the config as described above.
		   */
		  injectDOMPropertyConfig: function (domPropertyConfig) {
		    var Injection = DOMPropertyInjection;
		    var Properties = domPropertyConfig.Properties || {};
		    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
		    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
		    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
		    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
		
		    if (domPropertyConfig.isCustomAttribute) {
		      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
		    }
		
		    for (var propName in Properties) {
		      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(false) : undefined;
		
		      var lowerCased = propName.toLowerCase();
		      var propConfig = Properties[propName];
		
		      var propertyInfo = {
		        attributeName: lowerCased,
		        attributeNamespace: null,
		        propertyName: propName,
		        mutationMethod: null,
		
		        mustUseAttribute: checkMask(propConfig, Injection.MUST_USE_ATTRIBUTE),
		        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
		        hasSideEffects: checkMask(propConfig, Injection.HAS_SIDE_EFFECTS),
		        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
		        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
		        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
		        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
		      };
		
		      !(!propertyInfo.mustUseAttribute || !propertyInfo.mustUseProperty) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(false) : undefined;
		      !(propertyInfo.mustUseProperty || !propertyInfo.hasSideEffects) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(false) : undefined;
		      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(false) : undefined;
		
		      if (process.env.NODE_ENV !== 'production') {
		        DOMProperty.getPossibleStandardName[lowerCased] = propName;
		      }
		
		      if (DOMAttributeNames.hasOwnProperty(propName)) {
		        var attributeName = DOMAttributeNames[propName];
		        propertyInfo.attributeName = attributeName;
		        if (process.env.NODE_ENV !== 'production') {
		          DOMProperty.getPossibleStandardName[attributeName] = propName;
		        }
		      }
		
		      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
		        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
		      }
		
		      if (DOMPropertyNames.hasOwnProperty(propName)) {
		        propertyInfo.propertyName = DOMPropertyNames[propName];
		      }
		
		      if (DOMMutationMethods.hasOwnProperty(propName)) {
		        propertyInfo.mutationMethod = DOMMutationMethods[propName];
		      }
		
		      DOMProperty.properties[propName] = propertyInfo;
		    }
		  }
		};
		var defaultValueCache = {};
		
		/**
		 * DOMProperty exports lookup objects that can be used like functions:
		 *
		 *   > DOMProperty.isValid['id']
		 *   true
		 *   > DOMProperty.isValid['foobar']
		 *   undefined
		 *
		 * Although this may be confusing, it performs better in general.
		 *
		 * @see http://jsperf.com/key-exists
		 * @see http://jsperf.com/key-missing
		 */
		var DOMProperty = {
		
		  ID_ATTRIBUTE_NAME: 'data-reactid',
		
		  /**
		   * Map from property "standard name" to an object with info about how to set
		   * the property in the DOM. Each object contains:
		   *
		   * attributeName:
		   *   Used when rendering markup or with `*Attribute()`.
		   * attributeNamespace
		   * propertyName:
		   *   Used on DOM node instances. (This includes properties that mutate due to
		   *   external factors.)
		   * mutationMethod:
		   *   If non-null, used instead of the property or `setAttribute()` after
		   *   initial render.
		   * mustUseAttribute:
		   *   Whether the property must be accessed and mutated using `*Attribute()`.
		   *   (This includes anything that fails `<propName> in <element>`.)
		   * mustUseProperty:
		   *   Whether the property must be accessed and mutated as an object property.
		   * hasSideEffects:
		   *   Whether or not setting a value causes side effects such as triggering
		   *   resources to be loaded or text selection changes. If true, we read from
		   *   the DOM before updating to ensure that the value is only set if it has
		   *   changed.
		   * hasBooleanValue:
		   *   Whether the property should be removed when set to a falsey value.
		   * hasNumericValue:
		   *   Whether the property must be numeric or parse as a numeric and should be
		   *   removed when set to a falsey value.
		   * hasPositiveNumericValue:
		   *   Whether the property must be positive numeric or parse as a positive
		   *   numeric and should be removed when set to a falsey value.
		   * hasOverloadedBooleanValue:
		   *   Whether the property can be used as a flag as well as with a value.
		   *   Removed when strictly equal to false; present without a value when
		   *   strictly equal to true; present with a value otherwise.
		   */
		  properties: {},
		
		  /**
		   * Mapping from lowercase property names to the properly cased version, used
		   * to warn in the case of missing properties. Available only in __DEV__.
		   * @type {Object}
		   */
		  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? {} : null,
		
		  /**
		   * All of the isCustomAttribute() functions that have been injected.
		   */
		  _isCustomAttributeFunctions: [],
		
		  /**
		   * Checks whether a property name is a custom attribute.
		   * @method
		   */
		  isCustomAttribute: function (attributeName) {
		    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
		      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
		      if (isCustomAttributeFn(attributeName)) {
		        return true;
		      }
		    }
		    return false;
		  },
		
		  /**
		   * Returns the default property value for a DOM property (i.e., not an
		   * attribute). Most default values are '' or false, but not all. Worse yet,
		   * some (in particular, `type`) vary depending on the type of element.
		   *
		   * TODO: Is it better to grab all the possible properties when creating an
		   * element to avoid having to create the same element twice?
		   */
		  getDefaultValueForProperty: function (nodeName, prop) {
		    var nodeDefaults = defaultValueCache[nodeName];
		    var testElement;
		    if (!nodeDefaults) {
		      defaultValueCache[nodeName] = nodeDefaults = {};
		    }
		    if (!(prop in nodeDefaults)) {
		      testElement = document.createElement(nodeName);
		      nodeDefaults[prop] = testElement[prop];
		    }
		    return nodeDefaults[prop];
		  },
		
		  injection: DOMPropertyInjection
		};
		
		module.exports = DOMProperty;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 24 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule quoteAttributeValueForBrowser
		 */
		
		'use strict';
		
		var escapeTextContentForBrowser = __webpack_require__(21);
		
		/**
		 * Escapes attribute value to prevent scripting attacks.
		 *
		 * @param {*} value Value to escape.
		 * @return {string} An escaped string.
		 */
		function quoteAttributeValueForBrowser(value) {
		  return '"' + escapeTextContentForBrowser(value) + '"';
		}
		
		module.exports = quoteAttributeValueForBrowser;
	
	/***/ },
	/* 25 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2014-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule warning
		 */
		
		'use strict';
		
		var emptyFunction = __webpack_require__(15);
		
		/**
		 * Similar to invariant but only logs a warning if the condition is not met.
		 * This can be used to log issues in development environments in critical
		 * paths. Removing the logging code for production environments will keep the
		 * same logic and follow the same code paths.
		 */
		
		var warning = emptyFunction;
		
		if (process.env.NODE_ENV !== 'production') {
		  warning = function (condition, format) {
		    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
		      args[_key - 2] = arguments[_key];
		    }
		
		    if (format === undefined) {
		      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
		    }
		
		    if (format.indexOf('Failed Composite propType: ') === 0) {
		      return; // Ignore CompositeComponent proptype check.
		    }
		
		    if (!condition) {
		      var argIndex = 0;
		      var message = 'Warning: ' + format.replace(/%s/g, function () {
		        return args[argIndex++];
		      });
		      if (typeof console !== 'undefined') {
		        console.error(message);
		      }
		      try {
		        // --- Welcome to debugging React ---
		        // This error was thrown as a convenience so that you can use this stack
		        // to find the callsite that caused this warning to fire.
		        throw new Error(message);
		      } catch (x) {}
		    }
		  };
		}
		
		module.exports = warning;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 26 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactComponentBrowserEnvironment
		 */
		
		'use strict';
		
		var ReactDOMIDOperations = __webpack_require__(27);
		var ReactMount = __webpack_require__(28);
		
		/**
		 * Abstracts away all functionality of the reconciler that requires knowledge of
		 * the browser context. TODO: These callers should be refactored to avoid the
		 * need for this injection.
		 */
		var ReactComponentBrowserEnvironment = {
		
		  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
		
		  replaceNodeWithMarkupByID: ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,
		
		  /**
		   * If a particular environment requires that some resources be cleaned up,
		   * specify this in the injected Mixin. In the DOM, we would likely want to
		   * purge any cached node ID lookups.
		   *
		   * @private
		   */
		  unmountIDFromEnvironment: function (rootNodeID) {
		    ReactMount.purgeID(rootNodeID);
		  }
		
		};
		
		module.exports = ReactComponentBrowserEnvironment;
	
	/***/ },
	/* 27 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactDOMIDOperations
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var DOMChildrenOperations = __webpack_require__(7);
		var DOMPropertyOperations = __webpack_require__(22);
		var ReactMount = __webpack_require__(28);
		var ReactPerf = __webpack_require__(18);
		
		var invariant = __webpack_require__(13);
		
		/**
		 * Errors for properties that should not be updated with `updatePropertyByID()`.
		 *
		 * @type {object}
		 * @private
		 */
		var INVALID_PROPERTY_ERRORS = {
		  dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
		  style: '`style` must be set using `updateStylesByID()`.'
		};
		
		/**
		 * Operations used to process updates to DOM nodes.
		 */
		var ReactDOMIDOperations = {
		
		  /**
		   * Updates a DOM node with new property values. This should only be used to
		   * update DOM properties in `DOMProperty`.
		   *
		   * @param {string} id ID of the node to update.
		   * @param {string} name A valid property name, see `DOMProperty`.
		   * @param {*} value New value of the property.
		   * @internal
		   */
		  updatePropertyByID: function (id, name, value) {
		    var node = ReactMount.getNode(id);
		    !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;
		
		    // If we're updating to null or undefined, we should remove the property
		    // from the DOM node instead of inadvertantly setting to a string. This
		    // brings us in line with the same behavior we have on initial render.
		    if (value != null) {
		      DOMPropertyOperations.setValueForProperty(node, name, value);
		    } else {
		      DOMPropertyOperations.deleteValueForProperty(node, name);
		    }
		  },
		
		  /**
		   * Replaces a DOM node that exists in the document with markup.
		   *
		   * @param {string} id ID of child to be replaced.
		   * @param {string} markup Dangerous markup to inject in place of child.
		   * @internal
		   * @see {Danger.dangerouslyReplaceNodeWithMarkup}
		   */
		  dangerouslyReplaceNodeWithMarkupByID: function (id, markup) {
		    var node = ReactMount.getNode(id);
		    DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
		  },
		
		  /**
		   * Updates a component's children by processing a series of updates.
		   *
		   * @param {array<object>} updates List of update configurations.
		   * @param {array<string>} markup List of markup strings.
		   * @internal
		   */
		  dangerouslyProcessChildrenUpdates: function (updates, markup) {
		    for (var i = 0; i < updates.length; i++) {
		      updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
		    }
		    DOMChildrenOperations.processUpdates(updates, markup);
		  }
		};
		
		ReactPerf.measureMethods(ReactDOMIDOperations, 'ReactDOMIDOperations', {
		  dangerouslyReplaceNodeWithMarkupByID: 'dangerouslyReplaceNodeWithMarkupByID',
		  dangerouslyProcessChildrenUpdates: 'dangerouslyProcessChildrenUpdates'
		});
		
		module.exports = ReactDOMIDOperations;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 28 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactMount
		 */
		
		'use strict';
		
		var DOMProperty = __webpack_require__(23);
		var ReactBrowserEventEmitter = __webpack_require__(29);
		var ReactCurrentOwner = __webpack_require__(5);
		var ReactDOMFeatureFlags = __webpack_require__(41);
		var ReactElement = __webpack_require__(42);
		var ReactEmptyComponentRegistry = __webpack_require__(44);
		var ReactInstanceHandles = __webpack_require__(45);
		var ReactInstanceMap = __webpack_require__(47);
		var ReactMarkupChecksum = __webpack_require__(48);
		var ReactPerf = __webpack_require__(18);
		var ReactReconciler = __webpack_require__(50);
		var ReactUpdateQueue = __webpack_require__(53);
		var ReactUpdates = __webpack_require__(54);
		
		var assign = __webpack_require__(39);
		var emptyObject = __webpack_require__(58);
		var containsNode = __webpack_require__(59);
		var instantiateReactComponent = __webpack_require__(62);
		var invariant = __webpack_require__(13);
		var setInnerHTML = __webpack_require__(19);
		var shouldUpdateReactComponent = __webpack_require__(67);
		var validateDOMNesting = __webpack_require__(70);
		var warning = __webpack_require__(25);
		
		var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
		var nodeCache = {};
		
		var ELEMENT_NODE_TYPE = 1;
		var DOC_NODE_TYPE = 9;
		var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
		
		var ownerDocumentContextKey = '__ReactMount_ownerDocument$' + Math.random().toString(36).slice(2);
		
		/** Mapping from reactRootID to React component instance. */
		var instancesByReactRootID = {};
		
		/** Mapping from reactRootID to `container` nodes. */
		var containersByReactRootID = {};
		
		if (process.env.NODE_ENV !== 'production') {
		  /** __DEV__-only mapping from reactRootID to root elements. */
		  var rootElementsByReactRootID = {};
		}
		
		// Used to store breadth-first search state in findComponentRoot.
		var findComponentRootReusableArray = [];
		
		/**
		 * Finds the index of the first character
		 * that's not common between the two given strings.
		 *
		 * @return {number} the index of the character where the strings diverge
		 */
		function firstDifferenceIndex(string1, string2) {
		  var minLen = Math.min(string1.length, string2.length);
		  for (var i = 0; i < minLen; i++) {
		    if (string1.charAt(i) !== string2.charAt(i)) {
		      return i;
		    }
		  }
		  return string1.length === string2.length ? -1 : minLen;
		}
		
		/**
		 * @param {DOMElement|DOMDocument} container DOM element that may contain
		 * a React component
		 * @return {?*} DOM element that may have the reactRoot ID, or null.
		 */
		function getReactRootElementInContainer(container) {
		  if (!container) {
		    return null;
		  }
		
		  if (container.nodeType === DOC_NODE_TYPE) {
		    return container.documentElement;
		  } else {
		    return container.firstChild;
		  }
		}
		
		/**
		 * @param {DOMElement} container DOM element that may contain a React component.
		 * @return {?string} A "reactRoot" ID, if a React component is rendered.
		 */
		function getReactRootID(container) {
		  var rootElement = getReactRootElementInContainer(container);
		  return rootElement && ReactMount.getID(rootElement);
		}
		
		/**
		 * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form
		 * element can return its control whose name or ID equals ATTR_NAME. All
		 * DOM nodes support `getAttributeNode` but this can also get called on
		 * other objects so just return '' if we're given something other than a
		 * DOM node (such as window).
		 *
		 * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.
		 * @return {string} ID of the supplied `domNode`.
		 */
		function getID(node) {
		  var id = internalGetID(node);
		  if (id) {
		    if (nodeCache.hasOwnProperty(id)) {
		      var cached = nodeCache[id];
		      if (cached !== node) {
		        !!isValid(cached, id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;
		
		        nodeCache[id] = node;
		      }
		    } else {
		      nodeCache[id] = node;
		    }
		  }
		
		  return id;
		}
		
		function internalGetID(node) {
		  // If node is something like a window, document, or text node, none of
		  // which support attributes or a .getAttribute method, gracefully return
		  // the empty string, as if the attribute were missing.
		  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
		}
		
		/**
		 * Sets the React-specific ID of the given node.
		 *
		 * @param {DOMElement} node The DOM node whose ID will be set.
		 * @param {string} id The value of the ID attribute.
		 */
		function setID(node, id) {
		  var oldID = internalGetID(node);
		  if (oldID !== id) {
		    delete nodeCache[oldID];
		  }
		  node.setAttribute(ATTR_NAME, id);
		  nodeCache[id] = node;
		}
		
		/**
		 * Finds the node with the supplied React-generated DOM ID.
		 *
		 * @param {string} id A React-generated DOM ID.
		 * @return {DOMElement} DOM node with the suppled `id`.
		 * @internal
		 */
		function getNode(id) {
		  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
		    nodeCache[id] = ReactMount.findReactNodeByID(id);
		  }
		  return nodeCache[id];
		}
		
		/**
		 * Finds the node with the supplied public React instance.
		 *
		 * @param {*} instance A public React instance.
		 * @return {?DOMElement} DOM node with the suppled `id`.
		 * @internal
		 */
		function getNodeFromInstance(instance) {
		  var id = ReactInstanceMap.get(instance)._rootNodeID;
		  if (ReactEmptyComponentRegistry.isNullComponentID(id)) {
		    return null;
		  }
		  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
		    nodeCache[id] = ReactMount.findReactNodeByID(id);
		  }
		  return nodeCache[id];
		}
		
		/**
		 * A node is "valid" if it is contained by a currently mounted container.
		 *
		 * This means that the node does not have to be contained by a document in
		 * order to be considered valid.
		 *
		 * @param {?DOMElement} node The candidate DOM node.
		 * @param {string} id The expected ID of the node.
		 * @return {boolean} Whether the node is contained by a mounted container.
		 */
		function isValid(node, id) {
		  if (node) {
		    !(internalGetID(node) === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;
		
		    var container = ReactMount.findReactContainerForID(id);
		    if (container && containsNode(container, node)) {
		      return true;
		    }
		  }
		
		  return false;
		}
		
		/**
		 * Causes the cache to forget about one React-specific ID.
		 *
		 * @param {string} id The ID to forget.
		 */
		function purgeID(id) {
		  delete nodeCache[id];
		}
		
		var deepestNodeSoFar = null;
		function findDeepestCachedAncestorImpl(ancestorID) {
		  var ancestor = nodeCache[ancestorID];
		  if (ancestor && isValid(ancestor, ancestorID)) {
		    deepestNodeSoFar = ancestor;
		  } else {
		    // This node isn't populated in the cache, so presumably none of its
		    // descendants are. Break out of the loop.
		    return false;
		  }
		}
		
		/**
		 * Return the deepest cached node whose ID is a prefix of `targetID`.
		 */
		function findDeepestCachedAncestor(targetID) {
		  deepestNodeSoFar = null;
		  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);
		
		  var foundNode = deepestNodeSoFar;
		  deepestNodeSoFar = null;
		  return foundNode;
		}
		
		/**
		 * Mounts this component and inserts it into the DOM.
		 *
		 * @param {ReactComponent} componentInstance The instance to mount.
		 * @param {string} rootID DOM ID of the root node.
		 * @param {DOMElement} container DOM element to mount into.
		 * @param {ReactReconcileTransaction} transaction
		 * @param {boolean} shouldReuseMarkup If true, do not insert markup
		 */
		function mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {
		  if (ReactDOMFeatureFlags.useCreateElement) {
		    context = assign({}, context);
		    if (container.nodeType === DOC_NODE_TYPE) {
		      context[ownerDocumentContextKey] = container;
		    } else {
		      context[ownerDocumentContextKey] = container.ownerDocument;
		    }
		  }
		  if (process.env.NODE_ENV !== 'production') {
		    if (context === emptyObject) {
		      context = {};
		    }
		    var tag = container.nodeName.toLowerCase();
		    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);
		  }
		  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);
		  componentInstance._renderedComponent._topLevelWrapper = componentInstance;
		  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup, transaction);
		}
		
		/**
		 * Batched mount.
		 *
		 * @param {ReactComponent} componentInstance The instance to mount.
		 * @param {string} rootID DOM ID of the root node.
		 * @param {DOMElement} container DOM element to mount into.
		 * @param {boolean} shouldReuseMarkup If true, do not insert markup
		 */
		function batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {
		  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
		  /* forceHTML */shouldReuseMarkup);
		  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);
		  ReactUpdates.ReactReconcileTransaction.release(transaction);
		}
		
		/**
		 * Unmounts a component and removes it from the DOM.
		 *
		 * @param {ReactComponent} instance React component instance.
		 * @param {DOMElement} container DOM element to unmount from.
		 * @final
		 * @internal
		 * @see {ReactMount.unmountComponentAtNode}
		 */
		function unmountComponentFromNode(instance, container) {
		  ReactReconciler.unmountComponent(instance);
		
		  if (container.nodeType === DOC_NODE_TYPE) {
		    container = container.documentElement;
		  }
		
		  // http://jsperf.com/emptying-a-node
		  while (container.lastChild) {
		    container.removeChild(container.lastChild);
		  }
		}
		
		/**
		 * True if the supplied DOM node has a direct React-rendered child that is
		 * not a React root element. Useful for warning in `render`,
		 * `unmountComponentAtNode`, etc.
		 *
		 * @param {?DOMElement} node The candidate DOM node.
		 * @return {boolean} True if the DOM element contains a direct child that was
		 * rendered by React but is not a root element.
		 * @internal
		 */
		function hasNonRootReactChild(node) {
		  var reactRootID = getReactRootID(node);
		  return reactRootID ? reactRootID !== ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID) : false;
		}
		
		/**
		 * Returns the first (deepest) ancestor of a node which is rendered by this copy
		 * of React.
		 */
		function findFirstReactDOMImpl(node) {
		  // This node might be from another React instance, so we make sure not to
		  // examine the node cache here
		  for (; node && node.parentNode !== node; node = node.parentNode) {
		    if (node.nodeType !== 1) {
		      // Not a DOMElement, therefore not a React component
		      continue;
		    }
		    var nodeID = internalGetID(node);
		    if (!nodeID) {
		      continue;
		    }
		    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
		
		    // If containersByReactRootID contains the container we find by crawling up
		    // the tree, we know that this instance of React rendered the node.
		    // nb. isValid's strategy (with containsNode) does not work because render
		    // trees may be nested and we don't want a false positive in that case.
		    var current = node;
		    var lastID;
		    do {
		      lastID = internalGetID(current);
		      current = current.parentNode;
		      if (current == null) {
		        // The passed-in node has been detached from the container it was
		        // originally rendered into.
		        return null;
		      }
		    } while (lastID !== reactRootID);
		
		    if (current === containersByReactRootID[reactRootID]) {
		      return node;
		    }
		  }
		  return null;
		}
		
		/**
		 * Temporary (?) hack so that we can store all top-level pending updates on
		 * composites instead of having to worry about different types of components
		 * here.
		 */
		var TopLevelWrapper = function () {};
		TopLevelWrapper.prototype.isReactComponent = {};
		if (process.env.NODE_ENV !== 'production') {
		  TopLevelWrapper.displayName = 'TopLevelWrapper';
		}
		TopLevelWrapper.prototype.render = function () {
		  // this.props is actually a ReactElement
		  return this.props;
		};
		
		/**
		 * Mounting is the process of initializing a React component by creating its
		 * representative DOM elements and inserting them into a supplied `container`.
		 * Any prior content inside `container` is destroyed in the process.
		 *
		 *   ReactMount.render(
		 *     component,
		 *     document.getElementById('container')
		 *   );
		 *
		 *   <div id="container">                   <-- Supplied `container`.
		 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
		 *       // ...                                 component.
		 *     </div>
		 *   </div>
		 *
		 * Inside of `container`, the first element rendered is the "reactRoot".
		 */
		var ReactMount = {
		
		  TopLevelWrapper: TopLevelWrapper,
		
		  /** Exposed for debugging purposes **/
		  _instancesByReactRootID: instancesByReactRootID,
		
		  /**
		   * This is a hook provided to support rendering React components while
		   * ensuring that the apparent scroll position of its `container` does not
		   * change.
		   *
		   * @param {DOMElement} container The `container` being rendered into.
		   * @param {function} renderCallback This must be called once to do the render.
		   */
		  scrollMonitor: function (container, renderCallback) {
		    renderCallback();
		  },
		
		  /**
		   * Take a component that's already mounted into the DOM and replace its props
		   * @param {ReactComponent} prevComponent component instance already in the DOM
		   * @param {ReactElement} nextElement component instance to render
		   * @param {DOMElement} container container to render into
		   * @param {?function} callback function triggered on completion
		   */
		  _updateRootComponent: function (prevComponent, nextElement, container, callback) {
		    ReactMount.scrollMonitor(container, function () {
		      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
		      if (callback) {
		        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
		      }
		    });
		
		    if (process.env.NODE_ENV !== 'production') {
		      // Record the root element in case it later gets transplanted.
		      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
		    }
		
		    return prevComponent;
		  },
		
		  /**
		   * Register a component into the instance map and starts scroll value
		   * monitoring
		   * @param {ReactComponent} nextComponent component instance to render
		   * @param {DOMElement} container container to render into
		   * @return {string} reactRoot ID prefix
		   */
		  _registerComponent: function (nextComponent, container) {
		    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;
		
		    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
		
		    var reactRootID = ReactMount.registerContainer(container);
		    instancesByReactRootID[reactRootID] = nextComponent;
		    return reactRootID;
		  },
		
		  /**
		   * Render a new component into the DOM.
		   * @param {ReactElement} nextElement element to render
		   * @param {DOMElement} container container to render into
		   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
		   * @return {ReactComponent} nextComponent
		   */
		  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
		    // Various parts of our code (such as ReactCompositeComponent's
		    // _renderValidatedComponent) assume that calls to render aren't nested;
		    // verify that that's the case.
		    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;
		
		    var componentInstance = instantiateReactComponent(nextElement, null);
		    var reactRootID = ReactMount._registerComponent(componentInstance, container);
		
		    // The initial render is synchronous but any updates that happen during
		    // rendering, in componentWillMount or componentDidMount, will be batched
		    // according to the current batching strategy.
		
		    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);
		
		    if (process.env.NODE_ENV !== 'production') {
		      // Record the root element in case it later gets transplanted.
		      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
		    }
		
		    return componentInstance;
		  },
		
		  /**
		   * Renders a React component into the DOM in the supplied `container`.
		   *
		   * If the React component was previously rendered into `container`, this will
		   * perform an update on it and only mutate the DOM as necessary to reflect the
		   * latest React component.
		   *
		   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
		   * @param {ReactElement} nextElement Component element to render.
		   * @param {DOMElement} container DOM element to render into.
		   * @param {?function} callback function triggered on completion
		   * @return {ReactComponent} Component instance rendered in `container`.
		   */
		  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
		    !(parentComponent != null && parentComponent._reactInternalInstance != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;
		    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
		  },
		
		  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
		    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :
		    // Check if it quacks like an element
		    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;
		
		    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;
		
		    var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);
		
		    var prevComponent = instancesByReactRootID[getReactRootID(container)];
		
		    if (prevComponent) {
		      var prevWrappedElement = prevComponent._currentElement;
		      var prevElement = prevWrappedElement.props;
		      if (shouldUpdateReactComponent(prevElement, nextElement)) {
		        var publicInst = prevComponent._renderedComponent.getPublicInstance();
		        var updatedCallback = callback && function () {
		          callback.call(publicInst);
		        };
		        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);
		        return publicInst;
		      } else {
		        ReactMount.unmountComponentAtNode(container);
		      }
		    }
		
		    var reactRootElement = getReactRootElementInContainer(container);
		    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
		    var containerHasNonRootReactChild = hasNonRootReactChild(container);
		
		    if (process.env.NODE_ENV !== 'production') {
		      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : undefined;
		
		      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
		        var rootElementSibling = reactRootElement;
		        while (rootElementSibling) {
		          if (internalGetID(rootElementSibling)) {
		            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;
		            break;
		          }
		          rootElementSibling = rootElementSibling.nextSibling;
		        }
		      }
		    }
		
		    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
		    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();
		    if (callback) {
		      callback.call(component);
		    }
		    return component;
		  },
		
		  /**
		   * Renders a React component into the DOM in the supplied `container`.
		   *
		   * If the React component was previously rendered into `container`, this will
		   * perform an update on it and only mutate the DOM as necessary to reflect the
		   * latest React component.
		   *
		   * @param {ReactElement} nextElement Component element to render.
		   * @param {DOMElement} container DOM element to render into.
		   * @param {?function} callback function triggered on completion
		   * @return {ReactComponent} Component instance rendered in `container`.
		   */
		  render: function (nextElement, container, callback) {
		    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
		  },
		
		  /**
		   * Registers a container node into which React components will be rendered.
		   * This also creates the "reactRoot" ID that will be assigned to the element
		   * rendered within.
		   *
		   * @param {DOMElement} container DOM element to register as a container.
		   * @return {string} The "reactRoot" ID of elements rendered within.
		   */
		  registerContainer: function (container) {
		    var reactRootID = getReactRootID(container);
		    if (reactRootID) {
		      // If one exists, make sure it is a valid "reactRoot" ID.
		      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
		    }
		    if (!reactRootID) {
		      // No valid "reactRoot" ID found, create one.
		      reactRootID = ReactInstanceHandles.createReactRootID();
		    }
		    containersByReactRootID[reactRootID] = container;
		    return reactRootID;
		  },
		
		  /**
		   * Unmounts and destroys the React component rendered in the `container`.
		   *
		   * @param {DOMElement} container DOM element containing a React component.
		   * @return {boolean} True if a component was found in and unmounted from
		   *                   `container`
		   */
		  unmountComponentAtNode: function (container) {
		    // Various parts of our code (such as ReactCompositeComponent's
		    // _renderValidatedComponent) assume that calls to render aren't nested;
		    // verify that that's the case. (Strictly speaking, unmounting won't cause a
		    // render but we still don't expect to be in a render call here.)
		    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;
		
		    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;
		
		    var reactRootID = getReactRootID(container);
		    var component = instancesByReactRootID[reactRootID];
		    if (!component) {
		      // Check if the node being unmounted was rendered by React, but isn't a
		      // root node.
		      var containerHasNonRootReactChild = hasNonRootReactChild(container);
		
		      // Check if the container itself is a React root node.
		      var containerID = internalGetID(container);
		      var isContainerReactRoot = containerID && containerID === ReactInstanceHandles.getReactRootIDFromNodeID(containerID);
		
		      if (process.env.NODE_ENV !== 'production') {
		        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : undefined;
		      }
		
		      return false;
		    }
		    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);
		    delete instancesByReactRootID[reactRootID];
		    delete containersByReactRootID[reactRootID];
		    if (process.env.NODE_ENV !== 'production') {
		      delete rootElementsByReactRootID[reactRootID];
		    }
		    return true;
		  },
		
		  /**
		   * Finds the container DOM element that contains React component to which the
		   * supplied DOM `id` belongs.
		   *
		   * @param {string} id The ID of an element rendered by a React component.
		   * @return {?DOMElement} DOM element that contains the `id`.
		   */
		  findReactContainerForID: function (id) {
		    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
		    var container = containersByReactRootID[reactRootID];
		
		    if (process.env.NODE_ENV !== 'production') {
		      var rootElement = rootElementsByReactRootID[reactRootID];
		      if (rootElement && rootElement.parentNode !== container) {
		        process.env.NODE_ENV !== 'production' ? warning(
		        // Call internalGetID here because getID calls isValid which calls
		        // findReactContainerForID (this function).
		        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;
		        var containerChild = container.firstChild;
		        if (containerChild && reactRootID === internalGetID(containerChild)) {
		          // If the container has a new child with the same ID as the old
		          // root element, then rootElementsByReactRootID[reactRootID] is
		          // just stale and needs to be updated. The case that deserves a
		          // warning is when the container is empty.
		          rootElementsByReactRootID[reactRootID] = containerChild;
		        } else {
		          process.env.NODE_ENV !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;
		        }
		      }
		    }
		
		    return container;
		  },
		
		  /**
		   * Finds an element rendered by React with the supplied ID.
		   *
		   * @param {string} id ID of a DOM node in the React component.
		   * @return {DOMElement} Root DOM node of the React component.
		   */
		  findReactNodeByID: function (id) {
		    var reactRoot = ReactMount.findReactContainerForID(id);
		    return ReactMount.findComponentRoot(reactRoot, id);
		  },
		
		  /**
		   * Traverses up the ancestors of the supplied node to find a node that is a
		   * DOM representation of a React component rendered by this copy of React.
		   *
		   * @param {*} node
		   * @return {?DOMEventTarget}
		   * @internal
		   */
		  getFirstReactDOM: function (node) {
		    return findFirstReactDOMImpl(node);
		  },
		
		  /**
		   * Finds a node with the supplied `targetID` inside of the supplied
		   * `ancestorNode`.  Exploits the ID naming scheme to perform the search
		   * quickly.
		   *
		   * @param {DOMEventTarget} ancestorNode Search from this root.
		   * @pararm {string} targetID ID of the DOM representation of the component.
		   * @return {DOMEventTarget} DOM node with the supplied `targetID`.
		   * @internal
		   */
		  findComponentRoot: function (ancestorNode, targetID) {
		    var firstChildren = findComponentRootReusableArray;
		    var childIndex = 0;
		
		    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;
		
		    if (process.env.NODE_ENV !== 'production') {
		      // This will throw on the next line; give an early warning
		      process.env.NODE_ENV !== 'production' ? warning(deepestAncestor != null, 'React can\'t find the root component node for data-reactid value ' + '`%s`. If you\'re seeing this message, it probably means that ' + 'you\'ve loaded two copies of React on the page. At this time, only ' + 'a single copy of React can be loaded at a time.', targetID) : undefined;
		    }
		
		    firstChildren[0] = deepestAncestor.firstChild;
		    firstChildren.length = 1;
		
		    while (childIndex < firstChildren.length) {
		      var child = firstChildren[childIndex++];
		      var targetChild;
		
		      while (child) {
		        var childID = ReactMount.getID(child);
		        if (childID) {
		          // Even if we find the node we're looking for, we finish looping
		          // through its siblings to ensure they're cached so that we don't have
		          // to revisit this node again. Otherwise, we make n^2 calls to getID
		          // when visiting the many children of a single node in order.
		
		          if (targetID === childID) {
		            targetChild = child;
		          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
		            // If we find a child whose ID is an ancestor of the given ID,
		            // then we can be sure that we only want to search the subtree
		            // rooted at this child, so we can throw out the rest of the
		            // search state.
		            firstChildren.length = childIndex = 0;
		            firstChildren.push(child.firstChild);
		          }
		        } else {
		          // If this child had no ID, then there's a chance that it was
		          // injected automatically by the browser, as when a `<table>`
		          // element sprouts an extra `<tbody>` child as a side effect of
		          // `.innerHTML` parsing. Optimistically continue down this
		          // branch, but not before examining the other siblings.
		          firstChildren.push(child.firstChild);
		        }
		
		        child = child.nextSibling;
		      }
		
		      if (targetChild) {
		        // Emptying firstChildren/findComponentRootReusableArray is
		        // not necessary for correctness, but it helps the GC reclaim
		        // any nodes that were left at the end of the search.
		        firstChildren.length = 0;
		
		        return targetChild;
		      }
		    }
		
		    firstChildren.length = 0;
		
		     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;
		  },
		
		  _mountImageIntoNode: function (markup, container, shouldReuseMarkup, transaction) {
		    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;
		
		    if (shouldReuseMarkup) {
		      var rootElement = getReactRootElementInContainer(container);
		      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
		        return;
		      } else {
		        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
		        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
		
		        var rootMarkup = rootElement.outerHTML;
		        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
		
		        var normalizedMarkup = markup;
		        if (process.env.NODE_ENV !== 'production') {
		          // because rootMarkup is retrieved from the DOM, various normalizations
		          // will have occurred which will not be present in `markup`. Here,
		          // insert markup into a <div> or <iframe> depending on the container
		          // type to perform the same normalizations before comparing.
		          var normalizer;
		          if (container.nodeType === ELEMENT_NODE_TYPE) {
		            normalizer = document.createElement('div');
		            normalizer.innerHTML = markup;
		            normalizedMarkup = normalizer.innerHTML;
		          } else {
		            normalizer = document.createElement('iframe');
		            document.body.appendChild(normalizer);
		            normalizer.contentDocument.write(markup);
		            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
		            document.body.removeChild(normalizer);
		          }
		        }
		
		        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
		        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
		
		        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\n%s', difference) : invariant(false) : undefined;
		
		        if (process.env.NODE_ENV !== 'production') {
		          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : undefined;
		        }
		      }
		    }
		
		    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
		
		    if (transaction.useCreateElement) {
		      while (container.lastChild) {
		        container.removeChild(container.lastChild);
		      }
		      container.appendChild(markup);
		    } else {
		      setInnerHTML(container, markup);
		    }
		  },
		
		  ownerDocumentContextKey: ownerDocumentContextKey,
		
		  /**
		   * React ID utilities.
		   */
		
		  getReactRootID: getReactRootID,
		
		  getID: getID,
		
		  setID: setID,
		
		  getNode: getNode,
		
		  getNodeFromInstance: getNodeFromInstance,
		
		  isValid: isValid,
		
		  purgeID: purgeID
		};
		
		ReactPerf.measureMethods(ReactMount, 'ReactMount', {
		  _renderNewRootComponent: '_renderNewRootComponent',
		  _mountImageIntoNode: '_mountImageIntoNode'
		});
		
		module.exports = ReactMount;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 29 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactBrowserEventEmitter
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var EventConstants = __webpack_require__(30);
		var EventPluginHub = __webpack_require__(31);
		var EventPluginRegistry = __webpack_require__(32);
		var ReactEventEmitterMixin = __webpack_require__(37);
		var ReactPerf = __webpack_require__(18);
		var ViewportMetrics = __webpack_require__(38);
		
		var assign = __webpack_require__(39);
		var isEventSupported = __webpack_require__(40);
		
		/**
		 * Summary of `ReactBrowserEventEmitter` event handling:
		 *
		 *  - Top-level delegation is used to trap most native browser events. This
		 *    may only occur in the main thread and is the responsibility of
		 *    ReactEventListener, which is injected and can therefore support pluggable
		 *    event sources. This is the only work that occurs in the main thread.
		 *
		 *  - We normalize and de-duplicate events to account for browser quirks. This
		 *    may be done in the worker thread.
		 *
		 *  - Forward these native events (with the associated top-level type used to
		 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
		 *    to extract any synthetic events.
		 *
		 *  - The `EventPluginHub` will then process each event by annotating them with
		 *    "dispatches", a sequence of listeners and IDs that care about that event.
		 *
		 *  - The `EventPluginHub` then dispatches the events.
		 *
		 * Overview of React and the event system:
		 *
		 * +------------+    .
		 * |    DOM     |    .
		 * +------------+    .
		 *       |           .
		 *       v           .
		 * +------------+    .
		 * | ReactEvent |    .
		 * |  Listener  |    .
		 * +------------+    .                         +-----------+
		 *       |           .               +--------+|SimpleEvent|
		 *       |           .               |         |Plugin     |
		 * +-----|------+    .               v         +-----------+
		 * |     |      |    .    +--------------+                    +------------+
		 * |     +-----------.--->|EventPluginHub|                    |    Event   |
		 * |            |    .    |              |     +-----------+  | Propagators|
		 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
		 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
		 * |            |    .    |              |     +-----------+  |  utilities |
		 * |     +-----------.--->|              |                    +------------+
		 * |     |      |    .    +--------------+
		 * +-----|------+    .                ^        +-----------+
		 *       |           .                |        |Enter/Leave|
		 *       +           .                +-------+|Plugin     |
		 * +-------------+   .                         +-----------+
		 * | application |   .
		 * |-------------|   .
		 * |             |   .
		 * |             |   .
		 * +-------------+   .
		 *                   .
		 *    React Core     .  General Purpose Event Plugin System
		 */
		
		var alreadyListeningTo = {};
		var isMonitoringScrollValue = false;
		var reactTopListenersCounter = 0;
		
		// For events like 'submit' which don't consistently bubble (which we trap at a
		// lower node than `document`), binding at `document` would cause duplicate
		// events so we don't include them here
		var topEventMapping = {
		  topAbort: 'abort',
		  topBlur: 'blur',
		  topCanPlay: 'canplay',
		  topCanPlayThrough: 'canplaythrough',
		  topChange: 'change',
		  topClick: 'click',
		  topCompositionEnd: 'compositionend',
		  topCompositionStart: 'compositionstart',
		  topCompositionUpdate: 'compositionupdate',
		  topContextMenu: 'contextmenu',
		  topCopy: 'copy',
		  topCut: 'cut',
		  topDoubleClick: 'dblclick',
		  topDrag: 'drag',
		  topDragEnd: 'dragend',
		  topDragEnter: 'dragenter',
		  topDragExit: 'dragexit',
		  topDragLeave: 'dragleave',
		  topDragOver: 'dragover',
		  topDragStart: 'dragstart',
		  topDrop: 'drop',
		  topDurationChange: 'durationchange',
		  topEmptied: 'emptied',
		  topEncrypted: 'encrypted',
		  topEnded: 'ended',
		  topError: 'error',
		  topFocus: 'focus',
		  topInput: 'input',
		  topKeyDown: 'keydown',
		  topKeyPress: 'keypress',
		  topKeyUp: 'keyup',
		  topLoadedData: 'loadeddata',
		  topLoadedMetadata: 'loadedmetadata',
		  topLoadStart: 'loadstart',
		  topMouseDown: 'mousedown',
		  topMouseMove: 'mousemove',
		  topMouseOut: 'mouseout',
		  topMouseOver: 'mouseover',
		  topMouseUp: 'mouseup',
		  topPaste: 'paste',
		  topPause: 'pause',
		  topPlay: 'play',
		  topPlaying: 'playing',
		  topProgress: 'progress',
		  topRateChange: 'ratechange',
		  topScroll: 'scroll',
		  topSeeked: 'seeked',
		  topSeeking: 'seeking',
		  topSelectionChange: 'selectionchange',
		  topStalled: 'stalled',
		  topSuspend: 'suspend',
		  topTextInput: 'textInput',
		  topTimeUpdate: 'timeupdate',
		  topTouchCancel: 'touchcancel',
		  topTouchEnd: 'touchend',
		  topTouchMove: 'touchmove',
		  topTouchStart: 'touchstart',
		  topVolumeChange: 'volumechange',
		  topWaiting: 'waiting',
		  topWheel: 'wheel'
		};
		
		/**
		 * To ensure no conflicts with other potential React instances on the page
		 */
		var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
		
		function getListeningForDocument(mountAt) {
		  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
		  // directly.
		  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
		    mountAt[topListenersIDKey] = reactTopListenersCounter++;
		    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
		  }
		  return alreadyListeningTo[mountAt[topListenersIDKey]];
		}
		
		/**
		 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
		 * example:
		 *
		 *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);
		 *
		 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
		 *
		 * @internal
		 */
		var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {
		
		  /**
		   * Injectable event backend
		   */
		  ReactEventListener: null,
		
		  injection: {
		    /**
		     * @param {object} ReactEventListener
		     */
		    injectReactEventListener: function (ReactEventListener) {
		      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
		      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
		    }
		  },
		
		  /**
		   * Sets whether or not any created callbacks should be enabled.
		   *
		   * @param {boolean} enabled True if callbacks should be enabled.
		   */
		  setEnabled: function (enabled) {
		    if (ReactBrowserEventEmitter.ReactEventListener) {
		      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
		    }
		  },
		
		  /**
		   * @return {boolean} True if callbacks are enabled.
		   */
		  isEnabled: function () {
		    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
		  },
		
		  /**
		   * We listen for bubbled touch events on the document object.
		   *
		   * Firefox v8.01 (and possibly others) exhibited strange behavior when
		   * mounting `onmousemove` events at some node that was not the document
		   * element. The symptoms were that if your mouse is not moving over something
		   * contained within that mount point (for example on the background) the
		   * top-level listeners for `onmousemove` won't be called. However, if you
		   * register the `mousemove` on the document object, then it will of course
		   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
		   * top-level listeners to the document object only, at least for these
		   * movement types of events and possibly all events.
		   *
		   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
		   *
		   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
		   * they bubble to document.
		   *
		   * @param {string} registrationName Name of listener (e.g. `onClick`).
		   * @param {object} contentDocumentHandle Document which owns the container
		   */
		  listenTo: function (registrationName, contentDocumentHandle) {
		    var mountAt = contentDocumentHandle;
		    var isListening = getListeningForDocument(mountAt);
		    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
		
		    var topLevelTypes = EventConstants.topLevelTypes;
		    for (var i = 0; i < dependencies.length; i++) {
		      var dependency = dependencies[i];
		      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
		        if (dependency === topLevelTypes.topWheel) {
		          if (isEventSupported('wheel')) {
		            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
		          } else if (isEventSupported('mousewheel')) {
		            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
		          } else {
		            // Firefox needs to capture a different mouse scroll event.
		            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
		            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
		          }
		        } else if (dependency === topLevelTypes.topScroll) {
		
		          if (isEventSupported('scroll', true)) {
		            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
		          } else {
		            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
		          }
		        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {
		
		          if (isEventSupported('focus', true)) {
		            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
		            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
		          } else if (isEventSupported('focusin')) {
		            // IE has `focusin` and `focusout` events which bubble.
		            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
		            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
		            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
		          }
		
		          // to make sure blur and focus event listeners are only attached once
		          isListening[topLevelTypes.topBlur] = true;
		          isListening[topLevelTypes.topFocus] = true;
		        } else if (topEventMapping.hasOwnProperty(dependency)) {
		          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
		        }
		
		        isListening[dependency] = true;
		      }
		    }
		  },
		
		  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
		    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
		  },
		
		  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
		    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
		  },
		
		  /**
		   * Listens to window scroll and resize events. We cache scroll values so that
		   * application code can access them without triggering reflows.
		   *
		   * NOTE: Scroll events do not bubble.
		   *
		   * @see http://www.quirksmode.org/dom/events/scroll.html
		   */
		  ensureScrollValueMonitoring: function () {
		    if (!isMonitoringScrollValue) {
		      var refresh = ViewportMetrics.refreshScrollValues;
		      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
		      isMonitoringScrollValue = true;
		    }
		  },
		
		  eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,
		
		  registrationNameModules: EventPluginHub.registrationNameModules,
		
		  putListener: EventPluginHub.putListener,
		
		  getListener: EventPluginHub.getListener,
		
		  deleteListener: EventPluginHub.deleteListener,
		
		  deleteAllListeners: EventPluginHub.deleteAllListeners
		
		});
		
		ReactPerf.measureMethods(ReactBrowserEventEmitter, 'ReactBrowserEventEmitter', {
		  putListener: 'putListener',
		  deleteListener: 'deleteListener'
		});
		
		module.exports = ReactBrowserEventEmitter;
	
	/***/ },
	/* 30 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule EventConstants
		 */
		
		'use strict';
		
		var keyMirror = __webpack_require__(17);
		
		var PropagationPhases = keyMirror({ bubbled: null, captured: null });
		
		/**
		 * Types of raw signals from the browser caught at the top level.
		 */
		var topLevelTypes = keyMirror({
		  topAbort: null,
		  topBlur: null,
		  topCanPlay: null,
		  topCanPlayThrough: null,
		  topChange: null,
		  topClick: null,
		  topCompositionEnd: null,
		  topCompositionStart: null,
		  topCompositionUpdate: null,
		  topContextMenu: null,
		  topCopy: null,
		  topCut: null,
		  topDoubleClick: null,
		  topDrag: null,
		  topDragEnd: null,
		  topDragEnter: null,
		  topDragExit: null,
		  topDragLeave: null,
		  topDragOver: null,
		  topDragStart: null,
		  topDrop: null,
		  topDurationChange: null,
		  topEmptied: null,
		  topEncrypted: null,
		  topEnded: null,
		  topError: null,
		  topFocus: null,
		  topInput: null,
		  topKeyDown: null,
		  topKeyPress: null,
		  topKeyUp: null,
		  topLoad: null,
		  topLoadedData: null,
		  topLoadedMetadata: null,
		  topLoadStart: null,
		  topMouseDown: null,
		  topMouseMove: null,
		  topMouseOut: null,
		  topMouseOver: null,
		  topMouseUp: null,
		  topPaste: null,
		  topPause: null,
		  topPlay: null,
		  topPlaying: null,
		  topProgress: null,
		  topRateChange: null,
		  topReset: null,
		  topScroll: null,
		  topSeeked: null,
		  topSeeking: null,
		  topSelectionChange: null,
		  topStalled: null,
		  topSubmit: null,
		  topSuspend: null,
		  topTextInput: null,
		  topTimeUpdate: null,
		  topTouchCancel: null,
		  topTouchEnd: null,
		  topTouchMove: null,
		  topTouchStart: null,
		  topVolumeChange: null,
		  topWaiting: null,
		  topWheel: null
		});
		
		var EventConstants = {
		  topLevelTypes: topLevelTypes,
		  PropagationPhases: PropagationPhases
		};
		
		module.exports = EventConstants;
	
	/***/ },
	/* 31 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule EventPluginHub
		 */
		
		'use strict';
		
		var EventPluginRegistry = __webpack_require__(32);
		var EventPluginUtils = __webpack_require__(33);
		var ReactErrorUtils = __webpack_require__(34);
		
		var accumulateInto = __webpack_require__(35);
		var forEachAccumulated = __webpack_require__(36);
		var invariant = __webpack_require__(13);
		var warning = __webpack_require__(25);
		
		/**
		 * Internal store for event listeners
		 */
		var listenerBank = {};
		
		/**
		 * Internal queue of events that have accumulated their dispatches and are
		 * waiting to have their dispatches executed.
		 */
		var eventQueue = null;
		
		/**
		 * Dispatches an event and releases it back into the pool, unless persistent.
		 *
		 * @param {?object} event Synthetic event to be dispatched.
		 * @param {boolean} simulated If the event is simulated (changes exn behavior)
		 * @private
		 */
		var executeDispatchesAndRelease = function (event, simulated) {
		  if (event) {
		    EventPluginUtils.executeDispatchesInOrder(event, simulated);
		
		    if (!event.isPersistent()) {
		      event.constructor.release(event);
		    }
		  }
		};
		var executeDispatchesAndReleaseSimulated = function (e) {
		  return executeDispatchesAndRelease(e, true);
		};
		var executeDispatchesAndReleaseTopLevel = function (e) {
		  return executeDispatchesAndRelease(e, false);
		};
		
		/**
		 * - `InstanceHandle`: [required] Module that performs logical traversals of DOM
		 *   hierarchy given ids of the logical DOM elements involved.
		 */
		var InstanceHandle = null;
		
		function validateInstanceHandle() {
		  var valid = InstanceHandle && InstanceHandle.traverseTwoPhase && InstanceHandle.traverseEnterLeave;
		  process.env.NODE_ENV !== 'production' ? warning(valid, 'InstanceHandle not injected before use!') : undefined;
		}
		
		/**
		 * This is a unified interface for event plugins to be installed and configured.
		 *
		 * Event plugins can implement the following properties:
		 *
		 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
		 *     Required. When a top-level event is fired, this method is expected to
		 *     extract synthetic events that will in turn be queued and dispatched.
		 *
		 *   `eventTypes` {object}
		 *     Optional, plugins that fire events must publish a mapping of registration
		 *     names that are used to register listeners. Values of this mapping must
		 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
		 *
		 *   `executeDispatch` {function(object, function, string)}
		 *     Optional, allows plugins to override how an event gets dispatched. By
		 *     default, the listener is simply invoked.
		 *
		 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
		 *
		 * @public
		 */
		var EventPluginHub = {
		
		  /**
		   * Methods for injecting dependencies.
		   */
		  injection: {
		
		    /**
		     * @param {object} InjectedMount
		     * @public
		     */
		    injectMount: EventPluginUtils.injection.injectMount,
		
		    /**
		     * @param {object} InjectedInstanceHandle
		     * @public
		     */
		    injectInstanceHandle: function (InjectedInstanceHandle) {
		      InstanceHandle = InjectedInstanceHandle;
		      if (process.env.NODE_ENV !== 'production') {
		        validateInstanceHandle();
		      }
		    },
		
		    getInstanceHandle: function () {
		      if (process.env.NODE_ENV !== 'production') {
		        validateInstanceHandle();
		      }
		      return InstanceHandle;
		    },
		
		    /**
		     * @param {array} InjectedEventPluginOrder
		     * @public
		     */
		    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
		
		    /**
		     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
		     */
		    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
		
		  },
		
		  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,
		
		  registrationNameModules: EventPluginRegistry.registrationNameModules,
		
		  /**
		   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
		   *
		   * @param {string} id ID of the DOM element.
		   * @param {string} registrationName Name of listener (e.g. `onClick`).
		   * @param {?function} listener The callback to store.
		   */
		  putListener: function (id, registrationName, listener) {
		    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : invariant(false) : undefined;
		
		    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
		    bankForRegistrationName[id] = listener;
		
		    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
		    if (PluginModule && PluginModule.didPutListener) {
		      PluginModule.didPutListener(id, registrationName, listener);
		    }
		  },
		
		  /**
		   * @param {string} id ID of the DOM element.
		   * @param {string} registrationName Name of listener (e.g. `onClick`).
		   * @return {?function} The stored callback.
		   */
		  getListener: function (id, registrationName) {
		    var bankForRegistrationName = listenerBank[registrationName];
		    return bankForRegistrationName && bankForRegistrationName[id];
		  },
		
		  /**
		   * Deletes a listener from the registration bank.
		   *
		   * @param {string} id ID of the DOM element.
		   * @param {string} registrationName Name of listener (e.g. `onClick`).
		   */
		  deleteListener: function (id, registrationName) {
		    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
		    if (PluginModule && PluginModule.willDeleteListener) {
		      PluginModule.willDeleteListener(id, registrationName);
		    }
		
		    var bankForRegistrationName = listenerBank[registrationName];
		    // TODO: This should never be null -- when is it?
		    if (bankForRegistrationName) {
		      delete bankForRegistrationName[id];
		    }
		  },
		
		  /**
		   * Deletes all listeners for the DOM element with the supplied ID.
		   *
		   * @param {string} id ID of the DOM element.
		   */
		  deleteAllListeners: function (id) {
		    for (var registrationName in listenerBank) {
		      if (!listenerBank[registrationName][id]) {
		        continue;
		      }
		
		      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
		      if (PluginModule && PluginModule.willDeleteListener) {
		        PluginModule.willDeleteListener(id, registrationName);
		      }
		
		      delete listenerBank[registrationName][id];
		    }
		  },
		
		  /**
		   * Allows registered plugins an opportunity to extract events from top-level
		   * native browser events.
		   *
		   * @param {string} topLevelType Record from `EventConstants`.
		   * @param {DOMEventTarget} topLevelTarget The listening component root node.
		   * @param {string} topLevelTargetID ID of `topLevelTarget`.
		   * @param {object} nativeEvent Native browser event.
		   * @return {*} An accumulation of synthetic events.
		   * @internal
		   */
		  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
		    var events;
		    var plugins = EventPluginRegistry.plugins;
		    for (var i = 0; i < plugins.length; i++) {
		      // Not every plugin in the ordering may be loaded at runtime.
		      var possiblePlugin = plugins[i];
		      if (possiblePlugin) {
		        var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
		        if (extractedEvents) {
		          events = accumulateInto(events, extractedEvents);
		        }
		      }
		    }
		    return events;
		  },
		
		  /**
		   * Enqueues a synthetic event that should be dispatched when
		   * `processEventQueue` is invoked.
		   *
		   * @param {*} events An accumulation of synthetic events.
		   * @internal
		   */
		  enqueueEvents: function (events) {
		    if (events) {
		      eventQueue = accumulateInto(eventQueue, events);
		    }
		  },
		
		  /**
		   * Dispatches all synthetic events on the event queue.
		   *
		   * @internal
		   */
		  processEventQueue: function (simulated) {
		    // Set `eventQueue` to null before processing it so that we can tell if more
		    // events get enqueued while processing.
		    var processingEventQueue = eventQueue;
		    eventQueue = null;
		    if (simulated) {
		      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
		    } else {
		      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
		    }
		    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(false) : undefined;
		    // This would be a good time to rethrow if any of the event handlers threw.
		    ReactErrorUtils.rethrowCaughtError();
		  },
		
		  /**
		   * These are needed for tests only. Do not use!
		   */
		  __purge: function () {
		    listenerBank = {};
		  },
		
		  __getListenerBank: function () {
		    return listenerBank;
		  }
		
		};
		
		module.exports = EventPluginHub;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 32 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule EventPluginRegistry
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var invariant = __webpack_require__(13);
		
		/**
		 * Injectable ordering of event plugins.
		 */
		var EventPluginOrder = null;
		
		/**
		 * Injectable mapping from names to event plugin modules.
		 */
		var namesToPlugins = {};
		
		/**
		 * Recomputes the plugin list using the injected plugins and plugin ordering.
		 *
		 * @private
		 */
		function recomputePluginOrdering() {
		  if (!EventPluginOrder) {
		    // Wait until an `EventPluginOrder` is injected.
		    return;
		  }
		  for (var pluginName in namesToPlugins) {
		    var PluginModule = namesToPlugins[pluginName];
		    var pluginIndex = EventPluginOrder.indexOf(pluginName);
		    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(false) : undefined;
		    if (EventPluginRegistry.plugins[pluginIndex]) {
		      continue;
		    }
		    !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(false) : undefined;
		    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
		    var publishedEvents = PluginModule.eventTypes;
		    for (var eventName in publishedEvents) {
		      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(false) : undefined;
		    }
		  }
		}
		
		/**
		 * Publishes an event so that it can be dispatched by the supplied plugin.
		 *
		 * @param {object} dispatchConfig Dispatch configuration for the event.
		 * @param {object} PluginModule Plugin publishing the event.
		 * @return {boolean} True if the event was successfully published.
		 * @private
		 */
		function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
		  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(false) : undefined;
		  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
		
		  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
		  if (phasedRegistrationNames) {
		    for (var phaseName in phasedRegistrationNames) {
		      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
		        var phasedRegistrationName = phasedRegistrationNames[phaseName];
		        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
		      }
		    }
		    return true;
		  } else if (dispatchConfig.registrationName) {
		    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
		    return true;
		  }
		  return false;
		}
		
		/**
		 * Publishes a registration name that is used to identify dispatched events and
		 * can be used with `EventPluginHub.putListener` to register listeners.
		 *
		 * @param {string} registrationName Registration name to add.
		 * @param {object} PluginModule Plugin publishing the event.
		 * @private
		 */
		function publishRegistrationName(registrationName, PluginModule, eventName) {
		  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(false) : undefined;
		  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
		  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
		}
		
		/**
		 * Registers plugins so that they can extract and dispatch events.
		 *
		 * @see {EventPluginHub}
		 */
		var EventPluginRegistry = {
		
		  /**
		   * Ordered list of injected plugins.
		   */
		  plugins: [],
		
		  /**
		   * Mapping from event name to dispatch config
		   */
		  eventNameDispatchConfigs: {},
		
		  /**
		   * Mapping from registration name to plugin module
		   */
		  registrationNameModules: {},
		
		  /**
		   * Mapping from registration name to event name
		   */
		  registrationNameDependencies: {},
		
		  /**
		   * Injects an ordering of plugins (by plugin name). This allows the ordering
		   * to be decoupled from injection of the actual plugins so that ordering is
		   * always deterministic regardless of packaging, on-the-fly injection, etc.
		   *
		   * @param {array} InjectedEventPluginOrder
		   * @internal
		   * @see {EventPluginHub.injection.injectEventPluginOrder}
		   */
		  injectEventPluginOrder: function (InjectedEventPluginOrder) {
		    !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(false) : undefined;
		    // Clone the ordering so it cannot be dynamically mutated.
		    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
		    recomputePluginOrdering();
		  },
		
		  /**
		   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
		   * in the ordering injected by `injectEventPluginOrder`.
		   *
		   * Plugins can be injected as part of page initialization or on-the-fly.
		   *
		   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
		   * @internal
		   * @see {EventPluginHub.injection.injectEventPluginsByName}
		   */
		  injectEventPluginsByName: function (injectedNamesToPlugins) {
		    var isOrderingDirty = false;
		    for (var pluginName in injectedNamesToPlugins) {
		      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
		        continue;
		      }
		      var PluginModule = injectedNamesToPlugins[pluginName];
		      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
		        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(false) : undefined;
		        namesToPlugins[pluginName] = PluginModule;
		        isOrderingDirty = true;
		      }
		    }
		    if (isOrderingDirty) {
		      recomputePluginOrdering();
		    }
		  },
		
		  /**
		   * Looks up the plugin for the supplied event.
		   *
		   * @param {object} event A synthetic event.
		   * @return {?object} The plugin that created the supplied event.
		   * @internal
		   */
		  getPluginModuleForEvent: function (event) {
		    var dispatchConfig = event.dispatchConfig;
		    if (dispatchConfig.registrationName) {
		      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
		    }
		    for (var phase in dispatchConfig.phasedRegistrationNames) {
		      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
		        continue;
		      }
		      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
		      if (PluginModule) {
		        return PluginModule;
		      }
		    }
		    return null;
		  },
		
		  /**
		   * Exposed for unit testing.
		   * @private
		   */
		  _resetEventPlugins: function () {
		    EventPluginOrder = null;
		    for (var pluginName in namesToPlugins) {
		      if (namesToPlugins.hasOwnProperty(pluginName)) {
		        delete namesToPlugins[pluginName];
		      }
		    }
		    EventPluginRegistry.plugins.length = 0;
		
		    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
		    for (var eventName in eventNameDispatchConfigs) {
		      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
		        delete eventNameDispatchConfigs[eventName];
		      }
		    }
		
		    var registrationNameModules = EventPluginRegistry.registrationNameModules;
		    for (var registrationName in registrationNameModules) {
		      if (registrationNameModules.hasOwnProperty(registrationName)) {
		        delete registrationNameModules[registrationName];
		      }
		    }
		  }
		
		};
		
		module.exports = EventPluginRegistry;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 33 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule EventPluginUtils
		 */
		
		'use strict';
		
		var EventConstants = __webpack_require__(30);
		var ReactErrorUtils = __webpack_require__(34);
		
		var invariant = __webpack_require__(13);
		var warning = __webpack_require__(25);
		
		/**
		 * Injected dependencies:
		 */
		
		/**
		 * - `Mount`: [required] Module that can convert between React dom IDs and
		 *   actual node references.
		 */
		var injection = {
		  Mount: null,
		  injectMount: function (InjectedMount) {
		    injection.Mount = InjectedMount;
		    if (process.env.NODE_ENV !== 'production') {
		      process.env.NODE_ENV !== 'production' ? warning(InjectedMount && InjectedMount.getNode && InjectedMount.getID, 'EventPluginUtils.injection.injectMount(...): Injected Mount ' + 'module is missing getNode or getID.') : undefined;
		    }
		  }
		};
		
		var topLevelTypes = EventConstants.topLevelTypes;
		
		function isEndish(topLevelType) {
		  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
		}
		
		function isMoveish(topLevelType) {
		  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
		}
		function isStartish(topLevelType) {
		  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
		}
		
		var validateEventDispatches;
		if (process.env.NODE_ENV !== 'production') {
		  validateEventDispatches = function (event) {
		    var dispatchListeners = event._dispatchListeners;
		    var dispatchIDs = event._dispatchIDs;
		
		    var listenersIsArr = Array.isArray(dispatchListeners);
		    var idsIsArr = Array.isArray(dispatchIDs);
		    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
		    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
		
		    process.env.NODE_ENV !== 'production' ? warning(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : undefined;
		  };
		}
		
		/**
		 * Dispatch the event to the listener.
		 * @param {SyntheticEvent} event SyntheticEvent to handle
		 * @param {boolean} simulated If the event is simulated (changes exn behavior)
		 * @param {function} listener Application-level callback
		 * @param {string} domID DOM id to pass to the callback.
		 */
		function executeDispatch(event, simulated, listener, domID) {
		  var type = event.type || 'unknown-event';
		  event.currentTarget = injection.Mount.getNode(domID);
		  if (simulated) {
		    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event, domID);
		  } else {
		    ReactErrorUtils.invokeGuardedCallback(type, listener, event, domID);
		  }
		  event.currentTarget = null;
		}
		
		/**
		 * Standard/simple iteration through an event's collected dispatches.
		 */
		function executeDispatchesInOrder(event, simulated) {
		  var dispatchListeners = event._dispatchListeners;
		  var dispatchIDs = event._dispatchIDs;
		  if (process.env.NODE_ENV !== 'production') {
		    validateEventDispatches(event);
		  }
		  if (Array.isArray(dispatchListeners)) {
		    for (var i = 0; i < dispatchListeners.length; i++) {
		      if (event.isPropagationStopped()) {
		        break;
		      }
		      // Listeners and IDs are two parallel arrays that are always in sync.
		      executeDispatch(event, simulated, dispatchListeners[i], dispatchIDs[i]);
		    }
		  } else if (dispatchListeners) {
		    executeDispatch(event, simulated, dispatchListeners, dispatchIDs);
		  }
		  event._dispatchListeners = null;
		  event._dispatchIDs = null;
		}
		
		/**
		 * Standard/simple iteration through an event's collected dispatches, but stops
		 * at the first dispatch execution returning true, and returns that id.
		 *
		 * @return {?string} id of the first dispatch execution who's listener returns
		 * true, or null if no listener returned true.
		 */
		function executeDispatchesInOrderStopAtTrueImpl(event) {
		  var dispatchListeners = event._dispatchListeners;
		  var dispatchIDs = event._dispatchIDs;
		  if (process.env.NODE_ENV !== 'production') {
		    validateEventDispatches(event);
		  }
		  if (Array.isArray(dispatchListeners)) {
		    for (var i = 0; i < dispatchListeners.length; i++) {
		      if (event.isPropagationStopped()) {
		        break;
		      }
		      // Listeners and IDs are two parallel arrays that are always in sync.
		      if (dispatchListeners[i](event, dispatchIDs[i])) {
		        return dispatchIDs[i];
		      }
		    }
		  } else if (dispatchListeners) {
		    if (dispatchListeners(event, dispatchIDs)) {
		      return dispatchIDs;
		    }
		  }
		  return null;
		}
		
		/**
		 * @see executeDispatchesInOrderStopAtTrueImpl
		 */
		function executeDispatchesInOrderStopAtTrue(event) {
		  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
		  event._dispatchIDs = null;
		  event._dispatchListeners = null;
		  return ret;
		}
		
		/**
		 * Execution of a "direct" dispatch - there must be at most one dispatch
		 * accumulated on the event or it is considered an error. It doesn't really make
		 * sense for an event with multiple dispatches (bubbled) to keep track of the
		 * return values at each dispatch execution, but it does tend to make sense when
		 * dealing with "direct" dispatches.
		 *
		 * @return {*} The return value of executing the single dispatch.
		 */
		function executeDirectDispatch(event) {
		  if (process.env.NODE_ENV !== 'production') {
		    validateEventDispatches(event);
		  }
		  var dispatchListener = event._dispatchListeners;
		  var dispatchID = event._dispatchIDs;
		  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : invariant(false) : undefined;
		  var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
		  event._dispatchListeners = null;
		  event._dispatchIDs = null;
		  return res;
		}
		
		/**
		 * @param {SyntheticEvent} event
		 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
		 */
		function hasDispatches(event) {
		  return !!event._dispatchListeners;
		}
		
		/**
		 * General utilities that are useful in creating custom Event Plugins.
		 */
		var EventPluginUtils = {
		  isEndish: isEndish,
		  isMoveish: isMoveish,
		  isStartish: isStartish,
		
		  executeDirectDispatch: executeDirectDispatch,
		  executeDispatchesInOrder: executeDispatchesInOrder,
		  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
		  hasDispatches: hasDispatches,
		
		  getNode: function (id) {
		    return injection.Mount.getNode(id);
		  },
		  getID: function (node) {
		    return injection.Mount.getID(node);
		  },
		
		  injection: injection
		};
		
		module.exports = EventPluginUtils;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 34 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactErrorUtils
		 * @typechecks
		 */
		
		'use strict';
		
		var caughtError = null;
		
		/**
		 * Call a function while guarding against errors that happens within it.
		 *
		 * @param {?String} name of the guard to use for logging or debugging
		 * @param {Function} func The function to invoke
		 * @param {*} a First argument
		 * @param {*} b Second argument
		 */
		function invokeGuardedCallback(name, func, a, b) {
		  try {
		    return func(a, b);
		  } catch (x) {
		    if (caughtError === null) {
		      caughtError = x;
		    }
		    return undefined;
		  }
		}
		
		var ReactErrorUtils = {
		  invokeGuardedCallback: invokeGuardedCallback,
		
		  /**
		   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
		   * handler are sure to be rethrown by rethrowCaughtError.
		   */
		  invokeGuardedCallbackWithCatch: invokeGuardedCallback,
		
		  /**
		   * During execution of guarded functions we will capture the first error which
		   * we will rethrow to be handled by the top level error handler.
		   */
		  rethrowCaughtError: function () {
		    if (caughtError) {
		      var error = caughtError;
		      caughtError = null;
		      throw error;
		    }
		  }
		};
		
		if (process.env.NODE_ENV !== 'production') {
		  /**
		   * To help development we can get better devtools integration by simulating a
		   * real browser event.
		   */
		  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
		    var fakeNode = document.createElement('react');
		    ReactErrorUtils.invokeGuardedCallback = function (name, func, a, b) {
		      var boundFunc = func.bind(null, a, b);
		      var evtType = 'react-' + name;
		      fakeNode.addEventListener(evtType, boundFunc, false);
		      var evt = document.createEvent('Event');
		      evt.initEvent(evtType, false, false);
		      fakeNode.dispatchEvent(evt);
		      fakeNode.removeEventListener(evtType, boundFunc, false);
		    };
		  }
		}
		
		module.exports = ReactErrorUtils;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 35 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2014-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule accumulateInto
		 */
		
		'use strict';
		
		var invariant = __webpack_require__(13);
		
		/**
		 *
		 * Accumulates items that must not be null or undefined into the first one. This
		 * is used to conserve memory by avoiding array allocations, and thus sacrifices
		 * API cleanness. Since `current` can be null before being passed in and not
		 * null after this function, make sure to assign it back to `current`:
		 *
		 * `a = accumulateInto(a, b);`
		 *
		 * This API should be sparingly used. Try `accumulate` for something cleaner.
		 *
		 * @return {*|array<*>} An accumulation of items.
		 */
		
		function accumulateInto(current, next) {
		  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(false) : undefined;
		  if (current == null) {
		    return next;
		  }
		
		  // Both are not empty. Warning: Never call x.concat(y) when you are not
		  // certain that x is an Array (x could be a string with concat method).
		  var currentIsArray = Array.isArray(current);
		  var nextIsArray = Array.isArray(next);
		
		  if (currentIsArray && nextIsArray) {
		    current.push.apply(current, next);
		    return current;
		  }
		
		  if (currentIsArray) {
		    current.push(next);
		    return current;
		  }
		
		  if (nextIsArray) {
		    // A bit too dangerous to mutate `next`.
		    return [current].concat(next);
		  }
		
		  return [current, next];
		}
		
		module.exports = accumulateInto;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 36 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule forEachAccumulated
		 */
		
		'use strict';
		
		/**
		 * @param {array} arr an "accumulation" of items which is either an Array or
		 * a single item. Useful when paired with the `accumulate` module. This is a
		 * simple utility that allows us to reason about a collection of items, but
		 * handling the case when there is exactly one item (and we do not need to
		 * allocate an array).
		 */
		var forEachAccumulated = function (arr, cb, scope) {
		  if (Array.isArray(arr)) {
		    arr.forEach(cb, scope);
		  } else if (arr) {
		    cb.call(scope, arr);
		  }
		};
		
		module.exports = forEachAccumulated;
	
	/***/ },
	/* 37 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactEventEmitterMixin
		 */
		
		'use strict';
		
		var EventPluginHub = __webpack_require__(31);
		
		function runEventQueueInBatch(events) {
		  EventPluginHub.enqueueEvents(events);
		  EventPluginHub.processEventQueue(false);
		}
		
		var ReactEventEmitterMixin = {
		
		  /**
		   * Streams a fired top-level event to `EventPluginHub` where plugins have the
		   * opportunity to create `ReactEvent`s to be dispatched.
		   *
		   * @param {string} topLevelType Record from `EventConstants`.
		   * @param {object} topLevelTarget The listening component root node.
		   * @param {string} topLevelTargetID ID of `topLevelTarget`.
		   * @param {object} nativeEvent Native environment event.
		   */
		  handleTopLevel: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
		    var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
		    runEventQueueInBatch(events);
		  }
		};
		
		module.exports = ReactEventEmitterMixin;
	
	/***/ },
	/* 38 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ViewportMetrics
		 */
		
		'use strict';
		
		var ViewportMetrics = {
		
		  currentScrollLeft: 0,
		
		  currentScrollTop: 0,
		
		  refreshScrollValues: function (scrollPosition) {
		    ViewportMetrics.currentScrollLeft = scrollPosition.x;
		    ViewportMetrics.currentScrollTop = scrollPosition.y;
		  }
		
		};
		
		module.exports = ViewportMetrics;
	
	/***/ },
	/* 39 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2014-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule Object.assign
		 */
		
		// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign
		
		'use strict';
		
		function assign(target, sources) {
		  if (target == null) {
		    throw new TypeError('Object.assign target cannot be null or undefined');
		  }
		
		  var to = Object(target);
		  var hasOwnProperty = Object.prototype.hasOwnProperty;
		
		  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
		    var nextSource = arguments[nextIndex];
		    if (nextSource == null) {
		      continue;
		    }
		
		    var from = Object(nextSource);
		
		    // We don't currently support accessors nor proxies. Therefore this
		    // copy cannot throw. If we ever supported this then we must handle
		    // exceptions and side-effects. We don't support symbols so they won't
		    // be transferred.
		
		    for (var key in from) {
		      if (hasOwnProperty.call(from, key)) {
		        to[key] = from[key];
		      }
		    }
		  }
		
		  return to;
		}
		
		module.exports = assign;
	
	/***/ },
	/* 40 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule isEventSupported
		 */
		
		'use strict';
		
		var ExecutionEnvironment = __webpack_require__(9);
		
		var useHasFeature;
		if (ExecutionEnvironment.canUseDOM) {
		  useHasFeature = document.implementation && document.implementation.hasFeature &&
		  // always returns true in newer browsers as per the standard.
		  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
		  document.implementation.hasFeature('', '') !== true;
		}
		
		/**
		 * Checks if an event is supported in the current execution environment.
		 *
		 * NOTE: This will not work correctly for non-generic events such as `change`,
		 * `reset`, `load`, `error`, and `select`.
		 *
		 * Borrows from Modernizr.
		 *
		 * @param {string} eventNameSuffix Event name, e.g. "click".
		 * @param {?boolean} capture Check if the capture phase is supported.
		 * @return {boolean} True if the event is supported.
		 * @internal
		 * @license Modernizr 3.0.0pre (Custom Build) | MIT
		 */
		function isEventSupported(eventNameSuffix, capture) {
		  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
		    return false;
		  }
		
		  var eventName = 'on' + eventNameSuffix;
		  var isSupported = (eventName in document);
		
		  if (!isSupported) {
		    var element = document.createElement('div');
		    element.setAttribute(eventName, 'return;');
		    isSupported = typeof element[eventName] === 'function';
		  }
		
		  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
		    // This is the only way to test support for the `wheel` event in IE9+.
		    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
		  }
		
		  return isSupported;
		}
		
		module.exports = isEventSupported;
	
	/***/ },
	/* 41 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactDOMFeatureFlags
		 */
		
		'use strict';
		
		var ReactDOMFeatureFlags = {
		  useCreateElement: false
		};
		
		module.exports = ReactDOMFeatureFlags;
	
	/***/ },
	/* 42 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2014-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactElement
		 */
		
		'use strict';
		
		var ReactCurrentOwner = __webpack_require__(5);
		
		var assign = __webpack_require__(39);
		var canDefineProperty = __webpack_require__(43);
		
		// The Symbol used to tag the ReactElement type. If there is no native Symbol
		// nor polyfill, then a plain number is used for performance.
		var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
		
		var RESERVED_PROPS = {
		  key: true,
		  ref: true,
		  __self: true,
		  __source: true
		};
		
		/**
		 * Base constructor for all React elements. This is only used to make this
		 * work with a dynamic instanceof check. Nothing should live on this prototype.
		 *
		 * @param {*} type
		 * @param {*} key
		 * @param {string|object} ref
		 * @param {*} self A *temporary* helper to detect places where `this` is
		 * different from the `owner` when React.createElement is called, so that we
		 * can warn. We want to get rid of owner and replace string `ref`s with arrow
		 * functions, and as long as `this` and owner are the same, there will be no
		 * change in behavior.
		 * @param {*} source An annotation object (added by a transpiler or otherwise)
		 * indicating filename, line number, and/or other information.
		 * @param {*} owner
		 * @param {*} props
		 * @internal
		 */
		var ReactElement = function (type, key, ref, self, source, owner, props) {
		  var element = {
		    // This tag allow us to uniquely identify this as a React Element
		    $$typeof: REACT_ELEMENT_TYPE,
		
		    // Built-in properties that belong on the element
		    type: type,
		    key: key,
		    ref: ref,
		    props: props,
		
		    // Record the component responsible for creating this element.
		    _owner: owner
		  };
		
		  if (process.env.NODE_ENV !== 'production') {
		    // The validation flag is currently mutative. We put it on
		    // an external backing store so that we can freeze the whole object.
		    // This can be replaced with a WeakMap once they are implemented in
		    // commonly used development environments.
		    element._store = {};
		
		    // To make comparing ReactElements easier for testing purposes, we make
		    // the validation flag non-enumerable (where possible, which should
		    // include every environment we run tests in), so the test framework
		    // ignores it.
		    if (canDefineProperty) {
		      Object.defineProperty(element._store, 'validated', {
		        configurable: false,
		        enumerable: false,
		        writable: true,
		        value: false
		      });
		      // self and source are DEV only properties.
		      Object.defineProperty(element, '_self', {
		        configurable: false,
		        enumerable: false,
		        writable: false,
		        value: self
		      });
		      // Two elements created in two different places should be considered
		      // equal for testing purposes and therefore we hide it from enumeration.
		      Object.defineProperty(element, '_source', {
		        configurable: false,
		        enumerable: false,
		        writable: false,
		        value: source
		      });
		    } else {
		      element._store.validated = false;
		      element._self = self;
		      element._source = source;
		    }
		    Object.freeze(element.props);
		    Object.freeze(element);
		  }
		
		  return element;
		};
		
		ReactElement.createElement = function (type, config, children) {
		  var propName;
		
		  // Reserved names are extracted
		  var props = {};
		
		  var key = null;
		  var ref = null;
		  var self = null;
		  var source = null;
		
		  if (config != null) {
		    ref = config.ref === undefined ? null : config.ref;
		    key = config.key === undefined ? null : '' + config.key;
		    self = config.__self === undefined ? null : config.__self;
		    source = config.__source === undefined ? null : config.__source;
		    // Remaining properties are added to a new props object
		    for (propName in config) {
		      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
		        props[propName] = config[propName];
		      }
		    }
		  }
		
		  // Children can be more than one argument, and those are transferred onto
		  // the newly allocated props object.
		  var childrenLength = arguments.length - 2;
		  if (childrenLength === 1) {
		    props.children = children;
		  } else if (childrenLength > 1) {
		    var childArray = Array(childrenLength);
		    for (var i = 0; i < childrenLength; i++) {
		      childArray[i] = arguments[i + 2];
		    }
		    props.children = childArray;
		  }
		
		  // Resolve default props
		  if (type && type.defaultProps) {
		    var defaultProps = type.defaultProps;
		    for (propName in defaultProps) {
		      if (typeof props[propName] === 'undefined') {
		        props[propName] = defaultProps[propName];
		      }
		    }
		  }
		
		  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
		};
		
		ReactElement.createFactory = function (type) {
		  var factory = ReactElement.createElement.bind(null, type);
		  // Expose the type on the factory and the prototype so that it can be
		  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
		  // This should not be named `constructor` since this may not be the function
		  // that created the element, and it may not even be a constructor.
		  // Legacy hook TODO: Warn if this is accessed
		  factory.type = type;
		  return factory;
		};
		
		ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
		  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
		
		  return newElement;
		};
		
		ReactElement.cloneAndReplaceProps = function (oldElement, newProps) {
		  var newElement = ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, newProps);
		
		  if (process.env.NODE_ENV !== 'production') {
		    // If the key on the original is valid, then the clone is valid
		    newElement._store.validated = oldElement._store.validated;
		  }
		
		  return newElement;
		};
		
		ReactElement.cloneElement = function (element, config, children) {
		  var propName;
		
		  // Original props are copied
		  var props = assign({}, element.props);
		
		  // Reserved names are extracted
		  var key = element.key;
		  var ref = element.ref;
		  // Self is preserved since the owner is preserved.
		  var self = element._self;
		  // Source is preserved since cloneElement is unlikely to be targeted by a
		  // transpiler, and the original source is probably a better indicator of the
		  // true owner.
		  var source = element._source;
		
		  // Owner will be preserved, unless ref is overridden
		  var owner = element._owner;
		
		  if (config != null) {
		    if (config.ref !== undefined) {
		      // Silently steal the ref from the parent.
		      ref = config.ref;
		      owner = ReactCurrentOwner.current;
		    }
		    if (config.key !== undefined) {
		      key = '' + config.key;
		    }
		    // Remaining properties override existing props
		    for (propName in config) {
		      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
		        props[propName] = config[propName];
		      }
		    }
		  }
		
		  // Children can be more than one argument, and those are transferred onto
		  // the newly allocated props object.
		  var childrenLength = arguments.length - 2;
		  if (childrenLength === 1) {
		    props.children = children;
		  } else if (childrenLength > 1) {
		    var childArray = Array(childrenLength);
		    for (var i = 0; i < childrenLength; i++) {
		      childArray[i] = arguments[i + 2];
		    }
		    props.children = childArray;
		  }
		
		  return ReactElement(element.type, key, ref, self, source, owner, props);
		};
		
		/**
		 * @param {?object} object
		 * @return {boolean} True if `object` is a valid component.
		 * @final
		 */
		ReactElement.isValidElement = function (object) {
		  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
		};
		
		module.exports = ReactElement;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 43 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule canDefineProperty
		 */
		
		'use strict';
		
		var canDefineProperty = false;
		if (process.env.NODE_ENV !== 'production') {
		  try {
		    Object.defineProperty({}, 'x', { get: function () {} });
		    canDefineProperty = true;
		  } catch (x) {
		    // IE will fail on defineProperty
		  }
		}
		
		module.exports = canDefineProperty;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 44 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2014-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactEmptyComponentRegistry
		 */
		
		'use strict';
		
		// This registry keeps track of the React IDs of the components that rendered to
		// `null` (in reality a placeholder such as `noscript`)
		var nullComponentIDsRegistry = {};
		
		/**
		 * @param {string} id Component's `_rootNodeID`.
		 * @return {boolean} True if the component is rendered to null.
		 */
		function isNullComponentID(id) {
		  return !!nullComponentIDsRegistry[id];
		}
		
		/**
		 * Mark the component as having rendered to null.
		 * @param {string} id Component's `_rootNodeID`.
		 */
		function registerNullComponentID(id) {
		  nullComponentIDsRegistry[id] = true;
		}
		
		/**
		 * Unmark the component as having rendered to null: it renders to something now.
		 * @param {string} id Component's `_rootNodeID`.
		 */
		function deregisterNullComponentID(id) {
		  delete nullComponentIDsRegistry[id];
		}
		
		var ReactEmptyComponentRegistry = {
		  isNullComponentID: isNullComponentID,
		  registerNullComponentID: registerNullComponentID,
		  deregisterNullComponentID: deregisterNullComponentID
		};
		
		module.exports = ReactEmptyComponentRegistry;
	
	/***/ },
	/* 45 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactInstanceHandles
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var ReactRootIndex = __webpack_require__(46);
		
		var invariant = __webpack_require__(13);
		
		var SEPARATOR = '.';
		var SEPARATOR_LENGTH = SEPARATOR.length;
		
		/**
		 * Maximum depth of traversals before we consider the possibility of a bad ID.
		 */
		var MAX_TREE_DEPTH = 10000;
		
		/**
		 * Creates a DOM ID prefix to use when mounting React components.
		 *
		 * @param {number} index A unique integer
		 * @return {string} React root ID.
		 * @internal
		 */
		function getReactRootIDString(index) {
		  return SEPARATOR + index.toString(36);
		}
		
		/**
		 * Checks if a character in the supplied ID is a separator or the end.
		 *
		 * @param {string} id A React DOM ID.
		 * @param {number} index Index of the character to check.
		 * @return {boolean} True if the character is a separator or end of the ID.
		 * @private
		 */
		function isBoundary(id, index) {
		  return id.charAt(index) === SEPARATOR || index === id.length;
		}
		
		/**
		 * Checks if the supplied string is a valid React DOM ID.
		 *
		 * @param {string} id A React DOM ID, maybe.
		 * @return {boolean} True if the string is a valid React DOM ID.
		 * @private
		 */
		function isValidID(id) {
		  return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;
		}
		
		/**
		 * Checks if the first ID is an ancestor of or equal to the second ID.
		 *
		 * @param {string} ancestorID
		 * @param {string} descendantID
		 * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.
		 * @internal
		 */
		function isAncestorIDOf(ancestorID, descendantID) {
		  return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);
		}
		
		/**
		 * Gets the parent ID of the supplied React DOM ID, `id`.
		 *
		 * @param {string} id ID of a component.
		 * @return {string} ID of the parent, or an empty string.
		 * @private
		 */
		function getParentID(id) {
		  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
		}
		
		/**
		 * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the
		 * supplied `destinationID`. If they are equal, the ID is returned.
		 *
		 * @param {string} ancestorID ID of an ancestor node of `destinationID`.
		 * @param {string} destinationID ID of the destination node.
		 * @return {string} Next ID on the path from `ancestorID` to `destinationID`.
		 * @private
		 */
		function getNextDescendantID(ancestorID, destinationID) {
		  !(isValidID(ancestorID) && isValidID(destinationID)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(false) : undefined;
		  !isAncestorIDOf(ancestorID, destinationID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(false) : undefined;
		  if (ancestorID === destinationID) {
		    return ancestorID;
		  }
		  // Skip over the ancestor and the immediate separator. Traverse until we hit
		  // another separator or we reach the end of `destinationID`.
		  var start = ancestorID.length + SEPARATOR_LENGTH;
		  var i;
		  for (i = start; i < destinationID.length; i++) {
		    if (isBoundary(destinationID, i)) {
		      break;
		    }
		  }
		  return destinationID.substr(0, i);
		}
		
		/**
		 * Gets the nearest common ancestor ID of two IDs.
		 *
		 * Using this ID scheme, the nearest common ancestor ID is the longest common
		 * prefix of the two IDs that immediately preceded a "marker" in both strings.
		 *
		 * @param {string} oneID
		 * @param {string} twoID
		 * @return {string} Nearest common ancestor ID, or the empty string if none.
		 * @private
		 */
		function getFirstCommonAncestorID(oneID, twoID) {
		  var minLength = Math.min(oneID.length, twoID.length);
		  if (minLength === 0) {
		    return '';
		  }
		  var lastCommonMarkerIndex = 0;
		  // Use `<=` to traverse until the "EOL" of the shorter string.
		  for (var i = 0; i <= minLength; i++) {
		    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
		      lastCommonMarkerIndex = i;
		    } else if (oneID.charAt(i) !== twoID.charAt(i)) {
		      break;
		    }
		  }
		  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
		  !isValidID(longestCommonID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(false) : undefined;
		  return longestCommonID;
		}
		
		/**
		 * Traverses the parent path between two IDs (either up or down). The IDs must
		 * not be the same, and there must exist a parent path between them. If the
		 * callback returns `false`, traversal is stopped.
		 *
		 * @param {?string} start ID at which to start traversal.
		 * @param {?string} stop ID at which to end traversal.
		 * @param {function} cb Callback to invoke each ID with.
		 * @param {*} arg Argument to invoke the callback with.
		 * @param {?boolean} skipFirst Whether or not to skip the first node.
		 * @param {?boolean} skipLast Whether or not to skip the last node.
		 * @private
		 */
		function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
		  start = start || '';
		  stop = stop || '';
		  !(start !== stop) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(false) : undefined;
		  var traverseUp = isAncestorIDOf(stop, start);
		  !(traverseUp || isAncestorIDOf(start, stop)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(false) : undefined;
		  // Traverse from `start` to `stop` one depth at a time.
		  var depth = 0;
		  var traverse = traverseUp ? getParentID : getNextDescendantID;
		  for (var id = start;; /* until break */id = traverse(id, stop)) {
		    var ret;
		    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
		      ret = cb(id, traverseUp, arg);
		    }
		    if (ret === false || id === stop) {
		      // Only break //after// visiting `stop`.
		      break;
		    }
		    !(depth++ < MAX_TREE_DEPTH) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop, id) : invariant(false) : undefined;
		  }
		}
		
		/**
		 * Manages the IDs assigned to DOM representations of React components. This
		 * uses a specific scheme in order to traverse the DOM efficiently (e.g. in
		 * order to simulate events).
		 *
		 * @internal
		 */
		var ReactInstanceHandles = {
		
		  /**
		   * Constructs a React root ID
		   * @return {string} A React root ID.
		   */
		  createReactRootID: function () {
		    return getReactRootIDString(ReactRootIndex.createReactRootIndex());
		  },
		
		  /**
		   * Constructs a React ID by joining a root ID with a name.
		   *
		   * @param {string} rootID Root ID of a parent component.
		   * @param {string} name A component's name (as flattened children).
		   * @return {string} A React ID.
		   * @internal
		   */
		  createReactID: function (rootID, name) {
		    return rootID + name;
		  },
		
		  /**
		   * Gets the DOM ID of the React component that is the root of the tree that
		   * contains the React component with the supplied DOM ID.
		   *
		   * @param {string} id DOM ID of a React component.
		   * @return {?string} DOM ID of the React component that is the root.
		   * @internal
		   */
		  getReactRootIDFromNodeID: function (id) {
		    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
		      var index = id.indexOf(SEPARATOR, 1);
		      return index > -1 ? id.substr(0, index) : id;
		    }
		    return null;
		  },
		
		  /**
		   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
		   * should would receive a `mouseEnter` or `mouseLeave` event.
		   *
		   * NOTE: Does not invoke the callback on the nearest common ancestor because
		   * nothing "entered" or "left" that element.
		   *
		   * @param {string} leaveID ID being left.
		   * @param {string} enterID ID being entered.
		   * @param {function} cb Callback to invoke on each entered/left ID.
		   * @param {*} upArg Argument to invoke the callback with on left IDs.
		   * @param {*} downArg Argument to invoke the callback with on entered IDs.
		   * @internal
		   */
		  traverseEnterLeave: function (leaveID, enterID, cb, upArg, downArg) {
		    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
		    if (ancestorID !== leaveID) {
		      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
		    }
		    if (ancestorID !== enterID) {
		      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
		    }
		  },
		
		  /**
		   * Simulates the traversal of a two-phase, capture/bubble event dispatch.
		   *
		   * NOTE: This traversal happens on IDs without touching the DOM.
		   *
		   * @param {string} targetID ID of the target node.
		   * @param {function} cb Callback to invoke.
		   * @param {*} arg Argument to invoke the callback with.
		   * @internal
		   */
		  traverseTwoPhase: function (targetID, cb, arg) {
		    if (targetID) {
		      traverseParentPath('', targetID, cb, arg, true, false);
		      traverseParentPath(targetID, '', cb, arg, false, true);
		    }
		  },
		
		  /**
		   * Same as `traverseTwoPhase` but skips the `targetID`.
		   */
		  traverseTwoPhaseSkipTarget: function (targetID, cb, arg) {
		    if (targetID) {
		      traverseParentPath('', targetID, cb, arg, true, true);
		      traverseParentPath(targetID, '', cb, arg, true, true);
		    }
		  },
		
		  /**
		   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For
		   * example, passing `.0.$row-0.1` would result in `cb` getting called
		   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.
		   *
		   * NOTE: This traversal happens on IDs without touching the DOM.
		   *
		   * @param {string} targetID ID of the target node.
		   * @param {function} cb Callback to invoke.
		   * @param {*} arg Argument to invoke the callback with.
		   * @internal
		   */
		  traverseAncestors: function (targetID, cb, arg) {
		    traverseParentPath('', targetID, cb, arg, true, false);
		  },
		
		  getFirstCommonAncestorID: getFirstCommonAncestorID,
		
		  /**
		   * Exposed for unit testing.
		   * @private
		   */
		  _getNextDescendantID: getNextDescendantID,
		
		  isAncestorIDOf: isAncestorIDOf,
		
		  SEPARATOR: SEPARATOR
		
		};
		
		module.exports = ReactInstanceHandles;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 46 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactRootIndex
		 * @typechecks
		 */
		
		'use strict';
		
		var ReactRootIndexInjection = {
		  /**
		   * @param {function} _createReactRootIndex
		   */
		  injectCreateReactRootIndex: function (_createReactRootIndex) {
		    ReactRootIndex.createReactRootIndex = _createReactRootIndex;
		  }
		};
		
		var ReactRootIndex = {
		  createReactRootIndex: null,
		  injection: ReactRootIndexInjection
		};
		
		module.exports = ReactRootIndex;
	
	/***/ },
	/* 47 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactInstanceMap
		 */
		
		'use strict';
		
		/**
		 * `ReactInstanceMap` maintains a mapping from a public facing stateful
		 * instance (key) and the internal representation (value). This allows public
		 * methods to accept the user facing instance as an argument and map them back
		 * to internal methods.
		 */
		
		// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
		var ReactInstanceMap = {
		
		  /**
		   * This API should be called `delete` but we'd have to make sure to always
		   * transform these to strings for IE support. When this transform is fully
		   * supported we can rename it.
		   */
		  remove: function (key) {
		    key._reactInternalInstance = undefined;
		  },
		
		  get: function (key) {
		    return key._reactInternalInstance;
		  },
		
		  has: function (key) {
		    return key._reactInternalInstance !== undefined;
		  },
		
		  set: function (key, value) {
		    key._reactInternalInstance = value;
		  }
		
		};
		
		module.exports = ReactInstanceMap;
	
	/***/ },
	/* 48 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactMarkupChecksum
		 */
		
		'use strict';
		
		var adler32 = __webpack_require__(49);
		
		var TAG_END = /\/?>/;
		
		var ReactMarkupChecksum = {
		  CHECKSUM_ATTR_NAME: 'data-react-checksum',
		
		  /**
		   * @param {string} markup Markup string
		   * @return {string} Markup string with checksum attribute attached
		   */
		  addChecksumToMarkup: function (markup) {
		    var checksum = adler32(markup);
		
		    // Add checksum (handle both parent tags and self-closing tags)
		    return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
		  },
		
		  /**
		   * @param {string} markup to use
		   * @param {DOMElement} element root React element
		   * @returns {boolean} whether or not the markup is the same
		   */
		  canReuseMarkup: function (markup, element) {
		    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
		    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
		    var markupChecksum = adler32(markup);
		    return markupChecksum === existingChecksum;
		  }
		};
		
		module.exports = ReactMarkupChecksum;
	
	/***/ },
	/* 49 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule adler32
		 */
		
		'use strict';
		
		var MOD = 65521;
		
		// adler32 is not cryptographically strong, and is only used to sanity check that
		// markup generated on the server matches the markup generated on the client.
		// This implementation (a modified version of the SheetJS version) has been optimized
		// for our use case, at the expense of conforming to the adler32 specification
		// for non-ascii inputs.
		function adler32(data) {
		  var a = 1;
		  var b = 0;
		  var i = 0;
		  var l = data.length;
		  var m = l & ~0x3;
		  while (i < m) {
		    for (; i < Math.min(i + 4096, m); i += 4) {
		      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
		    }
		    a %= MOD;
		    b %= MOD;
		  }
		  for (; i < l; i++) {
		    b += a += data.charCodeAt(i);
		  }
		  a %= MOD;
		  b %= MOD;
		  return a | b << 16;
		}
		
		module.exports = adler32;
	
	/***/ },
	/* 50 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactReconciler
		 */
		
		'use strict';
		
		var ReactRef = __webpack_require__(51);
		
		/**
		 * Helper to call ReactRef.attachRefs with this composite component, split out
		 * to avoid allocations in the transaction mount-ready queue.
		 */
		function attachRefs() {
		  ReactRef.attachRefs(this, this._currentElement);
		}
		
		var ReactReconciler = {
		
		  /**
		   * Initializes the component, renders markup, and registers event listeners.
		   *
		   * @param {ReactComponent} internalInstance
		   * @param {string} rootID DOM ID of the root node.
		   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
		   * @return {?string} Rendered markup to be inserted into the DOM.
		   * @final
		   * @internal
		   */
		  mountComponent: function (internalInstance, rootID, transaction, context) {
		    var markup = internalInstance.mountComponent(rootID, transaction, context);
		    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
		      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
		    }
		    return markup;
		  },
		
		  /**
		   * Releases any resources allocated by `mountComponent`.
		   *
		   * @final
		   * @internal
		   */
		  unmountComponent: function (internalInstance) {
		    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
		    internalInstance.unmountComponent();
		  },
		
		  /**
		   * Update a component using a new element.
		   *
		   * @param {ReactComponent} internalInstance
		   * @param {ReactElement} nextElement
		   * @param {ReactReconcileTransaction} transaction
		   * @param {object} context
		   * @internal
		   */
		  receiveComponent: function (internalInstance, nextElement, transaction, context) {
		    var prevElement = internalInstance._currentElement;
		
		    if (nextElement === prevElement && context === internalInstance._context) {
		      // Since elements are immutable after the owner is rendered,
		      // we can do a cheap identity compare here to determine if this is a
		      // superfluous reconcile. It's possible for state to be mutable but such
		      // change should trigger an update of the owner which would recreate
		      // the element. We explicitly check for the existence of an owner since
		      // it's possible for an element created outside a composite to be
		      // deeply mutated and reused.
		
		      // TODO: Bailing out early is just a perf optimization right?
		      // TODO: Removing the return statement should affect correctness?
		      return;
		    }
		
		    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
		
		    if (refsChanged) {
		      ReactRef.detachRefs(internalInstance, prevElement);
		    }
		
		    internalInstance.receiveComponent(nextElement, transaction, context);
		
		    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
		      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
		    }
		  },
		
		  /**
		   * Flush any dirty changes in a component.
		   *
		   * @param {ReactComponent} internalInstance
		   * @param {ReactReconcileTransaction} transaction
		   * @internal
		   */
		  performUpdateIfNecessary: function (internalInstance, transaction) {
		    internalInstance.performUpdateIfNecessary(transaction);
		  }
		
		};
		
		module.exports = ReactReconciler;
	
	/***/ },
	/* 51 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactRef
		 */
		
		'use strict';
		
		var ReactOwner = __webpack_require__(52);
		
		var ReactRef = {};
		
		function attachRef(ref, component, owner) {
		  if (typeof ref === 'function') {
		    ref(component.getPublicInstance());
		  } else {
		    // Legacy ref
		    ReactOwner.addComponentAsRefTo(component, ref, owner);
		  }
		}
		
		function detachRef(ref, component, owner) {
		  if (typeof ref === 'function') {
		    ref(null);
		  } else {
		    // Legacy ref
		    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
		  }
		}
		
		ReactRef.attachRefs = function (instance, element) {
		  if (element === null || element === false) {
		    return;
		  }
		  var ref = element.ref;
		  if (ref != null) {
		    attachRef(ref, instance, element._owner);
		  }
		};
		
		ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
		  // If either the owner or a `ref` has changed, make sure the newest owner
		  // has stored a reference to `this`, and the previous owner (if different)
		  // has forgotten the reference to `this`. We use the element instead
		  // of the public this.props because the post processing cannot determine
		  // a ref. The ref conceptually lives on the element.
		
		  // TODO: Should this even be possible? The owner cannot change because
		  // it's forbidden by shouldUpdateReactComponent. The ref can change
		  // if you swap the keys of but not the refs. Reconsider where this check
		  // is made. It probably belongs where the key checking and
		  // instantiateReactComponent is done.
		
		  var prevEmpty = prevElement === null || prevElement === false;
		  var nextEmpty = nextElement === null || nextElement === false;
		
		  return(
		    // This has a few false positives w/r/t empty components.
		    prevEmpty || nextEmpty || nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref
		  );
		};
		
		ReactRef.detachRefs = function (instance, element) {
		  if (element === null || element === false) {
		    return;
		  }
		  var ref = element.ref;
		  if (ref != null) {
		    detachRef(ref, instance, element._owner);
		  }
		};
		
		module.exports = ReactRef;
	
	/***/ },
	/* 52 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactOwner
		 */
		
		'use strict';
		
		var invariant = __webpack_require__(13);
		
		/**
		 * ReactOwners are capable of storing references to owned components.
		 *
		 * All components are capable of //being// referenced by owner components, but
		 * only ReactOwner components are capable of //referencing// owned components.
		 * The named reference is known as a "ref".
		 *
		 * Refs are available when mounted and updated during reconciliation.
		 *
		 *   var MyComponent = React.createClass({
		 *     render: function() {
		 *       return (
		 *         <div onClick={this.handleClick}>
		 *           <CustomComponent ref="custom" />
		 *         </div>
		 *       );
		 *     },
		 *     handleClick: function() {
		 *       this.refs.custom.handleClick();
		 *     },
		 *     componentDidMount: function() {
		 *       this.refs.custom.initialize();
		 *     }
		 *   });
		 *
		 * Refs should rarely be used. When refs are used, they should only be done to
		 * control data that is not handled by React's data flow.
		 *
		 * @class ReactOwner
		 */
		var ReactOwner = {
		
		  /**
		   * @param {?object} object
		   * @return {boolean} True if `object` is a valid owner.
		   * @final
		   */
		  isValidOwner: function (object) {
		    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
		  },
		
		  /**
		   * Adds a component by ref to an owner component.
		   *
		   * @param {ReactComponent} component Component to reference.
		   * @param {string} ref Name by which to refer to the component.
		   * @param {ReactOwner} owner Component on which to record the ref.
		   * @final
		   * @internal
		   */
		  addComponentAsRefTo: function (component, ref, owner) {
		    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might ' + 'be adding a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
		    owner.attachRef(ref, component);
		  },
		
		  /**
		   * Removes a component by ref from an owner component.
		   *
		   * @param {ReactComponent} component Component to dereference.
		   * @param {string} ref Name of the ref to remove.
		   * @param {ReactOwner} owner Component on which the ref is recorded.
		   * @final
		   * @internal
		   */
		  removeComponentAsRefFrom: function (component, ref, owner) {
		    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might ' + 'be removing a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
		    // Check that `component` is still the current ref because we do not want to
		    // detach the ref if another component stole it.
		    if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {
		      owner.detachRef(ref);
		    }
		  }
		
		};
		
		module.exports = ReactOwner;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 53 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactUpdateQueue
		 */
		
		'use strict';
		
		var ReactCurrentOwner = __webpack_require__(5);
		var ReactElement = __webpack_require__(42);
		var ReactInstanceMap = __webpack_require__(47);
		var ReactUpdates = __webpack_require__(54);
		
		var assign = __webpack_require__(39);
		var invariant = __webpack_require__(13);
		var warning = __webpack_require__(25);
		
		function enqueueUpdate(internalInstance) {
		  ReactUpdates.enqueueUpdate(internalInstance);
		}
		
		function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
		  var internalInstance = ReactInstanceMap.get(publicInstance);
		  if (!internalInstance) {
		    if (process.env.NODE_ENV !== 'production') {
		      // Only warn when we have a callerName. Otherwise we should be silent.
		      // We're probably calling from enqueueCallback. We don't want to warn
		      // there because we already warned for the corresponding lifecycle method.
		      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : undefined;
		    }
		    return null;
		  }
		
		  if (process.env.NODE_ENV !== 'production') {
		    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : undefined;
		  }
		
		  return internalInstance;
		}
		
		/**
		 * ReactUpdateQueue allows for state updates to be scheduled into a later
		 * reconciliation step.
		 */
		var ReactUpdateQueue = {
		
		  /**
		   * Checks whether or not this composite component is mounted.
		   * @param {ReactClass} publicInstance The instance we want to test.
		   * @return {boolean} True if mounted, false otherwise.
		   * @protected
		   * @final
		   */
		  isMounted: function (publicInstance) {
		    if (process.env.NODE_ENV !== 'production') {
		      var owner = ReactCurrentOwner.current;
		      if (owner !== null) {
		        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
		        owner._warnedAboutRefsInRender = true;
		      }
		    }
		    var internalInstance = ReactInstanceMap.get(publicInstance);
		    if (internalInstance) {
		      // During componentWillMount and render this will still be null but after
		      // that will always render to something. At least for now. So we can use
		      // this hack.
		      return !!internalInstance._renderedComponent;
		    } else {
		      return false;
		    }
		  },
		
		  /**
		   * Enqueue a callback that will be executed after all the pending updates
		   * have processed.
		   *
		   * @param {ReactClass} publicInstance The instance to use as `this` context.
		   * @param {?function} callback Called after state is updated.
		   * @internal
		   */
		  enqueueCallback: function (publicInstance, callback) {
		    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
		    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
		
		    // Previously we would throw an error if we didn't have an internal
		    // instance. Since we want to make it a no-op instead, we mirror the same
		    // behavior we have in other enqueue* methods.
		    // We also need to ignore callbacks in componentWillMount. See
		    // enqueueUpdates.
		    if (!internalInstance) {
		      return null;
		    }
		
		    if (internalInstance._pendingCallbacks) {
		      internalInstance._pendingCallbacks.push(callback);
		    } else {
		      internalInstance._pendingCallbacks = [callback];
		    }
		    // TODO: The callback here is ignored when setState is called from
		    // componentWillMount. Either fix it or disallow doing so completely in
		    // favor of getInitialState. Alternatively, we can disallow
		    // componentWillMount during server-side rendering.
		    enqueueUpdate(internalInstance);
		  },
		
		  enqueueCallbackInternal: function (internalInstance, callback) {
		    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
		    if (internalInstance._pendingCallbacks) {
		      internalInstance._pendingCallbacks.push(callback);
		    } else {
		      internalInstance._pendingCallbacks = [callback];
		    }
		    enqueueUpdate(internalInstance);
		  },
		
		  /**
		   * Forces an update. This should only be invoked when it is known with
		   * certainty that we are **not** in a DOM transaction.
		   *
		   * You may want to call this when you know that some deeper aspect of the
		   * component's state has changed but `setState` was not called.
		   *
		   * This will not invoke `shouldComponentUpdate`, but it will invoke
		   * `componentWillUpdate` and `componentDidUpdate`.
		   *
		   * @param {ReactClass} publicInstance The instance that should rerender.
		   * @internal
		   */
		  enqueueForceUpdate: function (publicInstance) {
		    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
		
		    if (!internalInstance) {
		      return;
		    }
		
		    internalInstance._pendingForceUpdate = true;
		
		    enqueueUpdate(internalInstance);
		  },
		
		  /**
		   * Replaces all of the state. Always use this or `setState` to mutate state.
		   * You should treat `this.state` as immutable.
		   *
		   * There is no guarantee that `this.state` will be immediately updated, so
		   * accessing `this.state` after calling this method may return the old value.
		   *
		   * @param {ReactClass} publicInstance The instance that should rerender.
		   * @param {object} completeState Next state.
		   * @internal
		   */
		  enqueueReplaceState: function (publicInstance, completeState) {
		    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
		
		    if (!internalInstance) {
		      return;
		    }
		
		    internalInstance._pendingStateQueue = [completeState];
		    internalInstance._pendingReplaceState = true;
		
		    enqueueUpdate(internalInstance);
		  },
		
		  /**
		   * Sets a subset of the state. This only exists because _pendingState is
		   * internal. This provides a merging strategy that is not available to deep
		   * properties which is confusing. TODO: Expose pendingState or don't use it
		   * during the merge.
		   *
		   * @param {ReactClass} publicInstance The instance that should rerender.
		   * @param {object} partialState Next partial state to be merged with state.
		   * @internal
		   */
		  enqueueSetState: function (publicInstance, partialState) {
		    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
		
		    if (!internalInstance) {
		      return;
		    }
		
		    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
		    queue.push(partialState);
		
		    enqueueUpdate(internalInstance);
		  },
		
		  /**
		   * Sets a subset of the props.
		   *
		   * @param {ReactClass} publicInstance The instance that should rerender.
		   * @param {object} partialProps Subset of the next props.
		   * @internal
		   */
		  enqueueSetProps: function (publicInstance, partialProps) {
		    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');
		    if (!internalInstance) {
		      return;
		    }
		    ReactUpdateQueue.enqueueSetPropsInternal(internalInstance, partialProps);
		  },
		
		  enqueueSetPropsInternal: function (internalInstance, partialProps) {
		    var topLevelWrapper = internalInstance._topLevelWrapper;
		    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;
		
		    // Merge with the pending element if it exists, otherwise with existing
		    // element props.
		    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
		    var element = wrapElement.props;
		    var props = assign({}, element.props, partialProps);
		    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));
		
		    enqueueUpdate(topLevelWrapper);
		  },
		
		  /**
		   * Replaces all of the props.
		   *
		   * @param {ReactClass} publicInstance The instance that should rerender.
		   * @param {object} props New props.
		   * @internal
		   */
		  enqueueReplaceProps: function (publicInstance, props) {
		    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');
		    if (!internalInstance) {
		      return;
		    }
		    ReactUpdateQueue.enqueueReplacePropsInternal(internalInstance, props);
		  },
		
		  enqueueReplacePropsInternal: function (internalInstance, props) {
		    var topLevelWrapper = internalInstance._topLevelWrapper;
		    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;
		
		    // Merge with the pending element if it exists, otherwise with existing
		    // element props.
		    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
		    var element = wrapElement.props;
		    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));
		
		    enqueueUpdate(topLevelWrapper);
		  },
		
		  enqueueElementInternal: function (internalInstance, newElement) {
		    internalInstance._pendingElement = newElement;
		    enqueueUpdate(internalInstance);
		  }
		
		};
		
		module.exports = ReactUpdateQueue;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 54 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactUpdates
		 */
		
		'use strict';
		
		var CallbackQueue = __webpack_require__(55);
		var PooledClass = __webpack_require__(56);
		var ReactPerf = __webpack_require__(18);
		var ReactReconciler = __webpack_require__(50);
		var Transaction = __webpack_require__(57);
		
		var assign = __webpack_require__(39);
		var invariant = __webpack_require__(13);
		
		var dirtyComponents = [];
		var asapCallbackQueue = CallbackQueue.getPooled();
		var asapEnqueued = false;
		
		var batchingStrategy = null;
		
		function ensureInjected() {
		  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;
		}
		
		var NESTED_UPDATES = {
		  initialize: function () {
		    this.dirtyComponentsLength = dirtyComponents.length;
		  },
		  close: function () {
		    if (this.dirtyComponentsLength !== dirtyComponents.length) {
		      // Additional updates were enqueued by componentDidUpdate handlers or
		      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
		      // these new updates so that if A's componentDidUpdate calls setState on
		      // B, B will update before the callback A's updater provided when calling
		      // setState.
		      dirtyComponents.splice(0, this.dirtyComponentsLength);
		      flushBatchedUpdates();
		    } else {
		      dirtyComponents.length = 0;
		    }
		  }
		};
		
		var UPDATE_QUEUEING = {
		  initialize: function () {
		    this.callbackQueue.reset();
		  },
		  close: function () {
		    this.callbackQueue.notifyAll();
		  }
		};
		
		var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
		
		function ReactUpdatesFlushTransaction() {
		  this.reinitializeTransaction();
		  this.dirtyComponentsLength = null;
		  this.callbackQueue = CallbackQueue.getPooled();
		  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled( /* forceHTML */false);
		}
		
		assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
		  getTransactionWrappers: function () {
		    return TRANSACTION_WRAPPERS;
		  },
		
		  destructor: function () {
		    this.dirtyComponentsLength = null;
		    CallbackQueue.release(this.callbackQueue);
		    this.callbackQueue = null;
		    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
		    this.reconcileTransaction = null;
		  },
		
		  perform: function (method, scope, a) {
		    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
		    // with this transaction's wrappers around it.
		    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
		  }
		});
		
		PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
		
		function batchedUpdates(callback, a, b, c, d, e) {
		  ensureInjected();
		  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
		}
		
		/**
		 * Array comparator for ReactComponents by mount ordering.
		 *
		 * @param {ReactComponent} c1 first component you're comparing
		 * @param {ReactComponent} c2 second component you're comparing
		 * @return {number} Return value usable by Array.prototype.sort().
		 */
		function mountOrderComparator(c1, c2) {
		  return c1._mountOrder - c2._mountOrder;
		}
		
		function runBatchedUpdates(transaction) {
		  var len = transaction.dirtyComponentsLength;
		  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined;
		
		  // Since reconciling a component higher in the owner hierarchy usually (not
		  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
		  // them before their children by sorting the array.
		  dirtyComponents.sort(mountOrderComparator);
		
		  for (var i = 0; i < len; i++) {
		    // If a component is unmounted before pending changes apply, it will still
		    // be here, but we assume that it has cleared its _pendingCallbacks and
		    // that performUpdateIfNecessary is a noop.
		    var component = dirtyComponents[i];
		
		    // If performUpdateIfNecessary happens to enqueue any new updates, we
		    // shouldn't execute the callbacks until the next render happens, so
		    // stash the callbacks first
		    var callbacks = component._pendingCallbacks;
		    component._pendingCallbacks = null;
		
		    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);
		
		    if (callbacks) {
		      for (var j = 0; j < callbacks.length; j++) {
		        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
		      }
		    }
		  }
		}
		
		var flushBatchedUpdates = function () {
		  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
		  // array and perform any updates enqueued by mount-ready handlers (i.e.,
		  // componentDidUpdate) but we need to check here too in order to catch
		  // updates enqueued by setState callbacks and asap calls.
		  while (dirtyComponents.length || asapEnqueued) {
		    if (dirtyComponents.length) {
		      var transaction = ReactUpdatesFlushTransaction.getPooled();
		      transaction.perform(runBatchedUpdates, null, transaction);
		      ReactUpdatesFlushTransaction.release(transaction);
		    }
		
		    if (asapEnqueued) {
		      asapEnqueued = false;
		      var queue = asapCallbackQueue;
		      asapCallbackQueue = CallbackQueue.getPooled();
		      queue.notifyAll();
		      CallbackQueue.release(queue);
		    }
		  }
		};
		flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);
		
		/**
		 * Mark a component as needing a rerender, adding an optional callback to a
		 * list of functions which will be executed once the rerender occurs.
		 */
		function enqueueUpdate(component) {
		  ensureInjected();
		
		  // Various parts of our code (such as ReactCompositeComponent's
		  // _renderValidatedComponent) assume that calls to render aren't nested;
		  // verify that that's the case. (This is called by each top-level update
		  // function, like setProps, setState, forceUpdate, etc.; creation and
		  // destruction of top-level components is guarded in ReactMount.)
		
		  if (!batchingStrategy.isBatchingUpdates) {
		    batchingStrategy.batchedUpdates(enqueueUpdate, component);
		    return;
		  }
		
		  dirtyComponents.push(component);
		}
		
		/**
		 * Enqueue a callback to be run at the end of the current batching cycle. Throws
		 * if no updates are currently being performed.
		 */
		function asap(callback, context) {
		  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;
		  asapCallbackQueue.enqueue(callback, context);
		  asapEnqueued = true;
		}
		
		var ReactUpdatesInjection = {
		  injectReconcileTransaction: function (ReconcileTransaction) {
		    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;
		    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
		  },
		
		  injectBatchingStrategy: function (_batchingStrategy) {
		    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;
		    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;
		    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;
		    batchingStrategy = _batchingStrategy;
		  }
		};
		
		var ReactUpdates = {
		  /**
		   * React references `ReactReconcileTransaction` using this property in order
		   * to allow dependency injection.
		   *
		   * @internal
		   */
		  ReactReconcileTransaction: null,
		
		  batchedUpdates: batchedUpdates,
		  enqueueUpdate: enqueueUpdate,
		  flushBatchedUpdates: flushBatchedUpdates,
		  injection: ReactUpdatesInjection,
		  asap: asap
		};
		
		module.exports = ReactUpdates;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 55 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule CallbackQueue
		 */
		
		'use strict';
		
		var PooledClass = __webpack_require__(56);
		
		var assign = __webpack_require__(39);
		var invariant = __webpack_require__(13);
		
		/**
		 * A specialized pseudo-event module to help keep track of components waiting to
		 * be notified when their DOM representations are available for use.
		 *
		 * This implements `PooledClass`, so you should never need to instantiate this.
		 * Instead, use `CallbackQueue.getPooled()`.
		 *
		 * @class ReactMountReady
		 * @implements PooledClass
		 * @internal
		 */
		function CallbackQueue() {
		  this._callbacks = null;
		  this._contexts = null;
		}
		
		assign(CallbackQueue.prototype, {
		
		  /**
		   * Enqueues a callback to be invoked when `notifyAll` is invoked.
		   *
		   * @param {function} callback Invoked when `notifyAll` is invoked.
		   * @param {?object} context Context to call `callback` with.
		   * @internal
		   */
		  enqueue: function (callback, context) {
		    this._callbacks = this._callbacks || [];
		    this._contexts = this._contexts || [];
		    this._callbacks.push(callback);
		    this._contexts.push(context);
		  },
		
		  /**
		   * Invokes all enqueued callbacks and clears the queue. This is invoked after
		   * the DOM representation of a component has been created or updated.
		   *
		   * @internal
		   */
		  notifyAll: function () {
		    var callbacks = this._callbacks;
		    var contexts = this._contexts;
		    if (callbacks) {
		      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : invariant(false) : undefined;
		      this._callbacks = null;
		      this._contexts = null;
		      for (var i = 0; i < callbacks.length; i++) {
		        callbacks[i].call(contexts[i]);
		      }
		      callbacks.length = 0;
		      contexts.length = 0;
		    }
		  },
		
		  /**
		   * Resets the internal queue.
		   *
		   * @internal
		   */
		  reset: function () {
		    this._callbacks = null;
		    this._contexts = null;
		  },
		
		  /**
		   * `PooledClass` looks for this.
		   */
		  destructor: function () {
		    this.reset();
		  }
		
		});
		
		PooledClass.addPoolingTo(CallbackQueue);
		
		module.exports = CallbackQueue;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 56 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule PooledClass
		 */
		
		'use strict';
		
		var invariant = __webpack_require__(13);
		
		/**
		 * Static poolers. Several custom versions for each potential number of
		 * arguments. A completely generic pooler is easy to implement, but would
		 * require accessing the `arguments` object. In each of these, `this` refers to
		 * the Class itself, not an instance. If any others are needed, simply add them
		 * here, or in their own files.
		 */
		var oneArgumentPooler = function (copyFieldsFrom) {
		  var Klass = this;
		  if (Klass.instancePool.length) {
		    var instance = Klass.instancePool.pop();
		    Klass.call(instance, copyFieldsFrom);
		    return instance;
		  } else {
		    return new Klass(copyFieldsFrom);
		  }
		};
		
		var twoArgumentPooler = function (a1, a2) {
		  var Klass = this;
		  if (Klass.instancePool.length) {
		    var instance = Klass.instancePool.pop();
		    Klass.call(instance, a1, a2);
		    return instance;
		  } else {
		    return new Klass(a1, a2);
		  }
		};
		
		var threeArgumentPooler = function (a1, a2, a3) {
		  var Klass = this;
		  if (Klass.instancePool.length) {
		    var instance = Klass.instancePool.pop();
		    Klass.call(instance, a1, a2, a3);
		    return instance;
		  } else {
		    return new Klass(a1, a2, a3);
		  }
		};
		
		var fourArgumentPooler = function (a1, a2, a3, a4) {
		  var Klass = this;
		  if (Klass.instancePool.length) {
		    var instance = Klass.instancePool.pop();
		    Klass.call(instance, a1, a2, a3, a4);
		    return instance;
		  } else {
		    return new Klass(a1, a2, a3, a4);
		  }
		};
		
		var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
		  var Klass = this;
		  if (Klass.instancePool.length) {
		    var instance = Klass.instancePool.pop();
		    Klass.call(instance, a1, a2, a3, a4, a5);
		    return instance;
		  } else {
		    return new Klass(a1, a2, a3, a4, a5);
		  }
		};
		
		var standardReleaser = function (instance) {
		  var Klass = this;
		  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : invariant(false) : undefined;
		  instance.destructor();
		  if (Klass.instancePool.length < Klass.poolSize) {
		    Klass.instancePool.push(instance);
		  }
		};
		
		var DEFAULT_POOL_SIZE = 10;
		var DEFAULT_POOLER = oneArgumentPooler;
		
		/**
		 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
		 * itself (statically) not adding any prototypical fields. Any CopyConstructor
		 * you give this may have a `poolSize` property, and will look for a
		 * prototypical `destructor` on instances (optional).
		 *
		 * @param {Function} CopyConstructor Constructor that can be used to reset.
		 * @param {Function} pooler Customizable pooler.
		 */
		var addPoolingTo = function (CopyConstructor, pooler) {
		  var NewKlass = CopyConstructor;
		  NewKlass.instancePool = [];
		  NewKlass.getPooled = pooler || DEFAULT_POOLER;
		  if (!NewKlass.poolSize) {
		    NewKlass.poolSize = DEFAULT_POOL_SIZE;
		  }
		  NewKlass.release = standardReleaser;
		  return NewKlass;
		};
		
		var PooledClass = {
		  addPoolingTo: addPoolingTo,
		  oneArgumentPooler: oneArgumentPooler,
		  twoArgumentPooler: twoArgumentPooler,
		  threeArgumentPooler: threeArgumentPooler,
		  fourArgumentPooler: fourArgumentPooler,
		  fiveArgumentPooler: fiveArgumentPooler
		};
		
		module.exports = PooledClass;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 57 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule Transaction
		 */
		
		'use strict';
		
		var invariant = __webpack_require__(13);
		
		/**
		 * `Transaction` creates a black box that is able to wrap any method such that
		 * certain invariants are maintained before and after the method is invoked
		 * (Even if an exception is thrown while invoking the wrapped method). Whoever
		 * instantiates a transaction can provide enforcers of the invariants at
		 * creation time. The `Transaction` class itself will supply one additional
		 * automatic invariant for you - the invariant that any transaction instance
		 * should not be run while it is already being run. You would typically create a
		 * single instance of a `Transaction` for reuse multiple times, that potentially
		 * is used to wrap several different methods. Wrappers are extremely simple -
		 * they only require implementing two methods.
		 *
		 * <pre>
		 *                       wrappers (injected at creation time)
		 *                                      +        +
		 *                                      |        |
		 *                    +-----------------|--------|--------------+
		 *                    |                 v        |              |
		 *                    |      +---------------+   |              |
		 *                    |   +--|    wrapper1   |---|----+         |
		 *                    |   |  +---------------+   v    |         |
		 *                    |   |          +-------------+  |         |
		 *                    |   |     +----|   wrapper2  |--------+   |
		 *                    |   |     |    +-------------+  |     |   |
		 *                    |   |     |                     |     |   |
		 *                    |   v     v                     v     v   | wrapper
		 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
		 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
		 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
		 *                    | |   | |   |   |         |   |   | |   | |
		 *                    | |   | |   |   |         |   |   | |   | |
		 *                    | |   | |   |   |         |   |   | |   | |
		 *                    | +---+ +---+   +---------+   +---+ +---+ |
		 *                    |  initialize                    close    |
		 *                    +-----------------------------------------+
		 * </pre>
		 *
		 * Use cases:
		 * - Preserving the input selection ranges before/after reconciliation.
		 *   Restoring selection even in the event of an unexpected error.
		 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
		 *   while guaranteeing that afterwards, the event system is reactivated.
		 * - Flushing a queue of collected DOM mutations to the main UI thread after a
		 *   reconciliation takes place in a worker thread.
		 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
		 *   content.
		 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
		 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
		 * - (Future use case): Layout calculations before and after DOM updates.
		 *
		 * Transactional plugin API:
		 * - A module that has an `initialize` method that returns any precomputation.
		 * - and a `close` method that accepts the precomputation. `close` is invoked
		 *   when the wrapped process is completed, or has failed.
		 *
		 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
		 * that implement `initialize` and `close`.
		 * @return {Transaction} Single transaction for reuse in thread.
		 *
		 * @class Transaction
		 */
		var Mixin = {
		  /**
		   * Sets up this instance so that it is prepared for collecting metrics. Does
		   * so such that this setup method may be used on an instance that is already
		   * initialized, in a way that does not consume additional memory upon reuse.
		   * That can be useful if you decide to make your subclass of this mixin a
		   * "PooledClass".
		   */
		  reinitializeTransaction: function () {
		    this.transactionWrappers = this.getTransactionWrappers();
		    if (this.wrapperInitData) {
		      this.wrapperInitData.length = 0;
		    } else {
		      this.wrapperInitData = [];
		    }
		    this._isInTransaction = false;
		  },
		
		  _isInTransaction: false,
		
		  /**
		   * @abstract
		   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
		   */
		  getTransactionWrappers: null,
		
		  isInTransaction: function () {
		    return !!this._isInTransaction;
		  },
		
		  /**
		   * Executes the function within a safety window. Use this for the top level
		   * methods that result in large amounts of computation/mutations that would
		   * need to be safety checked. The optional arguments helps prevent the need
		   * to bind in many cases.
		   *
		   * @param {function} method Member of scope to call.
		   * @param {Object} scope Scope to invoke from.
		   * @param {Object?=} a Argument to pass to the method.
		   * @param {Object?=} b Argument to pass to the method.
		   * @param {Object?=} c Argument to pass to the method.
		   * @param {Object?=} d Argument to pass to the method.
		   * @param {Object?=} e Argument to pass to the method.
		   * @param {Object?=} f Argument to pass to the method.
		   *
		   * @return {*} Return value from `method`.
		   */
		  perform: function (method, scope, a, b, c, d, e, f) {
		    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(false) : undefined;
		    var errorThrown;
		    var ret;
		    try {
		      this._isInTransaction = true;
		      // Catching errors makes debugging more difficult, so we start with
		      // errorThrown set to true before setting it to false after calling
		      // close -- if it's still set to true in the finally block, it means
		      // one of these calls threw.
		      errorThrown = true;
		      this.initializeAll(0);
		      ret = method.call(scope, a, b, c, d, e, f);
		      errorThrown = false;
		    } finally {
		      try {
		        if (errorThrown) {
		          // If `method` throws, prefer to show that stack trace over any thrown
		          // by invoking `closeAll`.
		          try {
		            this.closeAll(0);
		          } catch (err) {}
		        } else {
		          // Since `method` didn't throw, we don't want to silence the exception
		          // here.
		          this.closeAll(0);
		        }
		      } finally {
		        this._isInTransaction = false;
		      }
		    }
		    return ret;
		  },
		
		  initializeAll: function (startIndex) {
		    var transactionWrappers = this.transactionWrappers;
		    for (var i = startIndex; i < transactionWrappers.length; i++) {
		      var wrapper = transactionWrappers[i];
		      try {
		        // Catching errors makes debugging more difficult, so we start with the
		        // OBSERVED_ERROR state before overwriting it with the real return value
		        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
		        // block, it means wrapper.initialize threw.
		        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
		        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
		      } finally {
		        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
		          // The initializer for wrapper i threw an error; initialize the
		          // remaining wrappers but silence any exceptions from them to ensure
		          // that the first error is the one to bubble up.
		          try {
		            this.initializeAll(i + 1);
		          } catch (err) {}
		        }
		      }
		    }
		  },
		
		  /**
		   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
		   * them the respective return values of `this.transactionWrappers.init[i]`
		   * (`close`rs that correspond to initializers that failed will not be
		   * invoked).
		   */
		  closeAll: function (startIndex) {
		    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(false) : undefined;
		    var transactionWrappers = this.transactionWrappers;
		    for (var i = startIndex; i < transactionWrappers.length; i++) {
		      var wrapper = transactionWrappers[i];
		      var initData = this.wrapperInitData[i];
		      var errorThrown;
		      try {
		        // Catching errors makes debugging more difficult, so we start with
		        // errorThrown set to true before setting it to false after calling
		        // close -- if it's still set to true in the finally block, it means
		        // wrapper.close threw.
		        errorThrown = true;
		        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
		          wrapper.close.call(this, initData);
		        }
		        errorThrown = false;
		      } finally {
		        if (errorThrown) {
		          // The closer for wrapper i threw an error; close the remaining
		          // wrappers but silence any exceptions from them to ensure that the
		          // first error is the one to bubble up.
		          try {
		            this.closeAll(i + 1);
		          } catch (e) {}
		        }
		      }
		    }
		    this.wrapperInitData.length = 0;
		  }
		};
		
		var Transaction = {
		
		  Mixin: Mixin,
		
		  /**
		   * Token to look for to determine if an error occurred.
		   */
		  OBSERVED_ERROR: {}
		
		};
		
		module.exports = Transaction;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 58 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule emptyObject
		 */
		
		'use strict';
		
		var emptyObject = {};
		
		if (process.env.NODE_ENV !== 'production') {
		  Object.freeze(emptyObject);
		}
		
		module.exports = emptyObject;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 59 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule containsNode
		 * @typechecks
		 */
		
		'use strict';
		
		var isTextNode = __webpack_require__(60);
		
		/*eslint-disable no-bitwise */
		
		/**
		 * Checks if a given DOM node contains or is another DOM node.
		 *
		 * @param {?DOMNode} outerNode Outer DOM node.
		 * @param {?DOMNode} innerNode Inner DOM node.
		 * @return {boolean} True if `outerNode` contains or is `innerNode`.
		 */
		function containsNode(_x, _x2) {
		  var _again = true;
		
		  _function: while (_again) {
		    var outerNode = _x,
		        innerNode = _x2;
		    _again = false;
		
		    if (!outerNode || !innerNode) {
		      return false;
		    } else if (outerNode === innerNode) {
		      return true;
		    } else if (isTextNode(outerNode)) {
		      return false;
		    } else if (isTextNode(innerNode)) {
		      _x = outerNode;
		      _x2 = innerNode.parentNode;
		      _again = true;
		      continue _function;
		    } else if (outerNode.contains) {
		      return outerNode.contains(innerNode);
		    } else if (outerNode.compareDocumentPosition) {
		      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
		    } else {
		      return false;
		    }
		  }
		}
		
		module.exports = containsNode;
	
	/***/ },
	/* 60 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule isTextNode
		 * @typechecks
		 */
		
		'use strict';
		
		var isNode = __webpack_require__(61);
		
		/**
		 * @param {*} object The object to check.
		 * @return {boolean} Whether or not the object is a DOM text node.
		 */
		function isTextNode(object) {
		  return isNode(object) && object.nodeType == 3;
		}
		
		module.exports = isTextNode;
	
	/***/ },
	/* 61 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule isNode
		 * @typechecks
		 */
		
		/**
		 * @param {*} object The object to check.
		 * @return {boolean} Whether or not the object is a DOM node.
		 */
		'use strict';
		
		function isNode(object) {
		  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
		}
		
		module.exports = isNode;
	
	/***/ },
	/* 62 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule instantiateReactComponent
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var ReactCompositeComponent = __webpack_require__(63);
		var ReactEmptyComponent = __webpack_require__(68);
		var ReactNativeComponent = __webpack_require__(69);
		
		var assign = __webpack_require__(39);
		var invariant = __webpack_require__(13);
		var warning = __webpack_require__(25);
		
		// To avoid a cyclic dependency, we create the final class in this module
		var ReactCompositeComponentWrapper = function () {};
		assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
		  _instantiateReactComponent: instantiateReactComponent
		});
		
		function getDeclarationErrorAddendum(owner) {
		  if (owner) {
		    var name = owner.getName();
		    if (name) {
		      return ' Check the render method of `' + name + '`.';
		    }
		  }
		  return '';
		}
		
		/**
		 * Check if the type reference is a known internal type. I.e. not a user
		 * provided composite type.
		 *
		 * @param {function} type
		 * @return {boolean} Returns true if this is a valid internal type.
		 */
		function isInternalComponentType(type) {
		  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
		}
		
		/**
		 * Given a ReactNode, create an instance that will actually be mounted.
		 *
		 * @param {ReactNode} node
		 * @return {object} A new instance of the element's constructor.
		 * @protected
		 */
		function instantiateReactComponent(node) {
		  var instance;
		
		  if (node === null || node === false) {
		    instance = new ReactEmptyComponent(instantiateReactComponent);
		  } else if (typeof node === 'object') {
		    var element = node;
		    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) ' + 'or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : invariant(false) : undefined;
		
		    // Special case string values
		    if (typeof element.type === 'string') {
		      instance = ReactNativeComponent.createInternalComponent(element);
		    } else if (isInternalComponentType(element.type)) {
		      // This is temporarily available for custom components that are not string
		      // representations. I.e. ART. Once those are updated to use the string
		      // representation, we can drop this code path.
		      instance = new element.type(element);
		    } else {
		      instance = new ReactCompositeComponentWrapper();
		    }
		  } else if (typeof node === 'string' || typeof node === 'number') {
		    instance = ReactNativeComponent.createInstanceForText(node);
		  } else {
		     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : invariant(false) : undefined;
		  }
		
		  if (process.env.NODE_ENV !== 'production') {
		    process.env.NODE_ENV !== 'production' ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : undefined;
		  }
		
		  // Sets up the instance. This can probably just move into the constructor now.
		  instance.construct(node);
		
		  // These two fields are used by the DOM and ART diffing algorithms
		  // respectively. Instead of using expandos on components, we should be
		  // storing the state needed by the diffing algorithms elsewhere.
		  instance._mountIndex = 0;
		  instance._mountImage = null;
		
		  if (process.env.NODE_ENV !== 'production') {
		    instance._isOwnerNecessary = false;
		    instance._warnedAboutRefsInRender = false;
		  }
		
		  // Internal instances should fully constructed at this point, so they should
		  // not get any new fields added to them at this point.
		  if (process.env.NODE_ENV !== 'production') {
		    if (Object.preventExtensions) {
		      Object.preventExtensions(instance);
		    }
		  }
		
		  return instance;
		}
		
		module.exports = instantiateReactComponent;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 63 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactCompositeComponent
		 */
		
		'use strict';
		
		var ReactComponentEnvironment = __webpack_require__(64);
		var ReactCurrentOwner = __webpack_require__(5);
		var ReactElement = __webpack_require__(42);
		var ReactInstanceMap = __webpack_require__(47);
		var ReactPerf = __webpack_require__(18);
		var ReactPropTypeLocations = __webpack_require__(65);
		var ReactPropTypeLocationNames = __webpack_require__(66);
		var ReactReconciler = __webpack_require__(50);
		var ReactUpdateQueue = __webpack_require__(53);
		
		var assign = __webpack_require__(39);
		var emptyObject = __webpack_require__(58);
		var invariant = __webpack_require__(13);
		var shouldUpdateReactComponent = __webpack_require__(67);
		var warning = __webpack_require__(25);
		
		function getDeclarationErrorAddendum(component) {
		  var owner = component._currentElement._owner || null;
		  if (owner) {
		    var name = owner.getName();
		    if (name) {
		      return ' Check the render method of `' + name + '`.';
		    }
		  }
		  return '';
		}
		
		function StatelessComponent(Component) {}
		StatelessComponent.prototype.render = function () {
		  var Component = ReactInstanceMap.get(this)._currentElement.type;
		  return Component(this.props, this.context, this.updater);
		};
		
		/**
		 * ------------------ The Life-Cycle of a Composite Component ------------------
		 *
		 * - constructor: Initialization of state. The instance is now retained.
		 *   - componentWillMount
		 *   - render
		 *   - [children's constructors]
		 *     - [children's componentWillMount and render]
		 *     - [children's componentDidMount]
		 *     - componentDidMount
		 *
		 *       Update Phases:
		 *       - componentWillReceiveProps (only called if parent updated)
		 *       - shouldComponentUpdate
		 *         - componentWillUpdate
		 *           - render
		 *           - [children's constructors or receive props phases]
		 *         - componentDidUpdate
		 *
		 *     - componentWillUnmount
		 *     - [children's componentWillUnmount]
		 *   - [children destroyed]
		 * - (destroyed): The instance is now blank, released by React and ready for GC.
		 *
		 * -----------------------------------------------------------------------------
		 */
		
		/**
		 * An incrementing ID assigned to each component when it is mounted. This is
		 * used to enforce the order in which `ReactUpdates` updates dirty components.
		 *
		 * @private
		 */
		var nextMountID = 1;
		
		/**
		 * @lends {ReactCompositeComponent.prototype}
		 */
		var ReactCompositeComponentMixin = {
		
		  /**
		   * Base constructor for all composite component.
		   *
		   * @param {ReactElement} element
		   * @final
		   * @internal
		   */
		  construct: function (element) {
		    this._currentElement = element;
		    this._rootNodeID = null;
		    this._instance = null;
		
		    // See ReactUpdateQueue
		    this._pendingElement = null;
		    this._pendingStateQueue = null;
		    this._pendingReplaceState = false;
		    this._pendingForceUpdate = false;
		
		    this._renderedComponent = null;
		
		    this._context = null;
		    this._mountOrder = 0;
		    this._topLevelWrapper = null;
		
		    // See ReactUpdates and ReactUpdateQueue.
		    this._pendingCallbacks = null;
		  },
		
		  /**
		   * Initializes the component, renders markup, and registers event listeners.
		   *
		   * @param {string} rootID DOM ID of the root node.
		   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
		   * @return {?string} Rendered markup to be inserted into the DOM.
		   * @final
		   * @internal
		   */
		  mountComponent: function (rootID, transaction, context) {
		    this._context = context;
		    this._mountOrder = nextMountID++;
		    this._rootNodeID = rootID;
		
		    var publicProps = this._processProps(this._currentElement.props);
		    var publicContext = this._processContext(context);
		
		    var Component = this._currentElement.type;
		
		    // Initialize the public class
		    var inst;
		    var renderedElement;
		
		    // This is a way to detect if Component is a stateless arrow function
		    // component, which is not newable. It might not be 100% reliable but is
		    // something we can do until we start detecting that Component extends
		    // React.Component. We already assume that typeof Component === 'function'.
		    var canInstantiate = ('prototype' in Component);
		
		    if (canInstantiate) {
		      if (process.env.NODE_ENV !== 'production') {
		        ReactCurrentOwner.current = this;
		        try {
		          inst = new Component(publicProps, publicContext, ReactUpdateQueue);
		        } finally {
		          ReactCurrentOwner.current = null;
		        }
		      } else {
		        inst = new Component(publicProps, publicContext, ReactUpdateQueue);
		      }
		    }
		
		    if (!canInstantiate || inst === null || inst === false || ReactElement.isValidElement(inst)) {
		      renderedElement = inst;
		      inst = new StatelessComponent(Component);
		    }
		
		    if (process.env.NODE_ENV !== 'production') {
		      // This will throw later in _renderValidatedComponent, but add an early
		      // warning now to help debugging
		      if (inst.render == null) {
		        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`, returned ' + 'null/false from a stateless component, or tried to render an ' + 'element whose type is a function that isn\'t a React component.', Component.displayName || Component.name || 'Component') : undefined;
		      } else {
		        // We support ES6 inheriting from React.Component, the module pattern,
		        // and stateless components, but not ES6 classes that don't extend
		        process.env.NODE_ENV !== 'production' ? warning(Component.prototype && Component.prototype.isReactComponent || !canInstantiate || !(inst instanceof Component), '%s(...): React component classes must extend React.Component.', Component.displayName || Component.name || 'Component') : undefined;
		      }
		    }
		
		    // These should be set up in the constructor, but as a convenience for
		    // simpler class abstractions, we set them up after the fact.
		    inst.props = publicProps;
		    inst.context = publicContext;
		    inst.refs = emptyObject;
		    inst.updater = ReactUpdateQueue;
		
		    this._instance = inst;
		
		    // Store a reference from the instance back to the internal representation
		    ReactInstanceMap.set(inst, this);
		
		    if (process.env.NODE_ENV !== 'production') {
		      // Since plain JS classes are defined without any special initialization
		      // logic, we can not catch common errors early. Therefore, we have to
		      // catch them here, at initialization time, instead.
		      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : undefined;
		      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : undefined;
		      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : undefined;
		      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : undefined;
		      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : undefined;
		      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : undefined;
		      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : undefined;
		    }
		
		    var initialState = inst.state;
		    if (initialState === undefined) {
		      inst.state = initialState = null;
		    }
		    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
		
		    this._pendingStateQueue = null;
		    this._pendingReplaceState = false;
		    this._pendingForceUpdate = false;
		
		    if (inst.componentWillMount) {
		      inst.componentWillMount();
		      // When mounting, calls to `setState` by `componentWillMount` will set
		      // `this._pendingStateQueue` without triggering a re-render.
		      if (this._pendingStateQueue) {
		        inst.state = this._processPendingState(inst.props, inst.context);
		      }
		    }
		
		    // If not a stateless component, we now render
		    if (renderedElement === undefined) {
		      renderedElement = this._renderValidatedComponent();
		    }
		
		    this._renderedComponent = this._instantiateReactComponent(renderedElement);
		
		    var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));
		    if (inst.componentDidMount) {
		      transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
		    }
		
		    return markup;
		  },
		
		  /**
		   * Releases any resources allocated by `mountComponent`.
		   *
		   * @final
		   * @internal
		   */
		  unmountComponent: function () {
		    var inst = this._instance;
		
		    if (inst.componentWillUnmount) {
		      inst.componentWillUnmount();
		    }
		
		    ReactReconciler.unmountComponent(this._renderedComponent);
		    this._renderedComponent = null;
		    this._instance = null;
		
		    // Reset pending fields
		    // Even if this component is scheduled for another update in ReactUpdates,
		    // it would still be ignored because these fields are reset.
		    this._pendingStateQueue = null;
		    this._pendingReplaceState = false;
		    this._pendingForceUpdate = false;
		    this._pendingCallbacks = null;
		    this._pendingElement = null;
		
		    // These fields do not really need to be reset since this object is no
		    // longer accessible.
		    this._context = null;
		    this._rootNodeID = null;
		    this._topLevelWrapper = null;
		
		    // Delete the reference from the instance to this internal representation
		    // which allow the internals to be properly cleaned up even if the user
		    // leaks a reference to the public instance.
		    ReactInstanceMap.remove(inst);
		
		    // Some existing components rely on inst.props even after they've been
		    // destroyed (in event handlers).
		    // TODO: inst.props = null;
		    // TODO: inst.state = null;
		    // TODO: inst.context = null;
		  },
		
		  /**
		   * Filters the context object to only contain keys specified in
		   * `contextTypes`
		   *
		   * @param {object} context
		   * @return {?object}
		   * @private
		   */
		  _maskContext: function (context) {
		    var maskedContext = null;
		    var Component = this._currentElement.type;
		    var contextTypes = Component.contextTypes;
		    if (!contextTypes) {
		      return emptyObject;
		    }
		    maskedContext = {};
		    for (var contextName in contextTypes) {
		      maskedContext[contextName] = context[contextName];
		    }
		    return maskedContext;
		  },
		
		  /**
		   * Filters the context object to only contain keys specified in
		   * `contextTypes`, and asserts that they are valid.
		   *
		   * @param {object} context
		   * @return {?object}
		   * @private
		   */
		  _processContext: function (context) {
		    var maskedContext = this._maskContext(context);
		    if (process.env.NODE_ENV !== 'production') {
		      var Component = this._currentElement.type;
		      if (Component.contextTypes) {
		        this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
		      }
		    }
		    return maskedContext;
		  },
		
		  /**
		   * @param {object} currentContext
		   * @return {object}
		   * @private
		   */
		  _processChildContext: function (currentContext) {
		    var Component = this._currentElement.type;
		    var inst = this._instance;
		    var childContext = inst.getChildContext && inst.getChildContext();
		    if (childContext) {
		      !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
		      if (process.env.NODE_ENV !== 'production') {
		        this._checkPropTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
		      }
		      for (var name in childContext) {
		        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(false) : undefined;
		      }
		      return assign({}, currentContext, childContext);
		    }
		    return currentContext;
		  },
		
		  /**
		   * Processes props by setting default values for unspecified props and
		   * asserting that the props are valid. Does not mutate its argument; returns
		   * a new props object with defaults merged in.
		   *
		   * @param {object} newProps
		   * @return {object}
		   * @private
		   */
		  _processProps: function (newProps) {
		    if (process.env.NODE_ENV !== 'production') {
		      var Component = this._currentElement.type;
		      if (Component.propTypes) {
		        this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);
		      }
		    }
		    return newProps;
		  },
		
		  /**
		   * Assert that the props are valid
		   *
		   * @param {object} propTypes Map of prop name to a ReactPropType
		   * @param {object} props
		   * @param {string} location e.g. "prop", "context", "child context"
		   * @private
		   */
		  _checkPropTypes: function (propTypes, props, location) {
		    // TODO: Stop validating prop types here and only use the element
		    // validation.
		    var componentName = this.getName();
		    for (var propName in propTypes) {
		      if (propTypes.hasOwnProperty(propName)) {
		        var error;
		        try {
		          // This is intentionally an invariant that gets caught. It's the same
		          // behavior as without this statement except with a better message.
		          !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
		          error = propTypes[propName](props, propName, componentName, location);
		        } catch (ex) {
		          error = ex;
		        }
		        if (error instanceof Error) {
		          // We may want to extend this logic for similar errors in
		          // top-level render calls, so I'm abstracting it away into
		          // a function to minimize refactoring in the future
		          var addendum = getDeclarationErrorAddendum(this);
		
		          if (location === ReactPropTypeLocations.prop) {
		            // Preface gives us something to blacklist in warning module
		            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : undefined;
		          } else {
		            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : undefined;
		          }
		        }
		      }
		    }
		  },
		
		  receiveComponent: function (nextElement, transaction, nextContext) {
		    var prevElement = this._currentElement;
		    var prevContext = this._context;
		
		    this._pendingElement = null;
		
		    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
		  },
		
		  /**
		   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
		   * is set, update the component.
		   *
		   * @param {ReactReconcileTransaction} transaction
		   * @internal
		   */
		  performUpdateIfNecessary: function (transaction) {
		    if (this._pendingElement != null) {
		      ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);
		    }
		
		    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
		      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
		    }
		  },
		
		  /**
		   * Perform an update to a mounted component. The componentWillReceiveProps and
		   * shouldComponentUpdate methods are called, then (assuming the update isn't
		   * skipped) the remaining update lifecycle methods are called and the DOM
		   * representation is updated.
		   *
		   * By default, this implements React's rendering and reconciliation algorithm.
		   * Sophisticated clients may wish to override this.
		   *
		   * @param {ReactReconcileTransaction} transaction
		   * @param {ReactElement} prevParentElement
		   * @param {ReactElement} nextParentElement
		   * @internal
		   * @overridable
		   */
		  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
		    var inst = this._instance;
		
		    var nextContext = this._context === nextUnmaskedContext ? inst.context : this._processContext(nextUnmaskedContext);
		    var nextProps;
		
		    // Distinguish between a props update versus a simple state update
		    if (prevParentElement === nextParentElement) {
		      // Skip checking prop types again -- we don't read inst.props to avoid
		      // warning for DOM component props in this upgrade
		      nextProps = nextParentElement.props;
		    } else {
		      nextProps = this._processProps(nextParentElement.props);
		      // An update here will schedule an update but immediately set
		      // _pendingStateQueue which will ensure that any state updates gets
		      // immediately reconciled instead of waiting for the next batch.
		
		      if (inst.componentWillReceiveProps) {
		        inst.componentWillReceiveProps(nextProps, nextContext);
		      }
		    }
		
		    var nextState = this._processPendingState(nextProps, nextContext);
		
		    var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);
		
		    if (process.env.NODE_ENV !== 'production') {
		      process.env.NODE_ENV !== 'production' ? warning(typeof shouldUpdate !== 'undefined', '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : undefined;
		    }
		
		    if (shouldUpdate) {
		      this._pendingForceUpdate = false;
		      // Will set `this.props`, `this.state` and `this.context`.
		      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
		    } else {
		      // If it's determined that a component should not update, we still want
		      // to set props and state but we shortcut the rest of the update.
		      this._currentElement = nextParentElement;
		      this._context = nextUnmaskedContext;
		      inst.props = nextProps;
		      inst.state = nextState;
		      inst.context = nextContext;
		    }
		  },
		
		  _processPendingState: function (props, context) {
		    var inst = this._instance;
		    var queue = this._pendingStateQueue;
		    var replace = this._pendingReplaceState;
		    this._pendingReplaceState = false;
		    this._pendingStateQueue = null;
		
		    if (!queue) {
		      return inst.state;
		    }
		
		    if (replace && queue.length === 1) {
		      return queue[0];
		    }
		
		    var nextState = assign({}, replace ? queue[0] : inst.state);
		    for (var i = replace ? 1 : 0; i < queue.length; i++) {
		      var partial = queue[i];
		      assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
		    }
		
		    return nextState;
		  },
		
		  /**
		   * Merges new props and state, notifies delegate methods of update and
		   * performs update.
		   *
		   * @param {ReactElement} nextElement Next element
		   * @param {object} nextProps Next public object to set as properties.
		   * @param {?object} nextState Next object to set as state.
		   * @param {?object} nextContext Next public object to set as context.
		   * @param {ReactReconcileTransaction} transaction
		   * @param {?object} unmaskedContext
		   * @private
		   */
		  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
		    var inst = this._instance;
		
		    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
		    var prevProps;
		    var prevState;
		    var prevContext;
		    if (hasComponentDidUpdate) {
		      prevProps = inst.props;
		      prevState = inst.state;
		      prevContext = inst.context;
		    }
		
		    if (inst.componentWillUpdate) {
		      inst.componentWillUpdate(nextProps, nextState, nextContext);
		    }
		
		    this._currentElement = nextElement;
		    this._context = unmaskedContext;
		    inst.props = nextProps;
		    inst.state = nextState;
		    inst.context = nextContext;
		
		    this._updateRenderedComponent(transaction, unmaskedContext);
		
		    if (hasComponentDidUpdate) {
		      transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
		    }
		  },
		
		  /**
		   * Call the component's `render` method and update the DOM accordingly.
		   *
		   * @param {ReactReconcileTransaction} transaction
		   * @internal
		   */
		  _updateRenderedComponent: function (transaction, context) {
		    var prevComponentInstance = this._renderedComponent;
		    var prevRenderedElement = prevComponentInstance._currentElement;
		    var nextRenderedElement = this._renderValidatedComponent();
		    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
		      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
		    } else {
		      // These two IDs are actually the same! But nothing should rely on that.
		      var thisID = this._rootNodeID;
		      var prevComponentID = prevComponentInstance._rootNodeID;
		      ReactReconciler.unmountComponent(prevComponentInstance);
		
		      this._renderedComponent = this._instantiateReactComponent(nextRenderedElement);
		      var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._processChildContext(context));
		      this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
		    }
		  },
		
		  /**
		   * @protected
		   */
		  _replaceNodeWithMarkupByID: function (prevComponentID, nextMarkup) {
		    ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
		  },
		
		  /**
		   * @protected
		   */
		  _renderValidatedComponentWithoutOwnerOrContext: function () {
		    var inst = this._instance;
		    var renderedComponent = inst.render();
		    if (process.env.NODE_ENV !== 'production') {
		      // We allow auto-mocks to proceed as if they're returning null.
		      if (typeof renderedComponent === 'undefined' && inst.render._isMockFunction) {
		        // This is probably bad practice. Consider warning here and
		        // deprecating this convenience.
		        renderedComponent = null;
		      }
		    }
		
		    return renderedComponent;
		  },
		
		  /**
		   * @private
		   */
		  _renderValidatedComponent: function () {
		    var renderedComponent;
		    ReactCurrentOwner.current = this;
		    try {
		      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
		    } finally {
		      ReactCurrentOwner.current = null;
		    }
		    !(
		    // TODO: An `isValidNode` function would probably be more appropriate
		    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
		    return renderedComponent;
		  },
		
		  /**
		   * Lazily allocates the refs object and stores `component` as `ref`.
		   *
		   * @param {string} ref Reference name.
		   * @param {component} component Component to store as `ref`.
		   * @final
		   * @private
		   */
		  attachRef: function (ref, component) {
		    var inst = this.getPublicInstance();
		    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : invariant(false) : undefined;
		    var publicComponentInstance = component.getPublicInstance();
		    if (process.env.NODE_ENV !== 'production') {
		      var componentName = component && component.getName ? component.getName() : 'a component';
		      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : undefined;
		    }
		    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
		    refs[ref] = publicComponentInstance;
		  },
		
		  /**
		   * Detaches a reference name.
		   *
		   * @param {string} ref Name to dereference.
		   * @final
		   * @private
		   */
		  detachRef: function (ref) {
		    var refs = this.getPublicInstance().refs;
		    delete refs[ref];
		  },
		
		  /**
		   * Get a text description of the component that can be used to identify it
		   * in error messages.
		   * @return {string} The name or null.
		   * @internal
		   */
		  getName: function () {
		    var type = this._currentElement.type;
		    var constructor = this._instance && this._instance.constructor;
		    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
		  },
		
		  /**
		   * Get the publicly accessible representation of this component - i.e. what
		   * is exposed by refs and returned by render. Can be null for stateless
		   * components.
		   *
		   * @return {ReactComponent} the public component instance.
		   * @internal
		   */
		  getPublicInstance: function () {
		    var inst = this._instance;
		    if (inst instanceof StatelessComponent) {
		      return null;
		    }
		    return inst;
		  },
		
		  // Stub
		  _instantiateReactComponent: null
		
		};
		
		ReactPerf.measureMethods(ReactCompositeComponentMixin, 'ReactCompositeComponent', {
		  mountComponent: 'mountComponent',
		  updateComponent: 'updateComponent',
		  _renderValidatedComponent: '_renderValidatedComponent'
		});
		
		var ReactCompositeComponent = {
		
		  Mixin: ReactCompositeComponentMixin
		
		};
		
		module.exports = ReactCompositeComponent;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 64 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2014-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactComponentEnvironment
		 */
		
		'use strict';
		
		var invariant = __webpack_require__(13);
		
		var injected = false;
		
		var ReactComponentEnvironment = {
		
		  /**
		   * Optionally injectable environment dependent cleanup hook. (server vs.
		   * browser etc). Example: A browser system caches DOM nodes based on component
		   * ID and must remove that cache entry when this instance is unmounted.
		   */
		  unmountIDFromEnvironment: null,
		
		  /**
		   * Optionally injectable hook for swapping out mount images in the middle of
		   * the tree.
		   */
		  replaceNodeWithMarkupByID: null,
		
		  /**
		   * Optionally injectable hook for processing a queue of child updates. Will
		   * later move into MultiChildComponents.
		   */
		  processChildrenUpdates: null,
		
		  injection: {
		    injectEnvironment: function (environment) {
		      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : invariant(false) : undefined;
		      ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;
		      ReactComponentEnvironment.replaceNodeWithMarkupByID = environment.replaceNodeWithMarkupByID;
		      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
		      injected = true;
		    }
		  }
		
		};
		
		module.exports = ReactComponentEnvironment;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 65 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactPropTypeLocations
		 */
		
		'use strict';
		
		var keyMirror = __webpack_require__(17);
		
		var ReactPropTypeLocations = keyMirror({
		  prop: null,
		  context: null,
		  childContext: null
		});
		
		module.exports = ReactPropTypeLocations;
	
	/***/ },
	/* 66 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactPropTypeLocationNames
		 */
		
		'use strict';
		
		var ReactPropTypeLocationNames = {};
		
		if (process.env.NODE_ENV !== 'production') {
		  ReactPropTypeLocationNames = {
		    prop: 'prop',
		    context: 'context',
		    childContext: 'child context'
		  };
		}
		
		module.exports = ReactPropTypeLocationNames;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 67 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule shouldUpdateReactComponent
		 * @typechecks static-only
		 */
		
		'use strict';
		
		/**
		 * Given a `prevElement` and `nextElement`, determines if the existing
		 * instance should be updated as opposed to being destroyed or replaced by a new
		 * instance. Both arguments are elements. This ensures that this logic can
		 * operate on stateless trees without any backing instance.
		 *
		 * @param {?object} prevElement
		 * @param {?object} nextElement
		 * @return {boolean} True if the existing instance should be updated.
		 * @protected
		 */
		function shouldUpdateReactComponent(prevElement, nextElement) {
		  var prevEmpty = prevElement === null || prevElement === false;
		  var nextEmpty = nextElement === null || nextElement === false;
		  if (prevEmpty || nextEmpty) {
		    return prevEmpty === nextEmpty;
		  }
		
		  var prevType = typeof prevElement;
		  var nextType = typeof nextElement;
		  if (prevType === 'string' || prevType === 'number') {
		    return nextType === 'string' || nextType === 'number';
		  } else {
		    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
		  }
		  return false;
		}
		
		module.exports = shouldUpdateReactComponent;
	
	/***/ },
	/* 68 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2014-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactEmptyComponent
		 */
		
		'use strict';
		
		var ReactElement = __webpack_require__(42);
		var ReactEmptyComponentRegistry = __webpack_require__(44);
		var ReactReconciler = __webpack_require__(50);
		
		var assign = __webpack_require__(39);
		
		var placeholderElement;
		
		var ReactEmptyComponentInjection = {
		  injectEmptyComponent: function (component) {
		    placeholderElement = ReactElement.createElement(component);
		  }
		};
		
		function registerNullComponentID() {
		  ReactEmptyComponentRegistry.registerNullComponentID(this._rootNodeID);
		}
		
		var ReactEmptyComponent = function (instantiate) {
		  this._currentElement = null;
		  this._rootNodeID = null;
		  this._renderedComponent = instantiate(placeholderElement);
		};
		assign(ReactEmptyComponent.prototype, {
		  construct: function (element) {},
		  mountComponent: function (rootID, transaction, context) {
		    transaction.getReactMountReady().enqueue(registerNullComponentID, this);
		    this._rootNodeID = rootID;
		    return ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, context);
		  },
		  receiveComponent: function () {},
		  unmountComponent: function (rootID, transaction, context) {
		    ReactReconciler.unmountComponent(this._renderedComponent);
		    ReactEmptyComponentRegistry.deregisterNullComponentID(this._rootNodeID);
		    this._rootNodeID = null;
		    this._renderedComponent = null;
		  }
		});
		
		ReactEmptyComponent.injection = ReactEmptyComponentInjection;
		
		module.exports = ReactEmptyComponent;
	
	/***/ },
	/* 69 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2014-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactNativeComponent
		 */
		
		'use strict';
		
		var assign = __webpack_require__(39);
		var invariant = __webpack_require__(13);
		
		var autoGenerateWrapperClass = null;
		var genericComponentClass = null;
		// This registry keeps track of wrapper classes around native tags.
		var tagToComponentClass = {};
		var textComponentClass = null;
		
		var ReactNativeComponentInjection = {
		  // This accepts a class that receives the tag string. This is a catch all
		  // that can render any kind of tag.
		  injectGenericComponentClass: function (componentClass) {
		    genericComponentClass = componentClass;
		  },
		  // This accepts a text component class that takes the text string to be
		  // rendered as props.
		  injectTextComponentClass: function (componentClass) {
		    textComponentClass = componentClass;
		  },
		  // This accepts a keyed object with classes as values. Each key represents a
		  // tag. That particular tag will use this class instead of the generic one.
		  injectComponentClasses: function (componentClasses) {
		    assign(tagToComponentClass, componentClasses);
		  }
		};
		
		/**
		 * Get a composite component wrapper class for a specific tag.
		 *
		 * @param {ReactElement} element The tag for which to get the class.
		 * @return {function} The React class constructor function.
		 */
		function getComponentClassForElement(element) {
		  if (typeof element.type === 'function') {
		    return element.type;
		  }
		  var tag = element.type;
		  var componentClass = tagToComponentClass[tag];
		  if (componentClass == null) {
		    tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);
		  }
		  return componentClass;
		}
		
		/**
		 * Get a native internal component class for a specific tag.
		 *
		 * @param {ReactElement} element The element to create.
		 * @return {function} The internal class constructor function.
		 */
		function createInternalComponent(element) {
		  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : invariant(false) : undefined;
		  return new genericComponentClass(element.type, element.props);
		}
		
		/**
		 * @param {ReactText} text
		 * @return {ReactComponent}
		 */
		function createInstanceForText(text) {
		  return new textComponentClass(text);
		}
		
		/**
		 * @param {ReactComponent} component
		 * @return {boolean}
		 */
		function isTextComponent(component) {
		  return component instanceof textComponentClass;
		}
		
		var ReactNativeComponent = {
		  getComponentClassForElement: getComponentClassForElement,
		  createInternalComponent: createInternalComponent,
		  createInstanceForText: createInstanceForText,
		  isTextComponent: isTextComponent,
		  injection: ReactNativeComponentInjection
		};
		
		module.exports = ReactNativeComponent;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 70 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule validateDOMNesting
		 */
		
		'use strict';
		
		var assign = __webpack_require__(39);
		var emptyFunction = __webpack_require__(15);
		var warning = __webpack_require__(25);
		
		var validateDOMNesting = emptyFunction;
		
		if (process.env.NODE_ENV !== 'production') {
		  // This validation code was written based on the HTML5 parsing spec:
		  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
		  //
		  // Note: this does not catch all invalid nesting, nor does it try to (as it's
		  // not clear what practical benefit doing so provides); instead, we warn only
		  // for cases where the parser will give a parse tree differing from what React
		  // intended. For example, <b><div></div></b> is invalid but we don't warn
		  // because it still parses correctly; we do warn for other cases like nested
		  // <p> tags where the beginning of the second element implicitly closes the
		  // first, causing a confusing mess.
		
		  // https://html.spec.whatwg.org/multipage/syntax.html#special
		  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
		
		  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
		  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',
		
		  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
		  // TODO: Distinguish by namespace here -- for <title>, including it here
		  // errs on the side of fewer warnings
		  'foreignObject', 'desc', 'title'];
		
		  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
		  var buttonScopeTags = inScopeTags.concat(['button']);
		
		  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
		  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
		
		  var emptyAncestorInfo = {
		    parentTag: null,
		
		    formTag: null,
		    aTagInScope: null,
		    buttonTagInScope: null,
		    nobrTagInScope: null,
		    pTagInButtonScope: null,
		
		    listItemTagAutoclosing: null,
		    dlItemTagAutoclosing: null
		  };
		
		  var updatedAncestorInfo = function (oldInfo, tag, instance) {
		    var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
		    var info = { tag: tag, instance: instance };
		
		    if (inScopeTags.indexOf(tag) !== -1) {
		      ancestorInfo.aTagInScope = null;
		      ancestorInfo.buttonTagInScope = null;
		      ancestorInfo.nobrTagInScope = null;
		    }
		    if (buttonScopeTags.indexOf(tag) !== -1) {
		      ancestorInfo.pTagInButtonScope = null;
		    }
		
		    // See rules for 'li', 'dd', 'dt' start tags in
		    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
		    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
		      ancestorInfo.listItemTagAutoclosing = null;
		      ancestorInfo.dlItemTagAutoclosing = null;
		    }
		
		    ancestorInfo.parentTag = info;
		
		    if (tag === 'form') {
		      ancestorInfo.formTag = info;
		    }
		    if (tag === 'a') {
		      ancestorInfo.aTagInScope = info;
		    }
		    if (tag === 'button') {
		      ancestorInfo.buttonTagInScope = info;
		    }
		    if (tag === 'nobr') {
		      ancestorInfo.nobrTagInScope = info;
		    }
		    if (tag === 'p') {
		      ancestorInfo.pTagInButtonScope = info;
		    }
		    if (tag === 'li') {
		      ancestorInfo.listItemTagAutoclosing = info;
		    }
		    if (tag === 'dd' || tag === 'dt') {
		      ancestorInfo.dlItemTagAutoclosing = info;
		    }
		
		    return ancestorInfo;
		  };
		
		  /**
		   * Returns whether
		   */
		  var isTagValidWithParent = function (tag, parentTag) {
		    // First, let's check if we're in an unusual parsing mode...
		    switch (parentTag) {
		      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
		      case 'select':
		        return tag === 'option' || tag === 'optgroup' || tag === '#text';
		      case 'optgroup':
		        return tag === 'option' || tag === '#text';
		      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
		      // but
		      case 'option':
		        return tag === '#text';
		
		      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
		      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
		      // No special behavior since these rules fall back to "in body" mode for
		      // all except special table nodes which cause bad parsing behavior anyway.
		
		      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
		      case 'tr':
		        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
		
		      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
		      case 'tbody':
		      case 'thead':
		      case 'tfoot':
		        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
		
		      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
		      case 'colgroup':
		        return tag === 'col' || tag === 'template';
		
		      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
		      case 'table':
		        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
		
		      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
		      case 'head':
		        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
		
		      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
		      case 'html':
		        return tag === 'head' || tag === 'body';
		    }
		
		    // Probably in the "in body" parsing mode, so we outlaw only tag combos
		    // where the parsing rules cause implicit opens or closes to be added.
		    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
		    switch (tag) {
		      case 'h1':
		      case 'h2':
		      case 'h3':
		      case 'h4':
		      case 'h5':
		      case 'h6':
		        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
		
		      case 'rp':
		      case 'rt':
		        return impliedEndTags.indexOf(parentTag) === -1;
		
		      case 'caption':
		      case 'col':
		      case 'colgroup':
		      case 'frame':
		      case 'head':
		      case 'tbody':
		      case 'td':
		      case 'tfoot':
		      case 'th':
		      case 'thead':
		      case 'tr':
		        // These tags are only valid with a few parents that have special child
		        // parsing rules -- if we're down here, then none of those matched and
		        // so we allow it only if we don't know what the parent is, as all other
		        // cases are invalid.
		        return parentTag == null;
		    }
		
		    return true;
		  };
		
		  /**
		   * Returns whether
		   */
		  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
		    switch (tag) {
		      case 'address':
		      case 'article':
		      case 'aside':
		      case 'blockquote':
		      case 'center':
		      case 'details':
		      case 'dialog':
		      case 'dir':
		      case 'div':
		      case 'dl':
		      case 'fieldset':
		      case 'figcaption':
		      case 'figure':
		      case 'footer':
		      case 'header':
		      case 'hgroup':
		      case 'main':
		      case 'menu':
		      case 'nav':
		      case 'ol':
		      case 'p':
		      case 'section':
		      case 'summary':
		      case 'ul':
		
		      case 'pre':
		      case 'listing':
		
		      case 'table':
		
		      case 'hr':
		
		      case 'xmp':
		
		      case 'h1':
		      case 'h2':
		      case 'h3':
		      case 'h4':
		      case 'h5':
		      case 'h6':
		        return ancestorInfo.pTagInButtonScope;
		
		      case 'form':
		        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
		
		      case 'li':
		        return ancestorInfo.listItemTagAutoclosing;
		
		      case 'dd':
		      case 'dt':
		        return ancestorInfo.dlItemTagAutoclosing;
		
		      case 'button':
		        return ancestorInfo.buttonTagInScope;
		
		      case 'a':
		        // Spec says something about storing a list of markers, but it sounds
		        // equivalent to this check.
		        return ancestorInfo.aTagInScope;
		
		      case 'nobr':
		        return ancestorInfo.nobrTagInScope;
		    }
		
		    return null;
		  };
		
		  /**
		   * Given a ReactCompositeComponent instance, return a list of its recursive
		   * owners, starting at the root and ending with the instance itself.
		   */
		  var findOwnerStack = function (instance) {
		    if (!instance) {
		      return [];
		    }
		
		    var stack = [];
		    /*eslint-disable space-after-keywords */
		    do {
		      /*eslint-enable space-after-keywords */
		      stack.push(instance);
		    } while (instance = instance._currentElement._owner);
		    stack.reverse();
		    return stack;
		  };
		
		  var didWarn = {};
		
		  validateDOMNesting = function (childTag, childInstance, ancestorInfo) {
		    ancestorInfo = ancestorInfo || emptyAncestorInfo;
		    var parentInfo = ancestorInfo.parentTag;
		    var parentTag = parentInfo && parentInfo.tag;
		
		    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
		    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
		    var problematic = invalidParent || invalidAncestor;
		
		    if (problematic) {
		      var ancestorTag = problematic.tag;
		      var ancestorInstance = problematic.instance;
		
		      var childOwner = childInstance && childInstance._currentElement._owner;
		      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
		
		      var childOwners = findOwnerStack(childOwner);
		      var ancestorOwners = findOwnerStack(ancestorOwner);
		
		      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
		      var i;
		
		      var deepestCommon = -1;
		      for (i = 0; i < minStackLen; i++) {
		        if (childOwners[i] === ancestorOwners[i]) {
		          deepestCommon = i;
		        } else {
		          break;
		        }
		      }
		
		      var UNKNOWN = '(unknown)';
		      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
		        return inst.getName() || UNKNOWN;
		      });
		      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
		        return inst.getName() || UNKNOWN;
		      });
		      var ownerInfo = [].concat(
		      // If the parent and child instances have a common owner ancestor, start
		      // with that -- otherwise we just start with the parent's owners.
		      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
		      // If we're warning about an invalid (non-parent) ancestry, add '...'
		      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
		
		      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
		      if (didWarn[warnKey]) {
		        return;
		      }
		      didWarn[warnKey] = true;
		
		      if (invalidParent) {
		        var info = '';
		        if (ancestorTag === 'table' && childTag === 'tr') {
		          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
		        }
		        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a child of <%s>. ' + 'See %s.%s', childTag, ancestorTag, ownerInfo, info) : undefined;
		      } else {
		        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a descendant of ' + '<%s>. See %s.', childTag, ancestorTag, ownerInfo) : undefined;
		      }
		    }
		  };
		
		  validateDOMNesting.ancestorInfoContextKey = '__validateDOMNesting_ancestorInfo$' + Math.random().toString(36).slice(2);
		
		  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
		
		  // For testing
		  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
		    ancestorInfo = ancestorInfo || emptyAncestorInfo;
		    var parentInfo = ancestorInfo.parentTag;
		    var parentTag = parentInfo && parentInfo.tag;
		    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
		  };
		}
		
		module.exports = validateDOMNesting;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 71 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactDefaultInjection
		 */
		
		'use strict';
		
		var BeforeInputEventPlugin = __webpack_require__(72);
		var ChangeEventPlugin = __webpack_require__(80);
		var ClientReactRootIndex = __webpack_require__(83);
		var DefaultEventPluginOrder = __webpack_require__(84);
		var EnterLeaveEventPlugin = __webpack_require__(85);
		var ExecutionEnvironment = __webpack_require__(9);
		var HTMLDOMPropertyConfig = __webpack_require__(89);
		var ReactBrowserComponentMixin = __webpack_require__(90);
		var ReactComponentBrowserEnvironment = __webpack_require__(26);
		var ReactDefaultBatchingStrategy = __webpack_require__(92);
		var ReactDOMComponent = __webpack_require__(93);
		var ReactDOMTextComponent = __webpack_require__(6);
		var ReactEventListener = __webpack_require__(118);
		var ReactInjection = __webpack_require__(121);
		var ReactInstanceHandles = __webpack_require__(45);
		var ReactMount = __webpack_require__(28);
		var ReactReconcileTransaction = __webpack_require__(125);
		var SelectEventPlugin = __webpack_require__(130);
		var ServerReactRootIndex = __webpack_require__(131);
		var SimpleEventPlugin = __webpack_require__(132);
		var SVGDOMPropertyConfig = __webpack_require__(141);
		
		var alreadyInjected = false;
		
		function inject() {
		  if (alreadyInjected) {
		    // TODO: This is currently true because these injections are shared between
		    // the client and the server package. They should be built independently
		    // and not share any injection state. Then this problem will be solved.
		    return;
		  }
		  alreadyInjected = true;
		
		  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
		
		  /**
		   * Inject modules for resolving DOM hierarchy and plugin ordering.
		   */
		  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
		  ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
		  ReactInjection.EventPluginHub.injectMount(ReactMount);
		
		  /**
		   * Some important event plugins included by default (without having to require
		   * them).
		   */
		  ReactInjection.EventPluginHub.injectEventPluginsByName({
		    SimpleEventPlugin: SimpleEventPlugin,
		    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
		    ChangeEventPlugin: ChangeEventPlugin,
		    SelectEventPlugin: SelectEventPlugin,
		    BeforeInputEventPlugin: BeforeInputEventPlugin
		  });
		
		  ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);
		
		  ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent);
		
		  ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);
		
		  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
		  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
		
		  ReactInjection.EmptyComponent.injectEmptyComponent('noscript');
		
		  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
		  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
		
		  ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);
		
		  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
		
		  if (process.env.NODE_ENV !== 'production') {
		    var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
		    if (/[?&]react_perf\b/.test(url)) {
		      var ReactDefaultPerf = __webpack_require__(142);
		      ReactDefaultPerf.start();
		    }
		  }
		}
		
		module.exports = {
		  inject: inject
		};
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 72 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015 Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule BeforeInputEventPlugin
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var EventConstants = __webpack_require__(30);
		var EventPropagators = __webpack_require__(73);
		var ExecutionEnvironment = __webpack_require__(9);
		var FallbackCompositionState = __webpack_require__(74);
		var SyntheticCompositionEvent = __webpack_require__(76);
		var SyntheticInputEvent = __webpack_require__(78);
		
		var keyOf = __webpack_require__(79);
		
		var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
		var START_KEYCODE = 229;
		
		var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
		
		var documentMode = null;
		if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
		  documentMode = document.documentMode;
		}
		
		// Webkit offers a very useful `textInput` event that can be used to
		// directly represent `beforeInput`. The IE `textinput` event is not as
		// useful, so we don't use it.
		var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
		
		// In IE9+, we have access to composition events, but the data supplied
		// by the native compositionend event may be incorrect. Japanese ideographic
		// spaces, for instance (\u3000) are not recorded correctly.
		var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
		
		/**
		 * Opera <= 12 includes TextEvent in window, but does not fire
		 * text input events. Rely on keypress instead.
		 */
		function isPresto() {
		  var opera = window.opera;
		  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
		}
		
		var SPACEBAR_CODE = 32;
		var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
		
		var topLevelTypes = EventConstants.topLevelTypes;
		
		// Events and their corresponding property names.
		var eventTypes = {
		  beforeInput: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onBeforeInput: null }),
		      captured: keyOf({ onBeforeInputCapture: null })
		    },
		    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
		  },
		  compositionEnd: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onCompositionEnd: null }),
		      captured: keyOf({ onCompositionEndCapture: null })
		    },
		    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
		  },
		  compositionStart: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onCompositionStart: null }),
		      captured: keyOf({ onCompositionStartCapture: null })
		    },
		    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
		  },
		  compositionUpdate: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onCompositionUpdate: null }),
		      captured: keyOf({ onCompositionUpdateCapture: null })
		    },
		    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
		  }
		};
		
		// Track whether we've ever handled a keypress on the space key.
		var hasSpaceKeypress = false;
		
		/**
		 * Return whether a native keypress event is assumed to be a command.
		 * This is required because Firefox fires `keypress` events for key commands
		 * (cut, copy, select-all, etc.) even though no character is inserted.
		 */
		function isKeypressCommand(nativeEvent) {
		  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
		  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
		  !(nativeEvent.ctrlKey && nativeEvent.altKey);
		}
		
		/**
		 * Translate native top level events into event types.
		 *
		 * @param {string} topLevelType
		 * @return {object}
		 */
		function getCompositionEventType(topLevelType) {
		  switch (topLevelType) {
		    case topLevelTypes.topCompositionStart:
		      return eventTypes.compositionStart;
		    case topLevelTypes.topCompositionEnd:
		      return eventTypes.compositionEnd;
		    case topLevelTypes.topCompositionUpdate:
		      return eventTypes.compositionUpdate;
		  }
		}
		
		/**
		 * Does our fallback best-guess model think this event signifies that
		 * composition has begun?
		 *
		 * @param {string} topLevelType
		 * @param {object} nativeEvent
		 * @return {boolean}
		 */
		function isFallbackCompositionStart(topLevelType, nativeEvent) {
		  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
		}
		
		/**
		 * Does our fallback mode think that this event is the end of composition?
		 *
		 * @param {string} topLevelType
		 * @param {object} nativeEvent
		 * @return {boolean}
		 */
		function isFallbackCompositionEnd(topLevelType, nativeEvent) {
		  switch (topLevelType) {
		    case topLevelTypes.topKeyUp:
		      // Command keys insert or clear IME input.
		      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
		    case topLevelTypes.topKeyDown:
		      // Expect IME keyCode on each keydown. If we get any other
		      // code we must have exited earlier.
		      return nativeEvent.keyCode !== START_KEYCODE;
		    case topLevelTypes.topKeyPress:
		    case topLevelTypes.topMouseDown:
		    case topLevelTypes.topBlur:
		      // Events are not possible without cancelling IME.
		      return true;
		    default:
		      return false;
		  }
		}
		
		/**
		 * Google Input Tools provides composition data via a CustomEvent,
		 * with the `data` property populated in the `detail` object. If this
		 * is available on the event object, use it. If not, this is a plain
		 * composition event and we have nothing special to extract.
		 *
		 * @param {object} nativeEvent
		 * @return {?string}
		 */
		function getDataFromCustomEvent(nativeEvent) {
		  var detail = nativeEvent.detail;
		  if (typeof detail === 'object' && 'data' in detail) {
		    return detail.data;
		  }
		  return null;
		}
		
		// Track the current IME composition fallback object, if any.
		var currentComposition = null;
		
		/**
		 * @param {string} topLevelType Record from `EventConstants`.
		 * @param {DOMEventTarget} topLevelTarget The listening component root node.
		 * @param {string} topLevelTargetID ID of `topLevelTarget`.
		 * @param {object} nativeEvent Native browser event.
		 * @return {?object} A SyntheticCompositionEvent.
		 */
		function extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
		  var eventType;
		  var fallbackData;
		
		  if (canUseCompositionEvent) {
		    eventType = getCompositionEventType(topLevelType);
		  } else if (!currentComposition) {
		    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
		      eventType = eventTypes.compositionStart;
		    }
		  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
		    eventType = eventTypes.compositionEnd;
		  }
		
		  if (!eventType) {
		    return null;
		  }
		
		  if (useFallbackCompositionData) {
		    // The current composition is stored statically and must not be
		    // overwritten while composition continues.
		    if (!currentComposition && eventType === eventTypes.compositionStart) {
		      currentComposition = FallbackCompositionState.getPooled(topLevelTarget);
		    } else if (eventType === eventTypes.compositionEnd) {
		      if (currentComposition) {
		        fallbackData = currentComposition.getData();
		      }
		    }
		  }
		
		  var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent, nativeEventTarget);
		
		  if (fallbackData) {
		    // Inject data generated from fallback path into the synthetic event.
		    // This matches the property of native CompositionEventInterface.
		    event.data = fallbackData;
		  } else {
		    var customData = getDataFromCustomEvent(nativeEvent);
		    if (customData !== null) {
		      event.data = customData;
		    }
		  }
		
		  EventPropagators.accumulateTwoPhaseDispatches(event);
		  return event;
		}
		
		/**
		 * @param {string} topLevelType Record from `EventConstants`.
		 * @param {object} nativeEvent Native browser event.
		 * @return {?string} The string corresponding to this `beforeInput` event.
		 */
		function getNativeBeforeInputChars(topLevelType, nativeEvent) {
		  switch (topLevelType) {
		    case topLevelTypes.topCompositionEnd:
		      return getDataFromCustomEvent(nativeEvent);
		    case topLevelTypes.topKeyPress:
		      /**
		       * If native `textInput` events are available, our goal is to make
		       * use of them. However, there is a special case: the spacebar key.
		       * In Webkit, preventing default on a spacebar `textInput` event
		       * cancels character insertion, but it *also* causes the browser
		       * to fall back to its default spacebar behavior of scrolling the
		       * page.
		       *
		       * Tracking at:
		       * https://code.google.com/p/chromium/issues/detail?id=355103
		       *
		       * To avoid this issue, use the keypress event as if no `textInput`
		       * event is available.
		       */
		      var which = nativeEvent.which;
		      if (which !== SPACEBAR_CODE) {
		        return null;
		      }
		
		      hasSpaceKeypress = true;
		      return SPACEBAR_CHAR;
		
		    case topLevelTypes.topTextInput:
		      // Record the characters to be added to the DOM.
		      var chars = nativeEvent.data;
		
		      // If it's a spacebar character, assume that we have already handled
		      // it at the keypress level and bail immediately. Android Chrome
		      // doesn't give us keycodes, so we need to blacklist it.
		      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
		        return null;
		      }
		
		      return chars;
		
		    default:
		      // For other native event types, do nothing.
		      return null;
		  }
		}
		
		/**
		 * For browsers that do not provide the `textInput` event, extract the
		 * appropriate string to use for SyntheticInputEvent.
		 *
		 * @param {string} topLevelType Record from `EventConstants`.
		 * @param {object} nativeEvent Native browser event.
		 * @return {?string} The fallback string for this `beforeInput` event.
		 */
		function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
		  // If we are currently composing (IME) and using a fallback to do so,
		  // try to extract the composed characters from the fallback object.
		  if (currentComposition) {
		    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
		      var chars = currentComposition.getData();
		      FallbackCompositionState.release(currentComposition);
		      currentComposition = null;
		      return chars;
		    }
		    return null;
		  }
		
		  switch (topLevelType) {
		    case topLevelTypes.topPaste:
		      // If a paste event occurs after a keypress, throw out the input
		      // chars. Paste events should not lead to BeforeInput events.
		      return null;
		    case topLevelTypes.topKeyPress:
		      /**
		       * As of v27, Firefox may fire keypress events even when no character
		       * will be inserted. A few possibilities:
		       *
		       * - `which` is `0`. Arrow keys, Esc key, etc.
		       *
		       * - `which` is the pressed key code, but no char is available.
		       *   Ex: 'AltGr + d` in Polish. There is no modified character for
		       *   this key combination and no character is inserted into the
		       *   document, but FF fires the keypress for char code `100` anyway.
		       *   No `input` event will occur.
		       *
		       * - `which` is the pressed key code, but a command combination is
		       *   being used. Ex: `Cmd+C`. No character is inserted, and no
		       *   `input` event will occur.
		       */
		      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
		        return String.fromCharCode(nativeEvent.which);
		      }
		      return null;
		    case topLevelTypes.topCompositionEnd:
		      return useFallbackCompositionData ? null : nativeEvent.data;
		    default:
		      return null;
		  }
		}
		
		/**
		 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
		 * `textInput` or fallback behavior.
		 *
		 * @param {string} topLevelType Record from `EventConstants`.
		 * @param {DOMEventTarget} topLevelTarget The listening component root node.
		 * @param {string} topLevelTargetID ID of `topLevelTarget`.
		 * @param {object} nativeEvent Native browser event.
		 * @return {?object} A SyntheticInputEvent.
		 */
		function extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
		  var chars;
		
		  if (canUseTextInputEvent) {
		    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
		  } else {
		    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
		  }
		
		  // If no characters are being inserted, no BeforeInput event should
		  // be fired.
		  if (!chars) {
		    return null;
		  }
		
		  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent, nativeEventTarget);
		
		  event.data = chars;
		  EventPropagators.accumulateTwoPhaseDispatches(event);
		  return event;
		}
		
		/**
		 * Create an `onBeforeInput` event to match
		 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
		 *
		 * This event plugin is based on the native `textInput` event
		 * available in Chrome, Safari, Opera, and IE. This event fires after
		 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
		 *
		 * `beforeInput` is spec'd but not implemented in any browsers, and
		 * the `input` event does not provide any useful information about what has
		 * actually been added, contrary to the spec. Thus, `textInput` is the best
		 * available event to identify the characters that have actually been inserted
		 * into the target node.
		 *
		 * This plugin is also responsible for emitting `composition` events, thus
		 * allowing us to share composition fallback code for both `beforeInput` and
		 * `composition` event types.
		 */
		var BeforeInputEventPlugin = {
		
		  eventTypes: eventTypes,
		
		  /**
		   * @param {string} topLevelType Record from `EventConstants`.
		   * @param {DOMEventTarget} topLevelTarget The listening component root node.
		   * @param {string} topLevelTargetID ID of `topLevelTarget`.
		   * @param {object} nativeEvent Native browser event.
		   * @return {*} An accumulation of synthetic events.
		   * @see {EventPluginHub.extractEvents}
		   */
		  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
		    return [extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget)];
		  }
		};
		
		module.exports = BeforeInputEventPlugin;
	
	/***/ },
	/* 73 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule EventPropagators
		 */
		
		'use strict';
		
		var EventConstants = __webpack_require__(30);
		var EventPluginHub = __webpack_require__(31);
		
		var warning = __webpack_require__(25);
		
		var accumulateInto = __webpack_require__(35);
		var forEachAccumulated = __webpack_require__(36);
		
		var PropagationPhases = EventConstants.PropagationPhases;
		var getListener = EventPluginHub.getListener;
		
		/**
		 * Some event types have a notion of different registration names for different
		 * "phases" of propagation. This finds listeners by a given phase.
		 */
		function listenerAtPhase(id, event, propagationPhase) {
		  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
		  return getListener(id, registrationName);
		}
		
		/**
		 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
		 * here, allows us to not have to bind or create functions for each event.
		 * Mutating the event's members allows us to not have to create a wrapping
		 * "dispatch" object that pairs the event with the listener.
		 */
		function accumulateDirectionalDispatches(domID, upwards, event) {
		  if (process.env.NODE_ENV !== 'production') {
		    process.env.NODE_ENV !== 'production' ? warning(domID, 'Dispatching id must not be null') : undefined;
		  }
		  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
		  var listener = listenerAtPhase(domID, event, phase);
		  if (listener) {
		    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
		    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
		  }
		}
		
		/**
		 * Collect dispatches (must be entirely collected before dispatching - see unit
		 * tests). Lazily allocate the array to conserve memory.  We must loop through
		 * each event and perform the traversal for each one. We cannot perform a
		 * single traversal for the entire collection of events because each event may
		 * have a different target.
		 */
		function accumulateTwoPhaseDispatchesSingle(event) {
		  if (event && event.dispatchConfig.phasedRegistrationNames) {
		    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
		  }
		}
		
		/**
		 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
		 */
		function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
		  if (event && event.dispatchConfig.phasedRegistrationNames) {
		    EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);
		  }
		}
		
		/**
		 * Accumulates without regard to direction, does not look for phased
		 * registration names. Same as `accumulateDirectDispatchesSingle` but without
		 * requiring that the `dispatchMarker` be the same as the dispatched ID.
		 */
		function accumulateDispatches(id, ignoredDirection, event) {
		  if (event && event.dispatchConfig.registrationName) {
		    var registrationName = event.dispatchConfig.registrationName;
		    var listener = getListener(id, registrationName);
		    if (listener) {
		      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
		      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
		    }
		  }
		}
		
		/**
		 * Accumulates dispatches on an `SyntheticEvent`, but only for the
		 * `dispatchMarker`.
		 * @param {SyntheticEvent} event
		 */
		function accumulateDirectDispatchesSingle(event) {
		  if (event && event.dispatchConfig.registrationName) {
		    accumulateDispatches(event.dispatchMarker, null, event);
		  }
		}
		
		function accumulateTwoPhaseDispatches(events) {
		  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
		}
		
		function accumulateTwoPhaseDispatchesSkipTarget(events) {
		  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
		}
		
		function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
		  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
		}
		
		function accumulateDirectDispatches(events) {
		  forEachAccumulated(events, accumulateDirectDispatchesSingle);
		}
		
		/**
		 * A small set of propagation patterns, each of which will accept a small amount
		 * of information, and generate a set of "dispatch ready event objects" - which
		 * are sets of events that have already been annotated with a set of dispatched
		 * listener functions/ids. The API is designed this way to discourage these
		 * propagation strategies from actually executing the dispatches, since we
		 * always want to collect the entire set of dispatches before executing event a
		 * single one.
		 *
		 * @constructor EventPropagators
		 */
		var EventPropagators = {
		  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
		  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
		  accumulateDirectDispatches: accumulateDirectDispatches,
		  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
		};
		
		module.exports = EventPropagators;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 74 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule FallbackCompositionState
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var PooledClass = __webpack_require__(56);
		
		var assign = __webpack_require__(39);
		var getTextContentAccessor = __webpack_require__(75);
		
		/**
		 * This helper class stores information about text content of a target node,
		 * allowing comparison of content before and after a given event.
		 *
		 * Identify the node where selection currently begins, then observe
		 * both its text content and its current position in the DOM. Since the
		 * browser may natively replace the target node during composition, we can
		 * use its position to find its replacement.
		 *
		 * @param {DOMEventTarget} root
		 */
		function FallbackCompositionState(root) {
		  this._root = root;
		  this._startText = this.getText();
		  this._fallbackText = null;
		}
		
		assign(FallbackCompositionState.prototype, {
		  destructor: function () {
		    this._root = null;
		    this._startText = null;
		    this._fallbackText = null;
		  },
		
		  /**
		   * Get current text of input.
		   *
		   * @return {string}
		   */
		  getText: function () {
		    if ('value' in this._root) {
		      return this._root.value;
		    }
		    return this._root[getTextContentAccessor()];
		  },
		
		  /**
		   * Determine the differing substring between the initially stored
		   * text content and the current content.
		   *
		   * @return {string}
		   */
		  getData: function () {
		    if (this._fallbackText) {
		      return this._fallbackText;
		    }
		
		    var start;
		    var startValue = this._startText;
		    var startLength = startValue.length;
		    var end;
		    var endValue = this.getText();
		    var endLength = endValue.length;
		
		    for (start = 0; start < startLength; start++) {
		      if (startValue[start] !== endValue[start]) {
		        break;
		      }
		    }
		
		    var minEnd = startLength - start;
		    for (end = 1; end <= minEnd; end++) {
		      if (startValue[startLength - end] !== endValue[endLength - end]) {
		        break;
		      }
		    }
		
		    var sliceTail = end > 1 ? 1 - end : undefined;
		    this._fallbackText = endValue.slice(start, sliceTail);
		    return this._fallbackText;
		  }
		});
		
		PooledClass.addPoolingTo(FallbackCompositionState);
		
		module.exports = FallbackCompositionState;
	
	/***/ },
	/* 75 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule getTextContentAccessor
		 */
		
		'use strict';
		
		var ExecutionEnvironment = __webpack_require__(9);
		
		var contentKey = null;
		
		/**
		 * Gets the key used to access text content on a DOM node.
		 *
		 * @return {?string} Key used to access text content.
		 * @internal
		 */
		function getTextContentAccessor() {
		  if (!contentKey && ExecutionEnvironment.canUseDOM) {
		    // Prefer textContent to innerText because many browsers support both but
		    // SVG <text> elements don't support innerText even when <div> does.
		    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
		  }
		  return contentKey;
		}
		
		module.exports = getTextContentAccessor;
	
	/***/ },
	/* 76 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule SyntheticCompositionEvent
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var SyntheticEvent = __webpack_require__(77);
		
		/**
		 * @interface Event
		 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
		 */
		var CompositionEventInterface = {
		  data: null
		};
		
		/**
		 * @param {object} dispatchConfig Configuration used to dispatch this event.
		 * @param {string} dispatchMarker Marker identifying the event target.
		 * @param {object} nativeEvent Native browser event.
		 * @extends {SyntheticUIEvent}
		 */
		function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
		  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
		}
		
		SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
		
		module.exports = SyntheticCompositionEvent;
	
	/***/ },
	/* 77 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule SyntheticEvent
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var PooledClass = __webpack_require__(56);
		
		var assign = __webpack_require__(39);
		var emptyFunction = __webpack_require__(15);
		var warning = __webpack_require__(25);
		
		/**
		 * @interface Event
		 * @see http://www.w3.org/TR/DOM-Level-3-Events/
		 */
		var EventInterface = {
		  type: null,
		  target: null,
		  // currentTarget is set when dispatching; no use in copying it here
		  currentTarget: emptyFunction.thatReturnsNull,
		  eventPhase: null,
		  bubbles: null,
		  cancelable: null,
		  timeStamp: function (event) {
		    return event.timeStamp || Date.now();
		  },
		  defaultPrevented: null,
		  isTrusted: null
		};
		
		/**
		 * Synthetic events are dispatched by event plugins, typically in response to a
		 * top-level event delegation handler.
		 *
		 * These systems should generally use pooling to reduce the frequency of garbage
		 * collection. The system should check `isPersistent` to determine whether the
		 * event should be released into the pool after being dispatched. Users that
		 * need a persisted event should invoke `persist`.
		 *
		 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
		 * normalizing browser quirks. Subclasses do not necessarily have to implement a
		 * DOM interface; custom application-specific events can also subclass this.
		 *
		 * @param {object} dispatchConfig Configuration used to dispatch this event.
		 * @param {string} dispatchMarker Marker identifying the event target.
		 * @param {object} nativeEvent Native browser event.
		 */
		function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
		  this.dispatchConfig = dispatchConfig;
		  this.dispatchMarker = dispatchMarker;
		  this.nativeEvent = nativeEvent;
		
		  var Interface = this.constructor.Interface;
		  for (var propName in Interface) {
		    if (!Interface.hasOwnProperty(propName)) {
		      continue;
		    }
		    var normalize = Interface[propName];
		    if (normalize) {
		      this[propName] = normalize(nativeEvent);
		    } else {
		      if (propName === 'target') {
		        this.target = nativeEventTarget;
		      } else {
		        this[propName] = nativeEvent[propName];
		      }
		    }
		  }
		
		  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
		  if (defaultPrevented) {
		    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
		  } else {
		    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
		  }
		  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
		}
		
		assign(SyntheticEvent.prototype, {
		
		  preventDefault: function () {
		    this.defaultPrevented = true;
		    var event = this.nativeEvent;
		    if (process.env.NODE_ENV !== 'production') {
		      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `preventDefault` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
		    }
		    if (!event) {
		      return;
		    }
		
		    if (event.preventDefault) {
		      event.preventDefault();
		    } else {
		      event.returnValue = false;
		    }
		    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
		  },
		
		  stopPropagation: function () {
		    var event = this.nativeEvent;
		    if (process.env.NODE_ENV !== 'production') {
		      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `stopPropagation` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
		    }
		    if (!event) {
		      return;
		    }
		
		    if (event.stopPropagation) {
		      event.stopPropagation();
		    } else {
		      event.cancelBubble = true;
		    }
		    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
		  },
		
		  /**
		   * We release all dispatched `SyntheticEvent`s after each event loop, adding
		   * them back into the pool. This allows a way to hold onto a reference that
		   * won't be added back into the pool.
		   */
		  persist: function () {
		    this.isPersistent = emptyFunction.thatReturnsTrue;
		  },
		
		  /**
		   * Checks if this event should be released back into the pool.
		   *
		   * @return {boolean} True if this should not be released, false otherwise.
		   */
		  isPersistent: emptyFunction.thatReturnsFalse,
		
		  /**
		   * `PooledClass` looks for `destructor` on each instance it releases.
		   */
		  destructor: function () {
		    var Interface = this.constructor.Interface;
		    for (var propName in Interface) {
		      this[propName] = null;
		    }
		    this.dispatchConfig = null;
		    this.dispatchMarker = null;
		    this.nativeEvent = null;
		  }
		
		});
		
		SyntheticEvent.Interface = EventInterface;
		
		/**
		 * Helper to reduce boilerplate when creating subclasses.
		 *
		 * @param {function} Class
		 * @param {?object} Interface
		 */
		SyntheticEvent.augmentClass = function (Class, Interface) {
		  var Super = this;
		
		  var prototype = Object.create(Super.prototype);
		  assign(prototype, Class.prototype);
		  Class.prototype = prototype;
		  Class.prototype.constructor = Class;
		
		  Class.Interface = assign({}, Super.Interface, Interface);
		  Class.augmentClass = Super.augmentClass;
		
		  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
		};
		
		PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
		
		module.exports = SyntheticEvent;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 78 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule SyntheticInputEvent
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var SyntheticEvent = __webpack_require__(77);
		
		/**
		 * @interface Event
		 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
		 *      /#events-inputevents
		 */
		var InputEventInterface = {
		  data: null
		};
		
		/**
		 * @param {object} dispatchConfig Configuration used to dispatch this event.
		 * @param {string} dispatchMarker Marker identifying the event target.
		 * @param {object} nativeEvent Native browser event.
		 * @extends {SyntheticUIEvent}
		 */
		function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
		  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
		}
		
		SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
		
		module.exports = SyntheticInputEvent;
	
	/***/ },
	/* 79 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule keyOf
		 */
		
		/**
		 * Allows extraction of a minified key. Let's the build system minify keys
		 * without losing the ability to dynamically use key strings as values
		 * themselves. Pass in an object with a single key/val pair and it will return
		 * you the string key of that single record. Suppose you want to grab the
		 * value for a key 'className' inside of an object. Key/val minification may
		 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
		 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
		 * reuse those resolutions.
		 */
		"use strict";
		
		var keyOf = function (oneKeyObj) {
		  var key;
		  for (key in oneKeyObj) {
		    if (!oneKeyObj.hasOwnProperty(key)) {
		      continue;
		    }
		    return key;
		  }
		  return null;
		};
		
		module.exports = keyOf;
	
	/***/ },
	/* 80 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ChangeEventPlugin
		 */
		
		'use strict';
		
		var EventConstants = __webpack_require__(30);
		var EventPluginHub = __webpack_require__(31);
		var EventPropagators = __webpack_require__(73);
		var ExecutionEnvironment = __webpack_require__(9);
		var ReactUpdates = __webpack_require__(54);
		var SyntheticEvent = __webpack_require__(77);
		
		var getEventTarget = __webpack_require__(81);
		var isEventSupported = __webpack_require__(40);
		var isTextInputElement = __webpack_require__(82);
		var keyOf = __webpack_require__(79);
		
		var topLevelTypes = EventConstants.topLevelTypes;
		
		var eventTypes = {
		  change: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onChange: null }),
		      captured: keyOf({ onChangeCapture: null })
		    },
		    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
		  }
		};
		
		/**
		 * For IE shims
		 */
		var activeElement = null;
		var activeElementID = null;
		var activeElementValue = null;
		var activeElementValueProp = null;
		
		/**
		 * SECTION: handle `change` event
		 */
		function shouldUseChangeEvent(elem) {
		  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
		  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
		}
		
		var doesChangeEventBubble = false;
		if (ExecutionEnvironment.canUseDOM) {
		  // See `handleChange` comment below
		  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
		}
		
		function manualDispatchChangeEvent(nativeEvent) {
		  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent, getEventTarget(nativeEvent));
		  EventPropagators.accumulateTwoPhaseDispatches(event);
		
		  // If change and propertychange bubbled, we'd just bind to it like all the
		  // other events and have it go through ReactBrowserEventEmitter. Since it
		  // doesn't, we manually listen for the events and so we have to enqueue and
		  // process the abstract event manually.
		  //
		  // Batching is necessary here in order to ensure that all event handlers run
		  // before the next rerender (including event handlers attached to ancestor
		  // elements instead of directly on the input). Without this, controlled
		  // components don't work properly in conjunction with event bubbling because
		  // the component is rerendered and the value reverted before all the event
		  // handlers can run. See https://github.com/facebook/react/issues/708.
		  ReactUpdates.batchedUpdates(runEventInBatch, event);
		}
		
		function runEventInBatch(event) {
		  EventPluginHub.enqueueEvents(event);
		  EventPluginHub.processEventQueue(false);
		}
		
		function startWatchingForChangeEventIE8(target, targetID) {
		  activeElement = target;
		  activeElementID = targetID;
		  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
		}
		
		function stopWatchingForChangeEventIE8() {
		  if (!activeElement) {
		    return;
		  }
		  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
		  activeElement = null;
		  activeElementID = null;
		}
		
		function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
		  if (topLevelType === topLevelTypes.topChange) {
		    return topLevelTargetID;
		  }
		}
		function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
		  if (topLevelType === topLevelTypes.topFocus) {
		    // stopWatching() should be a noop here but we call it just in case we
		    // missed a blur event somehow.
		    stopWatchingForChangeEventIE8();
		    startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
		  } else if (topLevelType === topLevelTypes.topBlur) {
		    stopWatchingForChangeEventIE8();
		  }
		}
		
		/**
		 * SECTION: handle `input` event
		 */
		var isInputEventSupported = false;
		if (ExecutionEnvironment.canUseDOM) {
		  // IE9 claims to support the input event but fails to trigger it when
		  // deleting text, so we ignore its input events
		  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
		}
		
		/**
		 * (For old IE.) Replacement getter/setter for the `value` property that gets
		 * set on the active element.
		 */
		var newValueProp = {
		  get: function () {
		    return activeElementValueProp.get.call(this);
		  },
		  set: function (val) {
		    // Cast to a string so we can do equality checks.
		    activeElementValue = '' + val;
		    activeElementValueProp.set.call(this, val);
		  }
		};
		
		/**
		 * (For old IE.) Starts tracking propertychange events on the passed-in element
		 * and override the value property so that we can distinguish user events from
		 * value changes in JS.
		 */
		function startWatchingForValueChange(target, targetID) {
		  activeElement = target;
		  activeElementID = targetID;
		  activeElementValue = target.value;
		  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
		
		  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
		  // on DOM elements
		  Object.defineProperty(activeElement, 'value', newValueProp);
		  activeElement.attachEvent('onpropertychange', handlePropertyChange);
		}
		
		/**
		 * (For old IE.) Removes the event listeners from the currently-tracked element,
		 * if any exists.
		 */
		function stopWatchingForValueChange() {
		  if (!activeElement) {
		    return;
		  }
		
		  // delete restores the original property definition
		  delete activeElement.value;
		  activeElement.detachEvent('onpropertychange', handlePropertyChange);
		
		  activeElement = null;
		  activeElementID = null;
		  activeElementValue = null;
		  activeElementValueProp = null;
		}
		
		/**
		 * (For old IE.) Handles a propertychange event, sending a `change` event if
		 * the value of the active element has changed.
		 */
		function handlePropertyChange(nativeEvent) {
		  if (nativeEvent.propertyName !== 'value') {
		    return;
		  }
		  var value = nativeEvent.srcElement.value;
		  if (value === activeElementValue) {
		    return;
		  }
		  activeElementValue = value;
		
		  manualDispatchChangeEvent(nativeEvent);
		}
		
		/**
		 * If a `change` event should be fired, returns the target's ID.
		 */
		function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
		  if (topLevelType === topLevelTypes.topInput) {
		    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
		    // what we want so fall through here and trigger an abstract event
		    return topLevelTargetID;
		  }
		}
		
		// For IE8 and IE9.
		function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
		  if (topLevelType === topLevelTypes.topFocus) {
		    // In IE8, we can capture almost all .value changes by adding a
		    // propertychange handler and looking for events with propertyName
		    // equal to 'value'
		    // In IE9, propertychange fires for most input events but is buggy and
		    // doesn't fire when text is deleted, but conveniently, selectionchange
		    // appears to fire in all of the remaining cases so we catch those and
		    // forward the event if the value has changed
		    // In either case, we don't want to call the event handler if the value
		    // is changed from JS so we redefine a setter for `.value` that updates
		    // our activeElementValue variable, allowing us to ignore those changes
		    //
		    // stopWatching() should be a noop here but we call it just in case we
		    // missed a blur event somehow.
		    stopWatchingForValueChange();
		    startWatchingForValueChange(topLevelTarget, topLevelTargetID);
		  } else if (topLevelType === topLevelTypes.topBlur) {
		    stopWatchingForValueChange();
		  }
		}
		
		// For IE8 and IE9.
		function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
		  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
		    // On the selectionchange event, the target is just document which isn't
		    // helpful for us so just check activeElement instead.
		    //
		    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
		    // propertychange on the first input event after setting `value` from a
		    // script and fires only keydown, keypress, keyup. Catching keyup usually
		    // gets it and catching keydown lets us fire an event for the first
		    // keystroke if user does a key repeat (it'll be a little delayed: right
		    // before the second keystroke). Other input methods (e.g., paste) seem to
		    // fire selectionchange normally.
		    if (activeElement && activeElement.value !== activeElementValue) {
		      activeElementValue = activeElement.value;
		      return activeElementID;
		    }
		  }
		}
		
		/**
		 * SECTION: handle `click` event
		 */
		function shouldUseClickEvent(elem) {
		  // Use the `click` event to detect changes to checkbox and radio inputs.
		  // This approach works across all browsers, whereas `change` does not fire
		  // until `blur` in IE8.
		  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
		}
		
		function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
		  if (topLevelType === topLevelTypes.topClick) {
		    return topLevelTargetID;
		  }
		}
		
		/**
		 * This plugin creates an `onChange` event that normalizes change events
		 * across form elements. This event fires at a time when it's possible to
		 * change the element's value without seeing a flicker.
		 *
		 * Supported elements are:
		 * - input (see `isTextInputElement`)
		 * - textarea
		 * - select
		 */
		var ChangeEventPlugin = {
		
		  eventTypes: eventTypes,
		
		  /**
		   * @param {string} topLevelType Record from `EventConstants`.
		   * @param {DOMEventTarget} topLevelTarget The listening component root node.
		   * @param {string} topLevelTargetID ID of `topLevelTarget`.
		   * @param {object} nativeEvent Native browser event.
		   * @return {*} An accumulation of synthetic events.
		   * @see {EventPluginHub.extractEvents}
		   */
		  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
		
		    var getTargetIDFunc, handleEventFunc;
		    if (shouldUseChangeEvent(topLevelTarget)) {
		      if (doesChangeEventBubble) {
		        getTargetIDFunc = getTargetIDForChangeEvent;
		      } else {
		        handleEventFunc = handleEventsForChangeEventIE8;
		      }
		    } else if (isTextInputElement(topLevelTarget)) {
		      if (isInputEventSupported) {
		        getTargetIDFunc = getTargetIDForInputEvent;
		      } else {
		        getTargetIDFunc = getTargetIDForInputEventIE;
		        handleEventFunc = handleEventsForInputEventIE;
		      }
		    } else if (shouldUseClickEvent(topLevelTarget)) {
		      getTargetIDFunc = getTargetIDForClickEvent;
		    }
		
		    if (getTargetIDFunc) {
		      var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
		      if (targetID) {
		        var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent, nativeEventTarget);
		        event.type = 'change';
		        EventPropagators.accumulateTwoPhaseDispatches(event);
		        return event;
		      }
		    }
		
		    if (handleEventFunc) {
		      handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
		    }
		  }
		
		};
		
		module.exports = ChangeEventPlugin;
	
	/***/ },
	/* 81 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule getEventTarget
		 * @typechecks static-only
		 */
		
		'use strict';
		
		/**
		 * Gets the target node from a native browser event by accounting for
		 * inconsistencies in browser DOM APIs.
		 *
		 * @param {object} nativeEvent Native browser event.
		 * @return {DOMEventTarget} Target node.
		 */
		function getEventTarget(nativeEvent) {
		  var target = nativeEvent.target || nativeEvent.srcElement || window;
		  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
		  // @see http://www.quirksmode.org/js/events_properties.html
		  return target.nodeType === 3 ? target.parentNode : target;
		}
		
		module.exports = getEventTarget;
	
	/***/ },
	/* 82 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule isTextInputElement
		 */
		
		'use strict';
		
		/**
		 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
		 */
		var supportedInputTypes = {
		  'color': true,
		  'date': true,
		  'datetime': true,
		  'datetime-local': true,
		  'email': true,
		  'month': true,
		  'number': true,
		  'password': true,
		  'range': true,
		  'search': true,
		  'tel': true,
		  'text': true,
		  'time': true,
		  'url': true,
		  'week': true
		};
		
		function isTextInputElement(elem) {
		  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
		  return nodeName && (nodeName === 'input' && supportedInputTypes[elem.type] || nodeName === 'textarea');
		}
		
		module.exports = isTextInputElement;
	
	/***/ },
	/* 83 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ClientReactRootIndex
		 * @typechecks
		 */
		
		'use strict';
		
		var nextReactRootIndex = 0;
		
		var ClientReactRootIndex = {
		  createReactRootIndex: function () {
		    return nextReactRootIndex++;
		  }
		};
		
		module.exports = ClientReactRootIndex;
	
	/***/ },
	/* 84 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule DefaultEventPluginOrder
		 */
		
		'use strict';
		
		var keyOf = __webpack_require__(79);
		
		/**
		 * Module that is injectable into `EventPluginHub`, that specifies a
		 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
		 * plugins, without having to package every one of them. This is better than
		 * having plugins be ordered in the same order that they are injected because
		 * that ordering would be influenced by the packaging order.
		 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
		 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
		 */
		var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];
		
		module.exports = DefaultEventPluginOrder;
	
	/***/ },
	/* 85 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule EnterLeaveEventPlugin
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var EventConstants = __webpack_require__(30);
		var EventPropagators = __webpack_require__(73);
		var SyntheticMouseEvent = __webpack_require__(86);
		
		var ReactMount = __webpack_require__(28);
		var keyOf = __webpack_require__(79);
		
		var topLevelTypes = EventConstants.topLevelTypes;
		var getFirstReactDOM = ReactMount.getFirstReactDOM;
		
		var eventTypes = {
		  mouseEnter: {
		    registrationName: keyOf({ onMouseEnter: null }),
		    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
		  },
		  mouseLeave: {
		    registrationName: keyOf({ onMouseLeave: null }),
		    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
		  }
		};
		
		var extractedEvents = [null, null];
		
		var EnterLeaveEventPlugin = {
		
		  eventTypes: eventTypes,
		
		  /**
		   * For almost every interaction we care about, there will be both a top-level
		   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
		   * we do not extract duplicate events. However, moving the mouse into the
		   * browser from outside will not fire a `mouseout` event. In this case, we use
		   * the `mouseover` top-level event.
		   *
		   * @param {string} topLevelType Record from `EventConstants`.
		   * @param {DOMEventTarget} topLevelTarget The listening component root node.
		   * @param {string} topLevelTargetID ID of `topLevelTarget`.
		   * @param {object} nativeEvent Native browser event.
		   * @return {*} An accumulation of synthetic events.
		   * @see {EventPluginHub.extractEvents}
		   */
		  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
		    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
		      return null;
		    }
		    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
		      // Must not be a mouse in or mouse out - ignoring.
		      return null;
		    }
		
		    var win;
		    if (topLevelTarget.window === topLevelTarget) {
		      // `topLevelTarget` is probably a window object.
		      win = topLevelTarget;
		    } else {
		      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
		      var doc = topLevelTarget.ownerDocument;
		      if (doc) {
		        win = doc.defaultView || doc.parentWindow;
		      } else {
		        win = window;
		      }
		    }
		
		    var from;
		    var to;
		    var fromID = '';
		    var toID = '';
		    if (topLevelType === topLevelTypes.topMouseOut) {
		      from = topLevelTarget;
		      fromID = topLevelTargetID;
		      to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement);
		      if (to) {
		        toID = ReactMount.getID(to);
		      } else {
		        to = win;
		      }
		      to = to || win;
		    } else {
		      from = win;
		      to = topLevelTarget;
		      toID = topLevelTargetID;
		    }
		
		    if (from === to) {
		      // Nothing pertains to our managed components.
		      return null;
		    }
		
		    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent, nativeEventTarget);
		    leave.type = 'mouseleave';
		    leave.target = from;
		    leave.relatedTarget = to;
		
		    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent, nativeEventTarget);
		    enter.type = 'mouseenter';
		    enter.target = to;
		    enter.relatedTarget = from;
		
		    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);
		
		    extractedEvents[0] = leave;
		    extractedEvents[1] = enter;
		
		    return extractedEvents;
		  }
		
		};
		
		module.exports = EnterLeaveEventPlugin;
	
	/***/ },
	/* 86 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule SyntheticMouseEvent
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var SyntheticUIEvent = __webpack_require__(87);
		var ViewportMetrics = __webpack_require__(38);
		
		var getEventModifierState = __webpack_require__(88);
		
		/**
		 * @interface MouseEvent
		 * @see http://www.w3.org/TR/DOM-Level-3-Events/
		 */
		var MouseEventInterface = {
		  screenX: null,
		  screenY: null,
		  clientX: null,
		  clientY: null,
		  ctrlKey: null,
		  shiftKey: null,
		  altKey: null,
		  metaKey: null,
		  getModifierState: getEventModifierState,
		  button: function (event) {
		    // Webkit, Firefox, IE9+
		    // which:  1 2 3
		    // button: 0 1 2 (standard)
		    var button = event.button;
		    if ('which' in event) {
		      return button;
		    }
		    // IE<9
		    // which:  undefined
		    // button: 0 0 0
		    // button: 1 4 2 (onmouseup)
		    return button === 2 ? 2 : button === 4 ? 1 : 0;
		  },
		  buttons: null,
		  relatedTarget: function (event) {
		    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
		  },
		  // "Proprietary" Interface.
		  pageX: function (event) {
		    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
		  },
		  pageY: function (event) {
		    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
		  }
		};
		
		/**
		 * @param {object} dispatchConfig Configuration used to dispatch this event.
		 * @param {string} dispatchMarker Marker identifying the event target.
		 * @param {object} nativeEvent Native browser event.
		 * @extends {SyntheticUIEvent}
		 */
		function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
		  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
		}
		
		SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
		
		module.exports = SyntheticMouseEvent;
	
	/***/ },
	/* 87 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule SyntheticUIEvent
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var SyntheticEvent = __webpack_require__(77);
		
		var getEventTarget = __webpack_require__(81);
		
		/**
		 * @interface UIEvent
		 * @see http://www.w3.org/TR/DOM-Level-3-Events/
		 */
		var UIEventInterface = {
		  view: function (event) {
		    if (event.view) {
		      return event.view;
		    }
		
		    var target = getEventTarget(event);
		    if (target != null && target.window === target) {
		      // target is a window object
		      return target;
		    }
		
		    var doc = target.ownerDocument;
		    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
		    if (doc) {
		      return doc.defaultView || doc.parentWindow;
		    } else {
		      return window;
		    }
		  },
		  detail: function (event) {
		    return event.detail || 0;
		  }
		};
		
		/**
		 * @param {object} dispatchConfig Configuration used to dispatch this event.
		 * @param {string} dispatchMarker Marker identifying the event target.
		 * @param {object} nativeEvent Native browser event.
		 * @extends {SyntheticEvent}
		 */
		function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
		  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
		}
		
		SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
		
		module.exports = SyntheticUIEvent;
	
	/***/ },
	/* 88 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule getEventModifierState
		 * @typechecks static-only
		 */
		
		'use strict';
		
		/**
		 * Translation from modifier key to the associated property in the event.
		 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
		 */
		
		var modifierKeyToProp = {
		  'Alt': 'altKey',
		  'Control': 'ctrlKey',
		  'Meta': 'metaKey',
		  'Shift': 'shiftKey'
		};
		
		// IE8 does not implement getModifierState so we simply map it to the only
		// modifier keys exposed by the event itself, does not support Lock-keys.
		// Currently, all major browsers except Chrome seems to support Lock-keys.
		function modifierStateGetter(keyArg) {
		  var syntheticEvent = this;
		  var nativeEvent = syntheticEvent.nativeEvent;
		  if (nativeEvent.getModifierState) {
		    return nativeEvent.getModifierState(keyArg);
		  }
		  var keyProp = modifierKeyToProp[keyArg];
		  return keyProp ? !!nativeEvent[keyProp] : false;
		}
		
		function getEventModifierState(nativeEvent) {
		  return modifierStateGetter;
		}
		
		module.exports = getEventModifierState;
	
	/***/ },
	/* 89 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule HTMLDOMPropertyConfig
		 */
		
		'use strict';
		
		var DOMProperty = __webpack_require__(23);
		var ExecutionEnvironment = __webpack_require__(9);
		
		var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
		var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
		var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
		var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
		var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
		var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
		var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
		
		var hasSVG;
		if (ExecutionEnvironment.canUseDOM) {
		  var implementation = document.implementation;
		  hasSVG = implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1');
		}
		
		var HTMLDOMPropertyConfig = {
		  isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
		  Properties: {
		    /**
		     * Standard Properties
		     */
		    accept: null,
		    acceptCharset: null,
		    accessKey: null,
		    action: null,
		    allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
		    allowTransparency: MUST_USE_ATTRIBUTE,
		    alt: null,
		    async: HAS_BOOLEAN_VALUE,
		    autoComplete: null,
		    // autoFocus is polyfilled/normalized by AutoFocusUtils
		    // autoFocus: HAS_BOOLEAN_VALUE,
		    autoPlay: HAS_BOOLEAN_VALUE,
		    capture: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
		    cellPadding: null,
		    cellSpacing: null,
		    charSet: MUST_USE_ATTRIBUTE,
		    challenge: MUST_USE_ATTRIBUTE,
		    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
		    classID: MUST_USE_ATTRIBUTE,
		    // To set className on SVG elements, it's necessary to use .setAttribute;
		    // this works on HTML elements too in all browsers except IE8. Conveniently,
		    // IE8 doesn't support SVG and so we can simply use the attribute in
		    // browsers that support SVG and the property in browsers that don't,
		    // regardless of whether the element is HTML or SVG.
		    className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
		    cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
		    colSpan: null,
		    content: null,
		    contentEditable: null,
		    contextMenu: MUST_USE_ATTRIBUTE,
		    controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
		    coords: null,
		    crossOrigin: null,
		    data: null, // For `<object />` acts as `src`.
		    dateTime: MUST_USE_ATTRIBUTE,
		    'default': HAS_BOOLEAN_VALUE,
		    defer: HAS_BOOLEAN_VALUE,
		    dir: null,
		    disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
		    download: HAS_OVERLOADED_BOOLEAN_VALUE,
		    draggable: null,
		    encType: null,
		    form: MUST_USE_ATTRIBUTE,
		    formAction: MUST_USE_ATTRIBUTE,
		    formEncType: MUST_USE_ATTRIBUTE,
		    formMethod: MUST_USE_ATTRIBUTE,
		    formNoValidate: HAS_BOOLEAN_VALUE,
		    formTarget: MUST_USE_ATTRIBUTE,
		    frameBorder: MUST_USE_ATTRIBUTE,
		    headers: null,
		    height: MUST_USE_ATTRIBUTE,
		    hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
		    high: null,
		    href: null,
		    hrefLang: null,
		    htmlFor: null,
		    httpEquiv: null,
		    icon: null,
		    id: MUST_USE_PROPERTY,
		    inputMode: MUST_USE_ATTRIBUTE,
		    integrity: null,
		    is: MUST_USE_ATTRIBUTE,
		    keyParams: MUST_USE_ATTRIBUTE,
		    keyType: MUST_USE_ATTRIBUTE,
		    kind: null,
		    label: null,
		    lang: null,
		    list: MUST_USE_ATTRIBUTE,
		    loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
		    low: null,
		    manifest: MUST_USE_ATTRIBUTE,
		    marginHeight: null,
		    marginWidth: null,
		    max: null,
		    maxLength: MUST_USE_ATTRIBUTE,
		    media: MUST_USE_ATTRIBUTE,
		    mediaGroup: null,
		    method: null,
		    min: null,
		    minLength: MUST_USE_ATTRIBUTE,
		    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
		    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
		    name: null,
		    nonce: MUST_USE_ATTRIBUTE,
		    noValidate: HAS_BOOLEAN_VALUE,
		    open: HAS_BOOLEAN_VALUE,
		    optimum: null,
		    pattern: null,
		    placeholder: null,
		    poster: null,
		    preload: null,
		    radioGroup: null,
		    readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
		    rel: null,
		    required: HAS_BOOLEAN_VALUE,
		    reversed: HAS_BOOLEAN_VALUE,
		    role: MUST_USE_ATTRIBUTE,
		    rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
		    rowSpan: null,
		    sandbox: null,
		    scope: null,
		    scoped: HAS_BOOLEAN_VALUE,
		    scrolling: null,
		    seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
		    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
		    shape: null,
		    size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
		    sizes: MUST_USE_ATTRIBUTE,
		    span: HAS_POSITIVE_NUMERIC_VALUE,
		    spellCheck: null,
		    src: null,
		    srcDoc: MUST_USE_PROPERTY,
		    srcLang: null,
		    srcSet: MUST_USE_ATTRIBUTE,
		    start: HAS_NUMERIC_VALUE,
		    step: null,
		    style: null,
		    summary: null,
		    tabIndex: null,
		    target: null,
		    title: null,
		    type: null,
		    useMap: null,
		    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
		    width: MUST_USE_ATTRIBUTE,
		    wmode: MUST_USE_ATTRIBUTE,
		    wrap: null,
		
		    /**
		     * RDFa Properties
		     */
		    about: MUST_USE_ATTRIBUTE,
		    datatype: MUST_USE_ATTRIBUTE,
		    inlist: MUST_USE_ATTRIBUTE,
		    prefix: MUST_USE_ATTRIBUTE,
		    // property is also supported for OpenGraph in meta tags.
		    property: MUST_USE_ATTRIBUTE,
		    resource: MUST_USE_ATTRIBUTE,
		    'typeof': MUST_USE_ATTRIBUTE,
		    vocab: MUST_USE_ATTRIBUTE,
		
		    /**
		     * Non-standard Properties
		     */
		    // autoCapitalize and autoCorrect are supported in Mobile Safari for
		    // keyboard hints.
		    autoCapitalize: MUST_USE_ATTRIBUTE,
		    autoCorrect: MUST_USE_ATTRIBUTE,
		    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
		    autoSave: null,
		    // color is for Safari mask-icon link
		    color: null,
		    // itemProp, itemScope, itemType are for
		    // Microdata support. See http://schema.org/docs/gs.html
		    itemProp: MUST_USE_ATTRIBUTE,
		    itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
		    itemType: MUST_USE_ATTRIBUTE,
		    // itemID and itemRef are for Microdata support as well but
		    // only specified in the the WHATWG spec document. See
		    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
		    itemID: MUST_USE_ATTRIBUTE,
		    itemRef: MUST_USE_ATTRIBUTE,
		    // results show looking glass icon and recent searches on input
		    // search fields in WebKit/Blink
		    results: null,
		    // IE-only attribute that specifies security restrictions on an iframe
		    // as an alternative to the sandbox attribute on IE<10
		    security: MUST_USE_ATTRIBUTE,
		    // IE-only attribute that controls focus behavior
		    unselectable: MUST_USE_ATTRIBUTE
		  },
		  DOMAttributeNames: {
		    acceptCharset: 'accept-charset',
		    className: 'class',
		    htmlFor: 'for',
		    httpEquiv: 'http-equiv'
		  },
		  DOMPropertyNames: {
		    autoComplete: 'autocomplete',
		    autoFocus: 'autofocus',
		    autoPlay: 'autoplay',
		    autoSave: 'autosave',
		    // `encoding` is equivalent to `enctype`, IE8 lacks an `enctype` setter.
		    // http://www.w3.org/TR/html5/forms.html#dom-fs-encoding
		    encType: 'encoding',
		    hrefLang: 'hreflang',
		    radioGroup: 'radiogroup',
		    spellCheck: 'spellcheck',
		    srcDoc: 'srcdoc',
		    srcSet: 'srcset'
		  }
		};
		
		module.exports = HTMLDOMPropertyConfig;
	
	/***/ },
	/* 90 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactBrowserComponentMixin
		 */
		
		'use strict';
		
		var ReactInstanceMap = __webpack_require__(47);
		
		var findDOMNode = __webpack_require__(91);
		var warning = __webpack_require__(25);
		
		var didWarnKey = '_getDOMNodeDidWarn';
		
		var ReactBrowserComponentMixin = {
		  /**
		   * Returns the DOM node rendered by this component.
		   *
		   * @return {DOMElement} The root node of this component.
		   * @final
		   * @protected
		   */
		  getDOMNode: function () {
		    process.env.NODE_ENV !== 'production' ? warning(this.constructor[didWarnKey], '%s.getDOMNode(...) is deprecated. Please use ' + 'ReactDOM.findDOMNode(instance) instead.', ReactInstanceMap.get(this).getName() || this.tagName || 'Unknown') : undefined;
		    this.constructor[didWarnKey] = true;
		    return findDOMNode(this);
		  }
		};
		
		module.exports = ReactBrowserComponentMixin;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 91 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule findDOMNode
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var ReactCurrentOwner = __webpack_require__(5);
		var ReactInstanceMap = __webpack_require__(47);
		var ReactMount = __webpack_require__(28);
		
		var invariant = __webpack_require__(13);
		var warning = __webpack_require__(25);
		
		/**
		 * Returns the DOM node rendered by this element.
		 *
		 * @param {ReactComponent|DOMElement} componentOrElement
		 * @return {?DOMElement} The root node of this element.
		 */
		function findDOMNode(componentOrElement) {
		  if (process.env.NODE_ENV !== 'production') {
		    var owner = ReactCurrentOwner.current;
		    if (owner !== null) {
		      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing getDOMNode or findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
		      owner._warnedAboutRefsInRender = true;
		    }
		  }
		  if (componentOrElement == null) {
		    return null;
		  }
		  if (componentOrElement.nodeType === 1) {
		    return componentOrElement;
		  }
		  if (ReactInstanceMap.has(componentOrElement)) {
		    return ReactMount.getNodeFromInstance(componentOrElement);
		  }
		  !(componentOrElement.render == null || typeof componentOrElement.render !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : invariant(false) : undefined;
		   true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : invariant(false) : undefined;
		}
		
		module.exports = findDOMNode;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 92 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactDefaultBatchingStrategy
		 */
		
		'use strict';
		
		var ReactUpdates = __webpack_require__(54);
		var Transaction = __webpack_require__(57);
		
		var assign = __webpack_require__(39);
		var emptyFunction = __webpack_require__(15);
		
		var RESET_BATCHED_UPDATES = {
		  initialize: emptyFunction,
		  close: function () {
		    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
		  }
		};
		
		var FLUSH_BATCHED_UPDATES = {
		  initialize: emptyFunction,
		  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
		};
		
		var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
		
		function ReactDefaultBatchingStrategyTransaction() {
		  this.reinitializeTransaction();
		}
		
		assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
		  getTransactionWrappers: function () {
		    return TRANSACTION_WRAPPERS;
		  }
		});
		
		var transaction = new ReactDefaultBatchingStrategyTransaction();
		
		var ReactDefaultBatchingStrategy = {
		  isBatchingUpdates: false,
		
		  /**
		   * Call the provided function in a context within which calls to `setState`
		   * and friends are batched such that components aren't updated unnecessarily.
		   */
		  batchedUpdates: function (callback, a, b, c, d, e) {
		    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
		
		    ReactDefaultBatchingStrategy.isBatchingUpdates = true;
		
		    // The code is written this way to avoid extra allocations
		    if (alreadyBatchingUpdates) {
		      callback(a, b, c, d, e);
		    } else {
		      transaction.perform(callback, null, a, b, c, d, e);
		    }
		  }
		};
		
		module.exports = ReactDefaultBatchingStrategy;
	
	/***/ },
	/* 93 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactDOMComponent
		 * @typechecks static-only
		 */
		
		/* global hasOwnProperty:true */
		
		'use strict';
		
		var AutoFocusUtils = __webpack_require__(94);
		var CSSPropertyOperations = __webpack_require__(96);
		var DOMProperty = __webpack_require__(23);
		var DOMPropertyOperations = __webpack_require__(22);
		var EventConstants = __webpack_require__(30);
		var ReactBrowserEventEmitter = __webpack_require__(29);
		var ReactComponentBrowserEnvironment = __webpack_require__(26);
		var ReactDOMButton = __webpack_require__(104);
		var ReactDOMInput = __webpack_require__(105);
		var ReactDOMOption = __webpack_require__(109);
		var ReactDOMSelect = __webpack_require__(112);
		var ReactDOMTextarea = __webpack_require__(113);
		var ReactMount = __webpack_require__(28);
		var ReactMultiChild = __webpack_require__(114);
		var ReactPerf = __webpack_require__(18);
		var ReactUpdateQueue = __webpack_require__(53);
		
		var assign = __webpack_require__(39);
		var canDefineProperty = __webpack_require__(43);
		var escapeTextContentForBrowser = __webpack_require__(21);
		var invariant = __webpack_require__(13);
		var isEventSupported = __webpack_require__(40);
		var keyOf = __webpack_require__(79);
		var setInnerHTML = __webpack_require__(19);
		var setTextContent = __webpack_require__(20);
		var shallowEqual = __webpack_require__(117);
		var validateDOMNesting = __webpack_require__(70);
		var warning = __webpack_require__(25);
		
		var deleteListener = ReactBrowserEventEmitter.deleteListener;
		var listenTo = ReactBrowserEventEmitter.listenTo;
		var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;
		
		// For quickly matching children type, to test if can be treated as content.
		var CONTENT_TYPES = { 'string': true, 'number': true };
		
		var CHILDREN = keyOf({ children: null });
		var STYLE = keyOf({ style: null });
		var HTML = keyOf({ __html: null });
		
		var ELEMENT_NODE_TYPE = 1;
		
		function getDeclarationErrorAddendum(internalInstance) {
		  if (internalInstance) {
		    var owner = internalInstance._currentElement._owner || null;
		    if (owner) {
		      var name = owner.getName();
		      if (name) {
		        return ' This DOM node was rendered by `' + name + '`.';
		      }
		    }
		  }
		  return '';
		}
		
		var legacyPropsDescriptor;
		if (process.env.NODE_ENV !== 'production') {
		  legacyPropsDescriptor = {
		    props: {
		      enumerable: false,
		      get: function () {
		        var component = this._reactInternalComponent;
		        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .props of a DOM node; instead, ' + 'recreate the props as `render` did originally or read the DOM ' + 'properties/attributes directly from this node (e.g., ' + 'this.refs.box.className).%s', getDeclarationErrorAddendum(component)) : undefined;
		        return component._currentElement.props;
		      }
		    }
		  };
		}
		
		function legacyGetDOMNode() {
		  if (process.env.NODE_ENV !== 'production') {
		    var component = this._reactInternalComponent;
		    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .getDOMNode() of a DOM node; ' + 'instead, use the node directly.%s', getDeclarationErrorAddendum(component)) : undefined;
		  }
		  return this;
		}
		
		function legacyIsMounted() {
		  var component = this._reactInternalComponent;
		  if (process.env.NODE_ENV !== 'production') {
		    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .isMounted() of a DOM node.%s', getDeclarationErrorAddendum(component)) : undefined;
		  }
		  return !!component;
		}
		
		function legacySetStateEtc() {
		  if (process.env.NODE_ENV !== 'production') {
		    var component = this._reactInternalComponent;
		    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setState(), .replaceState(), or ' + '.forceUpdate() of a DOM node. This is a no-op.%s', getDeclarationErrorAddendum(component)) : undefined;
		  }
		}
		
		function legacySetProps(partialProps, callback) {
		  var component = this._reactInternalComponent;
		  if (process.env.NODE_ENV !== 'production') {
		    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
		  }
		  if (!component) {
		    return;
		  }
		  ReactUpdateQueue.enqueueSetPropsInternal(component, partialProps);
		  if (callback) {
		    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
		  }
		}
		
		function legacyReplaceProps(partialProps, callback) {
		  var component = this._reactInternalComponent;
		  if (process.env.NODE_ENV !== 'production') {
		    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .replaceProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
		  }
		  if (!component) {
		    return;
		  }
		  ReactUpdateQueue.enqueueReplacePropsInternal(component, partialProps);
		  if (callback) {
		    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
		  }
		}
		
		function friendlyStringify(obj) {
		  if (typeof obj === 'object') {
		    if (Array.isArray(obj)) {
		      return '[' + obj.map(friendlyStringify).join(', ') + ']';
		    } else {
		      var pairs = [];
		      for (var key in obj) {
		        if (Object.prototype.hasOwnProperty.call(obj, key)) {
		          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
		          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
		        }
		      }
		      return '{' + pairs.join(', ') + '}';
		    }
		  } else if (typeof obj === 'string') {
		    return JSON.stringify(obj);
		  } else if (typeof obj === 'function') {
		    return '[function object]';
		  }
		  // Differs from JSON.stringify in that undefined becauses undefined and that
		  // inf and nan don't become null
		  return String(obj);
		}
		
		var styleMutationWarning = {};
		
		function checkAndWarnForMutatedStyle(style1, style2, component) {
		  if (style1 == null || style2 == null) {
		    return;
		  }
		  if (shallowEqual(style1, style2)) {
		    return;
		  }
		
		  var componentName = component._tag;
		  var owner = component._currentElement._owner;
		  var ownerName;
		  if (owner) {
		    ownerName = owner.getName();
		  }
		
		  var hash = ownerName + '|' + componentName;
		
		  if (styleMutationWarning.hasOwnProperty(hash)) {
		    return;
		  }
		
		  styleMutationWarning[hash] = true;
		
		  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : undefined;
		}
		
		/**
		 * @param {object} component
		 * @param {?object} props
		 */
		function assertValidProps(component, props) {
		  if (!props) {
		    return;
		  }
		  // Note the use of `==` which checks for null or undefined.
		  if (process.env.NODE_ENV !== 'production') {
		    if (voidElementTags[component._tag]) {
		      process.env.NODE_ENV !== 'production' ? warning(props.children == null && props.dangerouslySetInnerHTML == null, '%s is a void element tag and must not have `children` or ' + 'use `props.dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : undefined;
		    }
		  }
		  if (props.dangerouslySetInnerHTML != null) {
		    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(false) : undefined;
		    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' + 'for more information.') : invariant(false) : undefined;
		  }
		  if (process.env.NODE_ENV !== 'production') {
		    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : undefined;
		    process.env.NODE_ENV !== 'production' ? warning(!props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : undefined;
		  }
		  !(props.style == null || typeof props.style === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, ' + 'not a string. For example, style={{marginRight: spacing + \'em\'}} when ' + 'using JSX.%s', getDeclarationErrorAddendum(component)) : invariant(false) : undefined;
		}
		
		function enqueuePutListener(id, registrationName, listener, transaction) {
		  if (process.env.NODE_ENV !== 'production') {
		    // IE8 has no API for event capturing and the `onScroll` event doesn't
		    // bubble.
		    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : undefined;
		  }
		  var container = ReactMount.findReactContainerForID(id);
		  if (container) {
		    var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
		    listenTo(registrationName, doc);
		  }
		  transaction.getReactMountReady().enqueue(putListener, {
		    id: id,
		    registrationName: registrationName,
		    listener: listener
		  });
		}
		
		function putListener() {
		  var listenerToPut = this;
		  ReactBrowserEventEmitter.putListener(listenerToPut.id, listenerToPut.registrationName, listenerToPut.listener);
		}
		
		// There are so many media events, it makes sense to just
		// maintain a list rather than create a `trapBubbledEvent` for each
		var mediaEvents = {
		  topAbort: 'abort',
		  topCanPlay: 'canplay',
		  topCanPlayThrough: 'canplaythrough',
		  topDurationChange: 'durationchange',
		  topEmptied: 'emptied',
		  topEncrypted: 'encrypted',
		  topEnded: 'ended',
		  topError: 'error',
		  topLoadedData: 'loadeddata',
		  topLoadedMetadata: 'loadedmetadata',
		  topLoadStart: 'loadstart',
		  topPause: 'pause',
		  topPlay: 'play',
		  topPlaying: 'playing',
		  topProgress: 'progress',
		  topRateChange: 'ratechange',
		  topSeeked: 'seeked',
		  topSeeking: 'seeking',
		  topStalled: 'stalled',
		  topSuspend: 'suspend',
		  topTimeUpdate: 'timeupdate',
		  topVolumeChange: 'volumechange',
		  topWaiting: 'waiting'
		};
		
		function trapBubbledEventsLocal() {
		  var inst = this;
		  // If a component renders to null or if another component fatals and causes
		  // the state of the tree to be corrupted, `node` here can be null.
		  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : invariant(false) : undefined;
		  var node = ReactMount.getNode(inst._rootNodeID);
		  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : invariant(false) : undefined;
		
		  switch (inst._tag) {
		    case 'iframe':
		      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
		      break;
		    case 'video':
		    case 'audio':
		
		      inst._wrapperState.listeners = [];
		      // create listener for each media event
		      for (var event in mediaEvents) {
		        if (mediaEvents.hasOwnProperty(event)) {
		          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
		        }
		      }
		
		      break;
		    case 'img':
		      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
		      break;
		    case 'form':
		      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
		      break;
		  }
		}
		
		function mountReadyInputWrapper() {
		  ReactDOMInput.mountReadyWrapper(this);
		}
		
		function postUpdateSelectWrapper() {
		  ReactDOMSelect.postUpdateWrapper(this);
		}
		
		// For HTML, certain tags should omit their close tag. We keep a whitelist for
		// those special cased tags.
		
		var omittedCloseTags = {
		  'area': true,
		  'base': true,
		  'br': true,
		  'col': true,
		  'embed': true,
		  'hr': true,
		  'img': true,
		  'input': true,
		  'keygen': true,
		  'link': true,
		  'meta': true,
		  'param': true,
		  'source': true,
		  'track': true,
		  'wbr': true
		};
		
		// NOTE: menuitem's close tag should be omitted, but that causes problems.
		var newlineEatingTags = {
		  'listing': true,
		  'pre': true,
		  'textarea': true
		};
		
		// For HTML, certain tags cannot have children. This has the same purpose as
		// `omittedCloseTags` except that `menuitem` should still have its closing tag.
		
		var voidElementTags = assign({
		  'menuitem': true
		}, omittedCloseTags);
		
		// We accept any tag to be rendered but since this gets injected into arbitrary
		// HTML, we want to make sure that it's a safe tag.
		// http://www.w3.org/TR/REC-xml/#NT-Name
		
		var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
		var validatedTagCache = {};
		var hasOwnProperty = ({}).hasOwnProperty;
		
		function validateDangerousTag(tag) {
		  if (!hasOwnProperty.call(validatedTagCache, tag)) {
		    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : invariant(false) : undefined;
		    validatedTagCache[tag] = true;
		  }
		}
		
		function processChildContextDev(context, inst) {
		  // Pass down our tag name to child components for validation purposes
		  context = assign({}, context);
		  var info = context[validateDOMNesting.ancestorInfoContextKey];
		  context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(info, inst._tag, inst);
		  return context;
		}
		
		function isCustomComponent(tagName, props) {
		  return tagName.indexOf('-') >= 0 || props.is != null;
		}
		
		/**
		 * Creates a new React class that is idempotent and capable of containing other
		 * React components. It accepts event listeners and DOM properties that are
		 * valid according to `DOMProperty`.
		 *
		 *  - Event listeners: `onClick`, `onMouseDown`, etc.
		 *  - DOM properties: `className`, `name`, `title`, etc.
		 *
		 * The `style` property functions differently from the DOM API. It accepts an
		 * object mapping of style properties to values.
		 *
		 * @constructor ReactDOMComponent
		 * @extends ReactMultiChild
		 */
		function ReactDOMComponent(tag) {
		  validateDangerousTag(tag);
		  this._tag = tag.toLowerCase();
		  this._renderedChildren = null;
		  this._previousStyle = null;
		  this._previousStyleCopy = null;
		  this._rootNodeID = null;
		  this._wrapperState = null;
		  this._topLevelWrapper = null;
		  this._nodeWithLegacyProperties = null;
		  if (process.env.NODE_ENV !== 'production') {
		    this._unprocessedContextDev = null;
		    this._processedContextDev = null;
		  }
		}
		
		ReactDOMComponent.displayName = 'ReactDOMComponent';
		
		ReactDOMComponent.Mixin = {
		
		  construct: function (element) {
		    this._currentElement = element;
		  },
		
		  /**
		   * Generates root tag markup then recurses. This method has side effects and
		   * is not idempotent.
		   *
		   * @internal
		   * @param {string} rootID The root DOM ID for this node.
		   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
		   * @param {object} context
		   * @return {string} The computed markup.
		   */
		  mountComponent: function (rootID, transaction, context) {
		    this._rootNodeID = rootID;
		
		    var props = this._currentElement.props;
		
		    switch (this._tag) {
		      case 'iframe':
		      case 'img':
		      case 'form':
		      case 'video':
		      case 'audio':
		        this._wrapperState = {
		          listeners: null
		        };
		        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
		        break;
		      case 'button':
		        props = ReactDOMButton.getNativeProps(this, props, context);
		        break;
		      case 'input':
		        ReactDOMInput.mountWrapper(this, props, context);
		        props = ReactDOMInput.getNativeProps(this, props, context);
		        break;
		      case 'option':
		        ReactDOMOption.mountWrapper(this, props, context);
		        props = ReactDOMOption.getNativeProps(this, props, context);
		        break;
		      case 'select':
		        ReactDOMSelect.mountWrapper(this, props, context);
		        props = ReactDOMSelect.getNativeProps(this, props, context);
		        context = ReactDOMSelect.processChildContext(this, props, context);
		        break;
		      case 'textarea':
		        ReactDOMTextarea.mountWrapper(this, props, context);
		        props = ReactDOMTextarea.getNativeProps(this, props, context);
		        break;
		    }
		
		    assertValidProps(this, props);
		    if (process.env.NODE_ENV !== 'production') {
		      if (context[validateDOMNesting.ancestorInfoContextKey]) {
		        validateDOMNesting(this._tag, this, context[validateDOMNesting.ancestorInfoContextKey]);
		      }
		    }
		
		    if (process.env.NODE_ENV !== 'production') {
		      this._unprocessedContextDev = context;
		      this._processedContextDev = processChildContextDev(context, this);
		      context = this._processedContextDev;
		    }
		
		    var mountImage;
		    if (transaction.useCreateElement) {
		      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
		      var el = ownerDocument.createElement(this._currentElement.type);
		      DOMPropertyOperations.setAttributeForID(el, this._rootNodeID);
		      // Populate node cache
		      ReactMount.getID(el);
		      this._updateDOMProperties({}, props, transaction, el);
		      this._createInitialChildren(transaction, props, context, el);
		      mountImage = el;
		    } else {
		      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
		      var tagContent = this._createContentMarkup(transaction, props, context);
		      if (!tagContent && omittedCloseTags[this._tag]) {
		        mountImage = tagOpen + '/>';
		      } else {
		        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
		      }
		    }
		
		    switch (this._tag) {
		      case 'input':
		        transaction.getReactMountReady().enqueue(mountReadyInputWrapper, this);
		      // falls through
		      case 'button':
		      case 'select':
		      case 'textarea':
		        if (props.autoFocus) {
		          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
		        }
		        break;
		    }
		
		    return mountImage;
		  },
		
		  /**
		   * Creates markup for the open tag and all attributes.
		   *
		   * This method has side effects because events get registered.
		   *
		   * Iterating over object properties is faster than iterating over arrays.
		   * @see http://jsperf.com/obj-vs-arr-iteration
		   *
		   * @private
		   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
		   * @param {object} props
		   * @return {string} Markup of opening tag.
		   */
		  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
		    var ret = '<' + this._currentElement.type;
		
		    for (var propKey in props) {
		      if (!props.hasOwnProperty(propKey)) {
		        continue;
		      }
		      var propValue = props[propKey];
		      if (propValue == null) {
		        continue;
		      }
		      if (registrationNameModules.hasOwnProperty(propKey)) {
		        if (propValue) {
		          enqueuePutListener(this._rootNodeID, propKey, propValue, transaction);
		        }
		      } else {
		        if (propKey === STYLE) {
		          if (propValue) {
		            if (process.env.NODE_ENV !== 'production') {
		              // See `_updateDOMProperties`. style block
		              this._previousStyle = propValue;
		            }
		            propValue = this._previousStyleCopy = assign({}, props.style);
		          }
		          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
		        }
		        var markup = null;
		        if (this._tag != null && isCustomComponent(this._tag, props)) {
		          if (propKey !== CHILDREN) {
		            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
		          }
		        } else {
		          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
		        }
		        if (markup) {
		          ret += ' ' + markup;
		        }
		      }
		    }
		
		    // For static pages, no need to put React ID and checksum. Saves lots of
		    // bytes.
		    if (transaction.renderToStaticMarkup) {
		      return ret;
		    }
		
		    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
		    return ret + ' ' + markupForID;
		  },
		
		  /**
		   * Creates markup for the content between the tags.
		   *
		   * @private
		   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
		   * @param {object} props
		   * @param {object} context
		   * @return {string} Content markup.
		   */
		  _createContentMarkup: function (transaction, props, context) {
		    var ret = '';
		
		    // Intentional use of != to avoid catching zero/false.
		    var innerHTML = props.dangerouslySetInnerHTML;
		    if (innerHTML != null) {
		      if (innerHTML.__html != null) {
		        ret = innerHTML.__html;
		      }
		    } else {
		      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
		      var childrenToUse = contentToUse != null ? null : props.children;
		      if (contentToUse != null) {
		        // TODO: Validate that text is allowed as a child of this node
		        ret = escapeTextContentForBrowser(contentToUse);
		      } else if (childrenToUse != null) {
		        var mountImages = this.mountChildren(childrenToUse, transaction, context);
		        ret = mountImages.join('');
		      }
		    }
		    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
		      // text/html ignores the first character in these tags if it's a newline
		      // Prefer to break application/xml over text/html (for now) by adding
		      // a newline specifically to get eaten by the parser. (Alternately for
		      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
		      // \r is normalized out by HTMLTextAreaElement#value.)
		      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
		      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
		      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
		      // See: Parsing of "textarea" "listing" and "pre" elements
		      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
		      return '\n' + ret;
		    } else {
		      return ret;
		    }
		  },
		
		  _createInitialChildren: function (transaction, props, context, el) {
		    // Intentional use of != to avoid catching zero/false.
		    var innerHTML = props.dangerouslySetInnerHTML;
		    if (innerHTML != null) {
		      if (innerHTML.__html != null) {
		        setInnerHTML(el, innerHTML.__html);
		      }
		    } else {
		      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
		      var childrenToUse = contentToUse != null ? null : props.children;
		      if (contentToUse != null) {
		        // TODO: Validate that text is allowed as a child of this node
		        setTextContent(el, contentToUse);
		      } else if (childrenToUse != null) {
		        var mountImages = this.mountChildren(childrenToUse, transaction, context);
		        for (var i = 0; i < mountImages.length; i++) {
		          el.appendChild(mountImages[i]);
		        }
		      }
		    }
		  },
		
		  /**
		   * Receives a next element and updates the component.
		   *
		   * @internal
		   * @param {ReactElement} nextElement
		   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
		   * @param {object} context
		   */
		  receiveComponent: function (nextElement, transaction, context) {
		    var prevElement = this._currentElement;
		    this._currentElement = nextElement;
		    this.updateComponent(transaction, prevElement, nextElement, context);
		  },
		
		  /**
		   * Updates a native DOM component after it has already been allocated and
		   * attached to the DOM. Reconciles the root DOM node, then recurses.
		   *
		   * @param {ReactReconcileTransaction} transaction
		   * @param {ReactElement} prevElement
		   * @param {ReactElement} nextElement
		   * @internal
		   * @overridable
		   */
		  updateComponent: function (transaction, prevElement, nextElement, context) {
		    var lastProps = prevElement.props;
		    var nextProps = this._currentElement.props;
		
		    switch (this._tag) {
		      case 'button':
		        lastProps = ReactDOMButton.getNativeProps(this, lastProps);
		        nextProps = ReactDOMButton.getNativeProps(this, nextProps);
		        break;
		      case 'input':
		        ReactDOMInput.updateWrapper(this);
		        lastProps = ReactDOMInput.getNativeProps(this, lastProps);
		        nextProps = ReactDOMInput.getNativeProps(this, nextProps);
		        break;
		      case 'option':
		        lastProps = ReactDOMOption.getNativeProps(this, lastProps);
		        nextProps = ReactDOMOption.getNativeProps(this, nextProps);
		        break;
		      case 'select':
		        lastProps = ReactDOMSelect.getNativeProps(this, lastProps);
		        nextProps = ReactDOMSelect.getNativeProps(this, nextProps);
		        break;
		      case 'textarea':
		        ReactDOMTextarea.updateWrapper(this);
		        lastProps = ReactDOMTextarea.getNativeProps(this, lastProps);
		        nextProps = ReactDOMTextarea.getNativeProps(this, nextProps);
		        break;
		    }
		
		    if (process.env.NODE_ENV !== 'production') {
		      // If the context is reference-equal to the old one, pass down the same
		      // processed object so the update bailout in ReactReconciler behaves
		      // correctly (and identically in dev and prod). See #5005.
		      if (this._unprocessedContextDev !== context) {
		        this._unprocessedContextDev = context;
		        this._processedContextDev = processChildContextDev(context, this);
		      }
		      context = this._processedContextDev;
		    }
		
		    assertValidProps(this, nextProps);
		    this._updateDOMProperties(lastProps, nextProps, transaction, null);
		    this._updateDOMChildren(lastProps, nextProps, transaction, context);
		
		    if (!canDefineProperty && this._nodeWithLegacyProperties) {
		      this._nodeWithLegacyProperties.props = nextProps;
		    }
		
		    if (this._tag === 'select') {
		      // <select> value update needs to occur after <option> children
		      // reconciliation
		      transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
		    }
		  },
		
		  /**
		   * Reconciles the properties by detecting differences in property values and
		   * updating the DOM as necessary. This function is probably the single most
		   * critical path for performance optimization.
		   *
		   * TODO: Benchmark whether checking for changed values in memory actually
		   *       improves performance (especially statically positioned elements).
		   * TODO: Benchmark the effects of putting this at the top since 99% of props
		   *       do not change for a given reconciliation.
		   * TODO: Benchmark areas that can be improved with caching.
		   *
		   * @private
		   * @param {object} lastProps
		   * @param {object} nextProps
		   * @param {ReactReconcileTransaction} transaction
		   * @param {?DOMElement} node
		   */
		  _updateDOMProperties: function (lastProps, nextProps, transaction, node) {
		    var propKey;
		    var styleName;
		    var styleUpdates;
		    for (propKey in lastProps) {
		      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
		        continue;
		      }
		      if (propKey === STYLE) {
		        var lastStyle = this._previousStyleCopy;
		        for (styleName in lastStyle) {
		          if (lastStyle.hasOwnProperty(styleName)) {
		            styleUpdates = styleUpdates || {};
		            styleUpdates[styleName] = '';
		          }
		        }
		        this._previousStyleCopy = null;
		      } else if (registrationNameModules.hasOwnProperty(propKey)) {
		        if (lastProps[propKey]) {
		          // Only call deleteListener if there was a listener previously or
		          // else willDeleteListener gets called when there wasn't actually a
		          // listener (e.g., onClick={null})
		          deleteListener(this._rootNodeID, propKey);
		        }
		      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
		        if (!node) {
		          node = ReactMount.getNode(this._rootNodeID);
		        }
		        DOMPropertyOperations.deleteValueForProperty(node, propKey);
		      }
		    }
		    for (propKey in nextProps) {
		      var nextProp = nextProps[propKey];
		      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];
		      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
		        continue;
		      }
		      if (propKey === STYLE) {
		        if (nextProp) {
		          if (process.env.NODE_ENV !== 'production') {
		            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
		            this._previousStyle = nextProp;
		          }
		          nextProp = this._previousStyleCopy = assign({}, nextProp);
		        } else {
		          this._previousStyleCopy = null;
		        }
		        if (lastProp) {
		          // Unset styles on `lastProp` but not on `nextProp`.
		          for (styleName in lastProp) {
		            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
		              styleUpdates = styleUpdates || {};
		              styleUpdates[styleName] = '';
		            }
		          }
		          // Update styles that changed since `lastProp`.
		          for (styleName in nextProp) {
		            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
		              styleUpdates = styleUpdates || {};
		              styleUpdates[styleName] = nextProp[styleName];
		            }
		          }
		        } else {
		          // Relies on `updateStylesByID` not mutating `styleUpdates`.
		          styleUpdates = nextProp;
		        }
		      } else if (registrationNameModules.hasOwnProperty(propKey)) {
		        if (nextProp) {
		          enqueuePutListener(this._rootNodeID, propKey, nextProp, transaction);
		        } else if (lastProp) {
		          deleteListener(this._rootNodeID, propKey);
		        }
		      } else if (isCustomComponent(this._tag, nextProps)) {
		        if (!node) {
		          node = ReactMount.getNode(this._rootNodeID);
		        }
		        if (propKey === CHILDREN) {
		          nextProp = null;
		        }
		        DOMPropertyOperations.setValueForAttribute(node, propKey, nextProp);
		      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
		        if (!node) {
		          node = ReactMount.getNode(this._rootNodeID);
		        }
		        // If we're updating to null or undefined, we should remove the property
		        // from the DOM node instead of inadvertantly setting to a string. This
		        // brings us in line with the same behavior we have on initial render.
		        if (nextProp != null) {
		          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
		        } else {
		          DOMPropertyOperations.deleteValueForProperty(node, propKey);
		        }
		      }
		    }
		    if (styleUpdates) {
		      if (!node) {
		        node = ReactMount.getNode(this._rootNodeID);
		      }
		      CSSPropertyOperations.setValueForStyles(node, styleUpdates);
		    }
		  },
		
		  /**
		   * Reconciles the children with the various properties that affect the
		   * children content.
		   *
		   * @param {object} lastProps
		   * @param {object} nextProps
		   * @param {ReactReconcileTransaction} transaction
		   * @param {object} context
		   */
		  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
		    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
		    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
		
		    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
		    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
		
		    // Note the use of `!=` which checks for null or undefined.
		    var lastChildren = lastContent != null ? null : lastProps.children;
		    var nextChildren = nextContent != null ? null : nextProps.children;
		
		    // If we're switching from children to content/html or vice versa, remove
		    // the old content
		    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
		    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
		    if (lastChildren != null && nextChildren == null) {
		      this.updateChildren(null, transaction, context);
		    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
		      this.updateTextContent('');
		    }
		
		    if (nextContent != null) {
		      if (lastContent !== nextContent) {
		        this.updateTextContent('' + nextContent);
		      }
		    } else if (nextHtml != null) {
		      if (lastHtml !== nextHtml) {
		        this.updateMarkup('' + nextHtml);
		      }
		    } else if (nextChildren != null) {
		      this.updateChildren(nextChildren, transaction, context);
		    }
		  },
		
		  /**
		   * Destroys all event registrations for this instance. Does not remove from
		   * the DOM. That must be done by the parent.
		   *
		   * @internal
		   */
		  unmountComponent: function () {
		    switch (this._tag) {
		      case 'iframe':
		      case 'img':
		      case 'form':
		      case 'video':
		      case 'audio':
		        var listeners = this._wrapperState.listeners;
		        if (listeners) {
		          for (var i = 0; i < listeners.length; i++) {
		            listeners[i].remove();
		          }
		        }
		        break;
		      case 'input':
		        ReactDOMInput.unmountWrapper(this);
		        break;
		      case 'html':
		      case 'head':
		      case 'body':
		        /**
		         * Components like <html> <head> and <body> can't be removed or added
		         * easily in a cross-browser way, however it's valuable to be able to
		         * take advantage of React's reconciliation for styling and <title>
		         * management. So we just document it and throw in dangerous cases.
		         */
		         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, ' + '<head>, and <body>) reliably and efficiently. To fix this, have a ' + 'single top-level component that never unmounts render these ' + 'elements.', this._tag) : invariant(false) : undefined;
		        break;
		    }
		
		    this.unmountChildren();
		    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
		    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
		    this._rootNodeID = null;
		    this._wrapperState = null;
		    if (this._nodeWithLegacyProperties) {
		      var node = this._nodeWithLegacyProperties;
		      node._reactInternalComponent = null;
		      this._nodeWithLegacyProperties = null;
		    }
		  },
		
		  getPublicInstance: function () {
		    if (!this._nodeWithLegacyProperties) {
		      var node = ReactMount.getNode(this._rootNodeID);
		
		      node._reactInternalComponent = this;
		      node.getDOMNode = legacyGetDOMNode;
		      node.isMounted = legacyIsMounted;
		      node.setState = legacySetStateEtc;
		      node.replaceState = legacySetStateEtc;
		      node.forceUpdate = legacySetStateEtc;
		      node.setProps = legacySetProps;
		      node.replaceProps = legacyReplaceProps;
		
		      if (process.env.NODE_ENV !== 'production') {
		        if (canDefineProperty) {
		          Object.defineProperties(node, legacyPropsDescriptor);
		        } else {
		          // updateComponent will update this property on subsequent renders
		          node.props = this._currentElement.props;
		        }
		      } else {
		        // updateComponent will update this property on subsequent renders
		        node.props = this._currentElement.props;
		      }
		
		      this._nodeWithLegacyProperties = node;
		    }
		    return this._nodeWithLegacyProperties;
		  }
		
		};
		
		ReactPerf.measureMethods(ReactDOMComponent, 'ReactDOMComponent', {
		  mountComponent: 'mountComponent',
		  updateComponent: 'updateComponent'
		});
		
		assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
		
		module.exports = ReactDOMComponent;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 94 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule AutoFocusUtils
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var ReactMount = __webpack_require__(28);
		
		var findDOMNode = __webpack_require__(91);
		var focusNode = __webpack_require__(95);
		
		var Mixin = {
		  componentDidMount: function () {
		    if (this.props.autoFocus) {
		      focusNode(findDOMNode(this));
		    }
		  }
		};
		
		var AutoFocusUtils = {
		  Mixin: Mixin,
		
		  focusDOMComponent: function () {
		    focusNode(ReactMount.getNode(this._rootNodeID));
		  }
		};
		
		module.exports = AutoFocusUtils;
	
	/***/ },
	/* 95 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule focusNode
		 */
		
		'use strict';
		
		/**
		 * @param {DOMElement} node input/textarea to focus
		 */
		function focusNode(node) {
		  // IE8 can throw "Can't move focus to the control because it is invisible,
		  // not enabled, or of a type that does not accept the focus." for all kinds of
		  // reasons that are too expensive and fragile to test.
		  try {
		    node.focus();
		  } catch (e) {}
		}
		
		module.exports = focusNode;
	
	/***/ },
	/* 96 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule CSSPropertyOperations
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var CSSProperty = __webpack_require__(97);
		var ExecutionEnvironment = __webpack_require__(9);
		var ReactPerf = __webpack_require__(18);
		
		var camelizeStyleName = __webpack_require__(98);
		var dangerousStyleValue = __webpack_require__(100);
		var hyphenateStyleName = __webpack_require__(101);
		var memoizeStringOnly = __webpack_require__(103);
		var warning = __webpack_require__(25);
		
		var processStyleName = memoizeStringOnly(function (styleName) {
		  return hyphenateStyleName(styleName);
		});
		
		var hasShorthandPropertyBug = false;
		var styleFloatAccessor = 'cssFloat';
		if (ExecutionEnvironment.canUseDOM) {
		  var tempStyle = document.createElement('div').style;
		  try {
		    // IE8 throws "Invalid argument." if resetting shorthand style properties.
		    tempStyle.font = '';
		  } catch (e) {
		    hasShorthandPropertyBug = true;
		  }
		  // IE8 only supports accessing cssFloat (standard) as styleFloat
		  if (document.documentElement.style.cssFloat === undefined) {
		    styleFloatAccessor = 'styleFloat';
		  }
		}
		
		if (process.env.NODE_ENV !== 'production') {
		  // 'msTransform' is correct, but the other prefixes should be capitalized
		  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
		
		  // style values shouldn't contain a semicolon
		  var badStyleValueWithSemicolonPattern = /;\s*$/;
		
		  var warnedStyleNames = {};
		  var warnedStyleValues = {};
		
		  var warnHyphenatedStyleName = function (name) {
		    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
		      return;
		    }
		
		    warnedStyleNames[name] = true;
		    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?', name, camelizeStyleName(name)) : undefined;
		  };
		
		  var warnBadVendoredStyleName = function (name) {
		    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
		      return;
		    }
		
		    warnedStyleNames[name] = true;
		    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1)) : undefined;
		  };
		
		  var warnStyleValueWithSemicolon = function (name, value) {
		    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
		      return;
		    }
		
		    warnedStyleValues[value] = true;
		    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon. ' + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, '')) : undefined;
		  };
		
		  /**
		   * @param {string} name
		   * @param {*} value
		   */
		  var warnValidStyle = function (name, value) {
		    if (name.indexOf('-') > -1) {
		      warnHyphenatedStyleName(name);
		    } else if (badVendoredStyleNamePattern.test(name)) {
		      warnBadVendoredStyleName(name);
		    } else if (badStyleValueWithSemicolonPattern.test(value)) {
		      warnStyleValueWithSemicolon(name, value);
		    }
		  };
		}
		
		/**
		 * Operations for dealing with CSS properties.
		 */
		var CSSPropertyOperations = {
		
		  /**
		   * Serializes a mapping of style properties for use as inline styles:
		   *
		   *   > createMarkupForStyles({width: '200px', height: 0})
		   *   "width:200px;height:0;"
		   *
		   * Undefined values are ignored so that declarative programming is easier.
		   * The result should be HTML-escaped before insertion into the DOM.
		   *
		   * @param {object} styles
		   * @return {?string}
		   */
		  createMarkupForStyles: function (styles) {
		    var serialized = '';
		    for (var styleName in styles) {
		      if (!styles.hasOwnProperty(styleName)) {
		        continue;
		      }
		      var styleValue = styles[styleName];
		      if (process.env.NODE_ENV !== 'production') {
		        warnValidStyle(styleName, styleValue);
		      }
		      if (styleValue != null) {
		        serialized += processStyleName(styleName) + ':';
		        serialized += dangerousStyleValue(styleName, styleValue) + ';';
		      }
		    }
		    return serialized || null;
		  },
		
		  /**
		   * Sets the value for multiple styles on a node.  If a value is specified as
		   * '' (empty string), the corresponding style property will be unset.
		   *
		   * @param {DOMElement} node
		   * @param {object} styles
		   */
		  setValueForStyles: function (node, styles) {
		    var style = node.style;
		    for (var styleName in styles) {
		      if (!styles.hasOwnProperty(styleName)) {
		        continue;
		      }
		      if (process.env.NODE_ENV !== 'production') {
		        warnValidStyle(styleName, styles[styleName]);
		      }
		      var styleValue = dangerousStyleValue(styleName, styles[styleName]);
		      if (styleName === 'float') {
		        styleName = styleFloatAccessor;
		      }
		      if (styleValue) {
		        style[styleName] = styleValue;
		      } else {
		        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
		        if (expansion) {
		          // Shorthand property that IE8 won't like unsetting, so unset each
		          // component to placate it
		          for (var individualStyleName in expansion) {
		            style[individualStyleName] = '';
		          }
		        } else {
		          style[styleName] = '';
		        }
		      }
		    }
		  }
		
		};
		
		ReactPerf.measureMethods(CSSPropertyOperations, 'CSSPropertyOperations', {
		  setValueForStyles: 'setValueForStyles'
		});
		
		module.exports = CSSPropertyOperations;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 97 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule CSSProperty
		 */
		
		'use strict';
		
		/**
		 * CSS properties which accept numbers but are not in units of "px".
		 */
		var isUnitlessNumber = {
		  animationIterationCount: true,
		  boxFlex: true,
		  boxFlexGroup: true,
		  boxOrdinalGroup: true,
		  columnCount: true,
		  flex: true,
		  flexGrow: true,
		  flexPositive: true,
		  flexShrink: true,
		  flexNegative: true,
		  flexOrder: true,
		  fontWeight: true,
		  lineClamp: true,
		  lineHeight: true,
		  opacity: true,
		  order: true,
		  orphans: true,
		  tabSize: true,
		  widows: true,
		  zIndex: true,
		  zoom: true,
		
		  // SVG-related properties
		  fillOpacity: true,
		  stopOpacity: true,
		  strokeDashoffset: true,
		  strokeOpacity: true,
		  strokeWidth: true
		};
		
		/**
		 * @param {string} prefix vendor-specific prefix, eg: Webkit
		 * @param {string} key style name, eg: transitionDuration
		 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
		 * WebkitTransitionDuration
		 */
		function prefixKey(prefix, key) {
		  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
		}
		
		/**
		 * Support style names that may come passed in prefixed by adding permutations
		 * of vendor prefixes.
		 */
		var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
		
		// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
		// infinite loop, because it iterates over the newly added props too.
		Object.keys(isUnitlessNumber).forEach(function (prop) {
		  prefixes.forEach(function (prefix) {
		    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
		  });
		});
		
		/**
		 * Most style properties can be unset by doing .style[prop] = '' but IE8
		 * doesn't like doing that with shorthand properties so for the properties that
		 * IE8 breaks on, which are listed here, we instead unset each of the
		 * individual properties. See http://bugs.jquery.com/ticket/12385.
		 * The 4-value 'clock' properties like margin, padding, border-width seem to
		 * behave without any problems. Curiously, list-style works too without any
		 * special prodding.
		 */
		var shorthandPropertyExpansions = {
		  background: {
		    backgroundAttachment: true,
		    backgroundColor: true,
		    backgroundImage: true,
		    backgroundPositionX: true,
		    backgroundPositionY: true,
		    backgroundRepeat: true
		  },
		  backgroundPosition: {
		    backgroundPositionX: true,
		    backgroundPositionY: true
		  },
		  border: {
		    borderWidth: true,
		    borderStyle: true,
		    borderColor: true
		  },
		  borderBottom: {
		    borderBottomWidth: true,
		    borderBottomStyle: true,
		    borderBottomColor: true
		  },
		  borderLeft: {
		    borderLeftWidth: true,
		    borderLeftStyle: true,
		    borderLeftColor: true
		  },
		  borderRight: {
		    borderRightWidth: true,
		    borderRightStyle: true,
		    borderRightColor: true
		  },
		  borderTop: {
		    borderTopWidth: true,
		    borderTopStyle: true,
		    borderTopColor: true
		  },
		  font: {
		    fontStyle: true,
		    fontVariant: true,
		    fontWeight: true,
		    fontSize: true,
		    lineHeight: true,
		    fontFamily: true
		  },
		  outline: {
		    outlineWidth: true,
		    outlineStyle: true,
		    outlineColor: true
		  }
		};
		
		var CSSProperty = {
		  isUnitlessNumber: isUnitlessNumber,
		  shorthandPropertyExpansions: shorthandPropertyExpansions
		};
		
		module.exports = CSSProperty;
	
	/***/ },
	/* 98 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule camelizeStyleName
		 * @typechecks
		 */
		
		'use strict';
		
		var camelize = __webpack_require__(99);
		
		var msPattern = /^-ms-/;
		
		/**
		 * Camelcases a hyphenated CSS property name, for example:
		 *
		 *   > camelizeStyleName('background-color')
		 *   < "backgroundColor"
		 *   > camelizeStyleName('-moz-transition')
		 *   < "MozTransition"
		 *   > camelizeStyleName('-ms-transition')
		 *   < "msTransition"
		 *
		 * As Andi Smith suggests
		 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
		 * is converted to lowercase `ms`.
		 *
		 * @param {string} string
		 * @return {string}
		 */
		function camelizeStyleName(string) {
		  return camelize(string.replace(msPattern, 'ms-'));
		}
		
		module.exports = camelizeStyleName;
	
	/***/ },
	/* 99 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule camelize
		 * @typechecks
		 */
		
		"use strict";
		
		var _hyphenPattern = /-(.)/g;
		
		/**
		 * Camelcases a hyphenated string, for example:
		 *
		 *   > camelize('background-color')
		 *   < "backgroundColor"
		 *
		 * @param {string} string
		 * @return {string}
		 */
		function camelize(string) {
		  return string.replace(_hyphenPattern, function (_, character) {
		    return character.toUpperCase();
		  });
		}
		
		module.exports = camelize;
	
	/***/ },
	/* 100 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule dangerousStyleValue
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var CSSProperty = __webpack_require__(97);
		
		var isUnitlessNumber = CSSProperty.isUnitlessNumber;
		
		/**
		 * Convert a value into the proper css writable value. The style name `name`
		 * should be logical (no hyphens), as specified
		 * in `CSSProperty.isUnitlessNumber`.
		 *
		 * @param {string} name CSS property name such as `topMargin`.
		 * @param {*} value CSS property value such as `10px`.
		 * @return {string} Normalized style value with dimensions applied.
		 */
		function dangerousStyleValue(name, value) {
		  // Note that we've removed escapeTextForBrowser() calls here since the
		  // whole string will be escaped when the attribute is injected into
		  // the markup. If you provide unsafe user data here they can inject
		  // arbitrary CSS which may be problematic (I couldn't repro this):
		  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
		  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
		  // This is not an XSS hole but instead a potential CSS injection issue
		  // which has lead to a greater discussion about how we're going to
		  // trust URLs moving forward. See #2115901
		
		  var isEmpty = value == null || typeof value === 'boolean' || value === '';
		  if (isEmpty) {
		    return '';
		  }
		
		  var isNonNumeric = isNaN(value);
		  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
		    return '' + value; // cast to string
		  }
		
		  if (typeof value === 'string') {
		    value = value.trim();
		  }
		  return value + 'px';
		}
		
		module.exports = dangerousStyleValue;
	
	/***/ },
	/* 101 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule hyphenateStyleName
		 * @typechecks
		 */
		
		'use strict';
		
		var hyphenate = __webpack_require__(102);
		
		var msPattern = /^ms-/;
		
		/**
		 * Hyphenates a camelcased CSS property name, for example:
		 *
		 *   > hyphenateStyleName('backgroundColor')
		 *   < "background-color"
		 *   > hyphenateStyleName('MozTransition')
		 *   < "-moz-transition"
		 *   > hyphenateStyleName('msTransition')
		 *   < "-ms-transition"
		 *
		 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
		 * is converted to `-ms-`.
		 *
		 * @param {string} string
		 * @return {string}
		 */
		function hyphenateStyleName(string) {
		  return hyphenate(string).replace(msPattern, '-ms-');
		}
		
		module.exports = hyphenateStyleName;
	
	/***/ },
	/* 102 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule hyphenate
		 * @typechecks
		 */
		
		'use strict';
		
		var _uppercasePattern = /([A-Z])/g;
		
		/**
		 * Hyphenates a camelcased string, for example:
		 *
		 *   > hyphenate('backgroundColor')
		 *   < "background-color"
		 *
		 * For CSS style names, use `hyphenateStyleName` instead which works properly
		 * with all vendor prefixes, including `ms`.
		 *
		 * @param {string} string
		 * @return {string}
		 */
		function hyphenate(string) {
		  return string.replace(_uppercasePattern, '-$1').toLowerCase();
		}
		
		module.exports = hyphenate;
	
	/***/ },
	/* 103 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule memoizeStringOnly
		 * @typechecks static-only
		 */
		
		'use strict';
		
		/**
		 * Memoizes the return value of a function that accepts one string argument.
		 *
		 * @param {function} callback
		 * @return {function}
		 */
		function memoizeStringOnly(callback) {
		  var cache = {};
		  return function (string) {
		    if (!cache.hasOwnProperty(string)) {
		      cache[string] = callback.call(this, string);
		    }
		    return cache[string];
		  };
		}
		
		module.exports = memoizeStringOnly;
	
	/***/ },
	/* 104 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactDOMButton
		 */
		
		'use strict';
		
		var mouseListenerNames = {
		  onClick: true,
		  onDoubleClick: true,
		  onMouseDown: true,
		  onMouseMove: true,
		  onMouseUp: true,
		
		  onClickCapture: true,
		  onDoubleClickCapture: true,
		  onMouseDownCapture: true,
		  onMouseMoveCapture: true,
		  onMouseUpCapture: true
		};
		
		/**
		 * Implements a <button> native component that does not receive mouse events
		 * when `disabled` is set.
		 */
		var ReactDOMButton = {
		  getNativeProps: function (inst, props, context) {
		    if (!props.disabled) {
		      return props;
		    }
		
		    // Copy the props, except the mouse listeners
		    var nativeProps = {};
		    for (var key in props) {
		      if (props.hasOwnProperty(key) && !mouseListenerNames[key]) {
		        nativeProps[key] = props[key];
		      }
		    }
		
		    return nativeProps;
		  }
		};
		
		module.exports = ReactDOMButton;
	
	/***/ },
	/* 105 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactDOMInput
		 */
		
		'use strict';
		
		var ReactDOMIDOperations = __webpack_require__(27);
		var LinkedValueUtils = __webpack_require__(106);
		var ReactMount = __webpack_require__(28);
		var ReactUpdates = __webpack_require__(54);
		
		var assign = __webpack_require__(39);
		var invariant = __webpack_require__(13);
		
		var instancesByReactID = {};
		
		function forceUpdateIfMounted() {
		  if (this._rootNodeID) {
		    // DOM component is still mounted; update
		    ReactDOMInput.updateWrapper(this);
		  }
		}
		
		/**
		 * Implements an <input> native component that allows setting these optional
		 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
		 *
		 * If `checked` or `value` are not supplied (or null/undefined), user actions
		 * that affect the checked state or value will trigger updates to the element.
		 *
		 * If they are supplied (and not null/undefined), the rendered element will not
		 * trigger updates to the element. Instead, the props must change in order for
		 * the rendered element to be updated.
		 *
		 * The rendered element will be initialized as unchecked (or `defaultChecked`)
		 * with an empty value (or `defaultValue`).
		 *
		 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
		 */
		var ReactDOMInput = {
		  getNativeProps: function (inst, props, context) {
		    var value = LinkedValueUtils.getValue(props);
		    var checked = LinkedValueUtils.getChecked(props);
		
		    var nativeProps = assign({}, props, {
		      defaultChecked: undefined,
		      defaultValue: undefined,
		      value: value != null ? value : inst._wrapperState.initialValue,
		      checked: checked != null ? checked : inst._wrapperState.initialChecked,
		      onChange: inst._wrapperState.onChange
		    });
		
		    return nativeProps;
		  },
		
		  mountWrapper: function (inst, props) {
		    if (process.env.NODE_ENV !== 'production') {
		      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
		    }
		
		    var defaultValue = props.defaultValue;
		    inst._wrapperState = {
		      initialChecked: props.defaultChecked || false,
		      initialValue: defaultValue != null ? defaultValue : null,
		      onChange: _handleChange.bind(inst)
		    };
		  },
		
		  mountReadyWrapper: function (inst) {
		    // Can't be in mountWrapper or else server rendering leaks.
		    instancesByReactID[inst._rootNodeID] = inst;
		  },
		
		  unmountWrapper: function (inst) {
		    delete instancesByReactID[inst._rootNodeID];
		  },
		
		  updateWrapper: function (inst) {
		    var props = inst._currentElement.props;
		
		    // TODO: Shouldn't this be getChecked(props)?
		    var checked = props.checked;
		    if (checked != null) {
		      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'checked', checked || false);
		    }
		
		    var value = LinkedValueUtils.getValue(props);
		    if (value != null) {
		      // Cast `value` to a string to ensure the value is set correctly. While
		      // browsers typically do this as necessary, jsdom doesn't.
		      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
		    }
		  }
		};
		
		function _handleChange(event) {
		  var props = this._currentElement.props;
		
		  var returnValue = LinkedValueUtils.executeOnChange(props, event);
		
		  // Here we use asap to wait until all updates have propagated, which
		  // is important when using controlled components within layers:
		  // https://github.com/facebook/react/issues/1698
		  ReactUpdates.asap(forceUpdateIfMounted, this);
		
		  var name = props.name;
		  if (props.type === 'radio' && name != null) {
		    var rootNode = ReactMount.getNode(this._rootNodeID);
		    var queryRoot = rootNode;
		
		    while (queryRoot.parentNode) {
		      queryRoot = queryRoot.parentNode;
		    }
		
		    // If `rootNode.form` was non-null, then we could try `form.elements`,
		    // but that sometimes behaves strangely in IE8. We could also try using
		    // `form.getElementsByName`, but that will only return direct children
		    // and won't include inputs that use the HTML5 `form=` attribute. Since
		    // the input might not even be in a form, let's just use the global
		    // `querySelectorAll` to ensure we don't miss anything.
		    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
		
		    for (var i = 0; i < group.length; i++) {
		      var otherNode = group[i];
		      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
		        continue;
		      }
		      // This will throw if radio buttons rendered by different copies of React
		      // and the same name are rendered into the same form (same as #1939).
		      // That's probably okay; we don't support it just as we don't support
		      // mixing React with non-React.
		      var otherID = ReactMount.getID(otherNode);
		      !otherID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(false) : undefined;
		      var otherInstance = instancesByReactID[otherID];
		      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(false) : undefined;
		      // If this is a controlled radio button group, forcing the input that
		      // was previously checked to update will cause it to be come re-checked
		      // as appropriate.
		      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
		    }
		  }
		
		  return returnValue;
		}
		
		module.exports = ReactDOMInput;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 106 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule LinkedValueUtils
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var ReactPropTypes = __webpack_require__(107);
		var ReactPropTypeLocations = __webpack_require__(65);
		
		var invariant = __webpack_require__(13);
		var warning = __webpack_require__(25);
		
		var hasReadOnlyValue = {
		  'button': true,
		  'checkbox': true,
		  'image': true,
		  'hidden': true,
		  'radio': true,
		  'reset': true,
		  'submit': true
		};
		
		function _assertSingleLink(inputProps) {
		  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(false) : undefined;
		}
		function _assertValueLink(inputProps) {
		  _assertSingleLink(inputProps);
		  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(false) : undefined;
		}
		
		function _assertCheckedLink(inputProps) {
		  _assertSingleLink(inputProps);
		  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(false) : undefined;
		}
		
		var propTypes = {
		  value: function (props, propName, componentName) {
		    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
		      return null;
		    }
		    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
		  },
		  checked: function (props, propName, componentName) {
		    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
		      return null;
		    }
		    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
		  },
		  onChange: ReactPropTypes.func
		};
		
		var loggedTypeFailures = {};
		function getDeclarationErrorAddendum(owner) {
		  if (owner) {
		    var name = owner.getName();
		    if (name) {
		      return ' Check the render method of `' + name + '`.';
		    }
		  }
		  return '';
		}
		
		/**
		 * Provide a linked `value` attribute for controlled forms. You should not use
		 * this outside of the ReactDOM controlled form components.
		 */
		var LinkedValueUtils = {
		  checkPropTypes: function (tagName, props, owner) {
		    for (var propName in propTypes) {
		      if (propTypes.hasOwnProperty(propName)) {
		        var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop);
		      }
		      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
		        // Only monitor this failure once because there tends to be a lot of the
		        // same error.
		        loggedTypeFailures[error.message] = true;
		
		        var addendum = getDeclarationErrorAddendum(owner);
		        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : undefined;
		      }
		    }
		  },
		
		  /**
		   * @param {object} inputProps Props for form component
		   * @return {*} current value of the input either from value prop or link.
		   */
		  getValue: function (inputProps) {
		    if (inputProps.valueLink) {
		      _assertValueLink(inputProps);
		      return inputProps.valueLink.value;
		    }
		    return inputProps.value;
		  },
		
		  /**
		   * @param {object} inputProps Props for form component
		   * @return {*} current checked status of the input either from checked prop
		   *             or link.
		   */
		  getChecked: function (inputProps) {
		    if (inputProps.checkedLink) {
		      _assertCheckedLink(inputProps);
		      return inputProps.checkedLink.value;
		    }
		    return inputProps.checked;
		  },
		
		  /**
		   * @param {object} inputProps Props for form component
		   * @param {SyntheticEvent} event change event to handle
		   */
		  executeOnChange: function (inputProps, event) {
		    if (inputProps.valueLink) {
		      _assertValueLink(inputProps);
		      return inputProps.valueLink.requestChange(event.target.value);
		    } else if (inputProps.checkedLink) {
		      _assertCheckedLink(inputProps);
		      return inputProps.checkedLink.requestChange(event.target.checked);
		    } else if (inputProps.onChange) {
		      return inputProps.onChange.call(undefined, event);
		    }
		  }
		};
		
		module.exports = LinkedValueUtils;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 107 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactPropTypes
		 */
		
		'use strict';
		
		var ReactElement = __webpack_require__(42);
		var ReactPropTypeLocationNames = __webpack_require__(66);
		
		var emptyFunction = __webpack_require__(15);
		var getIteratorFn = __webpack_require__(108);
		
		/**
		 * Collection of methods that allow declaration and validation of props that are
		 * supplied to React components. Example usage:
		 *
		 *   var Props = require('ReactPropTypes');
		 *   var MyArticle = React.createClass({
		 *     propTypes: {
		 *       // An optional string prop named "description".
		 *       description: Props.string,
		 *
		 *       // A required enum prop named "category".
		 *       category: Props.oneOf(['News','Photos']).isRequired,
		 *
		 *       // A prop named "dialog" that requires an instance of Dialog.
		 *       dialog: Props.instanceOf(Dialog).isRequired
		 *     },
		 *     render: function() { ... }
		 *   });
		 *
		 * A more formal specification of how these methods are used:
		 *
		 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
		 *   decl := ReactPropTypes.{type}(.isRequired)?
		 *
		 * Each and every declaration produces a function with the same signature. This
		 * allows the creation of custom validation functions. For example:
		 *
		 *  var MyLink = React.createClass({
		 *    propTypes: {
		 *      // An optional string or URI prop named "href".
		 *      href: function(props, propName, componentName) {
		 *        var propValue = props[propName];
		 *        if (propValue != null && typeof propValue !== 'string' &&
		 *            !(propValue instanceof URI)) {
		 *          return new Error(
		 *            'Expected a string or an URI for ' + propName + ' in ' +
		 *            componentName
		 *          );
		 *        }
		 *      }
		 *    },
		 *    render: function() {...}
		 *  });
		 *
		 * @internal
		 */
		
		var ANONYMOUS = '<<anonymous>>';
		
		var ReactPropTypes = {
		  array: createPrimitiveTypeChecker('array'),
		  bool: createPrimitiveTypeChecker('boolean'),
		  func: createPrimitiveTypeChecker('function'),
		  number: createPrimitiveTypeChecker('number'),
		  object: createPrimitiveTypeChecker('object'),
		  string: createPrimitiveTypeChecker('string'),
		
		  any: createAnyTypeChecker(),
		  arrayOf: createArrayOfTypeChecker,
		  element: createElementTypeChecker(),
		  instanceOf: createInstanceTypeChecker,
		  node: createNodeChecker(),
		  objectOf: createObjectOfTypeChecker,
		  oneOf: createEnumTypeChecker,
		  oneOfType: createUnionTypeChecker,
		  shape: createShapeTypeChecker
		};
		
		function createChainableTypeChecker(validate) {
		  function checkType(isRequired, props, propName, componentName, location, propFullName) {
		    componentName = componentName || ANONYMOUS;
		    propFullName = propFullName || propName;
		    if (props[propName] == null) {
		      var locationName = ReactPropTypeLocationNames[location];
		      if (isRequired) {
		        return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
		      }
		      return null;
		    } else {
		      return validate(props, propName, componentName, location, propFullName);
		    }
		  }
		
		  var chainedCheckType = checkType.bind(null, false);
		  chainedCheckType.isRequired = checkType.bind(null, true);
		
		  return chainedCheckType;
		}
		
		function createPrimitiveTypeChecker(expectedType) {
		  function validate(props, propName, componentName, location, propFullName) {
		    var propValue = props[propName];
		    var propType = getPropType(propValue);
		    if (propType !== expectedType) {
		      var locationName = ReactPropTypeLocationNames[location];
		      // `propValue` being instance of, say, date/regexp, pass the 'object'
		      // check, but we can offer a more precise error message here rather than
		      // 'of type `object`'.
		      var preciseType = getPreciseType(propValue);
		
		      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
		    }
		    return null;
		  }
		  return createChainableTypeChecker(validate);
		}
		
		function createAnyTypeChecker() {
		  return createChainableTypeChecker(emptyFunction.thatReturns(null));
		}
		
		function createArrayOfTypeChecker(typeChecker) {
		  function validate(props, propName, componentName, location, propFullName) {
		    var propValue = props[propName];
		    if (!Array.isArray(propValue)) {
		      var locationName = ReactPropTypeLocationNames[location];
		      var propType = getPropType(propValue);
		      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
		    }
		    for (var i = 0; i < propValue.length; i++) {
		      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']');
		      if (error instanceof Error) {
		        return error;
		      }
		    }
		    return null;
		  }
		  return createChainableTypeChecker(validate);
		}
		
		function createElementTypeChecker() {
		  function validate(props, propName, componentName, location, propFullName) {
		    if (!ReactElement.isValidElement(props[propName])) {
		      var locationName = ReactPropTypeLocationNames[location];
		      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a single ReactElement.'));
		    }
		    return null;
		  }
		  return createChainableTypeChecker(validate);
		}
		
		function createInstanceTypeChecker(expectedClass) {
		  function validate(props, propName, componentName, location, propFullName) {
		    if (!(props[propName] instanceof expectedClass)) {
		      var locationName = ReactPropTypeLocationNames[location];
		      var expectedClassName = expectedClass.name || ANONYMOUS;
		      var actualClassName = getClassName(props[propName]);
		      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
		    }
		    return null;
		  }
		  return createChainableTypeChecker(validate);
		}
		
		function createEnumTypeChecker(expectedValues) {
		  if (!Array.isArray(expectedValues)) {
		    return createChainableTypeChecker(function () {
		      return new Error('Invalid argument supplied to oneOf, expected an instance of array.');
		    });
		  }
		
		  function validate(props, propName, componentName, location, propFullName) {
		    var propValue = props[propName];
		    for (var i = 0; i < expectedValues.length; i++) {
		      if (propValue === expectedValues[i]) {
		        return null;
		      }
		    }
		
		    var locationName = ReactPropTypeLocationNames[location];
		    var valuesString = JSON.stringify(expectedValues);
		    return new Error('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
		  }
		  return createChainableTypeChecker(validate);
		}
		
		function createObjectOfTypeChecker(typeChecker) {
		  function validate(props, propName, componentName, location, propFullName) {
		    var propValue = props[propName];
		    var propType = getPropType(propValue);
		    if (propType !== 'object') {
		      var locationName = ReactPropTypeLocationNames[location];
		      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
		    }
		    for (var key in propValue) {
		      if (propValue.hasOwnProperty(key)) {
		        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key);
		        if (error instanceof Error) {
		          return error;
		        }
		      }
		    }
		    return null;
		  }
		  return createChainableTypeChecker(validate);
		}
		
		function createUnionTypeChecker(arrayOfTypeCheckers) {
		  if (!Array.isArray(arrayOfTypeCheckers)) {
		    return createChainableTypeChecker(function () {
		      return new Error('Invalid argument supplied to oneOfType, expected an instance of array.');
		    });
		  }
		
		  function validate(props, propName, componentName, location, propFullName) {
		    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
		      var checker = arrayOfTypeCheckers[i];
		      if (checker(props, propName, componentName, location, propFullName) == null) {
		        return null;
		      }
		    }
		
		    var locationName = ReactPropTypeLocationNames[location];
		    return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
		  }
		  return createChainableTypeChecker(validate);
		}
		
		function createNodeChecker() {
		  function validate(props, propName, componentName, location, propFullName) {
		    if (!isNode(props[propName])) {
		      var locationName = ReactPropTypeLocationNames[location];
		      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
		    }
		    return null;
		  }
		  return createChainableTypeChecker(validate);
		}
		
		function createShapeTypeChecker(shapeTypes) {
		  function validate(props, propName, componentName, location, propFullName) {
		    var propValue = props[propName];
		    var propType = getPropType(propValue);
		    if (propType !== 'object') {
		      var locationName = ReactPropTypeLocationNames[location];
		      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
		    }
		    for (var key in shapeTypes) {
		      var checker = shapeTypes[key];
		      if (!checker) {
		        continue;
		      }
		      var error = checker(propValue, key, componentName, location, propFullName + '.' + key);
		      if (error) {
		        return error;
		      }
		    }
		    return null;
		  }
		  return createChainableTypeChecker(validate);
		}
		
		function isNode(propValue) {
		  switch (typeof propValue) {
		    case 'number':
		    case 'string':
		    case 'undefined':
		      return true;
		    case 'boolean':
		      return !propValue;
		    case 'object':
		      if (Array.isArray(propValue)) {
		        return propValue.every(isNode);
		      }
		      if (propValue === null || ReactElement.isValidElement(propValue)) {
		        return true;
		      }
		
		      var iteratorFn = getIteratorFn(propValue);
		      if (iteratorFn) {
		        var iterator = iteratorFn.call(propValue);
		        var step;
		        if (iteratorFn !== propValue.entries) {
		          while (!(step = iterator.next()).done) {
		            if (!isNode(step.value)) {
		              return false;
		            }
		          }
		        } else {
		          // Iterator will provide entry [k,v] tuples rather than values.
		          while (!(step = iterator.next()).done) {
		            var entry = step.value;
		            if (entry) {
		              if (!isNode(entry[1])) {
		                return false;
		              }
		            }
		          }
		        }
		      } else {
		        return false;
		      }
		
		      return true;
		    default:
		      return false;
		  }
		}
		
		// Equivalent of `typeof` but with special handling for array and regexp.
		function getPropType(propValue) {
		  var propType = typeof propValue;
		  if (Array.isArray(propValue)) {
		    return 'array';
		  }
		  if (propValue instanceof RegExp) {
		    // Old webkits (at least until Android 4.0) return 'function' rather than
		    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
		    // passes PropTypes.object.
		    return 'object';
		  }
		  return propType;
		}
		
		// This handles more types than `getPropType`. Only used for error messages.
		// See `createPrimitiveTypeChecker`.
		function getPreciseType(propValue) {
		  var propType = getPropType(propValue);
		  if (propType === 'object') {
		    if (propValue instanceof Date) {
		      return 'date';
		    } else if (propValue instanceof RegExp) {
		      return 'regexp';
		    }
		  }
		  return propType;
		}
		
		// Returns class name of the object, if any.
		function getClassName(propValue) {
		  if (!propValue.constructor || !propValue.constructor.name) {
		    return '<<anonymous>>';
		  }
		  return propValue.constructor.name;
		}
		
		module.exports = ReactPropTypes;
	
	/***/ },
	/* 108 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule getIteratorFn
		 * @typechecks static-only
		 */
		
		'use strict';
		
		/* global Symbol */
		var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
		var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
		
		/**
		 * Returns the iterator method function contained on the iterable object.
		 *
		 * Be sure to invoke the function with the iterable as context:
		 *
		 *     var iteratorFn = getIteratorFn(myIterable);
		 *     if (iteratorFn) {
		 *       var iterator = iteratorFn.call(myIterable);
		 *       ...
		 *     }
		 *
		 * @param {?object} maybeIterable
		 * @return {?function}
		 */
		function getIteratorFn(maybeIterable) {
		  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
		  if (typeof iteratorFn === 'function') {
		    return iteratorFn;
		  }
		}
		
		module.exports = getIteratorFn;
	
	/***/ },
	/* 109 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactDOMOption
		 */
		
		'use strict';
		
		var ReactChildren = __webpack_require__(110);
		var ReactDOMSelect = __webpack_require__(112);
		
		var assign = __webpack_require__(39);
		var warning = __webpack_require__(25);
		
		var valueContextKey = ReactDOMSelect.valueContextKey;
		
		/**
		 * Implements an <option> native component that warns when `selected` is set.
		 */
		var ReactDOMOption = {
		  mountWrapper: function (inst, props, context) {
		    // TODO (yungsters): Remove support for `selected` in <option>.
		    if (process.env.NODE_ENV !== 'production') {
		      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : undefined;
		    }
		
		    // Look up whether this option is 'selected' via context
		    var selectValue = context[valueContextKey];
		
		    // If context key is null (e.g., no specified value or after initial mount)
		    // or missing (e.g., for <datalist>), we don't change props.selected
		    var selected = null;
		    if (selectValue != null) {
		      selected = false;
		      if (Array.isArray(selectValue)) {
		        // multiple
		        for (var i = 0; i < selectValue.length; i++) {
		          if ('' + selectValue[i] === '' + props.value) {
		            selected = true;
		            break;
		          }
		        }
		      } else {
		        selected = '' + selectValue === '' + props.value;
		      }
		    }
		
		    inst._wrapperState = { selected: selected };
		  },
		
		  getNativeProps: function (inst, props, context) {
		    var nativeProps = assign({ selected: undefined, children: undefined }, props);
		
		    // Read state only from initial mount because <select> updates value
		    // manually; we need the initial state only for server rendering
		    if (inst._wrapperState.selected != null) {
		      nativeProps.selected = inst._wrapperState.selected;
		    }
		
		    var content = '';
		
		    // Flatten children and warn if they aren't strings or numbers;
		    // invalid types are ignored.
		    ReactChildren.forEach(props.children, function (child) {
		      if (child == null) {
		        return;
		      }
		      if (typeof child === 'string' || typeof child === 'number') {
		        content += child;
		      } else {
		        process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : undefined;
		      }
		    });
		
		    if (content) {
		      nativeProps.children = content;
		    }
		
		    return nativeProps;
		  }
		
		};
		
		module.exports = ReactDOMOption;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 110 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactChildren
		 */
		
		'use strict';
		
		var PooledClass = __webpack_require__(56);
		var ReactElement = __webpack_require__(42);
		
		var emptyFunction = __webpack_require__(15);
		var traverseAllChildren = __webpack_require__(111);
		
		var twoArgumentPooler = PooledClass.twoArgumentPooler;
		var fourArgumentPooler = PooledClass.fourArgumentPooler;
		
		var userProvidedKeyEscapeRegex = /\/(?!\/)/g;
		function escapeUserProvidedKey(text) {
		  return ('' + text).replace(userProvidedKeyEscapeRegex, '//');
		}
		
		/**
		 * PooledClass representing the bookkeeping associated with performing a child
		 * traversal. Allows avoiding binding callbacks.
		 *
		 * @constructor ForEachBookKeeping
		 * @param {!function} forEachFunction Function to perform traversal with.
		 * @param {?*} forEachContext Context to perform context with.
		 */
		function ForEachBookKeeping(forEachFunction, forEachContext) {
		  this.func = forEachFunction;
		  this.context = forEachContext;
		  this.count = 0;
		}
		ForEachBookKeeping.prototype.destructor = function () {
		  this.func = null;
		  this.context = null;
		  this.count = 0;
		};
		PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
		
		function forEachSingleChild(bookKeeping, child, name) {
		  var func = bookKeeping.func;
		  var context = bookKeeping.context;
		
		  func.call(context, child, bookKeeping.count++);
		}
		
		/**
		 * Iterates through children that are typically specified as `props.children`.
		 *
		 * The provided forEachFunc(child, index) will be called for each
		 * leaf child.
		 *
		 * @param {?*} children Children tree container.
		 * @param {function(*, int)} forEachFunc
		 * @param {*} forEachContext Context for forEachContext.
		 */
		function forEachChildren(children, forEachFunc, forEachContext) {
		  if (children == null) {
		    return children;
		  }
		  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
		  traverseAllChildren(children, forEachSingleChild, traverseContext);
		  ForEachBookKeeping.release(traverseContext);
		}
		
		/**
		 * PooledClass representing the bookkeeping associated with performing a child
		 * mapping. Allows avoiding binding callbacks.
		 *
		 * @constructor MapBookKeeping
		 * @param {!*} mapResult Object containing the ordered map of results.
		 * @param {!function} mapFunction Function to perform mapping with.
		 * @param {?*} mapContext Context to perform mapping with.
		 */
		function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
		  this.result = mapResult;
		  this.keyPrefix = keyPrefix;
		  this.func = mapFunction;
		  this.context = mapContext;
		  this.count = 0;
		}
		MapBookKeeping.prototype.destructor = function () {
		  this.result = null;
		  this.keyPrefix = null;
		  this.func = null;
		  this.context = null;
		  this.count = 0;
		};
		PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
		
		function mapSingleChildIntoContext(bookKeeping, child, childKey) {
		  var result = bookKeeping.result;
		  var keyPrefix = bookKeeping.keyPrefix;
		  var func = bookKeeping.func;
		  var context = bookKeeping.context;
		
		  var mappedChild = func.call(context, child, bookKeeping.count++);
		  if (Array.isArray(mappedChild)) {
		    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
		  } else if (mappedChild != null) {
		    if (ReactElement.isValidElement(mappedChild)) {
		      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
		      // Keep both the (mapped) and old keys if they differ, just as
		      // traverseAllChildren used to do for objects as children
		      keyPrefix + (mappedChild !== child ? escapeUserProvidedKey(mappedChild.key || '') + '/' : '') + childKey);
		    }
		    result.push(mappedChild);
		  }
		}
		
		function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
		  var escapedPrefix = '';
		  if (prefix != null) {
		    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
		  }
		  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
		  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
		  MapBookKeeping.release(traverseContext);
		}
		
		/**
		 * Maps children that are typically specified as `props.children`.
		 *
		 * The provided mapFunction(child, key, index) will be called for each
		 * leaf child.
		 *
		 * @param {?*} children Children tree container.
		 * @param {function(*, int)} func The map function.
		 * @param {*} context Context for mapFunction.
		 * @return {object} Object containing the ordered map of results.
		 */
		function mapChildren(children, func, context) {
		  if (children == null) {
		    return children;
		  }
		  var result = [];
		  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
		  return result;
		}
		
		function forEachSingleChildDummy(traverseContext, child, name) {
		  return null;
		}
		
		/**
		 * Count the number of children that are typically specified as
		 * `props.children`.
		 *
		 * @param {?*} children Children tree container.
		 * @return {number} The number of children.
		 */
		function countChildren(children, context) {
		  return traverseAllChildren(children, forEachSingleChildDummy, null);
		}
		
		/**
		 * Flatten a children object (typically specified as `props.children`) and
		 * return an array with appropriately re-keyed children.
		 */
		function toArray(children) {
		  var result = [];
		  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
		  return result;
		}
		
		var ReactChildren = {
		  forEach: forEachChildren,
		  map: mapChildren,
		  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
		  count: countChildren,
		  toArray: toArray
		};
		
		module.exports = ReactChildren;
	
	/***/ },
	/* 111 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule traverseAllChildren
		 */
		
		'use strict';
		
		var ReactCurrentOwner = __webpack_require__(5);
		var ReactElement = __webpack_require__(42);
		var ReactInstanceHandles = __webpack_require__(45);
		
		var getIteratorFn = __webpack_require__(108);
		var invariant = __webpack_require__(13);
		var warning = __webpack_require__(25);
		
		var SEPARATOR = ReactInstanceHandles.SEPARATOR;
		var SUBSEPARATOR = ':';
		
		/**
		 * TODO: Test that a single child and an array with one item have the same key
		 * pattern.
		 */
		
		var userProvidedKeyEscaperLookup = {
		  '=': '=0',
		  '.': '=1',
		  ':': '=2'
		};
		
		var userProvidedKeyEscapeRegex = /[=.:]/g;
		
		var didWarnAboutMaps = false;
		
		function userProvidedKeyEscaper(match) {
		  return userProvidedKeyEscaperLookup[match];
		}
		
		/**
		 * Generate a key string that identifies a component within a set.
		 *
		 * @param {*} component A component that could contain a manual key.
		 * @param {number} index Index that is used if a manual key is not provided.
		 * @return {string}
		 */
		function getComponentKey(component, index) {
		  if (component && component.key != null) {
		    // Explicit key
		    return wrapUserProvidedKey(component.key);
		  }
		  // Implicit key determined by the index in the set
		  return index.toString(36);
		}
		
		/**
		 * Escape a component key so that it is safe to use in a reactid.
		 *
		 * @param {*} text Component key to be escaped.
		 * @return {string} An escaped string.
		 */
		function escapeUserProvidedKey(text) {
		  return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
		}
		
		/**
		 * Wrap a `key` value explicitly provided by the user to distinguish it from
		 * implicitly-generated keys generated by a component's index in its parent.
		 *
		 * @param {string} key Value of a user-provided `key` attribute
		 * @return {string}
		 */
		function wrapUserProvidedKey(key) {
		  return '$' + escapeUserProvidedKey(key);
		}
		
		/**
		 * @param {?*} children Children tree container.
		 * @param {!string} nameSoFar Name of the key path so far.
		 * @param {!function} callback Callback to invoke with each child found.
		 * @param {?*} traverseContext Used to pass information throughout the traversal
		 * process.
		 * @return {!number} The number of children in this subtree.
		 */
		function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
		  var type = typeof children;
		
		  if (type === 'undefined' || type === 'boolean') {
		    // All of the above are perceived as null.
		    children = null;
		  }
		
		  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
		    callback(traverseContext, children,
		    // If it's the only child, treat the name as if it was wrapped in an array
		    // so that it's consistent if the number of children grows.
		    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
		    return 1;
		  }
		
		  var child;
		  var nextName;
		  var subtreeCount = 0; // Count of children found in the current subtree.
		  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
		
		  if (Array.isArray(children)) {
		    for (var i = 0; i < children.length; i++) {
		      child = children[i];
		      nextName = nextNamePrefix + getComponentKey(child, i);
		      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
		    }
		  } else {
		    var iteratorFn = getIteratorFn(children);
		    if (iteratorFn) {
		      var iterator = iteratorFn.call(children);
		      var step;
		      if (iteratorFn !== children.entries) {
		        var ii = 0;
		        while (!(step = iterator.next()).done) {
		          child = step.value;
		          nextName = nextNamePrefix + getComponentKey(child, ii++);
		          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
		        }
		      } else {
		        if (process.env.NODE_ENV !== 'production') {
		          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : undefined;
		          didWarnAboutMaps = true;
		        }
		        // Iterator will provide entry [k,v] tuples rather than values.
		        while (!(step = iterator.next()).done) {
		          var entry = step.value;
		          if (entry) {
		            child = entry[1];
		            nextName = nextNamePrefix + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
		            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
		          }
		        }
		      }
		    } else if (type === 'object') {
		      var addendum = '';
		      if (process.env.NODE_ENV !== 'production') {
		        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
		        if (children._isReactElement) {
		          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
		        }
		        if (ReactCurrentOwner.current) {
		          var name = ReactCurrentOwner.current.getName();
		          if (name) {
		            addendum += ' Check the render method of `' + name + '`.';
		          }
		        }
		      }
		      var childrenString = String(children);
		       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : invariant(false) : undefined;
		    }
		  }
		
		  return subtreeCount;
		}
		
		/**
		 * Traverses children that are typically specified as `props.children`, but
		 * might also be specified through attributes:
		 *
		 * - `traverseAllChildren(this.props.children, ...)`
		 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
		 *
		 * The `traverseContext` is an optional argument that is passed through the
		 * entire traversal. It can be used to store accumulations or anything else that
		 * the callback might find relevant.
		 *
		 * @param {?*} children Children tree object.
		 * @param {!function} callback To invoke upon traversing each child.
		 * @param {?*} traverseContext Context for traversal.
		 * @return {!number} The number of children in this subtree.
		 */
		function traverseAllChildren(children, callback, traverseContext) {
		  if (children == null) {
		    return 0;
		  }
		
		  return traverseAllChildrenImpl(children, '', callback, traverseContext);
		}
		
		module.exports = traverseAllChildren;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 112 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactDOMSelect
		 */
		
		'use strict';
		
		var LinkedValueUtils = __webpack_require__(106);
		var ReactMount = __webpack_require__(28);
		var ReactUpdates = __webpack_require__(54);
		
		var assign = __webpack_require__(39);
		var warning = __webpack_require__(25);
		
		var valueContextKey = '__ReactDOMSelect_value$' + Math.random().toString(36).slice(2);
		
		function updateOptionsIfPendingUpdateAndMounted() {
		  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
		    this._wrapperState.pendingUpdate = false;
		
		    var props = this._currentElement.props;
		    var value = LinkedValueUtils.getValue(props);
		
		    if (value != null) {
		      updateOptions(this, Boolean(props.multiple), value);
		    }
		  }
		}
		
		function getDeclarationErrorAddendum(owner) {
		  if (owner) {
		    var name = owner.getName();
		    if (name) {
		      return ' Check the render method of `' + name + '`.';
		    }
		  }
		  return '';
		}
		
		var valuePropNames = ['value', 'defaultValue'];
		
		/**
		 * Validation function for `value` and `defaultValue`.
		 * @private
		 */
		function checkSelectPropTypes(inst, props) {
		  var owner = inst._currentElement._owner;
		  LinkedValueUtils.checkPropTypes('select', props, owner);
		
		  for (var i = 0; i < valuePropNames.length; i++) {
		    var propName = valuePropNames[i];
		    if (props[propName] == null) {
		      continue;
		    }
		    if (props.multiple) {
		      process.env.NODE_ENV !== 'production' ? warning(Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
		    } else {
		      process.env.NODE_ENV !== 'production' ? warning(!Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
		    }
		  }
		}
		
		/**
		 * @param {ReactDOMComponent} inst
		 * @param {boolean} multiple
		 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
		 * @private
		 */
		function updateOptions(inst, multiple, propValue) {
		  var selectedValue, i;
		  var options = ReactMount.getNode(inst._rootNodeID).options;
		
		  if (multiple) {
		    selectedValue = {};
		    for (i = 0; i < propValue.length; i++) {
		      selectedValue['' + propValue[i]] = true;
		    }
		    for (i = 0; i < options.length; i++) {
		      var selected = selectedValue.hasOwnProperty(options[i].value);
		      if (options[i].selected !== selected) {
		        options[i].selected = selected;
		      }
		    }
		  } else {
		    // Do not set `select.value` as exact behavior isn't consistent across all
		    // browsers for all cases.
		    selectedValue = '' + propValue;
		    for (i = 0; i < options.length; i++) {
		      if (options[i].value === selectedValue) {
		        options[i].selected = true;
		        return;
		      }
		    }
		    if (options.length) {
		      options[0].selected = true;
		    }
		  }
		}
		
		/**
		 * Implements a <select> native component that allows optionally setting the
		 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
		 * stringable. If `multiple` is true, the prop must be an array of stringables.
		 *
		 * If `value` is not supplied (or null/undefined), user actions that change the
		 * selected option will trigger updates to the rendered options.
		 *
		 * If it is supplied (and not null/undefined), the rendered options will not
		 * update in response to user actions. Instead, the `value` prop must change in
		 * order for the rendered options to update.
		 *
		 * If `defaultValue` is provided, any options with the supplied values will be
		 * selected.
		 */
		var ReactDOMSelect = {
		  valueContextKey: valueContextKey,
		
		  getNativeProps: function (inst, props, context) {
		    return assign({}, props, {
		      onChange: inst._wrapperState.onChange,
		      value: undefined
		    });
		  },
		
		  mountWrapper: function (inst, props) {
		    if (process.env.NODE_ENV !== 'production') {
		      checkSelectPropTypes(inst, props);
		    }
		
		    var value = LinkedValueUtils.getValue(props);
		    inst._wrapperState = {
		      pendingUpdate: false,
		      initialValue: value != null ? value : props.defaultValue,
		      onChange: _handleChange.bind(inst),
		      wasMultiple: Boolean(props.multiple)
		    };
		  },
		
		  processChildContext: function (inst, props, context) {
		    // Pass down initial value so initial generated markup has correct
		    // `selected` attributes
		    var childContext = assign({}, context);
		    childContext[valueContextKey] = inst._wrapperState.initialValue;
		    return childContext;
		  },
		
		  postUpdateWrapper: function (inst) {
		    var props = inst._currentElement.props;
		
		    // After the initial mount, we control selected-ness manually so don't pass
		    // the context value down
		    inst._wrapperState.initialValue = undefined;
		
		    var wasMultiple = inst._wrapperState.wasMultiple;
		    inst._wrapperState.wasMultiple = Boolean(props.multiple);
		
		    var value = LinkedValueUtils.getValue(props);
		    if (value != null) {
		      inst._wrapperState.pendingUpdate = false;
		      updateOptions(inst, Boolean(props.multiple), value);
		    } else if (wasMultiple !== Boolean(props.multiple)) {
		      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
		      if (props.defaultValue != null) {
		        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
		      } else {
		        // Revert the select back to its default unselected state.
		        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
		      }
		    }
		  }
		};
		
		function _handleChange(event) {
		  var props = this._currentElement.props;
		  var returnValue = LinkedValueUtils.executeOnChange(props, event);
		
		  this._wrapperState.pendingUpdate = true;
		  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
		  return returnValue;
		}
		
		module.exports = ReactDOMSelect;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 113 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactDOMTextarea
		 */
		
		'use strict';
		
		var LinkedValueUtils = __webpack_require__(106);
		var ReactDOMIDOperations = __webpack_require__(27);
		var ReactUpdates = __webpack_require__(54);
		
		var assign = __webpack_require__(39);
		var invariant = __webpack_require__(13);
		var warning = __webpack_require__(25);
		
		function forceUpdateIfMounted() {
		  if (this._rootNodeID) {
		    // DOM component is still mounted; update
		    ReactDOMTextarea.updateWrapper(this);
		  }
		}
		
		/**
		 * Implements a <textarea> native component that allows setting `value`, and
		 * `defaultValue`. This differs from the traditional DOM API because value is
		 * usually set as PCDATA children.
		 *
		 * If `value` is not supplied (or null/undefined), user actions that affect the
		 * value will trigger updates to the element.
		 *
		 * If `value` is supplied (and not null/undefined), the rendered element will
		 * not trigger updates to the element. Instead, the `value` prop must change in
		 * order for the rendered element to be updated.
		 *
		 * The rendered element will be initialized with an empty value, the prop
		 * `defaultValue` if specified, or the children content (deprecated).
		 */
		var ReactDOMTextarea = {
		  getNativeProps: function (inst, props, context) {
		    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(false) : undefined;
		
		    // Always set children to the same thing. In IE9, the selection range will
		    // get reset if `textContent` is mutated.
		    var nativeProps = assign({}, props, {
		      defaultValue: undefined,
		      value: undefined,
		      children: inst._wrapperState.initialValue,
		      onChange: inst._wrapperState.onChange
		    });
		
		    return nativeProps;
		  },
		
		  mountWrapper: function (inst, props) {
		    if (process.env.NODE_ENV !== 'production') {
		      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
		    }
		
		    var defaultValue = props.defaultValue;
		    // TODO (yungsters): Remove support for children content in <textarea>.
		    var children = props.children;
		    if (children != null) {
		      if (process.env.NODE_ENV !== 'production') {
		        process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : undefined;
		      }
		      !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(false) : undefined;
		      if (Array.isArray(children)) {
		        !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : invariant(false) : undefined;
		        children = children[0];
		      }
		
		      defaultValue = '' + children;
		    }
		    if (defaultValue == null) {
		      defaultValue = '';
		    }
		    var value = LinkedValueUtils.getValue(props);
		
		    inst._wrapperState = {
		      // We save the initial value so that `ReactDOMComponent` doesn't update
		      // `textContent` (unnecessary since we update value).
		      // The initial value can be a boolean or object so that's why it's
		      // forced to be a string.
		      initialValue: '' + (value != null ? value : defaultValue),
		      onChange: _handleChange.bind(inst)
		    };
		  },
		
		  updateWrapper: function (inst) {
		    var props = inst._currentElement.props;
		    var value = LinkedValueUtils.getValue(props);
		    if (value != null) {
		      // Cast `value` to a string to ensure the value is set correctly. While
		      // browsers typically do this as necessary, jsdom doesn't.
		      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
		    }
		  }
		};
		
		function _handleChange(event) {
		  var props = this._currentElement.props;
		  var returnValue = LinkedValueUtils.executeOnChange(props, event);
		  ReactUpdates.asap(forceUpdateIfMounted, this);
		  return returnValue;
		}
		
		module.exports = ReactDOMTextarea;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 114 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactMultiChild
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var ReactComponentEnvironment = __webpack_require__(64);
		var ReactMultiChildUpdateTypes = __webpack_require__(16);
		
		var ReactCurrentOwner = __webpack_require__(5);
		var ReactReconciler = __webpack_require__(50);
		var ReactChildReconciler = __webpack_require__(115);
		
		var flattenChildren = __webpack_require__(116);
		
		/**
		 * Updating children of a component may trigger recursive updates. The depth is
		 * used to batch recursive updates to render markup more efficiently.
		 *
		 * @type {number}
		 * @private
		 */
		var updateDepth = 0;
		
		/**
		 * Queue of update configuration objects.
		 *
		 * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.
		 *
		 * @type {array<object>}
		 * @private
		 */
		var updateQueue = [];
		
		/**
		 * Queue of markup to be rendered.
		 *
		 * @type {array<string>}
		 * @private
		 */
		var markupQueue = [];
		
		/**
		 * Enqueues markup to be rendered and inserted at a supplied index.
		 *
		 * @param {string} parentID ID of the parent component.
		 * @param {string} markup Markup that renders into an element.
		 * @param {number} toIndex Destination index.
		 * @private
		 */
		function enqueueInsertMarkup(parentID, markup, toIndex) {
		  // NOTE: Null values reduce hidden classes.
		  updateQueue.push({
		    parentID: parentID,
		    parentNode: null,
		    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
		    markupIndex: markupQueue.push(markup) - 1,
		    content: null,
		    fromIndex: null,
		    toIndex: toIndex
		  });
		}
		
		/**
		 * Enqueues moving an existing element to another index.
		 *
		 * @param {string} parentID ID of the parent component.
		 * @param {number} fromIndex Source index of the existing element.
		 * @param {number} toIndex Destination index of the element.
		 * @private
		 */
		function enqueueMove(parentID, fromIndex, toIndex) {
		  // NOTE: Null values reduce hidden classes.
		  updateQueue.push({
		    parentID: parentID,
		    parentNode: null,
		    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
		    markupIndex: null,
		    content: null,
		    fromIndex: fromIndex,
		    toIndex: toIndex
		  });
		}
		
		/**
		 * Enqueues removing an element at an index.
		 *
		 * @param {string} parentID ID of the parent component.
		 * @param {number} fromIndex Index of the element to remove.
		 * @private
		 */
		function enqueueRemove(parentID, fromIndex) {
		  // NOTE: Null values reduce hidden classes.
		  updateQueue.push({
		    parentID: parentID,
		    parentNode: null,
		    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
		    markupIndex: null,
		    content: null,
		    fromIndex: fromIndex,
		    toIndex: null
		  });
		}
		
		/**
		 * Enqueues setting the markup of a node.
		 *
		 * @param {string} parentID ID of the parent component.
		 * @param {string} markup Markup that renders into an element.
		 * @private
		 */
		function enqueueSetMarkup(parentID, markup) {
		  // NOTE: Null values reduce hidden classes.
		  updateQueue.push({
		    parentID: parentID,
		    parentNode: null,
		    type: ReactMultiChildUpdateTypes.SET_MARKUP,
		    markupIndex: null,
		    content: markup,
		    fromIndex: null,
		    toIndex: null
		  });
		}
		
		/**
		 * Enqueues setting the text content.
		 *
		 * @param {string} parentID ID of the parent component.
		 * @param {string} textContent Text content to set.
		 * @private
		 */
		function enqueueTextContent(parentID, textContent) {
		  // NOTE: Null values reduce hidden classes.
		  updateQueue.push({
		    parentID: parentID,
		    parentNode: null,
		    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
		    markupIndex: null,
		    content: textContent,
		    fromIndex: null,
		    toIndex: null
		  });
		}
		
		/**
		 * Processes any enqueued updates.
		 *
		 * @private
		 */
		function processQueue() {
		  if (updateQueue.length) {
		    ReactComponentEnvironment.processChildrenUpdates(updateQueue, markupQueue);
		    clearQueue();
		  }
		}
		
		/**
		 * Clears any enqueued updates.
		 *
		 * @private
		 */
		function clearQueue() {
		  updateQueue.length = 0;
		  markupQueue.length = 0;
		}
		
		/**
		 * ReactMultiChild are capable of reconciling multiple children.
		 *
		 * @class ReactMultiChild
		 * @internal
		 */
		var ReactMultiChild = {
		
		  /**
		   * Provides common functionality for components that must reconcile multiple
		   * children. This is used by `ReactDOMComponent` to mount, update, and
		   * unmount child components.
		   *
		   * @lends {ReactMultiChild.prototype}
		   */
		  Mixin: {
		
		    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
		      if (process.env.NODE_ENV !== 'production') {
		        if (this._currentElement) {
		          try {
		            ReactCurrentOwner.current = this._currentElement._owner;
		            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
		          } finally {
		            ReactCurrentOwner.current = null;
		          }
		        }
		      }
		      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
		    },
		
		    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, transaction, context) {
		      var nextChildren;
		      if (process.env.NODE_ENV !== 'production') {
		        if (this._currentElement) {
		          try {
		            ReactCurrentOwner.current = this._currentElement._owner;
		            nextChildren = flattenChildren(nextNestedChildrenElements);
		          } finally {
		            ReactCurrentOwner.current = null;
		          }
		          return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
		        }
		      }
		      nextChildren = flattenChildren(nextNestedChildrenElements);
		      return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
		    },
		
		    /**
		     * Generates a "mount image" for each of the supplied children. In the case
		     * of `ReactDOMComponent`, a mount image is a string of markup.
		     *
		     * @param {?object} nestedChildren Nested child maps.
		     * @return {array} An array of mounted representations.
		     * @internal
		     */
		    mountChildren: function (nestedChildren, transaction, context) {
		      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
		      this._renderedChildren = children;
		      var mountImages = [];
		      var index = 0;
		      for (var name in children) {
		        if (children.hasOwnProperty(name)) {
		          var child = children[name];
		          // Inlined for performance, see `ReactInstanceHandles.createReactID`.
		          var rootID = this._rootNodeID + name;
		          var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
		          child._mountIndex = index++;
		          mountImages.push(mountImage);
		        }
		      }
		      return mountImages;
		    },
		
		    /**
		     * Replaces any rendered children with a text content string.
		     *
		     * @param {string} nextContent String of content.
		     * @internal
		     */
		    updateTextContent: function (nextContent) {
		      updateDepth++;
		      var errorThrown = true;
		      try {
		        var prevChildren = this._renderedChildren;
		        // Remove any rendered children.
		        ReactChildReconciler.unmountChildren(prevChildren);
		        // TODO: The setTextContent operation should be enough
		        for (var name in prevChildren) {
		          if (prevChildren.hasOwnProperty(name)) {
		            this._unmountChild(prevChildren[name]);
		          }
		        }
		        // Set new text content.
		        this.setTextContent(nextContent);
		        errorThrown = false;
		      } finally {
		        updateDepth--;
		        if (!updateDepth) {
		          if (errorThrown) {
		            clearQueue();
		          } else {
		            processQueue();
		          }
		        }
		      }
		    },
		
		    /**
		     * Replaces any rendered children with a markup string.
		     *
		     * @param {string} nextMarkup String of markup.
		     * @internal
		     */
		    updateMarkup: function (nextMarkup) {
		      updateDepth++;
		      var errorThrown = true;
		      try {
		        var prevChildren = this._renderedChildren;
		        // Remove any rendered children.
		        ReactChildReconciler.unmountChildren(prevChildren);
		        for (var name in prevChildren) {
		          if (prevChildren.hasOwnProperty(name)) {
		            this._unmountChildByName(prevChildren[name], name);
		          }
		        }
		        this.setMarkup(nextMarkup);
		        errorThrown = false;
		      } finally {
		        updateDepth--;
		        if (!updateDepth) {
		          if (errorThrown) {
		            clearQueue();
		          } else {
		            processQueue();
		          }
		        }
		      }
		    },
		
		    /**
		     * Updates the rendered children with new children.
		     *
		     * @param {?object} nextNestedChildrenElements Nested child element maps.
		     * @param {ReactReconcileTransaction} transaction
		     * @internal
		     */
		    updateChildren: function (nextNestedChildrenElements, transaction, context) {
		      updateDepth++;
		      var errorThrown = true;
		      try {
		        this._updateChildren(nextNestedChildrenElements, transaction, context);
		        errorThrown = false;
		      } finally {
		        updateDepth--;
		        if (!updateDepth) {
		          if (errorThrown) {
		            clearQueue();
		          } else {
		            processQueue();
		          }
		        }
		      }
		    },
		
		    /**
		     * Improve performance by isolating this hot code path from the try/catch
		     * block in `updateChildren`.
		     *
		     * @param {?object} nextNestedChildrenElements Nested child element maps.
		     * @param {ReactReconcileTransaction} transaction
		     * @final
		     * @protected
		     */
		    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
		      var prevChildren = this._renderedChildren;
		      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context);
		      this._renderedChildren = nextChildren;
		      if (!nextChildren && !prevChildren) {
		        return;
		      }
		      var name;
		      // `nextIndex` will increment for each child in `nextChildren`, but
		      // `lastIndex` will be the last index visited in `prevChildren`.
		      var lastIndex = 0;
		      var nextIndex = 0;
		      for (name in nextChildren) {
		        if (!nextChildren.hasOwnProperty(name)) {
		          continue;
		        }
		        var prevChild = prevChildren && prevChildren[name];
		        var nextChild = nextChildren[name];
		        if (prevChild === nextChild) {
		          this.moveChild(prevChild, nextIndex, lastIndex);
		          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
		          prevChild._mountIndex = nextIndex;
		        } else {
		          if (prevChild) {
		            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
		            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
		            this._unmountChild(prevChild);
		          }
		          // The child must be instantiated before it's mounted.
		          this._mountChildByNameAtIndex(nextChild, name, nextIndex, transaction, context);
		        }
		        nextIndex++;
		      }
		      // Remove children that are no longer present.
		      for (name in prevChildren) {
		        if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
		          this._unmountChild(prevChildren[name]);
		        }
		      }
		    },
		
		    /**
		     * Unmounts all rendered children. This should be used to clean up children
		     * when this component is unmounted.
		     *
		     * @internal
		     */
		    unmountChildren: function () {
		      var renderedChildren = this._renderedChildren;
		      ReactChildReconciler.unmountChildren(renderedChildren);
		      this._renderedChildren = null;
		    },
		
		    /**
		     * Moves a child component to the supplied index.
		     *
		     * @param {ReactComponent} child Component to move.
		     * @param {number} toIndex Destination index of the element.
		     * @param {number} lastIndex Last index visited of the siblings of `child`.
		     * @protected
		     */
		    moveChild: function (child, toIndex, lastIndex) {
		      // If the index of `child` is less than `lastIndex`, then it needs to
		      // be moved. Otherwise, we do not need to move it because a child will be
		      // inserted or moved before `child`.
		      if (child._mountIndex < lastIndex) {
		        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
		      }
		    },
		
		    /**
		     * Creates a child component.
		     *
		     * @param {ReactComponent} child Component to create.
		     * @param {string} mountImage Markup to insert.
		     * @protected
		     */
		    createChild: function (child, mountImage) {
		      enqueueInsertMarkup(this._rootNodeID, mountImage, child._mountIndex);
		    },
		
		    /**
		     * Removes a child component.
		     *
		     * @param {ReactComponent} child Child to remove.
		     * @protected
		     */
		    removeChild: function (child) {
		      enqueueRemove(this._rootNodeID, child._mountIndex);
		    },
		
		    /**
		     * Sets this text content string.
		     *
		     * @param {string} textContent Text content to set.
		     * @protected
		     */
		    setTextContent: function (textContent) {
		      enqueueTextContent(this._rootNodeID, textContent);
		    },
		
		    /**
		     * Sets this markup string.
		     *
		     * @param {string} markup Markup to set.
		     * @protected
		     */
		    setMarkup: function (markup) {
		      enqueueSetMarkup(this._rootNodeID, markup);
		    },
		
		    /**
		     * Mounts a child with the supplied name.
		     *
		     * NOTE: This is part of `updateChildren` and is here for readability.
		     *
		     * @param {ReactComponent} child Component to mount.
		     * @param {string} name Name of the child.
		     * @param {number} index Index at which to insert the child.
		     * @param {ReactReconcileTransaction} transaction
		     * @private
		     */
		    _mountChildByNameAtIndex: function (child, name, index, transaction, context) {
		      // Inlined for performance, see `ReactInstanceHandles.createReactID`.
		      var rootID = this._rootNodeID + name;
		      var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
		      child._mountIndex = index;
		      this.createChild(child, mountImage);
		    },
		
		    /**
		     * Unmounts a rendered child.
		     *
		     * NOTE: This is part of `updateChildren` and is here for readability.
		     *
		     * @param {ReactComponent} child Component to unmount.
		     * @private
		     */
		    _unmountChild: function (child) {
		      this.removeChild(child);
		      child._mountIndex = null;
		    }
		
		  }
		
		};
		
		module.exports = ReactMultiChild;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 115 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2014-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactChildReconciler
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var ReactReconciler = __webpack_require__(50);
		
		var instantiateReactComponent = __webpack_require__(62);
		var shouldUpdateReactComponent = __webpack_require__(67);
		var traverseAllChildren = __webpack_require__(111);
		var warning = __webpack_require__(25);
		
		function instantiateChild(childInstances, child, name) {
		  // We found a component instance.
		  var keyUnique = childInstances[name] === undefined;
		  if (process.env.NODE_ENV !== 'production') {
		    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
		  }
		  if (child != null && keyUnique) {
		    childInstances[name] = instantiateReactComponent(child, null);
		  }
		}
		
		/**
		 * ReactChildReconciler provides helpers for initializing or updating a set of
		 * children. Its output is suitable for passing it onto ReactMultiChild which
		 * does diffed reordering and insertion.
		 */
		var ReactChildReconciler = {
		  /**
		   * Generates a "mount image" for each of the supplied children. In the case
		   * of `ReactDOMComponent`, a mount image is a string of markup.
		   *
		   * @param {?object} nestedChildNodes Nested child maps.
		   * @return {?object} A set of child instances.
		   * @internal
		   */
		  instantiateChildren: function (nestedChildNodes, transaction, context) {
		    if (nestedChildNodes == null) {
		      return null;
		    }
		    var childInstances = {};
		    traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
		    return childInstances;
		  },
		
		  /**
		   * Updates the rendered children and returns a new set of children.
		   *
		   * @param {?object} prevChildren Previously initialized set of children.
		   * @param {?object} nextChildren Flat child element maps.
		   * @param {ReactReconcileTransaction} transaction
		   * @param {object} context
		   * @return {?object} A new set of child instances.
		   * @internal
		   */
		  updateChildren: function (prevChildren, nextChildren, transaction, context) {
		    // We currently don't have a way to track moves here but if we use iterators
		    // instead of for..in we can zip the iterators and check if an item has
		    // moved.
		    // TODO: If nothing has changed, return the prevChildren object so that we
		    // can quickly bailout if nothing has changed.
		    if (!nextChildren && !prevChildren) {
		      return null;
		    }
		    var name;
		    for (name in nextChildren) {
		      if (!nextChildren.hasOwnProperty(name)) {
		        continue;
		      }
		      var prevChild = prevChildren && prevChildren[name];
		      var prevElement = prevChild && prevChild._currentElement;
		      var nextElement = nextChildren[name];
		      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
		        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
		        nextChildren[name] = prevChild;
		      } else {
		        if (prevChild) {
		          ReactReconciler.unmountComponent(prevChild, name);
		        }
		        // The child must be instantiated before it's mounted.
		        var nextChildInstance = instantiateReactComponent(nextElement, null);
		        nextChildren[name] = nextChildInstance;
		      }
		    }
		    // Unmount children that are no longer present.
		    for (name in prevChildren) {
		      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
		        ReactReconciler.unmountComponent(prevChildren[name]);
		      }
		    }
		    return nextChildren;
		  },
		
		  /**
		   * Unmounts all rendered children. This should be used to clean up children
		   * when this component is unmounted.
		   *
		   * @param {?object} renderedChildren Previously initialized set of children.
		   * @internal
		   */
		  unmountChildren: function (renderedChildren) {
		    for (var name in renderedChildren) {
		      if (renderedChildren.hasOwnProperty(name)) {
		        var renderedChild = renderedChildren[name];
		        ReactReconciler.unmountComponent(renderedChild);
		      }
		    }
		  }
		
		};
		
		module.exports = ReactChildReconciler;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 116 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule flattenChildren
		 */
		
		'use strict';
		
		var traverseAllChildren = __webpack_require__(111);
		var warning = __webpack_require__(25);
		
		/**
		 * @param {function} traverseContext Context passed through traversal.
		 * @param {?ReactComponent} child React child component.
		 * @param {!string} name String name of key path to child.
		 */
		function flattenSingleChildIntoContext(traverseContext, child, name) {
		  // We found a component instance.
		  var result = traverseContext;
		  var keyUnique = result[name] === undefined;
		  if (process.env.NODE_ENV !== 'production') {
		    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
		  }
		  if (keyUnique && child != null) {
		    result[name] = child;
		  }
		}
		
		/**
		 * Flattens children that are typically specified as `props.children`. Any null
		 * children will not be included in the resulting object.
		 * @return {!object} flattened children keyed by name.
		 */
		function flattenChildren(children) {
		  if (children == null) {
		    return children;
		  }
		  var result = {};
		  traverseAllChildren(children, flattenSingleChildIntoContext, result);
		  return result;
		}
		
		module.exports = flattenChildren;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 117 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule shallowEqual
		 * @typechecks
		 * 
		 */
		
		'use strict';
		
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		
		/**
		 * Performs equality by iterating through keys on an object and returning false
		 * when any key has values which are not strictly equal between the arguments.
		 * Returns true when the values of all keys are strictly equal.
		 */
		function shallowEqual(objA, objB) {
		  if (objA === objB) {
		    return true;
		  }
		
		  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
		    return false;
		  }
		
		  var keysA = Object.keys(objA);
		  var keysB = Object.keys(objB);
		
		  if (keysA.length !== keysB.length) {
		    return false;
		  }
		
		  // Test for A's keys different from B.
		  var bHasOwnProperty = hasOwnProperty.bind(objB);
		  for (var i = 0; i < keysA.length; i++) {
		    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
		      return false;
		    }
		  }
		
		  return true;
		}
		
		module.exports = shallowEqual;
	
	/***/ },
	/* 118 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactEventListener
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var EventListener = __webpack_require__(119);
		var ExecutionEnvironment = __webpack_require__(9);
		var PooledClass = __webpack_require__(56);
		var ReactInstanceHandles = __webpack_require__(45);
		var ReactMount = __webpack_require__(28);
		var ReactUpdates = __webpack_require__(54);
		
		var assign = __webpack_require__(39);
		var getEventTarget = __webpack_require__(81);
		var getUnboundedScrollPosition = __webpack_require__(120);
		
		var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
		
		/**
		 * Finds the parent React component of `node`.
		 *
		 * @param {*} node
		 * @return {?DOMEventTarget} Parent container, or `null` if the specified node
		 *                           is not nested.
		 */
		function findParent(node) {
		  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
		  // traversal, but caching is difficult to do correctly without using a
		  // mutation observer to listen for all DOM changes.
		  var nodeID = ReactMount.getID(node);
		  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
		  var container = ReactMount.findReactContainerForID(rootID);
		  var parent = ReactMount.getFirstReactDOM(container);
		  return parent;
		}
		
		// Used to store ancestor hierarchy in top level callback
		function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
		  this.topLevelType = topLevelType;
		  this.nativeEvent = nativeEvent;
		  this.ancestors = [];
		}
		assign(TopLevelCallbackBookKeeping.prototype, {
		  destructor: function () {
		    this.topLevelType = null;
		    this.nativeEvent = null;
		    this.ancestors.length = 0;
		  }
		});
		PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
		
		function handleTopLevelImpl(bookKeeping) {
		  // TODO: Re-enable event.path handling
		  //
		  // if (bookKeeping.nativeEvent.path && bookKeeping.nativeEvent.path.length > 1) {
		  //   // New browsers have a path attribute on native events
		  //   handleTopLevelWithPath(bookKeeping);
		  // } else {
		  //   // Legacy browsers don't have a path attribute on native events
		  //   handleTopLevelWithoutPath(bookKeeping);
		  // }
		
		  void handleTopLevelWithPath; // temporarily unused
		  handleTopLevelWithoutPath(bookKeeping);
		}
		
		// Legacy browsers don't have a path attribute on native events
		function handleTopLevelWithoutPath(bookKeeping) {
		  var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;
		
		  // Loop through the hierarchy, in case there's any nested components.
		  // It's important that we build the array of ancestors before calling any
		  // event handlers, because event handlers can modify the DOM, leading to
		  // inconsistencies with ReactMount's node cache. See #1105.
		  var ancestor = topLevelTarget;
		  while (ancestor) {
		    bookKeeping.ancestors.push(ancestor);
		    ancestor = findParent(ancestor);
		  }
		
		  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
		    topLevelTarget = bookKeeping.ancestors[i];
		    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
		    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
		  }
		}
		
		// New browsers have a path attribute on native events
		function handleTopLevelWithPath(bookKeeping) {
		  var path = bookKeeping.nativeEvent.path;
		  var currentNativeTarget = path[0];
		  var eventsFired = 0;
		  for (var i = 0; i < path.length; i++) {
		    var currentPathElement = path[i];
		    if (currentPathElement.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE) {
		      currentNativeTarget = path[i + 1];
		    }
		    // TODO: slow
		    var reactParent = ReactMount.getFirstReactDOM(currentPathElement);
		    if (reactParent === currentPathElement) {
		      var currentPathElementID = ReactMount.getID(currentPathElement);
		      var newRootID = ReactInstanceHandles.getReactRootIDFromNodeID(currentPathElementID);
		      bookKeeping.ancestors.push(currentPathElement);
		
		      var topLevelTargetID = ReactMount.getID(currentPathElement) || '';
		      eventsFired++;
		      ReactEventListener._handleTopLevel(bookKeeping.topLevelType, currentPathElement, topLevelTargetID, bookKeeping.nativeEvent, currentNativeTarget);
		
		      // Jump to the root of this React render tree
		      while (currentPathElementID !== newRootID) {
		        i++;
		        currentPathElement = path[i];
		        currentPathElementID = ReactMount.getID(currentPathElement);
		      }
		    }
		  }
		  if (eventsFired === 0) {
		    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, window, '', bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
		  }
		}
		
		function scrollValueMonitor(cb) {
		  var scrollPosition = getUnboundedScrollPosition(window);
		  cb(scrollPosition);
		}
		
		var ReactEventListener = {
		  _enabled: true,
		  _handleTopLevel: null,
		
		  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
		
		  setHandleTopLevel: function (handleTopLevel) {
		    ReactEventListener._handleTopLevel = handleTopLevel;
		  },
		
		  setEnabled: function (enabled) {
		    ReactEventListener._enabled = !!enabled;
		  },
		
		  isEnabled: function () {
		    return ReactEventListener._enabled;
		  },
		
		  /**
		   * Traps top-level events by using event bubbling.
		   *
		   * @param {string} topLevelType Record from `EventConstants`.
		   * @param {string} handlerBaseName Event name (e.g. "click").
		   * @param {object} handle Element on which to attach listener.
		   * @return {?object} An object with a remove function which will forcefully
		   *                  remove the listener.
		   * @internal
		   */
		  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
		    var element = handle;
		    if (!element) {
		      return null;
		    }
		    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
		  },
		
		  /**
		   * Traps a top-level event by using event capturing.
		   *
		   * @param {string} topLevelType Record from `EventConstants`.
		   * @param {string} handlerBaseName Event name (e.g. "click").
		   * @param {object} handle Element on which to attach listener.
		   * @return {?object} An object with a remove function which will forcefully
		   *                  remove the listener.
		   * @internal
		   */
		  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
		    var element = handle;
		    if (!element) {
		      return null;
		    }
		    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
		  },
		
		  monitorScrollValue: function (refresh) {
		    var callback = scrollValueMonitor.bind(null, refresh);
		    EventListener.listen(window, 'scroll', callback);
		  },
		
		  dispatchEvent: function (topLevelType, nativeEvent) {
		    if (!ReactEventListener._enabled) {
		      return;
		    }
		
		    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
		    try {
		      // Event queue being processed in the same cycle allows
		      // `preventDefault`.
		      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
		    } finally {
		      TopLevelCallbackBookKeeping.release(bookKeeping);
		    }
		  }
		};
		
		module.exports = ReactEventListener;
	
	/***/ },
	/* 119 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 * http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 *
		 * @providesModule EventListener
		 * @typechecks
		 */
		
		'use strict';
		
		var emptyFunction = __webpack_require__(15);
		
		/**
		 * Upstream version of event listener. Does not take into account specific
		 * nature of platform.
		 */
		var EventListener = {
		  /**
		   * Listen to DOM events during the bubble phase.
		   *
		   * @param {DOMEventTarget} target DOM element to register listener on.
		   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
		   * @param {function} callback Callback function.
		   * @return {object} Object with a `remove` method.
		   */
		  listen: function (target, eventType, callback) {
		    if (target.addEventListener) {
		      target.addEventListener(eventType, callback, false);
		      return {
		        remove: function () {
		          target.removeEventListener(eventType, callback, false);
		        }
		      };
		    } else if (target.attachEvent) {
		      target.attachEvent('on' + eventType, callback);
		      return {
		        remove: function () {
		          target.detachEvent('on' + eventType, callback);
		        }
		      };
		    }
		  },
		
		  /**
		   * Listen to DOM events during the capture phase.
		   *
		   * @param {DOMEventTarget} target DOM element to register listener on.
		   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
		   * @param {function} callback Callback function.
		   * @return {object} Object with a `remove` method.
		   */
		  capture: function (target, eventType, callback) {
		    if (target.addEventListener) {
		      target.addEventListener(eventType, callback, true);
		      return {
		        remove: function () {
		          target.removeEventListener(eventType, callback, true);
		        }
		      };
		    } else {
		      if (process.env.NODE_ENV !== 'production') {
		        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
		      }
		      return {
		        remove: emptyFunction
		      };
		    }
		  },
		
		  registerDefault: function () {}
		};
		
		module.exports = EventListener;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 120 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule getUnboundedScrollPosition
		 * @typechecks
		 */
		
		'use strict';
		
		/**
		 * Gets the scroll position of the supplied element or window.
		 *
		 * The return values are unbounded, unlike `getScrollPosition`. This means they
		 * may be negative or exceed the element boundaries (which is possible using
		 * inertial scrolling).
		 *
		 * @param {DOMWindow|DOMElement} scrollable
		 * @return {object} Map with `x` and `y` keys.
		 */
		function getUnboundedScrollPosition(scrollable) {
		  if (scrollable === window) {
		    return {
		      x: window.pageXOffset || document.documentElement.scrollLeft,
		      y: window.pageYOffset || document.documentElement.scrollTop
		    };
		  }
		  return {
		    x: scrollable.scrollLeft,
		    y: scrollable.scrollTop
		  };
		}
		
		module.exports = getUnboundedScrollPosition;
	
	/***/ },
	/* 121 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactInjection
		 */
		
		'use strict';
		
		var DOMProperty = __webpack_require__(23);
		var EventPluginHub = __webpack_require__(31);
		var ReactComponentEnvironment = __webpack_require__(64);
		var ReactClass = __webpack_require__(122);
		var ReactEmptyComponent = __webpack_require__(68);
		var ReactBrowserEventEmitter = __webpack_require__(29);
		var ReactNativeComponent = __webpack_require__(69);
		var ReactPerf = __webpack_require__(18);
		var ReactRootIndex = __webpack_require__(46);
		var ReactUpdates = __webpack_require__(54);
		
		var ReactInjection = {
		  Component: ReactComponentEnvironment.injection,
		  Class: ReactClass.injection,
		  DOMProperty: DOMProperty.injection,
		  EmptyComponent: ReactEmptyComponent.injection,
		  EventPluginHub: EventPluginHub.injection,
		  EventEmitter: ReactBrowserEventEmitter.injection,
		  NativeComponent: ReactNativeComponent.injection,
		  Perf: ReactPerf.injection,
		  RootIndex: ReactRootIndex.injection,
		  Updates: ReactUpdates.injection
		};
		
		module.exports = ReactInjection;
	
	/***/ },
	/* 122 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactClass
		 */
		
		'use strict';
		
		var ReactComponent = __webpack_require__(123);
		var ReactElement = __webpack_require__(42);
		var ReactPropTypeLocations = __webpack_require__(65);
		var ReactPropTypeLocationNames = __webpack_require__(66);
		var ReactNoopUpdateQueue = __webpack_require__(124);
		
		var assign = __webpack_require__(39);
		var emptyObject = __webpack_require__(58);
		var invariant = __webpack_require__(13);
		var keyMirror = __webpack_require__(17);
		var keyOf = __webpack_require__(79);
		var warning = __webpack_require__(25);
		
		var MIXINS_KEY = keyOf({ mixins: null });
		
		/**
		 * Policies that describe methods in `ReactClassInterface`.
		 */
		var SpecPolicy = keyMirror({
		  /**
		   * These methods may be defined only once by the class specification or mixin.
		   */
		  DEFINE_ONCE: null,
		  /**
		   * These methods may be defined by both the class specification and mixins.
		   * Subsequent definitions will be chained. These methods must return void.
		   */
		  DEFINE_MANY: null,
		  /**
		   * These methods are overriding the base class.
		   */
		  OVERRIDE_BASE: null,
		  /**
		   * These methods are similar to DEFINE_MANY, except we assume they return
		   * objects. We try to merge the keys of the return values of all the mixed in
		   * functions. If there is a key conflict we throw.
		   */
		  DEFINE_MANY_MERGED: null
		});
		
		var injectedMixins = [];
		
		var warnedSetProps = false;
		function warnSetProps() {
		  if (!warnedSetProps) {
		    warnedSetProps = true;
		    process.env.NODE_ENV !== 'production' ? warning(false, 'setProps(...) and replaceProps(...) are deprecated. ' + 'Instead, call render again at the top level.') : undefined;
		  }
		}
		
		/**
		 * Composite components are higher-level components that compose other composite
		 * or native components.
		 *
		 * To create a new type of `ReactClass`, pass a specification of
		 * your new class to `React.createClass`. The only requirement of your class
		 * specification is that you implement a `render` method.
		 *
		 *   var MyComponent = React.createClass({
		 *     render: function() {
		 *       return <div>Hello World</div>;
		 *     }
		 *   });
		 *
		 * The class specification supports a specific protocol of methods that have
		 * special meaning (e.g. `render`). See `ReactClassInterface` for
		 * more the comprehensive protocol. Any other properties and methods in the
		 * class specification will be available on the prototype.
		 *
		 * @interface ReactClassInterface
		 * @internal
		 */
		var ReactClassInterface = {
		
		  /**
		   * An array of Mixin objects to include when defining your component.
		   *
		   * @type {array}
		   * @optional
		   */
		  mixins: SpecPolicy.DEFINE_MANY,
		
		  /**
		   * An object containing properties and methods that should be defined on
		   * the component's constructor instead of its prototype (static methods).
		   *
		   * @type {object}
		   * @optional
		   */
		  statics: SpecPolicy.DEFINE_MANY,
		
		  /**
		   * Definition of prop types for this component.
		   *
		   * @type {object}
		   * @optional
		   */
		  propTypes: SpecPolicy.DEFINE_MANY,
		
		  /**
		   * Definition of context types for this component.
		   *
		   * @type {object}
		   * @optional
		   */
		  contextTypes: SpecPolicy.DEFINE_MANY,
		
		  /**
		   * Definition of context types this component sets for its children.
		   *
		   * @type {object}
		   * @optional
		   */
		  childContextTypes: SpecPolicy.DEFINE_MANY,
		
		  // ==== Definition methods ====
		
		  /**
		   * Invoked when the component is mounted. Values in the mapping will be set on
		   * `this.props` if that prop is not specified (i.e. using an `in` check).
		   *
		   * This method is invoked before `getInitialState` and therefore cannot rely
		   * on `this.state` or use `this.setState`.
		   *
		   * @return {object}
		   * @optional
		   */
		  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
		
		  /**
		   * Invoked once before the component is mounted. The return value will be used
		   * as the initial value of `this.state`.
		   *
		   *   getInitialState: function() {
		   *     return {
		   *       isOn: false,
		   *       fooBaz: new BazFoo()
		   *     }
		   *   }
		   *
		   * @return {object}
		   * @optional
		   */
		  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
		
		  /**
		   * @return {object}
		   * @optional
		   */
		  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
		
		  /**
		   * Uses props from `this.props` and state from `this.state` to render the
		   * structure of the component.
		   *
		   * No guarantees are made about when or how often this method is invoked, so
		   * it must not have side effects.
		   *
		   *   render: function() {
		   *     var name = this.props.name;
		   *     return <div>Hello, {name}!</div>;
		   *   }
		   *
		   * @return {ReactComponent}
		   * @nosideeffects
		   * @required
		   */
		  render: SpecPolicy.DEFINE_ONCE,
		
		  // ==== Delegate methods ====
		
		  /**
		   * Invoked when the component is initially created and about to be mounted.
		   * This may have side effects, but any external subscriptions or data created
		   * by this method must be cleaned up in `componentWillUnmount`.
		   *
		   * @optional
		   */
		  componentWillMount: SpecPolicy.DEFINE_MANY,
		
		  /**
		   * Invoked when the component has been mounted and has a DOM representation.
		   * However, there is no guarantee that the DOM node is in the document.
		   *
		   * Use this as an opportunity to operate on the DOM when the component has
		   * been mounted (initialized and rendered) for the first time.
		   *
		   * @param {DOMElement} rootNode DOM element representing the component.
		   * @optional
		   */
		  componentDidMount: SpecPolicy.DEFINE_MANY,
		
		  /**
		   * Invoked before the component receives new props.
		   *
		   * Use this as an opportunity to react to a prop transition by updating the
		   * state using `this.setState`. Current props are accessed via `this.props`.
		   *
		   *   componentWillReceiveProps: function(nextProps, nextContext) {
		   *     this.setState({
		   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
		   *     });
		   *   }
		   *
		   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
		   * transition may cause a state change, but the opposite is not true. If you
		   * need it, you are probably looking for `componentWillUpdate`.
		   *
		   * @param {object} nextProps
		   * @optional
		   */
		  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
		
		  /**
		   * Invoked while deciding if the component should be updated as a result of
		   * receiving new props, state and/or context.
		   *
		   * Use this as an opportunity to `return false` when you're certain that the
		   * transition to the new props/state/context will not require a component
		   * update.
		   *
		   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
		   *     return !equal(nextProps, this.props) ||
		   *       !equal(nextState, this.state) ||
		   *       !equal(nextContext, this.context);
		   *   }
		   *
		   * @param {object} nextProps
		   * @param {?object} nextState
		   * @param {?object} nextContext
		   * @return {boolean} True if the component should update.
		   * @optional
		   */
		  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
		
		  /**
		   * Invoked when the component is about to update due to a transition from
		   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
		   * and `nextContext`.
		   *
		   * Use this as an opportunity to perform preparation before an update occurs.
		   *
		   * NOTE: You **cannot** use `this.setState()` in this method.
		   *
		   * @param {object} nextProps
		   * @param {?object} nextState
		   * @param {?object} nextContext
		   * @param {ReactReconcileTransaction} transaction
		   * @optional
		   */
		  componentWillUpdate: SpecPolicy.DEFINE_MANY,
		
		  /**
		   * Invoked when the component's DOM representation has been updated.
		   *
		   * Use this as an opportunity to operate on the DOM when the component has
		   * been updated.
		   *
		   * @param {object} prevProps
		   * @param {?object} prevState
		   * @param {?object} prevContext
		   * @param {DOMElement} rootNode DOM element representing the component.
		   * @optional
		   */
		  componentDidUpdate: SpecPolicy.DEFINE_MANY,
		
		  /**
		   * Invoked when the component is about to be removed from its parent and have
		   * its DOM representation destroyed.
		   *
		   * Use this as an opportunity to deallocate any external resources.
		   *
		   * NOTE: There is no `componentDidUnmount` since your component will have been
		   * destroyed by that point.
		   *
		   * @optional
		   */
		  componentWillUnmount: SpecPolicy.DEFINE_MANY,
		
		  // ==== Advanced methods ====
		
		  /**
		   * Updates the component's currently mounted DOM representation.
		   *
		   * By default, this implements React's rendering and reconciliation algorithm.
		   * Sophisticated clients may wish to override this.
		   *
		   * @param {ReactReconcileTransaction} transaction
		   * @internal
		   * @overridable
		   */
		  updateComponent: SpecPolicy.OVERRIDE_BASE
		
		};
		
		/**
		 * Mapping from class specification keys to special processing functions.
		 *
		 * Although these are declared like instance properties in the specification
		 * when defining classes using `React.createClass`, they are actually static
		 * and are accessible on the constructor instead of the prototype. Despite
		 * being static, they must be defined outside of the "statics" key under
		 * which all other static methods are defined.
		 */
		var RESERVED_SPEC_KEYS = {
		  displayName: function (Constructor, displayName) {
		    Constructor.displayName = displayName;
		  },
		  mixins: function (Constructor, mixins) {
		    if (mixins) {
		      for (var i = 0; i < mixins.length; i++) {
		        mixSpecIntoComponent(Constructor, mixins[i]);
		      }
		    }
		  },
		  childContextTypes: function (Constructor, childContextTypes) {
		    if (process.env.NODE_ENV !== 'production') {
		      validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
		    }
		    Constructor.childContextTypes = assign({}, Constructor.childContextTypes, childContextTypes);
		  },
		  contextTypes: function (Constructor, contextTypes) {
		    if (process.env.NODE_ENV !== 'production') {
		      validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
		    }
		    Constructor.contextTypes = assign({}, Constructor.contextTypes, contextTypes);
		  },
		  /**
		   * Special case getDefaultProps which should move into statics but requires
		   * automatic merging.
		   */
		  getDefaultProps: function (Constructor, getDefaultProps) {
		    if (Constructor.getDefaultProps) {
		      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
		    } else {
		      Constructor.getDefaultProps = getDefaultProps;
		    }
		  },
		  propTypes: function (Constructor, propTypes) {
		    if (process.env.NODE_ENV !== 'production') {
		      validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
		    }
		    Constructor.propTypes = assign({}, Constructor.propTypes, propTypes);
		  },
		  statics: function (Constructor, statics) {
		    mixStaticSpecIntoComponent(Constructor, statics);
		  },
		  autobind: function () {} };
		
		// noop
		function validateTypeDef(Constructor, typeDef, location) {
		  for (var propName in typeDef) {
		    if (typeDef.hasOwnProperty(propName)) {
		      // use a warning instead of an invariant so components
		      // don't show up in prod but not in __DEV__
		      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : undefined;
		    }
		  }
		}
		
		function validateMethodOverride(proto, name) {
		  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
		
		  // Disallow overriding of base class methods unless explicitly allowed.
		  if (ReactClassMixin.hasOwnProperty(name)) {
		    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(false) : undefined;
		  }
		
		  // Disallow defining methods more than once unless explicitly allowed.
		  if (proto.hasOwnProperty(name)) {
		    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(false) : undefined;
		  }
		}
		
		/**
		 * Mixin helper which handles policy validation and reserved
		 * specification keys when building React classses.
		 */
		function mixSpecIntoComponent(Constructor, spec) {
		  if (!spec) {
		    return;
		  }
		
		  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
		  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
		
		  var proto = Constructor.prototype;
		
		  // By handling mixins before any other properties, we ensure the same
		  // chaining order is applied to methods with DEFINE_MANY policy, whether
		  // mixins are listed before or after these methods in the spec.
		  if (spec.hasOwnProperty(MIXINS_KEY)) {
		    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
		  }
		
		  for (var name in spec) {
		    if (!spec.hasOwnProperty(name)) {
		      continue;
		    }
		
		    if (name === MIXINS_KEY) {
		      // We have already handled mixins in a special case above.
		      continue;
		    }
		
		    var property = spec[name];
		    validateMethodOverride(proto, name);
		
		    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
		      RESERVED_SPEC_KEYS[name](Constructor, property);
		    } else {
		      // Setup methods on prototype:
		      // The following member methods should not be automatically bound:
		      // 1. Expected ReactClass methods (in the "interface").
		      // 2. Overridden methods (that were mixed in).
		      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
		      var isAlreadyDefined = proto.hasOwnProperty(name);
		      var isFunction = typeof property === 'function';
		      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
		
		      if (shouldAutoBind) {
		        if (!proto.__reactAutoBindMap) {
		          proto.__reactAutoBindMap = {};
		        }
		        proto.__reactAutoBindMap[name] = property;
		        proto[name] = property;
		      } else {
		        if (isAlreadyDefined) {
		          var specPolicy = ReactClassInterface[name];
		
		          // These cases should already be caught by validateMethodOverride.
		          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(false) : undefined;
		
		          // For methods which are defined more than once, call the existing
		          // methods before calling the new property, merging if appropriate.
		          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
		            proto[name] = createMergedResultFunction(proto[name], property);
		          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
		            proto[name] = createChainedFunction(proto[name], property);
		          }
		        } else {
		          proto[name] = property;
		          if (process.env.NODE_ENV !== 'production') {
		            // Add verbose displayName to the function, which helps when looking
		            // at profiling tools.
		            if (typeof property === 'function' && spec.displayName) {
		              proto[name].displayName = spec.displayName + '_' + name;
		            }
		          }
		        }
		      }
		    }
		  }
		}
		
		function mixStaticSpecIntoComponent(Constructor, statics) {
		  if (!statics) {
		    return;
		  }
		  for (var name in statics) {
		    var property = statics[name];
		    if (!statics.hasOwnProperty(name)) {
		      continue;
		    }
		
		    var isReserved = (name in RESERVED_SPEC_KEYS);
		    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(false) : undefined;
		
		    var isInherited = (name in Constructor);
		    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(false) : undefined;
		    Constructor[name] = property;
		  }
		}
		
		/**
		 * Merge two objects, but throw if both contain the same key.
		 *
		 * @param {object} one The first object, which is mutated.
		 * @param {object} two The second object
		 * @return {object} one after it has been mutated to contain everything in two.
		 */
		function mergeIntoWithNoDuplicateKeys(one, two) {
		  !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : invariant(false) : undefined;
		
		  for (var key in two) {
		    if (two.hasOwnProperty(key)) {
		      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(false) : undefined;
		      one[key] = two[key];
		    }
		  }
		  return one;
		}
		
		/**
		 * Creates a function that invokes two functions and merges their return values.
		 *
		 * @param {function} one Function to invoke first.
		 * @param {function} two Function to invoke second.
		 * @return {function} Function that invokes the two argument functions.
		 * @private
		 */
		function createMergedResultFunction(one, two) {
		  return function mergedResult() {
		    var a = one.apply(this, arguments);
		    var b = two.apply(this, arguments);
		    if (a == null) {
		      return b;
		    } else if (b == null) {
		      return a;
		    }
		    var c = {};
		    mergeIntoWithNoDuplicateKeys(c, a);
		    mergeIntoWithNoDuplicateKeys(c, b);
		    return c;
		  };
		}
		
		/**
		 * Creates a function that invokes two functions and ignores their return vales.
		 *
		 * @param {function} one Function to invoke first.
		 * @param {function} two Function to invoke second.
		 * @return {function} Function that invokes the two argument functions.
		 * @private
		 */
		function createChainedFunction(one, two) {
		  return function chainedFunction() {
		    one.apply(this, arguments);
		    two.apply(this, arguments);
		  };
		}
		
		/**
		 * Binds a method to the component.
		 *
		 * @param {object} component Component whose method is going to be bound.
		 * @param {function} method Method to be bound.
		 * @return {function} The bound method.
		 */
		function bindAutoBindMethod(component, method) {
		  var boundMethod = method.bind(component);
		  if (process.env.NODE_ENV !== 'production') {
		    boundMethod.__reactBoundContext = component;
		    boundMethod.__reactBoundMethod = method;
		    boundMethod.__reactBoundArguments = null;
		    var componentName = component.constructor.displayName;
		    var _bind = boundMethod.bind;
		    /* eslint-disable block-scoped-var, no-undef */
		    boundMethod.bind = function (newThis) {
		      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		        args[_key - 1] = arguments[_key];
		      }
		
		      // User is trying to bind() an autobound method; we effectively will
		      // ignore the value of "this" that the user is trying to use, so
		      // let's warn.
		      if (newThis !== component && newThis !== null) {
		        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : undefined;
		      } else if (!args.length) {
		        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : undefined;
		        return boundMethod;
		      }
		      var reboundMethod = _bind.apply(boundMethod, arguments);
		      reboundMethod.__reactBoundContext = component;
		      reboundMethod.__reactBoundMethod = method;
		      reboundMethod.__reactBoundArguments = args;
		      return reboundMethod;
		      /* eslint-enable */
		    };
		  }
		  return boundMethod;
		}
		
		/**
		 * Binds all auto-bound methods in a component.
		 *
		 * @param {object} component Component whose method is going to be bound.
		 */
		function bindAutoBindMethods(component) {
		  for (var autoBindKey in component.__reactAutoBindMap) {
		    if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
		      var method = component.__reactAutoBindMap[autoBindKey];
		      component[autoBindKey] = bindAutoBindMethod(component, method);
		    }
		  }
		}
		
		/**
		 * Add more to the ReactClass base class. These are all legacy features and
		 * therefore not already part of the modern ReactComponent.
		 */
		var ReactClassMixin = {
		
		  /**
		   * TODO: This will be deprecated because state should always keep a consistent
		   * type signature and the only use case for this, is to avoid that.
		   */
		  replaceState: function (newState, callback) {
		    this.updater.enqueueReplaceState(this, newState);
		    if (callback) {
		      this.updater.enqueueCallback(this, callback);
		    }
		  },
		
		  /**
		   * Checks whether or not this composite component is mounted.
		   * @return {boolean} True if mounted, false otherwise.
		   * @protected
		   * @final
		   */
		  isMounted: function () {
		    return this.updater.isMounted(this);
		  },
		
		  /**
		   * Sets a subset of the props.
		   *
		   * @param {object} partialProps Subset of the next props.
		   * @param {?function} callback Called after props are updated.
		   * @final
		   * @public
		   * @deprecated
		   */
		  setProps: function (partialProps, callback) {
		    if (process.env.NODE_ENV !== 'production') {
		      warnSetProps();
		    }
		    this.updater.enqueueSetProps(this, partialProps);
		    if (callback) {
		      this.updater.enqueueCallback(this, callback);
		    }
		  },
		
		  /**
		   * Replace all the props.
		   *
		   * @param {object} newProps Subset of the next props.
		   * @param {?function} callback Called after props are updated.
		   * @final
		   * @public
		   * @deprecated
		   */
		  replaceProps: function (newProps, callback) {
		    if (process.env.NODE_ENV !== 'production') {
		      warnSetProps();
		    }
		    this.updater.enqueueReplaceProps(this, newProps);
		    if (callback) {
		      this.updater.enqueueCallback(this, callback);
		    }
		  }
		};
		
		var ReactClassComponent = function () {};
		assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
		
		/**
		 * Module for creating composite components.
		 *
		 * @class ReactClass
		 */
		var ReactClass = {
		
		  /**
		   * Creates a composite component class given a class specification.
		   *
		   * @param {object} spec Class specification (which must define `render`).
		   * @return {function} Component constructor function.
		   * @public
		   */
		  createClass: function (spec) {
		    var Constructor = function (props, context, updater) {
		      // This constructor is overridden by mocks. The argument is used
		      // by mocks to assert on what gets mounted.
		
		      if (process.env.NODE_ENV !== 'production') {
		        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : undefined;
		      }
		
		      // Wire up auto-binding
		      if (this.__reactAutoBindMap) {
		        bindAutoBindMethods(this);
		      }
		
		      this.props = props;
		      this.context = context;
		      this.refs = emptyObject;
		      this.updater = updater || ReactNoopUpdateQueue;
		
		      this.state = null;
		
		      // ReactClasses doesn't have constructors. Instead, they use the
		      // getInitialState and componentWillMount methods for initialization.
		
		      var initialState = this.getInitialState ? this.getInitialState() : null;
		      if (process.env.NODE_ENV !== 'production') {
		        // We allow auto-mocks to proceed as if they're returning null.
		        if (typeof initialState === 'undefined' && this.getInitialState._isMockFunction) {
		          // This is probably bad practice. Consider warning here and
		          // deprecating this convenience.
		          initialState = null;
		        }
		      }
		      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : invariant(false) : undefined;
		
		      this.state = initialState;
		    };
		    Constructor.prototype = new ReactClassComponent();
		    Constructor.prototype.constructor = Constructor;
		
		    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
		
		    mixSpecIntoComponent(Constructor, spec);
		
		    // Initialize the defaultProps property after all mixins have been merged.
		    if (Constructor.getDefaultProps) {
		      Constructor.defaultProps = Constructor.getDefaultProps();
		    }
		
		    if (process.env.NODE_ENV !== 'production') {
		      // This is a tag to indicate that the use of these method names is ok,
		      // since it's used with createClass. If it's not, then it's likely a
		      // mistake so we'll warn you to use the static property, property
		      // initializer or constructor respectively.
		      if (Constructor.getDefaultProps) {
		        Constructor.getDefaultProps.isReactClassApproved = {};
		      }
		      if (Constructor.prototype.getInitialState) {
		        Constructor.prototype.getInitialState.isReactClassApproved = {};
		      }
		    }
		
		    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : invariant(false) : undefined;
		
		    if (process.env.NODE_ENV !== 'production') {
		      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : undefined;
		      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : undefined;
		    }
		
		    // Reduce time spent doing lookups by setting these on the prototype.
		    for (var methodName in ReactClassInterface) {
		      if (!Constructor.prototype[methodName]) {
		        Constructor.prototype[methodName] = null;
		      }
		    }
		
		    return Constructor;
		  },
		
		  injection: {
		    injectMixin: function (mixin) {
		      injectedMixins.push(mixin);
		    }
		  }
		
		};
		
		module.exports = ReactClass;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 123 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactComponent
		 */
		
		'use strict';
		
		var ReactNoopUpdateQueue = __webpack_require__(124);
		
		var canDefineProperty = __webpack_require__(43);
		var emptyObject = __webpack_require__(58);
		var invariant = __webpack_require__(13);
		var warning = __webpack_require__(25);
		
		/**
		 * Base class helpers for the updating state of a component.
		 */
		function ReactComponent(props, context, updater) {
		  this.props = props;
		  this.context = context;
		  this.refs = emptyObject;
		  // We initialize the default updater but the real one gets injected by the
		  // renderer.
		  this.updater = updater || ReactNoopUpdateQueue;
		}
		
		ReactComponent.prototype.isReactComponent = {};
		
		/**
		 * Sets a subset of the state. Always use this to mutate
		 * state. You should treat `this.state` as immutable.
		 *
		 * There is no guarantee that `this.state` will be immediately updated, so
		 * accessing `this.state` after calling this method may return the old value.
		 *
		 * There is no guarantee that calls to `setState` will run synchronously,
		 * as they may eventually be batched together.  You can provide an optional
		 * callback that will be executed when the call to setState is actually
		 * completed.
		 *
		 * When a function is provided to setState, it will be called at some point in
		 * the future (not synchronously). It will be called with the up to date
		 * component arguments (state, props, context). These values can be different
		 * from this.* because your function may be called after receiveProps but before
		 * shouldComponentUpdate, and this new state, props, and context will not yet be
		 * assigned to this.
		 *
		 * @param {object|function} partialState Next partial state or function to
		 *        produce next partial state to be merged with current state.
		 * @param {?function} callback Called after state is updated.
		 * @final
		 * @protected
		 */
		ReactComponent.prototype.setState = function (partialState, callback) {
		  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.') : invariant(false) : undefined;
		  if (process.env.NODE_ENV !== 'production') {
		    process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : undefined;
		  }
		  this.updater.enqueueSetState(this, partialState);
		  if (callback) {
		    this.updater.enqueueCallback(this, callback);
		  }
		};
		
		/**
		 * Forces an update. This should only be invoked when it is known with
		 * certainty that we are **not** in a DOM transaction.
		 *
		 * You may want to call this when you know that some deeper aspect of the
		 * component's state has changed but `setState` was not called.
		 *
		 * This will not invoke `shouldComponentUpdate`, but it will invoke
		 * `componentWillUpdate` and `componentDidUpdate`.
		 *
		 * @param {?function} callback Called after update is complete.
		 * @final
		 * @protected
		 */
		ReactComponent.prototype.forceUpdate = function (callback) {
		  this.updater.enqueueForceUpdate(this);
		  if (callback) {
		    this.updater.enqueueCallback(this, callback);
		  }
		};
		
		/**
		 * Deprecated APIs. These APIs used to exist on classic React classes but since
		 * we would like to deprecate them, we're not going to move them over to this
		 * modern base class. Instead, we define a getter that warns if it's accessed.
		 */
		if (process.env.NODE_ENV !== 'production') {
		  var deprecatedAPIs = {
		    getDOMNode: ['getDOMNode', 'Use ReactDOM.findDOMNode(component) instead.'],
		    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
		    replaceProps: ['replaceProps', 'Instead, call render again at the top level.'],
		    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'],
		    setProps: ['setProps', 'Instead, call render again at the top level.']
		  };
		  var defineDeprecationWarning = function (methodName, info) {
		    if (canDefineProperty) {
		      Object.defineProperty(ReactComponent.prototype, methodName, {
		        get: function () {
		          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : undefined;
		          return undefined;
		        }
		      });
		    }
		  };
		  for (var fnName in deprecatedAPIs) {
		    if (deprecatedAPIs.hasOwnProperty(fnName)) {
		      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
		    }
		  }
		}
		
		module.exports = ReactComponent;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 124 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactNoopUpdateQueue
		 */
		
		'use strict';
		
		var warning = __webpack_require__(25);
		
		function warnTDZ(publicInstance, callerName) {
		  if (process.env.NODE_ENV !== 'production') {
		    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor && publicInstance.constructor.displayName || '') : undefined;
		  }
		}
		
		/**
		 * This is the abstract API for an update queue.
		 */
		var ReactNoopUpdateQueue = {
		
		  /**
		   * Checks whether or not this composite component is mounted.
		   * @param {ReactClass} publicInstance The instance we want to test.
		   * @return {boolean} True if mounted, false otherwise.
		   * @protected
		   * @final
		   */
		  isMounted: function (publicInstance) {
		    return false;
		  },
		
		  /**
		   * Enqueue a callback that will be executed after all the pending updates
		   * have processed.
		   *
		   * @param {ReactClass} publicInstance The instance to use as `this` context.
		   * @param {?function} callback Called after state is updated.
		   * @internal
		   */
		  enqueueCallback: function (publicInstance, callback) {},
		
		  /**
		   * Forces an update. This should only be invoked when it is known with
		   * certainty that we are **not** in a DOM transaction.
		   *
		   * You may want to call this when you know that some deeper aspect of the
		   * component's state has changed but `setState` was not called.
		   *
		   * This will not invoke `shouldComponentUpdate`, but it will invoke
		   * `componentWillUpdate` and `componentDidUpdate`.
		   *
		   * @param {ReactClass} publicInstance The instance that should rerender.
		   * @internal
		   */
		  enqueueForceUpdate: function (publicInstance) {
		    warnTDZ(publicInstance, 'forceUpdate');
		  },
		
		  /**
		   * Replaces all of the state. Always use this or `setState` to mutate state.
		   * You should treat `this.state` as immutable.
		   *
		   * There is no guarantee that `this.state` will be immediately updated, so
		   * accessing `this.state` after calling this method may return the old value.
		   *
		   * @param {ReactClass} publicInstance The instance that should rerender.
		   * @param {object} completeState Next state.
		   * @internal
		   */
		  enqueueReplaceState: function (publicInstance, completeState) {
		    warnTDZ(publicInstance, 'replaceState');
		  },
		
		  /**
		   * Sets a subset of the state. This only exists because _pendingState is
		   * internal. This provides a merging strategy that is not available to deep
		   * properties which is confusing. TODO: Expose pendingState or don't use it
		   * during the merge.
		   *
		   * @param {ReactClass} publicInstance The instance that should rerender.
		   * @param {object} partialState Next partial state to be merged with state.
		   * @internal
		   */
		  enqueueSetState: function (publicInstance, partialState) {
		    warnTDZ(publicInstance, 'setState');
		  },
		
		  /**
		   * Sets a subset of the props.
		   *
		   * @param {ReactClass} publicInstance The instance that should rerender.
		   * @param {object} partialProps Subset of the next props.
		   * @internal
		   */
		  enqueueSetProps: function (publicInstance, partialProps) {
		    warnTDZ(publicInstance, 'setProps');
		  },
		
		  /**
		   * Replaces all of the props.
		   *
		   * @param {ReactClass} publicInstance The instance that should rerender.
		   * @param {object} props New props.
		   * @internal
		   */
		  enqueueReplaceProps: function (publicInstance, props) {
		    warnTDZ(publicInstance, 'replaceProps');
		  }
		
		};
		
		module.exports = ReactNoopUpdateQueue;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 125 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactReconcileTransaction
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var CallbackQueue = __webpack_require__(55);
		var PooledClass = __webpack_require__(56);
		var ReactBrowserEventEmitter = __webpack_require__(29);
		var ReactDOMFeatureFlags = __webpack_require__(41);
		var ReactInputSelection = __webpack_require__(126);
		var Transaction = __webpack_require__(57);
		
		var assign = __webpack_require__(39);
		
		/**
		 * Ensures that, when possible, the selection range (currently selected text
		 * input) is not disturbed by performing the transaction.
		 */
		var SELECTION_RESTORATION = {
		  /**
		   * @return {Selection} Selection information.
		   */
		  initialize: ReactInputSelection.getSelectionInformation,
		  /**
		   * @param {Selection} sel Selection information returned from `initialize`.
		   */
		  close: ReactInputSelection.restoreSelection
		};
		
		/**
		 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
		 * high level DOM manipulations (like temporarily removing a text input from the
		 * DOM).
		 */
		var EVENT_SUPPRESSION = {
		  /**
		   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
		   * the reconciliation.
		   */
		  initialize: function () {
		    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
		    ReactBrowserEventEmitter.setEnabled(false);
		    return currentlyEnabled;
		  },
		
		  /**
		   * @param {boolean} previouslyEnabled Enabled status of
		   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
		   *   restores the previous value.
		   */
		  close: function (previouslyEnabled) {
		    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
		  }
		};
		
		/**
		 * Provides a queue for collecting `componentDidMount` and
		 * `componentDidUpdate` callbacks during the the transaction.
		 */
		var ON_DOM_READY_QUEUEING = {
		  /**
		   * Initializes the internal `onDOMReady` queue.
		   */
		  initialize: function () {
		    this.reactMountReady.reset();
		  },
		
		  /**
		   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
		   */
		  close: function () {
		    this.reactMountReady.notifyAll();
		  }
		};
		
		/**
		 * Executed within the scope of the `Transaction` instance. Consider these as
		 * being member methods, but with an implied ordering while being isolated from
		 * each other.
		 */
		var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
		
		/**
		 * Currently:
		 * - The order that these are listed in the transaction is critical:
		 * - Suppresses events.
		 * - Restores selection range.
		 *
		 * Future:
		 * - Restore document/overflow scroll positions that were unintentionally
		 *   modified via DOM insertions above the top viewport boundary.
		 * - Implement/integrate with customized constraint based layout system and keep
		 *   track of which dimensions must be remeasured.
		 *
		 * @class ReactReconcileTransaction
		 */
		function ReactReconcileTransaction(forceHTML) {
		  this.reinitializeTransaction();
		  // Only server-side rendering really needs this option (see
		  // `ReactServerRendering`), but server-side uses
		  // `ReactServerRenderingTransaction` instead. This option is here so that it's
		  // accessible and defaults to false when `ReactDOMComponent` and
		  // `ReactTextComponent` checks it in `mountComponent`.`
		  this.renderToStaticMarkup = false;
		  this.reactMountReady = CallbackQueue.getPooled(null);
		  this.useCreateElement = !forceHTML && ReactDOMFeatureFlags.useCreateElement;
		}
		
		var Mixin = {
		  /**
		   * @see Transaction
		   * @abstract
		   * @final
		   * @return {array<object>} List of operation wrap procedures.
		   *   TODO: convert to array<TransactionWrapper>
		   */
		  getTransactionWrappers: function () {
		    return TRANSACTION_WRAPPERS;
		  },
		
		  /**
		   * @return {object} The queue to collect `onDOMReady` callbacks with.
		   */
		  getReactMountReady: function () {
		    return this.reactMountReady;
		  },
		
		  /**
		   * `PooledClass` looks for this, and will invoke this before allowing this
		   * instance to be reused.
		   */
		  destructor: function () {
		    CallbackQueue.release(this.reactMountReady);
		    this.reactMountReady = null;
		  }
		};
		
		assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
		
		PooledClass.addPoolingTo(ReactReconcileTransaction);
		
		module.exports = ReactReconcileTransaction;
	
	/***/ },
	/* 126 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactInputSelection
		 */
		
		'use strict';
		
		var ReactDOMSelection = __webpack_require__(127);
		
		var containsNode = __webpack_require__(59);
		var focusNode = __webpack_require__(95);
		var getActiveElement = __webpack_require__(129);
		
		function isInDocument(node) {
		  return containsNode(document.documentElement, node);
		}
		
		/**
		 * @ReactInputSelection: React input selection module. Based on Selection.js,
		 * but modified to be suitable for react and has a couple of bug fixes (doesn't
		 * assume buttons have range selections allowed).
		 * Input selection module for React.
		 */
		var ReactInputSelection = {
		
		  hasSelectionCapabilities: function (elem) {
		    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
		    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
		  },
		
		  getSelectionInformation: function () {
		    var focusedElem = getActiveElement();
		    return {
		      focusedElem: focusedElem,
		      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
		    };
		  },
		
		  /**
		   * @restoreSelection: If any selection information was potentially lost,
		   * restore it. This is useful when performing operations that could remove dom
		   * nodes and place them back in, resulting in focus being lost.
		   */
		  restoreSelection: function (priorSelectionInformation) {
		    var curFocusedElem = getActiveElement();
		    var priorFocusedElem = priorSelectionInformation.focusedElem;
		    var priorSelectionRange = priorSelectionInformation.selectionRange;
		    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
		      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
		        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
		      }
		      focusNode(priorFocusedElem);
		    }
		  },
		
		  /**
		   * @getSelection: Gets the selection bounds of a focused textarea, input or
		   * contentEditable node.
		   * -@input: Look up selection bounds of this input
		   * -@return {start: selectionStart, end: selectionEnd}
		   */
		  getSelection: function (input) {
		    var selection;
		
		    if ('selectionStart' in input) {
		      // Modern browser with input or textarea.
		      selection = {
		        start: input.selectionStart,
		        end: input.selectionEnd
		      };
		    } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {
		      // IE8 input.
		      var range = document.selection.createRange();
		      // There can only be one selection per document in IE, so it must
		      // be in our element.
		      if (range.parentElement() === input) {
		        selection = {
		          start: -range.moveStart('character', -input.value.length),
		          end: -range.moveEnd('character', -input.value.length)
		        };
		      }
		    } else {
		      // Content editable or old IE textarea.
		      selection = ReactDOMSelection.getOffsets(input);
		    }
		
		    return selection || { start: 0, end: 0 };
		  },
		
		  /**
		   * @setSelection: Sets the selection bounds of a textarea or input and focuses
		   * the input.
		   * -@input     Set selection bounds of this input or textarea
		   * -@offsets   Object of same form that is returned from get*
		   */
		  setSelection: function (input, offsets) {
		    var start = offsets.start;
		    var end = offsets.end;
		    if (typeof end === 'undefined') {
		      end = start;
		    }
		
		    if ('selectionStart' in input) {
		      input.selectionStart = start;
		      input.selectionEnd = Math.min(end, input.value.length);
		    } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {
		      var range = input.createTextRange();
		      range.collapse(true);
		      range.moveStart('character', start);
		      range.moveEnd('character', end - start);
		      range.select();
		    } else {
		      ReactDOMSelection.setOffsets(input, offsets);
		    }
		  }
		};
		
		module.exports = ReactInputSelection;
	
	/***/ },
	/* 127 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactDOMSelection
		 */
		
		'use strict';
		
		var ExecutionEnvironment = __webpack_require__(9);
		
		var getNodeForCharacterOffset = __webpack_require__(128);
		var getTextContentAccessor = __webpack_require__(75);
		
		/**
		 * While `isCollapsed` is available on the Selection object and `collapsed`
		 * is available on the Range object, IE11 sometimes gets them wrong.
		 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
		 */
		function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
		  return anchorNode === focusNode && anchorOffset === focusOffset;
		}
		
		/**
		 * Get the appropriate anchor and focus node/offset pairs for IE.
		 *
		 * The catch here is that IE's selection API doesn't provide information
		 * about whether the selection is forward or backward, so we have to
		 * behave as though it's always forward.
		 *
		 * IE text differs from modern selection in that it behaves as though
		 * block elements end with a new line. This means character offsets will
		 * differ between the two APIs.
		 *
		 * @param {DOMElement} node
		 * @return {object}
		 */
		function getIEOffsets(node) {
		  var selection = document.selection;
		  var selectedRange = selection.createRange();
		  var selectedLength = selectedRange.text.length;
		
		  // Duplicate selection so we can move range without breaking user selection.
		  var fromStart = selectedRange.duplicate();
		  fromStart.moveToElementText(node);
		  fromStart.setEndPoint('EndToStart', selectedRange);
		
		  var startOffset = fromStart.text.length;
		  var endOffset = startOffset + selectedLength;
		
		  return {
		    start: startOffset,
		    end: endOffset
		  };
		}
		
		/**
		 * @param {DOMElement} node
		 * @return {?object}
		 */
		function getModernOffsets(node) {
		  var selection = window.getSelection && window.getSelection();
		
		  if (!selection || selection.rangeCount === 0) {
		    return null;
		  }
		
		  var anchorNode = selection.anchorNode;
		  var anchorOffset = selection.anchorOffset;
		  var focusNode = selection.focusNode;
		  var focusOffset = selection.focusOffset;
		
		  var currentRange = selection.getRangeAt(0);
		
		  // In Firefox, range.startContainer and range.endContainer can be "anonymous
		  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
		  // divs do not seem to expose properties, triggering a "Permission denied
		  // error" if any of its properties are accessed. The only seemingly possible
		  // way to avoid erroring is to access a property that typically works for
		  // non-anonymous divs and catch any error that may otherwise arise. See
		  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
		  try {
		    /* eslint-disable no-unused-expressions */
		    currentRange.startContainer.nodeType;
		    currentRange.endContainer.nodeType;
		    /* eslint-enable no-unused-expressions */
		  } catch (e) {
		    return null;
		  }
		
		  // If the node and offset values are the same, the selection is collapsed.
		  // `Selection.isCollapsed` is available natively, but IE sometimes gets
		  // this value wrong.
		  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
		
		  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
		
		  var tempRange = currentRange.cloneRange();
		  tempRange.selectNodeContents(node);
		  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
		
		  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
		
		  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
		  var end = start + rangeLength;
		
		  // Detect whether the selection is backward.
		  var detectionRange = document.createRange();
		  detectionRange.setStart(anchorNode, anchorOffset);
		  detectionRange.setEnd(focusNode, focusOffset);
		  var isBackward = detectionRange.collapsed;
		
		  return {
		    start: isBackward ? end : start,
		    end: isBackward ? start : end
		  };
		}
		
		/**
		 * @param {DOMElement|DOMTextNode} node
		 * @param {object} offsets
		 */
		function setIEOffsets(node, offsets) {
		  var range = document.selection.createRange().duplicate();
		  var start, end;
		
		  if (typeof offsets.end === 'undefined') {
		    start = offsets.start;
		    end = start;
		  } else if (offsets.start > offsets.end) {
		    start = offsets.end;
		    end = offsets.start;
		  } else {
		    start = offsets.start;
		    end = offsets.end;
		  }
		
		  range.moveToElementText(node);
		  range.moveStart('character', start);
		  range.setEndPoint('EndToStart', range);
		  range.moveEnd('character', end - start);
		  range.select();
		}
		
		/**
		 * In modern non-IE browsers, we can support both forward and backward
		 * selections.
		 *
		 * Note: IE10+ supports the Selection object, but it does not support
		 * the `extend` method, which means that even in modern IE, it's not possible
		 * to programatically create a backward selection. Thus, for all IE
		 * versions, we use the old IE API to create our selections.
		 *
		 * @param {DOMElement|DOMTextNode} node
		 * @param {object} offsets
		 */
		function setModernOffsets(node, offsets) {
		  if (!window.getSelection) {
		    return;
		  }
		
		  var selection = window.getSelection();
		  var length = node[getTextContentAccessor()].length;
		  var start = Math.min(offsets.start, length);
		  var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);
		
		  // IE 11 uses modern selection, but doesn't support the extend method.
		  // Flip backward selections, so we can set with a single range.
		  if (!selection.extend && start > end) {
		    var temp = end;
		    end = start;
		    start = temp;
		  }
		
		  var startMarker = getNodeForCharacterOffset(node, start);
		  var endMarker = getNodeForCharacterOffset(node, end);
		
		  if (startMarker && endMarker) {
		    var range = document.createRange();
		    range.setStart(startMarker.node, startMarker.offset);
		    selection.removeAllRanges();
		
		    if (start > end) {
		      selection.addRange(range);
		      selection.extend(endMarker.node, endMarker.offset);
		    } else {
		      range.setEnd(endMarker.node, endMarker.offset);
		      selection.addRange(range);
		    }
		  }
		}
		
		var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
		
		var ReactDOMSelection = {
		  /**
		   * @param {DOMElement} node
		   */
		  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
		
		  /**
		   * @param {DOMElement|DOMTextNode} node
		   * @param {object} offsets
		   */
		  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
		};
		
		module.exports = ReactDOMSelection;
	
	/***/ },
	/* 128 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule getNodeForCharacterOffset
		 */
		
		'use strict';
		
		/**
		 * Given any node return the first leaf node without children.
		 *
		 * @param {DOMElement|DOMTextNode} node
		 * @return {DOMElement|DOMTextNode}
		 */
		function getLeafNode(node) {
		  while (node && node.firstChild) {
		    node = node.firstChild;
		  }
		  return node;
		}
		
		/**
		 * Get the next sibling within a container. This will walk up the
		 * DOM if a node's siblings have been exhausted.
		 *
		 * @param {DOMElement|DOMTextNode} node
		 * @return {?DOMElement|DOMTextNode}
		 */
		function getSiblingNode(node) {
		  while (node) {
		    if (node.nextSibling) {
		      return node.nextSibling;
		    }
		    node = node.parentNode;
		  }
		}
		
		/**
		 * Get object describing the nodes which contain characters at offset.
		 *
		 * @param {DOMElement|DOMTextNode} root
		 * @param {number} offset
		 * @return {?object}
		 */
		function getNodeForCharacterOffset(root, offset) {
		  var node = getLeafNode(root);
		  var nodeStart = 0;
		  var nodeEnd = 0;
		
		  while (node) {
		    if (node.nodeType === 3) {
		      nodeEnd = nodeStart + node.textContent.length;
		
		      if (nodeStart <= offset && nodeEnd >= offset) {
		        return {
		          node: node,
		          offset: offset - nodeStart
		        };
		      }
		
		      nodeStart = nodeEnd;
		    }
		
		    node = getLeafNode(getSiblingNode(node));
		  }
		}
		
		module.exports = getNodeForCharacterOffset;
	
	/***/ },
	/* 129 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule getActiveElement
		 * @typechecks
		 */
		
		/* eslint-disable fb-www/typeof-undefined */
		
		/**
		 * Same as document.activeElement but wraps in a try-catch block. In IE it is
		 * not safe to call document.activeElement if there is nothing focused.
		 *
		 * The activeElement will be null only if the document or document body is not
		 * yet defined.
		 */
		'use strict';
		
		function getActiveElement() /*?DOMElement*/{
		  if (typeof document === 'undefined') {
		    return null;
		  }
		  try {
		    return document.activeElement || document.body;
		  } catch (e) {
		    return document.body;
		  }
		}
		
		module.exports = getActiveElement;
	
	/***/ },
	/* 130 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule SelectEventPlugin
		 */
		
		'use strict';
		
		var EventConstants = __webpack_require__(30);
		var EventPropagators = __webpack_require__(73);
		var ExecutionEnvironment = __webpack_require__(9);
		var ReactInputSelection = __webpack_require__(126);
		var SyntheticEvent = __webpack_require__(77);
		
		var getActiveElement = __webpack_require__(129);
		var isTextInputElement = __webpack_require__(82);
		var keyOf = __webpack_require__(79);
		var shallowEqual = __webpack_require__(117);
		
		var topLevelTypes = EventConstants.topLevelTypes;
		
		var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
		
		var eventTypes = {
		  select: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onSelect: null }),
		      captured: keyOf({ onSelectCapture: null })
		    },
		    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
		  }
		};
		
		var activeElement = null;
		var activeElementID = null;
		var lastSelection = null;
		var mouseDown = false;
		
		// Track whether a listener exists for this plugin. If none exist, we do
		// not extract events.
		var hasListener = false;
		var ON_SELECT_KEY = keyOf({ onSelect: null });
		
		/**
		 * Get an object which is a unique representation of the current selection.
		 *
		 * The return value will not be consistent across nodes or browsers, but
		 * two identical selections on the same node will return identical objects.
		 *
		 * @param {DOMElement} node
		 * @return {object}
		 */
		function getSelection(node) {
		  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
		    return {
		      start: node.selectionStart,
		      end: node.selectionEnd
		    };
		  } else if (window.getSelection) {
		    var selection = window.getSelection();
		    return {
		      anchorNode: selection.anchorNode,
		      anchorOffset: selection.anchorOffset,
		      focusNode: selection.focusNode,
		      focusOffset: selection.focusOffset
		    };
		  } else if (document.selection) {
		    var range = document.selection.createRange();
		    return {
		      parentElement: range.parentElement(),
		      text: range.text,
		      top: range.boundingTop,
		      left: range.boundingLeft
		    };
		  }
		}
		
		/**
		 * Poll selection to see whether it's changed.
		 *
		 * @param {object} nativeEvent
		 * @return {?SyntheticEvent}
		 */
		function constructSelectEvent(nativeEvent, nativeEventTarget) {
		  // Ensure we have the right element, and that the user is not dragging a
		  // selection (this matches native `select` event behavior). In HTML5, select
		  // fires only on input and textarea thus if there's no focused element we
		  // won't dispatch.
		  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
		    return null;
		  }
		
		  // Only fire when selection has actually changed.
		  var currentSelection = getSelection(activeElement);
		  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
		    lastSelection = currentSelection;
		
		    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent, nativeEventTarget);
		
		    syntheticEvent.type = 'select';
		    syntheticEvent.target = activeElement;
		
		    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
		
		    return syntheticEvent;
		  }
		
		  return null;
		}
		
		/**
		 * This plugin creates an `onSelect` event that normalizes select events
		 * across form elements.
		 *
		 * Supported elements are:
		 * - input (see `isTextInputElement`)
		 * - textarea
		 * - contentEditable
		 *
		 * This differs from native browser implementations in the following ways:
		 * - Fires on contentEditable fields as well as inputs.
		 * - Fires for collapsed selection.
		 * - Fires after user input.
		 */
		var SelectEventPlugin = {
		
		  eventTypes: eventTypes,
		
		  /**
		   * @param {string} topLevelType Record from `EventConstants`.
		   * @param {DOMEventTarget} topLevelTarget The listening component root node.
		   * @param {string} topLevelTargetID ID of `topLevelTarget`.
		   * @param {object} nativeEvent Native browser event.
		   * @return {*} An accumulation of synthetic events.
		   * @see {EventPluginHub.extractEvents}
		   */
		  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
		    if (!hasListener) {
		      return null;
		    }
		
		    switch (topLevelType) {
		      // Track the input node that has focus.
		      case topLevelTypes.topFocus:
		        if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {
		          activeElement = topLevelTarget;
		          activeElementID = topLevelTargetID;
		          lastSelection = null;
		        }
		        break;
		      case topLevelTypes.topBlur:
		        activeElement = null;
		        activeElementID = null;
		        lastSelection = null;
		        break;
		
		      // Don't fire the event while the user is dragging. This matches the
		      // semantics of the native select event.
		      case topLevelTypes.topMouseDown:
		        mouseDown = true;
		        break;
		      case topLevelTypes.topContextMenu:
		      case topLevelTypes.topMouseUp:
		        mouseDown = false;
		        return constructSelectEvent(nativeEvent, nativeEventTarget);
		
		      // Chrome and IE fire non-standard event when selection is changed (and
		      // sometimes when it hasn't). IE's event fires out of order with respect
		      // to key and input events on deletion, so we discard it.
		      //
		      // Firefox doesn't support selectionchange, so check selection status
		      // after each key entry. The selection changes after keydown and before
		      // keyup, but we check on keydown as well in the case of holding down a
		      // key, when multiple keydown events are fired but only one keyup is.
		      // This is also our approach for IE handling, for the reason above.
		      case topLevelTypes.topSelectionChange:
		        if (skipSelectionChangeEvent) {
		          break;
		        }
		      // falls through
		      case topLevelTypes.topKeyDown:
		      case topLevelTypes.topKeyUp:
		        return constructSelectEvent(nativeEvent, nativeEventTarget);
		    }
		
		    return null;
		  },
		
		  didPutListener: function (id, registrationName, listener) {
		    if (registrationName === ON_SELECT_KEY) {
		      hasListener = true;
		    }
		  }
		};
		
		module.exports = SelectEventPlugin;
	
	/***/ },
	/* 131 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ServerReactRootIndex
		 * @typechecks
		 */
		
		'use strict';
		
		/**
		 * Size of the reactRoot ID space. We generate random numbers for React root
		 * IDs and if there's a collision the events and DOM update system will
		 * get confused. In the future we need a way to generate GUIDs but for
		 * now this will work on a smaller scale.
		 */
		var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);
		
		var ServerReactRootIndex = {
		  createReactRootIndex: function () {
		    return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
		  }
		};
		
		module.exports = ServerReactRootIndex;
	
	/***/ },
	/* 132 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule SimpleEventPlugin
		 */
		
		'use strict';
		
		var EventConstants = __webpack_require__(30);
		var EventListener = __webpack_require__(119);
		var EventPropagators = __webpack_require__(73);
		var ReactMount = __webpack_require__(28);
		var SyntheticClipboardEvent = __webpack_require__(133);
		var SyntheticEvent = __webpack_require__(77);
		var SyntheticFocusEvent = __webpack_require__(134);
		var SyntheticKeyboardEvent = __webpack_require__(135);
		var SyntheticMouseEvent = __webpack_require__(86);
		var SyntheticDragEvent = __webpack_require__(138);
		var SyntheticTouchEvent = __webpack_require__(139);
		var SyntheticUIEvent = __webpack_require__(87);
		var SyntheticWheelEvent = __webpack_require__(140);
		
		var emptyFunction = __webpack_require__(15);
		var getEventCharCode = __webpack_require__(136);
		var invariant = __webpack_require__(13);
		var keyOf = __webpack_require__(79);
		
		var topLevelTypes = EventConstants.topLevelTypes;
		
		var eventTypes = {
		  abort: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onAbort: true }),
		      captured: keyOf({ onAbortCapture: true })
		    }
		  },
		  blur: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onBlur: true }),
		      captured: keyOf({ onBlurCapture: true })
		    }
		  },
		  canPlay: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onCanPlay: true }),
		      captured: keyOf({ onCanPlayCapture: true })
		    }
		  },
		  canPlayThrough: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onCanPlayThrough: true }),
		      captured: keyOf({ onCanPlayThroughCapture: true })
		    }
		  },
		  click: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onClick: true }),
		      captured: keyOf({ onClickCapture: true })
		    }
		  },
		  contextMenu: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onContextMenu: true }),
		      captured: keyOf({ onContextMenuCapture: true })
		    }
		  },
		  copy: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onCopy: true }),
		      captured: keyOf({ onCopyCapture: true })
		    }
		  },
		  cut: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onCut: true }),
		      captured: keyOf({ onCutCapture: true })
		    }
		  },
		  doubleClick: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onDoubleClick: true }),
		      captured: keyOf({ onDoubleClickCapture: true })
		    }
		  },
		  drag: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onDrag: true }),
		      captured: keyOf({ onDragCapture: true })
		    }
		  },
		  dragEnd: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onDragEnd: true }),
		      captured: keyOf({ onDragEndCapture: true })
		    }
		  },
		  dragEnter: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onDragEnter: true }),
		      captured: keyOf({ onDragEnterCapture: true })
		    }
		  },
		  dragExit: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onDragExit: true }),
		      captured: keyOf({ onDragExitCapture: true })
		    }
		  },
		  dragLeave: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onDragLeave: true }),
		      captured: keyOf({ onDragLeaveCapture: true })
		    }
		  },
		  dragOver: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onDragOver: true }),
		      captured: keyOf({ onDragOverCapture: true })
		    }
		  },
		  dragStart: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onDragStart: true }),
		      captured: keyOf({ onDragStartCapture: true })
		    }
		  },
		  drop: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onDrop: true }),
		      captured: keyOf({ onDropCapture: true })
		    }
		  },
		  durationChange: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onDurationChange: true }),
		      captured: keyOf({ onDurationChangeCapture: true })
		    }
		  },
		  emptied: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onEmptied: true }),
		      captured: keyOf({ onEmptiedCapture: true })
		    }
		  },
		  encrypted: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onEncrypted: true }),
		      captured: keyOf({ onEncryptedCapture: true })
		    }
		  },
		  ended: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onEnded: true }),
		      captured: keyOf({ onEndedCapture: true })
		    }
		  },
		  error: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onError: true }),
		      captured: keyOf({ onErrorCapture: true })
		    }
		  },
		  focus: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onFocus: true }),
		      captured: keyOf({ onFocusCapture: true })
		    }
		  },
		  input: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onInput: true }),
		      captured: keyOf({ onInputCapture: true })
		    }
		  },
		  keyDown: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onKeyDown: true }),
		      captured: keyOf({ onKeyDownCapture: true })
		    }
		  },
		  keyPress: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onKeyPress: true }),
		      captured: keyOf({ onKeyPressCapture: true })
		    }
		  },
		  keyUp: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onKeyUp: true }),
		      captured: keyOf({ onKeyUpCapture: true })
		    }
		  },
		  load: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onLoad: true }),
		      captured: keyOf({ onLoadCapture: true })
		    }
		  },
		  loadedData: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onLoadedData: true }),
		      captured: keyOf({ onLoadedDataCapture: true })
		    }
		  },
		  loadedMetadata: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onLoadedMetadata: true }),
		      captured: keyOf({ onLoadedMetadataCapture: true })
		    }
		  },
		  loadStart: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onLoadStart: true }),
		      captured: keyOf({ onLoadStartCapture: true })
		    }
		  },
		  // Note: We do not allow listening to mouseOver events. Instead, use the
		  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
		  mouseDown: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onMouseDown: true }),
		      captured: keyOf({ onMouseDownCapture: true })
		    }
		  },
		  mouseMove: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onMouseMove: true }),
		      captured: keyOf({ onMouseMoveCapture: true })
		    }
		  },
		  mouseOut: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onMouseOut: true }),
		      captured: keyOf({ onMouseOutCapture: true })
		    }
		  },
		  mouseOver: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onMouseOver: true }),
		      captured: keyOf({ onMouseOverCapture: true })
		    }
		  },
		  mouseUp: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onMouseUp: true }),
		      captured: keyOf({ onMouseUpCapture: true })
		    }
		  },
		  paste: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onPaste: true }),
		      captured: keyOf({ onPasteCapture: true })
		    }
		  },
		  pause: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onPause: true }),
		      captured: keyOf({ onPauseCapture: true })
		    }
		  },
		  play: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onPlay: true }),
		      captured: keyOf({ onPlayCapture: true })
		    }
		  },
		  playing: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onPlaying: true }),
		      captured: keyOf({ onPlayingCapture: true })
		    }
		  },
		  progress: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onProgress: true }),
		      captured: keyOf({ onProgressCapture: true })
		    }
		  },
		  rateChange: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onRateChange: true }),
		      captured: keyOf({ onRateChangeCapture: true })
		    }
		  },
		  reset: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onReset: true }),
		      captured: keyOf({ onResetCapture: true })
		    }
		  },
		  scroll: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onScroll: true }),
		      captured: keyOf({ onScrollCapture: true })
		    }
		  },
		  seeked: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onSeeked: true }),
		      captured: keyOf({ onSeekedCapture: true })
		    }
		  },
		  seeking: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onSeeking: true }),
		      captured: keyOf({ onSeekingCapture: true })
		    }
		  },
		  stalled: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onStalled: true }),
		      captured: keyOf({ onStalledCapture: true })
		    }
		  },
		  submit: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onSubmit: true }),
		      captured: keyOf({ onSubmitCapture: true })
		    }
		  },
		  suspend: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onSuspend: true }),
		      captured: keyOf({ onSuspendCapture: true })
		    }
		  },
		  timeUpdate: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onTimeUpdate: true }),
		      captured: keyOf({ onTimeUpdateCapture: true })
		    }
		  },
		  touchCancel: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onTouchCancel: true }),
		      captured: keyOf({ onTouchCancelCapture: true })
		    }
		  },
		  touchEnd: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onTouchEnd: true }),
		      captured: keyOf({ onTouchEndCapture: true })
		    }
		  },
		  touchMove: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onTouchMove: true }),
		      captured: keyOf({ onTouchMoveCapture: true })
		    }
		  },
		  touchStart: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onTouchStart: true }),
		      captured: keyOf({ onTouchStartCapture: true })
		    }
		  },
		  volumeChange: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onVolumeChange: true }),
		      captured: keyOf({ onVolumeChangeCapture: true })
		    }
		  },
		  waiting: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onWaiting: true }),
		      captured: keyOf({ onWaitingCapture: true })
		    }
		  },
		  wheel: {
		    phasedRegistrationNames: {
		      bubbled: keyOf({ onWheel: true }),
		      captured: keyOf({ onWheelCapture: true })
		    }
		  }
		};
		
		var topLevelEventsToDispatchConfig = {
		  topAbort: eventTypes.abort,
		  topBlur: eventTypes.blur,
		  topCanPlay: eventTypes.canPlay,
		  topCanPlayThrough: eventTypes.canPlayThrough,
		  topClick: eventTypes.click,
		  topContextMenu: eventTypes.contextMenu,
		  topCopy: eventTypes.copy,
		  topCut: eventTypes.cut,
		  topDoubleClick: eventTypes.doubleClick,
		  topDrag: eventTypes.drag,
		  topDragEnd: eventTypes.dragEnd,
		  topDragEnter: eventTypes.dragEnter,
		  topDragExit: eventTypes.dragExit,
		  topDragLeave: eventTypes.dragLeave,
		  topDragOver: eventTypes.dragOver,
		  topDragStart: eventTypes.dragStart,
		  topDrop: eventTypes.drop,
		  topDurationChange: eventTypes.durationChange,
		  topEmptied: eventTypes.emptied,
		  topEncrypted: eventTypes.encrypted,
		  topEnded: eventTypes.ended,
		  topError: eventTypes.error,
		  topFocus: eventTypes.focus,
		  topInput: eventTypes.input,
		  topKeyDown: eventTypes.keyDown,
		  topKeyPress: eventTypes.keyPress,
		  topKeyUp: eventTypes.keyUp,
		  topLoad: eventTypes.load,
		  topLoadedData: eventTypes.loadedData,
		  topLoadedMetadata: eventTypes.loadedMetadata,
		  topLoadStart: eventTypes.loadStart,
		  topMouseDown: eventTypes.mouseDown,
		  topMouseMove: eventTypes.mouseMove,
		  topMouseOut: eventTypes.mouseOut,
		  topMouseOver: eventTypes.mouseOver,
		  topMouseUp: eventTypes.mouseUp,
		  topPaste: eventTypes.paste,
		  topPause: eventTypes.pause,
		  topPlay: eventTypes.play,
		  topPlaying: eventTypes.playing,
		  topProgress: eventTypes.progress,
		  topRateChange: eventTypes.rateChange,
		  topReset: eventTypes.reset,
		  topScroll: eventTypes.scroll,
		  topSeeked: eventTypes.seeked,
		  topSeeking: eventTypes.seeking,
		  topStalled: eventTypes.stalled,
		  topSubmit: eventTypes.submit,
		  topSuspend: eventTypes.suspend,
		  topTimeUpdate: eventTypes.timeUpdate,
		  topTouchCancel: eventTypes.touchCancel,
		  topTouchEnd: eventTypes.touchEnd,
		  topTouchMove: eventTypes.touchMove,
		  topTouchStart: eventTypes.touchStart,
		  topVolumeChange: eventTypes.volumeChange,
		  topWaiting: eventTypes.waiting,
		  topWheel: eventTypes.wheel
		};
		
		for (var type in topLevelEventsToDispatchConfig) {
		  topLevelEventsToDispatchConfig[type].dependencies = [type];
		}
		
		var ON_CLICK_KEY = keyOf({ onClick: null });
		var onClickListeners = {};
		
		var SimpleEventPlugin = {
		
		  eventTypes: eventTypes,
		
		  /**
		   * @param {string} topLevelType Record from `EventConstants`.
		   * @param {DOMEventTarget} topLevelTarget The listening component root node.
		   * @param {string} topLevelTargetID ID of `topLevelTarget`.
		   * @param {object} nativeEvent Native browser event.
		   * @return {*} An accumulation of synthetic events.
		   * @see {EventPluginHub.extractEvents}
		   */
		  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
		    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
		    if (!dispatchConfig) {
		      return null;
		    }
		    var EventConstructor;
		    switch (topLevelType) {
		      case topLevelTypes.topAbort:
		      case topLevelTypes.topCanPlay:
		      case topLevelTypes.topCanPlayThrough:
		      case topLevelTypes.topDurationChange:
		      case topLevelTypes.topEmptied:
		      case topLevelTypes.topEncrypted:
		      case topLevelTypes.topEnded:
		      case topLevelTypes.topError:
		      case topLevelTypes.topInput:
		      case topLevelTypes.topLoad:
		      case topLevelTypes.topLoadedData:
		      case topLevelTypes.topLoadedMetadata:
		      case topLevelTypes.topLoadStart:
		      case topLevelTypes.topPause:
		      case topLevelTypes.topPlay:
		      case topLevelTypes.topPlaying:
		      case topLevelTypes.topProgress:
		      case topLevelTypes.topRateChange:
		      case topLevelTypes.topReset:
		      case topLevelTypes.topSeeked:
		      case topLevelTypes.topSeeking:
		      case topLevelTypes.topStalled:
		      case topLevelTypes.topSubmit:
		      case topLevelTypes.topSuspend:
		      case topLevelTypes.topTimeUpdate:
		      case topLevelTypes.topVolumeChange:
		      case topLevelTypes.topWaiting:
		        // HTML Events
		        // @see http://www.w3.org/TR/html5/index.html#events-0
		        EventConstructor = SyntheticEvent;
		        break;
		      case topLevelTypes.topKeyPress:
		        // FireFox creates a keypress event for function keys too. This removes
		        // the unwanted keypress events. Enter is however both printable and
		        // non-printable. One would expect Tab to be as well (but it isn't).
		        if (getEventCharCode(nativeEvent) === 0) {
		          return null;
		        }
		      /* falls through */
		      case topLevelTypes.topKeyDown:
		      case topLevelTypes.topKeyUp:
		        EventConstructor = SyntheticKeyboardEvent;
		        break;
		      case topLevelTypes.topBlur:
		      case topLevelTypes.topFocus:
		        EventConstructor = SyntheticFocusEvent;
		        break;
		      case topLevelTypes.topClick:
		        // Firefox creates a click event on right mouse clicks. This removes the
		        // unwanted click events.
		        if (nativeEvent.button === 2) {
		          return null;
		        }
		      /* falls through */
		      case topLevelTypes.topContextMenu:
		      case topLevelTypes.topDoubleClick:
		      case topLevelTypes.topMouseDown:
		      case topLevelTypes.topMouseMove:
		      case topLevelTypes.topMouseOut:
		      case topLevelTypes.topMouseOver:
		      case topLevelTypes.topMouseUp:
		        EventConstructor = SyntheticMouseEvent;
		        break;
		      case topLevelTypes.topDrag:
		      case topLevelTypes.topDragEnd:
		      case topLevelTypes.topDragEnter:
		      case topLevelTypes.topDragExit:
		      case topLevelTypes.topDragLeave:
		      case topLevelTypes.topDragOver:
		      case topLevelTypes.topDragStart:
		      case topLevelTypes.topDrop:
		        EventConstructor = SyntheticDragEvent;
		        break;
		      case topLevelTypes.topTouchCancel:
		      case topLevelTypes.topTouchEnd:
		      case topLevelTypes.topTouchMove:
		      case topLevelTypes.topTouchStart:
		        EventConstructor = SyntheticTouchEvent;
		        break;
		      case topLevelTypes.topScroll:
		        EventConstructor = SyntheticUIEvent;
		        break;
		      case topLevelTypes.topWheel:
		        EventConstructor = SyntheticWheelEvent;
		        break;
		      case topLevelTypes.topCopy:
		      case topLevelTypes.topCut:
		      case topLevelTypes.topPaste:
		        EventConstructor = SyntheticClipboardEvent;
		        break;
		    }
		    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(false) : undefined;
		    var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent, nativeEventTarget);
		    EventPropagators.accumulateTwoPhaseDispatches(event);
		    return event;
		  },
		
		  didPutListener: function (id, registrationName, listener) {
		    // Mobile Safari does not fire properly bubble click events on
		    // non-interactive elements, which means delegated click listeners do not
		    // fire. The workaround for this bug involves attaching an empty click
		    // listener on the target node.
		    if (registrationName === ON_CLICK_KEY) {
		      var node = ReactMount.getNode(id);
		      if (!onClickListeners[id]) {
		        onClickListeners[id] = EventListener.listen(node, 'click', emptyFunction);
		      }
		    }
		  },
		
		  willDeleteListener: function (id, registrationName) {
		    if (registrationName === ON_CLICK_KEY) {
		      onClickListeners[id].remove();
		      delete onClickListeners[id];
		    }
		  }
		
		};
		
		module.exports = SimpleEventPlugin;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 133 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule SyntheticClipboardEvent
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var SyntheticEvent = __webpack_require__(77);
		
		/**
		 * @interface Event
		 * @see http://www.w3.org/TR/clipboard-apis/
		 */
		var ClipboardEventInterface = {
		  clipboardData: function (event) {
		    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
		  }
		};
		
		/**
		 * @param {object} dispatchConfig Configuration used to dispatch this event.
		 * @param {string} dispatchMarker Marker identifying the event target.
		 * @param {object} nativeEvent Native browser event.
		 * @extends {SyntheticUIEvent}
		 */
		function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
		  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
		}
		
		SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
		
		module.exports = SyntheticClipboardEvent;
	
	/***/ },
	/* 134 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule SyntheticFocusEvent
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var SyntheticUIEvent = __webpack_require__(87);
		
		/**
		 * @interface FocusEvent
		 * @see http://www.w3.org/TR/DOM-Level-3-Events/
		 */
		var FocusEventInterface = {
		  relatedTarget: null
		};
		
		/**
		 * @param {object} dispatchConfig Configuration used to dispatch this event.
		 * @param {string} dispatchMarker Marker identifying the event target.
		 * @param {object} nativeEvent Native browser event.
		 * @extends {SyntheticUIEvent}
		 */
		function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
		  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
		}
		
		SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
		
		module.exports = SyntheticFocusEvent;
	
	/***/ },
	/* 135 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule SyntheticKeyboardEvent
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var SyntheticUIEvent = __webpack_require__(87);
		
		var getEventCharCode = __webpack_require__(136);
		var getEventKey = __webpack_require__(137);
		var getEventModifierState = __webpack_require__(88);
		
		/**
		 * @interface KeyboardEvent
		 * @see http://www.w3.org/TR/DOM-Level-3-Events/
		 */
		var KeyboardEventInterface = {
		  key: getEventKey,
		  location: null,
		  ctrlKey: null,
		  shiftKey: null,
		  altKey: null,
		  metaKey: null,
		  repeat: null,
		  locale: null,
		  getModifierState: getEventModifierState,
		  // Legacy Interface
		  charCode: function (event) {
		    // `charCode` is the result of a KeyPress event and represents the value of
		    // the actual printable character.
		
		    // KeyPress is deprecated, but its replacement is not yet final and not
		    // implemented in any major browser. Only KeyPress has charCode.
		    if (event.type === 'keypress') {
		      return getEventCharCode(event);
		    }
		    return 0;
		  },
		  keyCode: function (event) {
		    // `keyCode` is the result of a KeyDown/Up event and represents the value of
		    // physical keyboard key.
		
		    // The actual meaning of the value depends on the users' keyboard layout
		    // which cannot be detected. Assuming that it is a US keyboard layout
		    // provides a surprisingly accurate mapping for US and European users.
		    // Due to this, it is left to the user to implement at this time.
		    if (event.type === 'keydown' || event.type === 'keyup') {
		      return event.keyCode;
		    }
		    return 0;
		  },
		  which: function (event) {
		    // `which` is an alias for either `keyCode` or `charCode` depending on the
		    // type of the event.
		    if (event.type === 'keypress') {
		      return getEventCharCode(event);
		    }
		    if (event.type === 'keydown' || event.type === 'keyup') {
		      return event.keyCode;
		    }
		    return 0;
		  }
		};
		
		/**
		 * @param {object} dispatchConfig Configuration used to dispatch this event.
		 * @param {string} dispatchMarker Marker identifying the event target.
		 * @param {object} nativeEvent Native browser event.
		 * @extends {SyntheticUIEvent}
		 */
		function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
		  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
		}
		
		SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
		
		module.exports = SyntheticKeyboardEvent;
	
	/***/ },
	/* 136 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule getEventCharCode
		 * @typechecks static-only
		 */
		
		'use strict';
		
		/**
		 * `charCode` represents the actual "character code" and is safe to use with
		 * `String.fromCharCode`. As such, only keys that correspond to printable
		 * characters produce a valid `charCode`, the only exception to this is Enter.
		 * The Tab-key is considered non-printable and does not have a `charCode`,
		 * presumably because it does not produce a tab-character in browsers.
		 *
		 * @param {object} nativeEvent Native browser event.
		 * @return {number} Normalized `charCode` property.
		 */
		function getEventCharCode(nativeEvent) {
		  var charCode;
		  var keyCode = nativeEvent.keyCode;
		
		  if ('charCode' in nativeEvent) {
		    charCode = nativeEvent.charCode;
		
		    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
		    if (charCode === 0 && keyCode === 13) {
		      charCode = 13;
		    }
		  } else {
		    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
		    charCode = keyCode;
		  }
		
		  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
		  // Must not discard the (non-)printable Enter-key.
		  if (charCode >= 32 || charCode === 13) {
		    return charCode;
		  }
		
		  return 0;
		}
		
		module.exports = getEventCharCode;
	
	/***/ },
	/* 137 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule getEventKey
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var getEventCharCode = __webpack_require__(136);
		
		/**
		 * Normalization of deprecated HTML5 `key` values
		 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
		 */
		var normalizeKey = {
		  'Esc': 'Escape',
		  'Spacebar': ' ',
		  'Left': 'ArrowLeft',
		  'Up': 'ArrowUp',
		  'Right': 'ArrowRight',
		  'Down': 'ArrowDown',
		  'Del': 'Delete',
		  'Win': 'OS',
		  'Menu': 'ContextMenu',
		  'Apps': 'ContextMenu',
		  'Scroll': 'ScrollLock',
		  'MozPrintableKey': 'Unidentified'
		};
		
		/**
		 * Translation from legacy `keyCode` to HTML5 `key`
		 * Only special keys supported, all others depend on keyboard layout or browser
		 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
		 */
		var translateToKey = {
		  8: 'Backspace',
		  9: 'Tab',
		  12: 'Clear',
		  13: 'Enter',
		  16: 'Shift',
		  17: 'Control',
		  18: 'Alt',
		  19: 'Pause',
		  20: 'CapsLock',
		  27: 'Escape',
		  32: ' ',
		  33: 'PageUp',
		  34: 'PageDown',
		  35: 'End',
		  36: 'Home',
		  37: 'ArrowLeft',
		  38: 'ArrowUp',
		  39: 'ArrowRight',
		  40: 'ArrowDown',
		  45: 'Insert',
		  46: 'Delete',
		  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
		  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
		  144: 'NumLock',
		  145: 'ScrollLock',
		  224: 'Meta'
		};
		
		/**
		 * @param {object} nativeEvent Native browser event.
		 * @return {string} Normalized `key` property.
		 */
		function getEventKey(nativeEvent) {
		  if (nativeEvent.key) {
		    // Normalize inconsistent values reported by browsers due to
		    // implementations of a working draft specification.
		
		    // FireFox implements `key` but returns `MozPrintableKey` for all
		    // printable characters (normalized to `Unidentified`), ignore it.
		    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
		    if (key !== 'Unidentified') {
		      return key;
		    }
		  }
		
		  // Browser does not implement `key`, polyfill as much of it as we can.
		  if (nativeEvent.type === 'keypress') {
		    var charCode = getEventCharCode(nativeEvent);
		
		    // The enter-key is technically both printable and non-printable and can
		    // thus be captured by `keypress`, no other non-printable key should.
		    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
		  }
		  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
		    // While user keyboard layout determines the actual meaning of each
		    // `keyCode` value, almost all function keys have a universal value.
		    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
		  }
		  return '';
		}
		
		module.exports = getEventKey;
	
	/***/ },
	/* 138 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule SyntheticDragEvent
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var SyntheticMouseEvent = __webpack_require__(86);
		
		/**
		 * @interface DragEvent
		 * @see http://www.w3.org/TR/DOM-Level-3-Events/
		 */
		var DragEventInterface = {
		  dataTransfer: null
		};
		
		/**
		 * @param {object} dispatchConfig Configuration used to dispatch this event.
		 * @param {string} dispatchMarker Marker identifying the event target.
		 * @param {object} nativeEvent Native browser event.
		 * @extends {SyntheticUIEvent}
		 */
		function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
		  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
		}
		
		SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
		
		module.exports = SyntheticDragEvent;
	
	/***/ },
	/* 139 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule SyntheticTouchEvent
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var SyntheticUIEvent = __webpack_require__(87);
		
		var getEventModifierState = __webpack_require__(88);
		
		/**
		 * @interface TouchEvent
		 * @see http://www.w3.org/TR/touch-events/
		 */
		var TouchEventInterface = {
		  touches: null,
		  targetTouches: null,
		  changedTouches: null,
		  altKey: null,
		  metaKey: null,
		  ctrlKey: null,
		  shiftKey: null,
		  getModifierState: getEventModifierState
		};
		
		/**
		 * @param {object} dispatchConfig Configuration used to dispatch this event.
		 * @param {string} dispatchMarker Marker identifying the event target.
		 * @param {object} nativeEvent Native browser event.
		 * @extends {SyntheticUIEvent}
		 */
		function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
		  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
		}
		
		SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
		
		module.exports = SyntheticTouchEvent;
	
	/***/ },
	/* 140 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule SyntheticWheelEvent
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var SyntheticMouseEvent = __webpack_require__(86);
		
		/**
		 * @interface WheelEvent
		 * @see http://www.w3.org/TR/DOM-Level-3-Events/
		 */
		var WheelEventInterface = {
		  deltaX: function (event) {
		    return 'deltaX' in event ? event.deltaX :
		    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
		    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
		  },
		  deltaY: function (event) {
		    return 'deltaY' in event ? event.deltaY :
		    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
		    'wheelDeltaY' in event ? -event.wheelDeltaY :
		    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
		    'wheelDelta' in event ? -event.wheelDelta : 0;
		  },
		  deltaZ: null,
		
		  // Browsers without "deltaMode" is reporting in raw wheel delta where one
		  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
		  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
		  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
		  deltaMode: null
		};
		
		/**
		 * @param {object} dispatchConfig Configuration used to dispatch this event.
		 * @param {string} dispatchMarker Marker identifying the event target.
		 * @param {object} nativeEvent Native browser event.
		 * @extends {SyntheticMouseEvent}
		 */
		function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
		  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
		}
		
		SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
		
		module.exports = SyntheticWheelEvent;
	
	/***/ },
	/* 141 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule SVGDOMPropertyConfig
		 */
		
		'use strict';
		
		var DOMProperty = __webpack_require__(23);
		
		var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
		
		var NS = {
		  xlink: 'http://www.w3.org/1999/xlink',
		  xml: 'http://www.w3.org/XML/1998/namespace'
		};
		
		var SVGDOMPropertyConfig = {
		  Properties: {
		    clipPath: MUST_USE_ATTRIBUTE,
		    cx: MUST_USE_ATTRIBUTE,
		    cy: MUST_USE_ATTRIBUTE,
		    d: MUST_USE_ATTRIBUTE,
		    dx: MUST_USE_ATTRIBUTE,
		    dy: MUST_USE_ATTRIBUTE,
		    fill: MUST_USE_ATTRIBUTE,
		    fillOpacity: MUST_USE_ATTRIBUTE,
		    fontFamily: MUST_USE_ATTRIBUTE,
		    fontSize: MUST_USE_ATTRIBUTE,
		    fx: MUST_USE_ATTRIBUTE,
		    fy: MUST_USE_ATTRIBUTE,
		    gradientTransform: MUST_USE_ATTRIBUTE,
		    gradientUnits: MUST_USE_ATTRIBUTE,
		    markerEnd: MUST_USE_ATTRIBUTE,
		    markerMid: MUST_USE_ATTRIBUTE,
		    markerStart: MUST_USE_ATTRIBUTE,
		    offset: MUST_USE_ATTRIBUTE,
		    opacity: MUST_USE_ATTRIBUTE,
		    patternContentUnits: MUST_USE_ATTRIBUTE,
		    patternUnits: MUST_USE_ATTRIBUTE,
		    points: MUST_USE_ATTRIBUTE,
		    preserveAspectRatio: MUST_USE_ATTRIBUTE,
		    r: MUST_USE_ATTRIBUTE,
		    rx: MUST_USE_ATTRIBUTE,
		    ry: MUST_USE_ATTRIBUTE,
		    spreadMethod: MUST_USE_ATTRIBUTE,
		    stopColor: MUST_USE_ATTRIBUTE,
		    stopOpacity: MUST_USE_ATTRIBUTE,
		    stroke: MUST_USE_ATTRIBUTE,
		    strokeDasharray: MUST_USE_ATTRIBUTE,
		    strokeLinecap: MUST_USE_ATTRIBUTE,
		    strokeOpacity: MUST_USE_ATTRIBUTE,
		    strokeWidth: MUST_USE_ATTRIBUTE,
		    textAnchor: MUST_USE_ATTRIBUTE,
		    transform: MUST_USE_ATTRIBUTE,
		    version: MUST_USE_ATTRIBUTE,
		    viewBox: MUST_USE_ATTRIBUTE,
		    x1: MUST_USE_ATTRIBUTE,
		    x2: MUST_USE_ATTRIBUTE,
		    x: MUST_USE_ATTRIBUTE,
		    xlinkActuate: MUST_USE_ATTRIBUTE,
		    xlinkArcrole: MUST_USE_ATTRIBUTE,
		    xlinkHref: MUST_USE_ATTRIBUTE,
		    xlinkRole: MUST_USE_ATTRIBUTE,
		    xlinkShow: MUST_USE_ATTRIBUTE,
		    xlinkTitle: MUST_USE_ATTRIBUTE,
		    xlinkType: MUST_USE_ATTRIBUTE,
		    xmlBase: MUST_USE_ATTRIBUTE,
		    xmlLang: MUST_USE_ATTRIBUTE,
		    xmlSpace: MUST_USE_ATTRIBUTE,
		    y1: MUST_USE_ATTRIBUTE,
		    y2: MUST_USE_ATTRIBUTE,
		    y: MUST_USE_ATTRIBUTE
		  },
		  DOMAttributeNamespaces: {
		    xlinkActuate: NS.xlink,
		    xlinkArcrole: NS.xlink,
		    xlinkHref: NS.xlink,
		    xlinkRole: NS.xlink,
		    xlinkShow: NS.xlink,
		    xlinkTitle: NS.xlink,
		    xlinkType: NS.xlink,
		    xmlBase: NS.xml,
		    xmlLang: NS.xml,
		    xmlSpace: NS.xml
		  },
		  DOMAttributeNames: {
		    clipPath: 'clip-path',
		    fillOpacity: 'fill-opacity',
		    fontFamily: 'font-family',
		    fontSize: 'font-size',
		    gradientTransform: 'gradientTransform',
		    gradientUnits: 'gradientUnits',
		    markerEnd: 'marker-end',
		    markerMid: 'marker-mid',
		    markerStart: 'marker-start',
		    patternContentUnits: 'patternContentUnits',
		    patternUnits: 'patternUnits',
		    preserveAspectRatio: 'preserveAspectRatio',
		    spreadMethod: 'spreadMethod',
		    stopColor: 'stop-color',
		    stopOpacity: 'stop-opacity',
		    strokeDasharray: 'stroke-dasharray',
		    strokeLinecap: 'stroke-linecap',
		    strokeOpacity: 'stroke-opacity',
		    strokeWidth: 'stroke-width',
		    textAnchor: 'text-anchor',
		    viewBox: 'viewBox',
		    xlinkActuate: 'xlink:actuate',
		    xlinkArcrole: 'xlink:arcrole',
		    xlinkHref: 'xlink:href',
		    xlinkRole: 'xlink:role',
		    xlinkShow: 'xlink:show',
		    xlinkTitle: 'xlink:title',
		    xlinkType: 'xlink:type',
		    xmlBase: 'xml:base',
		    xmlLang: 'xml:lang',
		    xmlSpace: 'xml:space'
		  }
		};
		
		module.exports = SVGDOMPropertyConfig;
	
	/***/ },
	/* 142 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactDefaultPerf
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var DOMProperty = __webpack_require__(23);
		var ReactDefaultPerfAnalysis = __webpack_require__(143);
		var ReactMount = __webpack_require__(28);
		var ReactPerf = __webpack_require__(18);
		
		var performanceNow = __webpack_require__(144);
		
		function roundFloat(val) {
		  return Math.floor(val * 100) / 100;
		}
		
		function addValue(obj, key, val) {
		  obj[key] = (obj[key] || 0) + val;
		}
		
		var ReactDefaultPerf = {
		  _allMeasurements: [], // last item in the list is the current one
		  _mountStack: [0],
		  _injected: false,
		
		  start: function () {
		    if (!ReactDefaultPerf._injected) {
		      ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
		    }
		
		    ReactDefaultPerf._allMeasurements.length = 0;
		    ReactPerf.enableMeasure = true;
		  },
		
		  stop: function () {
		    ReactPerf.enableMeasure = false;
		  },
		
		  getLastMeasurements: function () {
		    return ReactDefaultPerf._allMeasurements;
		  },
		
		  printExclusive: function (measurements) {
		    measurements = measurements || ReactDefaultPerf._allMeasurements;
		    var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
		    console.table(summary.map(function (item) {
		      return {
		        'Component class name': item.componentName,
		        'Total inclusive time (ms)': roundFloat(item.inclusive),
		        'Exclusive mount time (ms)': roundFloat(item.exclusive),
		        'Exclusive render time (ms)': roundFloat(item.render),
		        'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
		        'Render time per instance (ms)': roundFloat(item.render / item.count),
		        'Instances': item.count
		      };
		    }));
		    // TODO: ReactDefaultPerfAnalysis.getTotalTime() does not return the correct
		    // number.
		  },
		
		  printInclusive: function (measurements) {
		    measurements = measurements || ReactDefaultPerf._allMeasurements;
		    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
		    console.table(summary.map(function (item) {
		      return {
		        'Owner > component': item.componentName,
		        'Inclusive time (ms)': roundFloat(item.time),
		        'Instances': item.count
		      };
		    }));
		    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
		  },
		
		  getMeasurementsSummaryMap: function (measurements) {
		    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);
		    return summary.map(function (item) {
		      return {
		        'Owner > component': item.componentName,
		        'Wasted time (ms)': item.time,
		        'Instances': item.count
		      };
		    });
		  },
		
		  printWasted: function (measurements) {
		    measurements = measurements || ReactDefaultPerf._allMeasurements;
		    console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
		    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
		  },
		
		  printDOM: function (measurements) {
		    measurements = measurements || ReactDefaultPerf._allMeasurements;
		    var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
		    console.table(summary.map(function (item) {
		      var result = {};
		      result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
		      result.type = item.type;
		      result.args = JSON.stringify(item.args);
		      return result;
		    }));
		    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
		  },
		
		  _recordWrite: function (id, fnName, totalTime, args) {
		    // TODO: totalTime isn't that useful since it doesn't count paints/reflows
		    var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
		    writes[id] = writes[id] || [];
		    writes[id].push({
		      type: fnName,
		      time: totalTime,
		      args: args
		    });
		  },
		
		  measure: function (moduleName, fnName, func) {
		    return function () {
		      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		        args[_key] = arguments[_key];
		      }
		
		      var totalTime;
		      var rv;
		      var start;
		
		      if (fnName === '_renderNewRootComponent' || fnName === 'flushBatchedUpdates') {
		        // A "measurement" is a set of metrics recorded for each flush. We want
		        // to group the metrics for a given flush together so we can look at the
		        // components that rendered and the DOM operations that actually
		        // happened to determine the amount of "wasted work" performed.
		        ReactDefaultPerf._allMeasurements.push({
		          exclusive: {},
		          inclusive: {},
		          render: {},
		          counts: {},
		          writes: {},
		          displayNames: {},
		          totalTime: 0,
		          created: {}
		        });
		        start = performanceNow();
		        rv = func.apply(this, args);
		        ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
		        return rv;
		      } else if (fnName === '_mountImageIntoNode' || moduleName === 'ReactBrowserEventEmitter' || moduleName === 'ReactDOMIDOperations' || moduleName === 'CSSPropertyOperations' || moduleName === 'DOMChildrenOperations' || moduleName === 'DOMPropertyOperations') {
		        start = performanceNow();
		        rv = func.apply(this, args);
		        totalTime = performanceNow() - start;
		
		        if (fnName === '_mountImageIntoNode') {
		          var mountID = ReactMount.getID(args[1]);
		          ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
		        } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
		          // special format
		          args[0].forEach(function (update) {
		            var writeArgs = {};
		            if (update.fromIndex !== null) {
		              writeArgs.fromIndex = update.fromIndex;
		            }
		            if (update.toIndex !== null) {
		              writeArgs.toIndex = update.toIndex;
		            }
		            if (update.textContent !== null) {
		              writeArgs.textContent = update.textContent;
		            }
		            if (update.markupIndex !== null) {
		              writeArgs.markup = args[1][update.markupIndex];
		            }
		            ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs);
		          });
		        } else {
		          // basic format
		          var id = args[0];
		          if (typeof id === 'object') {
		            id = ReactMount.getID(args[0]);
		          }
		          ReactDefaultPerf._recordWrite(id, fnName, totalTime, Array.prototype.slice.call(args, 1));
		        }
		        return rv;
		      } else if (moduleName === 'ReactCompositeComponent' && (fnName === 'mountComponent' || fnName === 'updateComponent' || // TODO: receiveComponent()?
		      fnName === '_renderValidatedComponent')) {
		
		        if (this._currentElement.type === ReactMount.TopLevelWrapper) {
		          return func.apply(this, args);
		        }
		
		        var rootNodeID = fnName === 'mountComponent' ? args[0] : this._rootNodeID;
		        var isRender = fnName === '_renderValidatedComponent';
		        var isMount = fnName === 'mountComponent';
		
		        var mountStack = ReactDefaultPerf._mountStack;
		        var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];
		
		        if (isRender) {
		          addValue(entry.counts, rootNodeID, 1);
		        } else if (isMount) {
		          entry.created[rootNodeID] = true;
		          mountStack.push(0);
		        }
		
		        start = performanceNow();
		        rv = func.apply(this, args);
		        totalTime = performanceNow() - start;
		
		        if (isRender) {
		          addValue(entry.render, rootNodeID, totalTime);
		        } else if (isMount) {
		          var subMountTime = mountStack.pop();
		          mountStack[mountStack.length - 1] += totalTime;
		          addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
		          addValue(entry.inclusive, rootNodeID, totalTime);
		        } else {
		          addValue(entry.inclusive, rootNodeID, totalTime);
		        }
		
		        entry.displayNames[rootNodeID] = {
		          current: this.getName(),
		          owner: this._currentElement._owner ? this._currentElement._owner.getName() : '<root>'
		        };
		
		        return rv;
		      } else {
		        return func.apply(this, args);
		      }
		    };
		  }
		};
		
		module.exports = ReactDefaultPerf;
	
	/***/ },
	/* 143 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactDefaultPerfAnalysis
		 */
		
		'use strict';
		
		var assign = __webpack_require__(39);
		
		// Don't try to save users less than 1.2ms (a number I made up)
		var DONT_CARE_THRESHOLD = 1.2;
		var DOM_OPERATION_TYPES = {
		  '_mountImageIntoNode': 'set innerHTML',
		  INSERT_MARKUP: 'set innerHTML',
		  MOVE_EXISTING: 'move',
		  REMOVE_NODE: 'remove',
		  SET_MARKUP: 'set innerHTML',
		  TEXT_CONTENT: 'set textContent',
		  'setValueForProperty': 'update attribute',
		  'setValueForAttribute': 'update attribute',
		  'deleteValueForProperty': 'remove attribute',
		  'setValueForStyles': 'update styles',
		  'replaceNodeWithMarkup': 'replace',
		  'updateTextContent': 'set textContent'
		};
		
		function getTotalTime(measurements) {
		  // TODO: return number of DOM ops? could be misleading.
		  // TODO: measure dropped frames after reconcile?
		  // TODO: log total time of each reconcile and the top-level component
		  // class that triggered it.
		  var totalTime = 0;
		  for (var i = 0; i < measurements.length; i++) {
		    var measurement = measurements[i];
		    totalTime += measurement.totalTime;
		  }
		  return totalTime;
		}
		
		function getDOMSummary(measurements) {
		  var items = [];
		  measurements.forEach(function (measurement) {
		    Object.keys(measurement.writes).forEach(function (id) {
		      measurement.writes[id].forEach(function (write) {
		        items.push({
		          id: id,
		          type: DOM_OPERATION_TYPES[write.type] || write.type,
		          args: write.args
		        });
		      });
		    });
		  });
		  return items;
		}
		
		function getExclusiveSummary(measurements) {
		  var candidates = {};
		  var displayName;
		
		  for (var i = 0; i < measurements.length; i++) {
		    var measurement = measurements[i];
		    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
		
		    for (var id in allIDs) {
		      displayName = measurement.displayNames[id].current;
		
		      candidates[displayName] = candidates[displayName] || {
		        componentName: displayName,
		        inclusive: 0,
		        exclusive: 0,
		        render: 0,
		        count: 0
		      };
		      if (measurement.render[id]) {
		        candidates[displayName].render += measurement.render[id];
		      }
		      if (measurement.exclusive[id]) {
		        candidates[displayName].exclusive += measurement.exclusive[id];
		      }
		      if (measurement.inclusive[id]) {
		        candidates[displayName].inclusive += measurement.inclusive[id];
		      }
		      if (measurement.counts[id]) {
		        candidates[displayName].count += measurement.counts[id];
		      }
		    }
		  }
		
		  // Now make a sorted array with the results.
		  var arr = [];
		  for (displayName in candidates) {
		    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
		      arr.push(candidates[displayName]);
		    }
		  }
		
		  arr.sort(function (a, b) {
		    return b.exclusive - a.exclusive;
		  });
		
		  return arr;
		}
		
		function getInclusiveSummary(measurements, onlyClean) {
		  var candidates = {};
		  var inclusiveKey;
		
		  for (var i = 0; i < measurements.length; i++) {
		    var measurement = measurements[i];
		    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
		    var cleanComponents;
		
		    if (onlyClean) {
		      cleanComponents = getUnchangedComponents(measurement);
		    }
		
		    for (var id in allIDs) {
		      if (onlyClean && !cleanComponents[id]) {
		        continue;
		      }
		
		      var displayName = measurement.displayNames[id];
		
		      // Inclusive time is not useful for many components without knowing where
		      // they are instantiated. So we aggregate inclusive time with both the
		      // owner and current displayName as the key.
		      inclusiveKey = displayName.owner + ' > ' + displayName.current;
		
		      candidates[inclusiveKey] = candidates[inclusiveKey] || {
		        componentName: inclusiveKey,
		        time: 0,
		        count: 0
		      };
		
		      if (measurement.inclusive[id]) {
		        candidates[inclusiveKey].time += measurement.inclusive[id];
		      }
		      if (measurement.counts[id]) {
		        candidates[inclusiveKey].count += measurement.counts[id];
		      }
		    }
		  }
		
		  // Now make a sorted array with the results.
		  var arr = [];
		  for (inclusiveKey in candidates) {
		    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
		      arr.push(candidates[inclusiveKey]);
		    }
		  }
		
		  arr.sort(function (a, b) {
		    return b.time - a.time;
		  });
		
		  return arr;
		}
		
		function getUnchangedComponents(measurement) {
		  // For a given reconcile, look at which components did not actually
		  // render anything to the DOM and return a mapping of their ID to
		  // the amount of time it took to render the entire subtree.
		  var cleanComponents = {};
		  var dirtyLeafIDs = Object.keys(measurement.writes);
		  var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
		
		  for (var id in allIDs) {
		    var isDirty = false;
		    // For each component that rendered, see if a component that triggered
		    // a DOM op is in its subtree.
		    for (var i = 0; i < dirtyLeafIDs.length; i++) {
		      if (dirtyLeafIDs[i].indexOf(id) === 0) {
		        isDirty = true;
		        break;
		      }
		    }
		    // check if component newly created
		    if (measurement.created[id]) {
		      isDirty = true;
		    }
		    if (!isDirty && measurement.counts[id] > 0) {
		      cleanComponents[id] = true;
		    }
		  }
		  return cleanComponents;
		}
		
		var ReactDefaultPerfAnalysis = {
		  getExclusiveSummary: getExclusiveSummary,
		  getInclusiveSummary: getInclusiveSummary,
		  getDOMSummary: getDOMSummary,
		  getTotalTime: getTotalTime
		};
		
		module.exports = ReactDefaultPerfAnalysis;
	
	/***/ },
	/* 144 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule performanceNow
		 * @typechecks
		 */
		
		'use strict';
		
		var performance = __webpack_require__(145);
		
		var performanceNow;
		
		/**
		 * Detect if we can use `window.performance.now()` and gracefully fallback to
		 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
		 * because of Facebook's testing infrastructure.
		 */
		if (performance.now) {
		  performanceNow = function () {
		    return performance.now();
		  };
		} else {
		  performanceNow = function () {
		    return Date.now();
		  };
		}
		
		module.exports = performanceNow;
	
	/***/ },
	/* 145 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule performance
		 * @typechecks
		 */
		
		'use strict';
		
		var ExecutionEnvironment = __webpack_require__(9);
		
		var performance;
		
		if (ExecutionEnvironment.canUseDOM) {
		  performance = window.performance || window.msPerformance || window.webkitPerformance;
		}
		
		module.exports = performance || {};
	
	/***/ },
	/* 146 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactVersion
		 */
		
		'use strict';
		
		module.exports = '0.14.8';
	
	/***/ },
	/* 147 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		* @providesModule renderSubtreeIntoContainer
		*/
		
		'use strict';
		
		var ReactMount = __webpack_require__(28);
		
		module.exports = ReactMount.renderSubtreeIntoContainer;
	
	/***/ },
	/* 148 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactDOMServer
		 */
		
		'use strict';
		
		var ReactDefaultInjection = __webpack_require__(71);
		var ReactServerRendering = __webpack_require__(149);
		var ReactVersion = __webpack_require__(146);
		
		ReactDefaultInjection.inject();
		
		var ReactDOMServer = {
		  renderToString: ReactServerRendering.renderToString,
		  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
		  version: ReactVersion
		};
		
		module.exports = ReactDOMServer;
	
	/***/ },
	/* 149 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @typechecks static-only
		 * @providesModule ReactServerRendering
		 */
		'use strict';
		
		var ReactDefaultBatchingStrategy = __webpack_require__(92);
		var ReactElement = __webpack_require__(42);
		var ReactInstanceHandles = __webpack_require__(45);
		var ReactMarkupChecksum = __webpack_require__(48);
		var ReactServerBatchingStrategy = __webpack_require__(150);
		var ReactServerRenderingTransaction = __webpack_require__(151);
		var ReactUpdates = __webpack_require__(54);
		
		var emptyObject = __webpack_require__(58);
		var instantiateReactComponent = __webpack_require__(62);
		var invariant = __webpack_require__(13);
		
		/**
		 * @param {ReactElement} element
		 * @return {string} the HTML markup
		 */
		function renderToString(element) {
		  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToString(): You must pass a valid ReactElement.') : invariant(false) : undefined;
		
		  var transaction;
		  try {
		    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);
		
		    var id = ReactInstanceHandles.createReactRootID();
		    transaction = ReactServerRenderingTransaction.getPooled(false);
		
		    return transaction.perform(function () {
		      var componentInstance = instantiateReactComponent(element, null);
		      var markup = componentInstance.mountComponent(id, transaction, emptyObject);
		      return ReactMarkupChecksum.addChecksumToMarkup(markup);
		    }, null);
		  } finally {
		    ReactServerRenderingTransaction.release(transaction);
		    // Revert to the DOM batching strategy since these two renderers
		    // currently share these stateful modules.
		    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
		  }
		}
		
		/**
		 * @param {ReactElement} element
		 * @return {string} the HTML markup, without the extra React ID and checksum
		 * (for generating static pages)
		 */
		function renderToStaticMarkup(element) {
		  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(false) : undefined;
		
		  var transaction;
		  try {
		    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);
		
		    var id = ReactInstanceHandles.createReactRootID();
		    transaction = ReactServerRenderingTransaction.getPooled(true);
		
		    return transaction.perform(function () {
		      var componentInstance = instantiateReactComponent(element, null);
		      return componentInstance.mountComponent(id, transaction, emptyObject);
		    }, null);
		  } finally {
		    ReactServerRenderingTransaction.release(transaction);
		    // Revert to the DOM batching strategy since these two renderers
		    // currently share these stateful modules.
		    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
		  }
		}
		
		module.exports = {
		  renderToString: renderToString,
		  renderToStaticMarkup: renderToStaticMarkup
		};
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 150 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2014-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactServerBatchingStrategy
		 * @typechecks
		 */
		
		'use strict';
		
		var ReactServerBatchingStrategy = {
		  isBatchingUpdates: false,
		  batchedUpdates: function (callback) {
		    // Don't do anything here. During the server rendering we don't want to
		    // schedule any updates. We will simply ignore them.
		  }
		};
		
		module.exports = ReactServerBatchingStrategy;
	
	/***/ },
	/* 151 */
	/***/ function(module, exports, __webpack_require__) {
	
		/**
		 * Copyright 2014-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactServerRenderingTransaction
		 * @typechecks
		 */
		
		'use strict';
		
		var PooledClass = __webpack_require__(56);
		var CallbackQueue = __webpack_require__(55);
		var Transaction = __webpack_require__(57);
		
		var assign = __webpack_require__(39);
		var emptyFunction = __webpack_require__(15);
		
		/**
		 * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks
		 * during the performing of the transaction.
		 */
		var ON_DOM_READY_QUEUEING = {
		  /**
		   * Initializes the internal `onDOMReady` queue.
		   */
		  initialize: function () {
		    this.reactMountReady.reset();
		  },
		
		  close: emptyFunction
		};
		
		/**
		 * Executed within the scope of the `Transaction` instance. Consider these as
		 * being member methods, but with an implied ordering while being isolated from
		 * each other.
		 */
		var TRANSACTION_WRAPPERS = [ON_DOM_READY_QUEUEING];
		
		/**
		 * @class ReactServerRenderingTransaction
		 * @param {boolean} renderToStaticMarkup
		 */
		function ReactServerRenderingTransaction(renderToStaticMarkup) {
		  this.reinitializeTransaction();
		  this.renderToStaticMarkup = renderToStaticMarkup;
		  this.reactMountReady = CallbackQueue.getPooled(null);
		  this.useCreateElement = false;
		}
		
		var Mixin = {
		  /**
		   * @see Transaction
		   * @abstract
		   * @final
		   * @return {array} Empty list of operation wrap procedures.
		   */
		  getTransactionWrappers: function () {
		    return TRANSACTION_WRAPPERS;
		  },
		
		  /**
		   * @return {object} The queue to collect `onDOMReady` callbacks with.
		   */
		  getReactMountReady: function () {
		    return this.reactMountReady;
		  },
		
		  /**
		   * `PooledClass` looks for this, and will invoke this before allowing this
		   * instance to be reused.
		   */
		  destructor: function () {
		    CallbackQueue.release(this.reactMountReady);
		    this.reactMountReady = null;
		  }
		};
		
		assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);
		
		PooledClass.addPoolingTo(ReactServerRenderingTransaction);
		
		module.exports = ReactServerRenderingTransaction;
	
	/***/ },
	/* 152 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactIsomorphic
		 */
		
		'use strict';
		
		var ReactChildren = __webpack_require__(110);
		var ReactComponent = __webpack_require__(123);
		var ReactClass = __webpack_require__(122);
		var ReactDOMFactories = __webpack_require__(153);
		var ReactElement = __webpack_require__(42);
		var ReactElementValidator = __webpack_require__(154);
		var ReactPropTypes = __webpack_require__(107);
		var ReactVersion = __webpack_require__(146);
		
		var assign = __webpack_require__(39);
		var onlyChild = __webpack_require__(156);
		
		var createElement = ReactElement.createElement;
		var createFactory = ReactElement.createFactory;
		var cloneElement = ReactElement.cloneElement;
		
		if (process.env.NODE_ENV !== 'production') {
		  createElement = ReactElementValidator.createElement;
		  createFactory = ReactElementValidator.createFactory;
		  cloneElement = ReactElementValidator.cloneElement;
		}
		
		var React = {
		
		  // Modern
		
		  Children: {
		    map: ReactChildren.map,
		    forEach: ReactChildren.forEach,
		    count: ReactChildren.count,
		    toArray: ReactChildren.toArray,
		    only: onlyChild
		  },
		
		  Component: ReactComponent,
		
		  createElement: createElement,
		  cloneElement: cloneElement,
		  isValidElement: ReactElement.isValidElement,
		
		  // Classic
		
		  PropTypes: ReactPropTypes,
		  createClass: ReactClass.createClass,
		  createFactory: createFactory,
		  createMixin: function (mixin) {
		    // Currently a noop. Will be used to validate and trace mixins.
		    return mixin;
		  },
		
		  // This looks DOM specific but these are actually isomorphic helpers
		  // since they are just generating DOM strings.
		  DOM: ReactDOMFactories,
		
		  version: ReactVersion,
		
		  // Hook for JSX spread, don't use this for anything else.
		  __spread: assign
		};
		
		module.exports = React;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 153 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactDOMFactories
		 * @typechecks static-only
		 */
		
		'use strict';
		
		var ReactElement = __webpack_require__(42);
		var ReactElementValidator = __webpack_require__(154);
		
		var mapObject = __webpack_require__(155);
		
		/**
		 * Create a factory that creates HTML tag elements.
		 *
		 * @param {string} tag Tag name (e.g. `div`).
		 * @private
		 */
		function createDOMFactory(tag) {
		  if (process.env.NODE_ENV !== 'production') {
		    return ReactElementValidator.createFactory(tag);
		  }
		  return ReactElement.createFactory(tag);
		}
		
		/**
		 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
		 * This is also accessible via `React.DOM`.
		 *
		 * @public
		 */
		var ReactDOMFactories = mapObject({
		  a: 'a',
		  abbr: 'abbr',
		  address: 'address',
		  area: 'area',
		  article: 'article',
		  aside: 'aside',
		  audio: 'audio',
		  b: 'b',
		  base: 'base',
		  bdi: 'bdi',
		  bdo: 'bdo',
		  big: 'big',
		  blockquote: 'blockquote',
		  body: 'body',
		  br: 'br',
		  button: 'button',
		  canvas: 'canvas',
		  caption: 'caption',
		  cite: 'cite',
		  code: 'code',
		  col: 'col',
		  colgroup: 'colgroup',
		  data: 'data',
		  datalist: 'datalist',
		  dd: 'dd',
		  del: 'del',
		  details: 'details',
		  dfn: 'dfn',
		  dialog: 'dialog',
		  div: 'div',
		  dl: 'dl',
		  dt: 'dt',
		  em: 'em',
		  embed: 'embed',
		  fieldset: 'fieldset',
		  figcaption: 'figcaption',
		  figure: 'figure',
		  footer: 'footer',
		  form: 'form',
		  h1: 'h1',
		  h2: 'h2',
		  h3: 'h3',
		  h4: 'h4',
		  h5: 'h5',
		  h6: 'h6',
		  head: 'head',
		  header: 'header',
		  hgroup: 'hgroup',
		  hr: 'hr',
		  html: 'html',
		  i: 'i',
		  iframe: 'iframe',
		  img: 'img',
		  input: 'input',
		  ins: 'ins',
		  kbd: 'kbd',
		  keygen: 'keygen',
		  label: 'label',
		  legend: 'legend',
		  li: 'li',
		  link: 'link',
		  main: 'main',
		  map: 'map',
		  mark: 'mark',
		  menu: 'menu',
		  menuitem: 'menuitem',
		  meta: 'meta',
		  meter: 'meter',
		  nav: 'nav',
		  noscript: 'noscript',
		  object: 'object',
		  ol: 'ol',
		  optgroup: 'optgroup',
		  option: 'option',
		  output: 'output',
		  p: 'p',
		  param: 'param',
		  picture: 'picture',
		  pre: 'pre',
		  progress: 'progress',
		  q: 'q',
		  rp: 'rp',
		  rt: 'rt',
		  ruby: 'ruby',
		  s: 's',
		  samp: 'samp',
		  script: 'script',
		  section: 'section',
		  select: 'select',
		  small: 'small',
		  source: 'source',
		  span: 'span',
		  strong: 'strong',
		  style: 'style',
		  sub: 'sub',
		  summary: 'summary',
		  sup: 'sup',
		  table: 'table',
		  tbody: 'tbody',
		  td: 'td',
		  textarea: 'textarea',
		  tfoot: 'tfoot',
		  th: 'th',
		  thead: 'thead',
		  time: 'time',
		  title: 'title',
		  tr: 'tr',
		  track: 'track',
		  u: 'u',
		  ul: 'ul',
		  'var': 'var',
		  video: 'video',
		  wbr: 'wbr',
		
		  // SVG
		  circle: 'circle',
		  clipPath: 'clipPath',
		  defs: 'defs',
		  ellipse: 'ellipse',
		  g: 'g',
		  image: 'image',
		  line: 'line',
		  linearGradient: 'linearGradient',
		  mask: 'mask',
		  path: 'path',
		  pattern: 'pattern',
		  polygon: 'polygon',
		  polyline: 'polyline',
		  radialGradient: 'radialGradient',
		  rect: 'rect',
		  stop: 'stop',
		  svg: 'svg',
		  text: 'text',
		  tspan: 'tspan'
		
		}, createDOMFactory);
		
		module.exports = ReactDOMFactories;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 154 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2014-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule ReactElementValidator
		 */
		
		/**
		 * ReactElementValidator provides a wrapper around a element factory
		 * which validates the props passed to the element. This is intended to be
		 * used only in DEV and could be replaced by a static type checker for languages
		 * that support it.
		 */
		
		'use strict';
		
		var ReactElement = __webpack_require__(42);
		var ReactPropTypeLocations = __webpack_require__(65);
		var ReactPropTypeLocationNames = __webpack_require__(66);
		var ReactCurrentOwner = __webpack_require__(5);
		
		var canDefineProperty = __webpack_require__(43);
		var getIteratorFn = __webpack_require__(108);
		var invariant = __webpack_require__(13);
		var warning = __webpack_require__(25);
		
		function getDeclarationErrorAddendum() {
		  if (ReactCurrentOwner.current) {
		    var name = ReactCurrentOwner.current.getName();
		    if (name) {
		      return ' Check the render method of `' + name + '`.';
		    }
		  }
		  return '';
		}
		
		/**
		 * Warn if there's no key explicitly set on dynamic arrays of children or
		 * object keys are not valid. This allows us to keep track of children between
		 * updates.
		 */
		var ownerHasKeyUseWarning = {};
		
		var loggedTypeFailures = {};
		
		/**
		 * Warn if the element doesn't have an explicit key assigned to it.
		 * This element is in an array. The array could grow and shrink or be
		 * reordered. All children that haven't already been validated are required to
		 * have a "key" property assigned to it.
		 *
		 * @internal
		 * @param {ReactElement} element Element that requires a key.
		 * @param {*} parentType element's parent's type.
		 */
		function validateExplicitKey(element, parentType) {
		  if (!element._store || element._store.validated || element.key != null) {
		    return;
		  }
		  element._store.validated = true;
		
		  var addenda = getAddendaForKeyUse('uniqueKey', element, parentType);
		  if (addenda === null) {
		    // we already showed the warning
		    return;
		  }
		  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s%s', addenda.parentOrOwner || '', addenda.childOwner || '', addenda.url || '') : undefined;
		}
		
		/**
		 * Shared warning and monitoring code for the key warnings.
		 *
		 * @internal
		 * @param {string} messageType A key used for de-duping warnings.
		 * @param {ReactElement} element Component that requires a key.
		 * @param {*} parentType element's parent's type.
		 * @returns {?object} A set of addenda to use in the warning message, or null
		 * if the warning has already been shown before (and shouldn't be shown again).
		 */
		function getAddendaForKeyUse(messageType, element, parentType) {
		  var addendum = getDeclarationErrorAddendum();
		  if (!addendum) {
		    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
		    if (parentName) {
		      addendum = ' Check the top-level render call using <' + parentName + '>.';
		    }
		  }
		
		  var memoizer = ownerHasKeyUseWarning[messageType] || (ownerHasKeyUseWarning[messageType] = {});
		  if (memoizer[addendum]) {
		    return null;
		  }
		  memoizer[addendum] = true;
		
		  var addenda = {
		    parentOrOwner: addendum,
		    url: ' See https://fb.me/react-warning-keys for more information.',
		    childOwner: null
		  };
		
		  // Usually the current owner is the offender, but if it accepts children as a
		  // property, it may be the creator of the child that's responsible for
		  // assigning it a key.
		  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
		    // Give the component that originally created this child.
		    addenda.childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
		  }
		
		  return addenda;
		}
		
		/**
		 * Ensure that every element either is passed in a static location, in an
		 * array with an explicit keys property defined, or in an object literal
		 * with valid key property.
		 *
		 * @internal
		 * @param {ReactNode} node Statically passed child of any type.
		 * @param {*} parentType node's parent's type.
		 */
		function validateChildKeys(node, parentType) {
		  if (typeof node !== 'object') {
		    return;
		  }
		  if (Array.isArray(node)) {
		    for (var i = 0; i < node.length; i++) {
		      var child = node[i];
		      if (ReactElement.isValidElement(child)) {
		        validateExplicitKey(child, parentType);
		      }
		    }
		  } else if (ReactElement.isValidElement(node)) {
		    // This element was passed in a valid location.
		    if (node._store) {
		      node._store.validated = true;
		    }
		  } else if (node) {
		    var iteratorFn = getIteratorFn(node);
		    // Entry iterators provide implicit keys.
		    if (iteratorFn) {
		      if (iteratorFn !== node.entries) {
		        var iterator = iteratorFn.call(node);
		        var step;
		        while (!(step = iterator.next()).done) {
		          if (ReactElement.isValidElement(step.value)) {
		            validateExplicitKey(step.value, parentType);
		          }
		        }
		      }
		    }
		  }
		}
		
		/**
		 * Assert that the props are valid
		 *
		 * @param {string} componentName Name of the component for error messages.
		 * @param {object} propTypes Map of prop name to a ReactPropType
		 * @param {object} props
		 * @param {string} location e.g. "prop", "context", "child context"
		 * @private
		 */
		function checkPropTypes(componentName, propTypes, props, location) {
		  for (var propName in propTypes) {
		    if (propTypes.hasOwnProperty(propName)) {
		      var error;
		      // Prop type validation may throw. In case they do, we don't want to
		      // fail the render phase where it didn't fail before. So we log it.
		      // After these have been cleaned up, we'll let them throw.
		      try {
		        // This is intentionally an invariant that gets caught. It's the same
		        // behavior as without this statement except with a better message.
		        !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
		        error = propTypes[propName](props, propName, componentName, location);
		      } catch (ex) {
		        error = ex;
		      }
		      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], propName, typeof error) : undefined;
		      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
		        // Only monitor this failure once because there tends to be a lot of the
		        // same error.
		        loggedTypeFailures[error.message] = true;
		
		        var addendum = getDeclarationErrorAddendum();
		        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed propType: %s%s', error.message, addendum) : undefined;
		      }
		    }
		  }
		}
		
		/**
		 * Given an element, validate that its props follow the propTypes definition,
		 * provided by the type.
		 *
		 * @param {ReactElement} element
		 */
		function validatePropTypes(element) {
		  var componentClass = element.type;
		  if (typeof componentClass !== 'function') {
		    return;
		  }
		  var name = componentClass.displayName || componentClass.name;
		  if (componentClass.propTypes) {
		    checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);
		  }
		  if (typeof componentClass.getDefaultProps === 'function') {
		    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : undefined;
		  }
		}
		
		var ReactElementValidator = {
		
		  createElement: function (type, props, children) {
		    var validType = typeof type === 'string' || typeof type === 'function';
		    // We warn in this case but don't throw. We expect the element creation to
		    // succeed and there will likely be errors in render.
		    process.env.NODE_ENV !== 'production' ? warning(validType, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : undefined;
		
		    var element = ReactElement.createElement.apply(this, arguments);
		
		    // The result can be nullish if a mock or a custom function is used.
		    // TODO: Drop this when these are no longer allowed as the type argument.
		    if (element == null) {
		      return element;
		    }
		
		    // Skip key warning if the type isn't valid since our key validation logic
		    // doesn't expect a non-string/function type and can throw confusing errors.
		    // We don't want exception behavior to differ between dev and prod.
		    // (Rendering will throw with a helpful message and as soon as the type is
		    // fixed, the key warnings will appear.)
		    if (validType) {
		      for (var i = 2; i < arguments.length; i++) {
		        validateChildKeys(arguments[i], type);
		      }
		    }
		
		    validatePropTypes(element);
		
		    return element;
		  },
		
		  createFactory: function (type) {
		    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
		    // Legacy hook TODO: Warn if this is accessed
		    validatedFactory.type = type;
		
		    if (process.env.NODE_ENV !== 'production') {
		      if (canDefineProperty) {
		        Object.defineProperty(validatedFactory, 'type', {
		          enumerable: false,
		          get: function () {
		            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : undefined;
		            Object.defineProperty(this, 'type', {
		              value: type
		            });
		            return type;
		          }
		        });
		      }
		    }
		
		    return validatedFactory;
		  },
		
		  cloneElement: function (element, props, children) {
		    var newElement = ReactElement.cloneElement.apply(this, arguments);
		    for (var i = 2; i < arguments.length; i++) {
		      validateChildKeys(arguments[i], newElement.type);
		    }
		    validatePropTypes(newElement);
		    return newElement;
		  }
		
		};
		
		module.exports = ReactElementValidator;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 155 */
	/***/ function(module, exports) {
	
		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule mapObject
		 */
		
		'use strict';
		
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		
		/**
		 * Executes the provided `callback` once for each enumerable own property in the
		 * object and constructs a new object from the results. The `callback` is
		 * invoked with three arguments:
		 *
		 *  - the property value
		 *  - the property name
		 *  - the object being traversed
		 *
		 * Properties that are added after the call to `mapObject` will not be visited
		 * by `callback`. If the values of existing properties are changed, the value
		 * passed to `callback` will be the value at the time `mapObject` visits them.
		 * Properties that are deleted before being visited are not visited.
		 *
		 * @grep function objectMap()
		 * @grep function objMap()
		 *
		 * @param {?object} object
		 * @param {function} callback
		 * @param {*} context
		 * @return {?object}
		 */
		function mapObject(object, callback, context) {
		  if (!object) {
		    return null;
		  }
		  var result = {};
		  for (var name in object) {
		    if (hasOwnProperty.call(object, name)) {
		      result[name] = callback.call(context, object[name], name, object);
		    }
		  }
		  return result;
		}
		
		module.exports = mapObject;
	
	/***/ },
	/* 156 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule onlyChild
		 */
		'use strict';
		
		var ReactElement = __webpack_require__(42);
		
		var invariant = __webpack_require__(13);
		
		/**
		 * Returns the first child in a collection of children and verifies that there
		 * is only one child in the collection. The current implementation of this
		 * function assumes that a single child gets passed without a wrapper, but the
		 * purpose of this helper function is to abstract away the particular structure
		 * of children.
		 *
		 * @param {?object} children Child collection structure.
		 * @return {ReactComponent} The first and only `ReactComponent` contained in the
		 * structure.
		 */
		function onlyChild(children) {
		  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'onlyChild must be passed a children with exactly one child.') : invariant(false) : undefined;
		  return children;
		}
		
		module.exports = onlyChild;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 157 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule deprecated
		 */
		
		'use strict';
		
		var assign = __webpack_require__(39);
		var warning = __webpack_require__(25);
		
		/**
		 * This will log a single deprecation notice per function and forward the call
		 * on to the new API.
		 *
		 * @param {string} fnName The name of the function
		 * @param {string} newModule The module that fn will exist in
		 * @param {string} newPackage The module that fn will exist in
		 * @param {*} ctx The context this forwarded call should run in
		 * @param {function} fn The function to forward on to
		 * @return {function} The function that will warn once and then call fn
		 */
		function deprecated(fnName, newModule, newPackage, ctx, fn) {
		  var warned = false;
		  if (process.env.NODE_ENV !== 'production') {
		    var newFn = function () {
		      process.env.NODE_ENV !== 'production' ? warning(warned,
		      // Require examples in this string must be split to prevent React's
		      // build tools from mistaking them for real requires.
		      // Otherwise the build tools will attempt to build a '%s' module.
		      'React.%s is deprecated. Please use %s.%s from require' + '(\'%s\') ' + 'instead.', fnName, newModule, fnName, newPackage) : undefined;
		      warned = true;
		      return fn.apply(ctx, arguments);
		    };
		    // We need to make sure all properties of the original fn are copied over.
		    // In particular, this is needed to support PropTypes
		    return assign(newFn, fn);
		  }
		
		  return fn;
		}
		
		module.exports = deprecated;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))
	
	/***/ },
	/* 158 */
	/***/ function(module, exports) {
	
		"use strict";
		
		var _id = 0;
		
		module.exports = function generateId() {
		  return "simplepostmd-editor-" + ++_id;
		};
	
	/***/ },
	/* 159 */
	/***/ function(module, exports) {
	
		"use strict";
		
		module.exports = function () {};
	
	/***/ },
	/* 160 */
	/***/ function(module, exports, __webpack_require__) {
	
		/*global require,module*/
		"use strict";
		var CodeMirror = __webpack_require__(161);
		__webpack_require__(162);
		__webpack_require__(163);
		__webpack_require__(164);
		__webpack_require__(165);
		__webpack_require__(168);
		__webpack_require__(169);
		__webpack_require__(170);
		__webpack_require__(171);
		__webpack_require__(166);
		var CodeMirrorSpellChecker = __webpack_require__(172);
		var marked = __webpack_require__(179);
		
		
		// Some variables
		var isMac = /Mac/.test(navigator.platform);
		
		// Mapping of actions that can be bound to keyboard shortcuts or toolbar buttons
		var bindings = {
			"toggleBold": toggleBold,
			"toggleItalic": toggleItalic,
			"drawLink": drawLink,
			"toggleHeadingSmaller": toggleHeadingSmaller,
			"toggleHeadingBigger": toggleHeadingBigger,
			"drawImage": drawImage,
			"toggleBlockquote": toggleBlockquote,
			"toggleOrderedList": toggleOrderedList,
			"toggleUnorderedList": toggleUnorderedList,
			"toggleCodeBlock": toggleCodeBlock,
			"togglePreview": togglePreview,
			"toggleStrikethrough": toggleStrikethrough,
			"toggleHeading1": toggleHeading1,
			"toggleHeading2": toggleHeading2,
			"toggleHeading3": toggleHeading3,
			"cleanBlock": cleanBlock,
			"drawTable": drawTable,
			"drawHorizontalRule": drawHorizontalRule,
			"undo": undo,
			"redo": redo,
			"toggleSideBySide": toggleSideBySide,
			"toggleFullScreen": toggleFullScreen
		};
		
		var shortcuts = {
			"toggleBold": "Cmd-B",
			"toggleItalic": "Cmd-I",
			"drawLink": "Cmd-K",
			"toggleHeadingSmaller": "Cmd-H",
			"toggleHeadingBigger": "Shift-Cmd-H",
			"cleanBlock": "Cmd-E",
			"drawImage": "Cmd-Alt-I",
			"toggleBlockquote": "Cmd-'",
			"toggleOrderedList": "Cmd-Alt-L",
			"toggleUnorderedList": "Cmd-L",
			"toggleCodeBlock": "Cmd-Alt-C",
			"togglePreview": "Cmd-P",
			"toggleSideBySide": "F9",
			"toggleFullScreen": "F11"
		};
		
		var getBindingName = function(f) {
			for(var key in bindings) {
				if(bindings[key] === f) {
					return key;
				}
			}
			return null;
		};
		
		var isMobile = function() {
			var check = false;
			(function(a) {
				if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) check = true;
			})(navigator.userAgent || navigator.vendor || window.opera);
			return check;
		};
		
		
		/**
		 * Fix shortcut. Mac use Command, others use Ctrl.
		 */
		function fixShortcut(name) {
			if(isMac) {
				name = name.replace("Ctrl", "Cmd");
			} else {
				name = name.replace("Cmd", "Ctrl");
			}
			return name;
		}
		
		
		/**
		 * Create icon element for toolbar.
		 */
		function createIcon(options, enableTooltips, shortcuts) {
			options = options || {};
			var el = document.createElement("a");
			enableTooltips = (enableTooltips == undefined) ? true : enableTooltips;
		
			if(options.title && enableTooltips) {
				el.title = createTootlip(options.title, options.action, shortcuts);
		
				if(isMac) {
					el.title = el.title.replace("Ctrl", "⌘");
					el.title = el.title.replace("Alt", "⌥");
				}
			}
		
			el.tabIndex = -1;
			el.className = options.className;
			return el;
		}
		
		function createSep() {
			var el = document.createElement("i");
			el.className = "separator";
			el.innerHTML = "|";
			return el;
		}
		
		function createTootlip(title, action, shortcuts) {
			var actionName;
			var tooltip = title;
		
			if(action) {
				actionName = getBindingName(action);
				if(shortcuts[actionName]) {
					tooltip += " (" + fixShortcut(shortcuts[actionName]) + ")";
				}
			}
		
			return tooltip;
		}
		
		/**
		 * The state of CodeMirror at the given position.
		 */
		function getState(cm, pos) {
			pos = pos || cm.getCursor("start");
			var stat = cm.getTokenAt(pos);
			if(!stat.type) return {};
		
			var types = stat.type.split(" ");
		
			var ret = {},
				data, text;
			for(var i = 0; i < types.length; i++) {
				data = types[i];
				if(data === "strong") {
					ret.bold = true;
				} else if(data === "variable-2") {
					text = cm.getLine(pos.line);
					if(/^\s*\d+\.\s/.test(text)) {
						ret["ordered-list"] = true;
					} else {
						ret["unordered-list"] = true;
					}
				} else if(data === "atom") {
					ret.quote = true;
				} else if(data === "em") {
					ret.italic = true;
				} else if(data === "quote") {
					ret.quote = true;
				} else if(data === "strikethrough") {
					ret.strikethrough = true;
				} else if(data === "comment") {
					ret.code = true;
				} else if(data === "link") {
					ret.link = true;
				} else if(data === "tag") {
					ret.image = true;
				} else if(data.match(/^header(\-[1-6])?$/)) {
					ret[data.replace("header", "heading")] = true;
				}
			}
			return ret;
		}
		
		
		// Saved overflow setting
		var saved_overflow = "";
		
		/**
		 * Toggle full screen of the editor.
		 */
		function toggleFullScreen(editor) {
			// Set fullscreen
			var cm = editor.codemirror;
			cm.setOption("fullScreen", !cm.getOption("fullScreen"));
		
		
			// Prevent scrolling on body during fullscreen active
			if(cm.getOption("fullScreen")) {
				saved_overflow = document.body.style.overflow;
				document.body.style.overflow = "hidden";
			} else {
				document.body.style.overflow = saved_overflow;
			}
		
		
			// Update toolbar class
			var wrap = cm.getWrapperElement();
		
			if(!/fullscreen/.test(wrap.previousSibling.className)) {
				wrap.previousSibling.className += " fullscreen";
			} else {
				wrap.previousSibling.className = wrap.previousSibling.className.replace(/\s*fullscreen\b/, "");
			}
		
		
			// Update toolbar button
			var toolbarButton = editor.toolbarElements.fullscreen;
		
			if(!/active/.test(toolbarButton.className)) {
				toolbarButton.className += " active";
			} else {
				toolbarButton.className = toolbarButton.className.replace(/\s*active\s*/g, "");
			}
		
		
			// Hide side by side if needed
			var sidebyside = cm.getWrapperElement().nextSibling;
			if(/editor-preview-active-side/.test(sidebyside.className))
				toggleSideBySide(editor);
		}
		
		
		/**
		 * Action for toggling bold.
		 */
		function toggleBold(editor) {
			_toggleBlock(editor, "bold", editor.options.blockStyles.bold);
		}
		
		
		/**
		 * Action for toggling italic.
		 */
		function toggleItalic(editor) {
			_toggleBlock(editor, "italic", editor.options.blockStyles.italic);
		}
		
		
		/**
		 * Action for toggling strikethrough.
		 */
		function toggleStrikethrough(editor) {
			_toggleBlock(editor, "strikethrough", "~~");
		}
		
		/**
		 * Action for toggling code block.
		 */
		function toggleCodeBlock(editor) {
			var fenceCharsToInsert = editor.options.blockStyles.code;
		
			function fencing_line(line) {
				/* return true, if this is a ``` or ~~~ line */
				if(typeof line !== "object") {
					throw "fencing_line() takes a 'line' object (not a line number, or line text).  Got: " + typeof line + ": " + line;
				}
				return line.styles && line.styles[2] && line.styles[2].indexOf("formatting-code-block") !== -1;
			}
		
			function token_state(token) {
				// base goes an extra level deep when mode backdrops are used, e.g. spellchecker on
				return token.state.base.base || token.state.base;
			}
		
			function code_type(cm, line_num, line, firstTok, lastTok) {
				/*
				 * Return "single", "indented", "fenced" or false
				 *
				 * cm and line_num are required.  Others are optional for efficiency
				 *   To check in the middle of a line, pass in firstTok yourself.
				 */
				line = line || cm.getLineHandle(line_num);
				firstTok = firstTok || cm.getTokenAt({
					line: line_num,
					ch: 1
				});
				lastTok = lastTok || (!!line.text && cm.getTokenAt({
					line: line_num,
					ch: line.text.length - 1
				}));
				var types = firstTok.type ? firstTok.type.split(" ") : [];
				if(lastTok && token_state(lastTok).indentedCode) {
					// have to check last char, since first chars of first line aren"t marked as indented
					return "indented";
				} else if(types.indexOf("comment") === -1) {
					// has to be after "indented" check, since first chars of first indented line aren"t marked as such
					return false;
				} else if(token_state(firstTok).fencedChars || token_state(lastTok).fencedChars || fencing_line(line)) {
					return "fenced";
				} else {
					return "single";
				}
			}
		
			function insertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert) {
				var start_line_sel = cur_start.line + 1,
					end_line_sel = cur_end.line + 1,
					sel_multi = cur_start.line !== cur_end.line,
					repl_start = fenceCharsToInsert + "\n",
					repl_end = "\n" + fenceCharsToInsert;
				if(sel_multi) {
					end_line_sel++;
				}
				// handle last char including \n or not
				if(sel_multi && cur_end.ch === 0) {
					repl_end = fenceCharsToInsert + "\n";
					end_line_sel--;
				}
				_replaceSelection(cm, false, [repl_start, repl_end]);
				cm.setSelection({
					line: start_line_sel,
					ch: 0
				}, {
					line: end_line_sel,
					ch: 0
				});
			}
		
			var cm = editor.codemirror,
				cur_start = cm.getCursor("start"),
				cur_end = cm.getCursor("end"),
				tok = cm.getTokenAt({
					line: cur_start.line,
					ch: cur_start.ch || 1
				}), // avoid ch 0 which is a cursor pos but not token
				line = cm.getLineHandle(cur_start.line),
				is_code = code_type(cm, cur_start.line, line, tok);
			var block_start, block_end, lineCount;
		
			if(is_code === "single") {
				// similar to some SimpleMDE _toggleBlock logic
				var start = line.text.slice(0, cur_start.ch).replace("`", ""),
					end = line.text.slice(cur_start.ch).replace("`", "");
				cm.replaceRange(start + end, {
					line: cur_start.line,
					ch: 0
				}, {
					line: cur_start.line,
					ch: 99999999999999
				});
				cur_start.ch--;
				if(cur_start !== cur_end) {
					cur_end.ch--;
				}
				cm.setSelection(cur_start, cur_end);
				cm.focus();
			} else if(is_code === "fenced") {
				if(cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {
					// use selection
		
					// find the fenced line so we know what type it is (tilde, backticks, number of them)
					for(block_start = cur_start.line; block_start >= 0; block_start--) {
						line = cm.getLineHandle(block_start);
						if(fencing_line(line)) {
							break;
						}
					}
					var fencedTok = cm.getTokenAt({
						line: block_start,
						ch: 1
					});
					var fence_chars = token_state(fencedTok).fencedChars;
					var start_text, start_line;
					var end_text, end_line;
					// check for selection going up against fenced lines, in which case we don't want to add more fencing
					if(fencing_line(cm.getLineHandle(cur_start.line))) {
						start_text = "";
						start_line = cur_start.line;
					} else if(fencing_line(cm.getLineHandle(cur_start.line - 1))) {
						start_text = "";
						start_line = cur_start.line - 1;
					} else {
						start_text = fence_chars + "\n";
						start_line = cur_start.line;
					}
					if(fencing_line(cm.getLineHandle(cur_end.line))) {
						end_text = "";
						end_line = cur_end.line;
						if(cur_end.ch === 0) {
							end_line += 1;
						}
					} else if(cur_end.ch !== 0 && fencing_line(cm.getLineHandle(cur_end.line + 1))) {
						end_text = "";
						end_line = cur_end.line + 1;
					} else {
						end_text = fence_chars + "\n";
						end_line = cur_end.line + 1;
					}
					if(cur_end.ch === 0) {
						// full last line selected, putting cursor at beginning of next
						end_line -= 1;
					}
					cm.operation(function() {
						// end line first, so that line numbers don't change
						cm.replaceRange(end_text, {
							line: end_line,
							ch: 0
						}, {
							line: end_line + (end_text ? 0 : 1),
							ch: 0
						});
						cm.replaceRange(start_text, {
							line: start_line,
							ch: 0
						}, {
							line: start_line + (start_text ? 0 : 1),
							ch: 0
						});
					});
					cm.setSelection({
						line: start_line + (start_text ? 1 : 0),
						ch: 0
					}, {
						line: end_line + (start_text ? 1 : -1),
						ch: 0
					});
					cm.focus();
				} else {
					// no selection, search for ends of this fenced block
					var search_from = cur_start.line;
					if(fencing_line(cm.getLineHandle(cur_start.line))) { // gets a little tricky if cursor is right on a fenced line
						if(code_type(cm, cur_start.line + 1) === "fenced") {
							block_start = cur_start.line;
							search_from = cur_start.line + 1; // for searching for "end"
						} else {
							block_end = cur_start.line;
							search_from = cur_start.line - 1; // for searching for "start"
						}
					}
					if(block_start === undefined) {
						for(block_start = search_from; block_start >= 0; block_start--) {
							line = cm.getLineHandle(block_start);
							if(fencing_line(line)) {
								break;
							}
						}
					}
					if(block_end === undefined) {
						lineCount = cm.lineCount();
						for(block_end = search_from; block_end < lineCount; block_end++) {
							line = cm.getLineHandle(block_end);
							if(fencing_line(line)) {
								break;
							}
						}
					}
					cm.operation(function() {
						cm.replaceRange("", {
							line: block_start,
							ch: 0
						}, {
							line: block_start + 1,
							ch: 0
						});
						cm.replaceRange("", {
							line: block_end - 1,
							ch: 0
						}, {
							line: block_end,
							ch: 0
						});
					});
					cm.focus();
				}
			} else if(is_code === "indented") {
				if(cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {
					// use selection
					block_start = cur_start.line;
					block_end = cur_end.line;
					if(cur_end.ch === 0) {
						block_end--;
					}
				} else {
					// no selection, search for ends of this indented block
					for(block_start = cur_start.line; block_start >= 0; block_start--) {
						line = cm.getLineHandle(block_start);
						if(line.text.match(/^\s*$/)) {
							// empty or all whitespace - keep going
							continue;
						} else {
							if(code_type(cm, block_start, line) !== "indented") {
								block_start += 1;
								break;
							}
						}
					}
					lineCount = cm.lineCount();
					for(block_end = cur_start.line; block_end < lineCount; block_end++) {
						line = cm.getLineHandle(block_end);
						if(line.text.match(/^\s*$/)) {
							// empty or all whitespace - keep going
							continue;
						} else {
							if(code_type(cm, block_end, line) !== "indented") {
								block_end -= 1;
								break;
							}
						}
					}
				}
				// if we are going to un-indent based on a selected set of lines, and the next line is indented too, we need to
				// insert a blank line so that the next line(s) continue to be indented code
				var next_line = cm.getLineHandle(block_end + 1),
					next_line_last_tok = next_line && cm.getTokenAt({
						line: block_end + 1,
						ch: next_line.text.length - 1
					}),
					next_line_indented = next_line_last_tok && token_state(next_line_last_tok).indentedCode;
				if(next_line_indented) {
					cm.replaceRange("\n", {
						line: block_end + 1,
						ch: 0
					});
				}
		
				for(var i = block_start; i <= block_end; i++) {
					cm.indentLine(i, "subtract"); // TODO: this doesn't get tracked in the history, so can't be undone :(
				}
				cm.focus();
			} else {
				// insert code formatting
				var no_sel_and_starting_of_line = (cur_start.line === cur_end.line && cur_start.ch === cur_end.ch && cur_start.ch === 0);
				var sel_multi = cur_start.line !== cur_end.line;
				if(no_sel_and_starting_of_line || sel_multi) {
					insertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert);
				} else {
					_replaceSelection(cm, false, ["`", "`"]);
				}
			}
		}
		
		/**
		 * Action for toggling blockquote.
		 */
		function toggleBlockquote(editor) {
			var cm = editor.codemirror;
			_toggleLine(cm, "quote");
		}
		
		/**
		 * Action for toggling heading size: normal -> h1 -> h2 -> h3 -> h4 -> h5 -> h6 -> normal
		 */
		function toggleHeadingSmaller(editor) {
			var cm = editor.codemirror;
			_toggleHeading(cm, "smaller");
		}
		
		/**
		 * Action for toggling heading size: normal -> h6 -> h5 -> h4 -> h3 -> h2 -> h1 -> normal
		 */
		function toggleHeadingBigger(editor) {
			var cm = editor.codemirror;
			_toggleHeading(cm, "bigger");
		}
		
		/**
		 * Action for toggling heading size 1
		 */
		function toggleHeading1(editor) {
			var cm = editor.codemirror;
			_toggleHeading(cm, undefined, 1);
		}
		
		/**
		 * Action for toggling heading size 2
		 */
		function toggleHeading2(editor) {
			var cm = editor.codemirror;
			_toggleHeading(cm, undefined, 2);
		}
		
		/**
		 * Action for toggling heading size 3
		 */
		function toggleHeading3(editor) {
			var cm = editor.codemirror;
			_toggleHeading(cm, undefined, 3);
		}
		
		
		/**
		 * Action for toggling ul.
		 */
		function toggleUnorderedList(editor) {
			var cm = editor.codemirror;
			_toggleLine(cm, "unordered-list");
		}
		
		
		/**
		 * Action for toggling ol.
		 */
		function toggleOrderedList(editor) {
			var cm = editor.codemirror;
			_toggleLine(cm, "ordered-list");
		}
		
		/**
		 * Action for clean block (remove headline, list, blockquote code, markers)
		 */
		function cleanBlock(editor) {
			var cm = editor.codemirror;
			_cleanBlock(cm);
		}
		
		/**
		 * Action for drawing a link.
		 */
		function drawLink(editor) {
			var cm = editor.codemirror;
			var stat = getState(cm);
			var options = editor.options;
			var url = "http://";
			if(options.promptURLs) {
				url = prompt(options.promptTexts.link);
				if(!url) {
					return false;
				}
			}
			_replaceSelection(cm, stat.link, options.insertTexts.link, url);
		}
		
		/**
		 * Action for drawing an img.
		 */
		function drawImage(editor) {
			var cm = editor.codemirror;
			var stat = getState(cm);
			var options = editor.options;
			var url = "http://";
			if(options.promptURLs) {
				url = prompt(options.promptTexts.image);
				if(!url) {
					return false;
				}
			}
			_replaceSelection(cm, stat.image, options.insertTexts.image, url);
		}
		
		/**
		 * Action for drawing a table.
		 */
		function drawTable(editor) {
			var cm = editor.codemirror;
			var stat = getState(cm);
			var options = editor.options;
			_replaceSelection(cm, stat.table, options.insertTexts.table);
		}
		
		/**
		 * Action for drawing a horizontal rule.
		 */
		function drawHorizontalRule(editor) {
			var cm = editor.codemirror;
			var stat = getState(cm);
			var options = editor.options;
			_replaceSelection(cm, stat.image, options.insertTexts.horizontalRule);
		}
		
		
		/**
		 * Undo action.
		 */
		function undo(editor) {
			var cm = editor.codemirror;
			cm.undo();
			cm.focus();
		}
		
		
		/**
		 * Redo action.
		 */
		function redo(editor) {
			var cm = editor.codemirror;
			cm.redo();
			cm.focus();
		}
		
		
		/**
		 * Toggle side by side preview
		 */
		function toggleSideBySide(editor) {
			var cm = editor.codemirror;
			var wrapper = cm.getWrapperElement();
			var preview = wrapper.nextSibling;
			var toolbarButton = editor.toolbarElements["side-by-side"];
			var useSideBySideListener = false;
			if(/editor-preview-active-side/.test(preview.className)) {
				preview.className = preview.className.replace(
					/\s*editor-preview-active-side\s*/g, ""
				);
				toolbarButton.className = toolbarButton.className.replace(/\s*active\s*/g, "");
				wrapper.className = wrapper.className.replace(/\s*CodeMirror-sided\s*/g, " ");
			} else {
				// When the preview button is clicked for the first time,
				// give some time for the transition from editor.css to fire and the view to slide from right to left,
				// instead of just appearing.
				setTimeout(function() {
					if(!cm.getOption("fullScreen"))
						toggleFullScreen(editor);
					preview.className += " editor-preview-active-side";
				}, 1);
				toolbarButton.className += " active";
				wrapper.className += " CodeMirror-sided";
				useSideBySideListener = true;
			}
		
			// Hide normal preview if active
			var previewNormal = wrapper.lastChild;
			if(/editor-preview-active/.test(previewNormal.className)) {
				previewNormal.className = previewNormal.className.replace(
					/\s*editor-preview-active\s*/g, ""
				);
				var toolbar = editor.toolbarElements.preview;
				var toolbar_div = wrapper.previousSibling;
				toolbar.className = toolbar.className.replace(/\s*active\s*/g, "");
				toolbar_div.className = toolbar_div.className.replace(/\s*disabled-for-preview*/g, "");
			}
		
			var sideBySideRenderingFunction = function() {
				preview.innerHTML = editor.options.previewRender(editor.value(), preview);
			};
		
			if(!cm.sideBySideRenderingFunction) {
				cm.sideBySideRenderingFunction = sideBySideRenderingFunction;
			}
		
			if(useSideBySideListener) {
				preview.innerHTML = editor.options.previewRender(editor.value(), preview);
				cm.on("update", cm.sideBySideRenderingFunction);
			} else {
				cm.off("update", cm.sideBySideRenderingFunction);
			}
		
			// Refresh to fix selection being off (#309)
			cm.refresh();
		}
		
		
		/**
		 * Preview action.
		 */
		function togglePreview(editor) {
			var cm = editor.codemirror;
			var wrapper = cm.getWrapperElement();
			var toolbar_div = wrapper.previousSibling;
			var toolbar = editor.options.toolbar ? editor.toolbarElements.preview : false;
			var preview = wrapper.lastChild;
			if(!preview || !/editor-preview/.test(preview.className)) {
				preview = document.createElement("div");
				preview.className = "editor-preview";
				wrapper.appendChild(preview);
			}
			if(/editor-preview-active/.test(preview.className)) {
				preview.className = preview.className.replace(
					/\s*editor-preview-active\s*/g, ""
				);
				if(toolbar) {
					toolbar.className = toolbar.className.replace(/\s*active\s*/g, "");
					toolbar_div.className = toolbar_div.className.replace(/\s*disabled-for-preview*/g, "");
				}
			} else {
				// When the preview button is clicked for the first time,
				// give some time for the transition from editor.css to fire and the view to slide from right to left,
				// instead of just appearing.
				setTimeout(function() {
					preview.className += " editor-preview-active";
				}, 1);
				if(toolbar) {
					toolbar.className += " active";
					toolbar_div.className += " disabled-for-preview";
				}
			}
			preview.innerHTML = editor.options.previewRender(editor.value(), preview);
		
			// Turn off side by side if needed
			var sidebyside = cm.getWrapperElement().nextSibling;
			if(/editor-preview-active-side/.test(sidebyside.className))
				toggleSideBySide(editor);
		}
		
		function _replaceSelection(cm, active, startEnd, url) {
			if(/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))
				return;
		
			var text;
			var start = startEnd[0];
			var end = startEnd[1];
			var startPoint = cm.getCursor("start");
			var endPoint = cm.getCursor("end");
			if(url) {
				end = end.replace("#url#", url);
			}
			if(active) {
				text = cm.getLine(startPoint.line);
				start = text.slice(0, startPoint.ch);
				end = text.slice(startPoint.ch);
				cm.replaceRange(start + end, {
					line: startPoint.line,
					ch: 0
				});
			} else {
				text = cm.getSelection();
				cm.replaceSelection(start + text + end);
		
				startPoint.ch += start.length;
				if(startPoint !== endPoint) {
					endPoint.ch += start.length;
				}
			}
			cm.setSelection(startPoint, endPoint);
			cm.focus();
		}
		
		
		function _toggleHeading(cm, direction, size) {
			if(/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))
				return;
		
			var startPoint = cm.getCursor("start");
			var endPoint = cm.getCursor("end");
			for(var i = startPoint.line; i <= endPoint.line; i++) {
				(function(i) {
					var text = cm.getLine(i);
					var currHeadingLevel = text.search(/[^#]/);
		
					if(direction !== undefined) {
						if(currHeadingLevel <= 0) {
							if(direction == "bigger") {
								text = "###### " + text;
							} else {
								text = "# " + text;
							}
						} else if(currHeadingLevel == 6 && direction == "smaller") {
							text = text.substr(7);
						} else if(currHeadingLevel == 1 && direction == "bigger") {
							text = text.substr(2);
						} else {
							if(direction == "bigger") {
								text = text.substr(1);
							} else {
								text = "#" + text;
							}
						}
					} else {
						if(size == 1) {
							if(currHeadingLevel <= 0) {
								text = "# " + text;
							} else if(currHeadingLevel == size) {
								text = text.substr(currHeadingLevel + 1);
							} else {
								text = "# " + text.substr(currHeadingLevel + 1);
							}
						} else if(size == 2) {
							if(currHeadingLevel <= 0) {
								text = "## " + text;
							} else if(currHeadingLevel == size) {
								text = text.substr(currHeadingLevel + 1);
							} else {
								text = "## " + text.substr(currHeadingLevel + 1);
							}
						} else {
							if(currHeadingLevel <= 0) {
								text = "### " + text;
							} else if(currHeadingLevel == size) {
								text = text.substr(currHeadingLevel + 1);
							} else {
								text = "### " + text.substr(currHeadingLevel + 1);
							}
						}
					}
		
					cm.replaceRange(text, {
						line: i,
						ch: 0
					}, {
						line: i,
						ch: 99999999999999
					});
				})(i);
			}
			cm.focus();
		}
		
		
		function _toggleLine(cm, name) {
			if(/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))
				return;
		
			var stat = getState(cm);
			var startPoint = cm.getCursor("start");
			var endPoint = cm.getCursor("end");
			var repl = {
				"quote": /^(\s*)\>\s+/,
				"unordered-list": /^(\s*)(\*|\-|\+)\s+/,
				"ordered-list": /^(\s*)\d+\.\s+/
			};
			var map = {
				"quote": "> ",
				"unordered-list": "* ",
				"ordered-list": "1. "
			};
			for(var i = startPoint.line; i <= endPoint.line; i++) {
				(function(i) {
					var text = cm.getLine(i);
					if(stat[name]) {
						text = text.replace(repl[name], "$1");
					} else {
						text = map[name] + text;
					}
					cm.replaceRange(text, {
						line: i,
						ch: 0
					}, {
						line: i,
						ch: 99999999999999
					});
				})(i);
			}
			cm.focus();
		}
		
		function _toggleBlock(editor, type, start_chars, end_chars) {
			if(/editor-preview-active/.test(editor.codemirror.getWrapperElement().lastChild.className))
				return;
		
			end_chars = (typeof end_chars === "undefined") ? start_chars : end_chars;
			var cm = editor.codemirror;
			var stat = getState(cm);
		
			var text;
			var start = start_chars;
			var end = end_chars;
		
			var startPoint = cm.getCursor("start");
			var endPoint = cm.getCursor("end");
		
			if(stat[type]) {
				text = cm.getLine(startPoint.line);
				start = text.slice(0, startPoint.ch);
				end = text.slice(startPoint.ch);
				if(type == "bold") {
					start = start.replace(/(\*\*|__)(?![\s\S]*(\*\*|__))/, "");
					end = end.replace(/(\*\*|__)/, "");
				} else if(type == "italic") {
					start = start.replace(/(\*|_)(?![\s\S]*(\*|_))/, "");
					end = end.replace(/(\*|_)/, "");
				} else if(type == "strikethrough") {
					start = start.replace(/(\*\*|~~)(?![\s\S]*(\*\*|~~))/, "");
					end = end.replace(/(\*\*|~~)/, "");
				}
				cm.replaceRange(start + end, {
					line: startPoint.line,
					ch: 0
				}, {
					line: startPoint.line,
					ch: 99999999999999
				});
		
				if(type == "bold" || type == "strikethrough") {
					startPoint.ch -= 2;
					if(startPoint !== endPoint) {
						endPoint.ch -= 2;
					}
				} else if(type == "italic") {
					startPoint.ch -= 1;
					if(startPoint !== endPoint) {
						endPoint.ch -= 1;
					}
				}
			} else {
				text = cm.getSelection();
				if(type == "bold") {
					text = text.split("**").join("");
					text = text.split("__").join("");
				} else if(type == "italic") {
					text = text.split("*").join("");
					text = text.split("_").join("");
				} else if(type == "strikethrough") {
					text = text.split("~~").join("");
				}
				cm.replaceSelection(start + text + end);
		
				startPoint.ch += start_chars.length;
				endPoint.ch = startPoint.ch + text.length;
			}
		
			cm.setSelection(startPoint, endPoint);
			cm.focus();
		}
		
		function _cleanBlock(cm) {
			if(/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))
				return;
		
			var startPoint = cm.getCursor("start");
			var endPoint = cm.getCursor("end");
			var text;
		
			for(var line = startPoint.line; line <= endPoint.line; line++) {
				text = cm.getLine(line);
				text = text.replace(/^[ ]*([# ]+|\*|\-|[> ]+|[0-9]+(.|\)))[ ]*/, "");
		
				cm.replaceRange(text, {
					line: line,
					ch: 0
				}, {
					line: line,
					ch: 99999999999999
				});
			}
		}
		
		// Merge the properties of one object into another.
		function _mergeProperties(target, source) {
			for(var property in source) {
				if(source.hasOwnProperty(property)) {
					if(source[property] instanceof Array) {
						target[property] = source[property].concat(target[property] instanceof Array ? target[property] : []);
					} else if(
						source[property] !== null &&
						typeof source[property] === "object" &&
						source[property].constructor === Object
					) {
						target[property] = _mergeProperties(target[property] || {}, source[property]);
					} else {
						target[property] = source[property];
					}
				}
			}
		
			return target;
		}
		
		// Merge an arbitrary number of objects into one.
		function extend(target) {
			for(var i = 1; i < arguments.length; i++) {
				target = _mergeProperties(target, arguments[i]);
			}
		
			return target;
		}
		
		/* The right word count in respect for CJK. */
		function wordCount(data) {
			var pattern = /[a-zA-Z0-9_\u0392-\u03c9\u0410-\u04F9]+|[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af]+/g;
			var m = data.match(pattern);
			var count = 0;
			if(m === null) return count;
			for(var i = 0; i < m.length; i++) {
				if(m[i].charCodeAt(0) >= 0x4E00) {
					count += m[i].length;
				} else {
					count += 1;
				}
			}
			return count;
		}
		
		var toolbarBuiltInButtons = {
			"bold": {
				name: "bold",
				action: toggleBold,
				className: "fa fa-bold",
				title: "Bold",
				default: true
			},
			"italic": {
				name: "italic",
				action: toggleItalic,
				className: "fa fa-italic",
				title: "Italic",
				default: true
			},
			"strikethrough": {
				name: "strikethrough",
				action: toggleStrikethrough,
				className: "fa fa-strikethrough",
				title: "Strikethrough"
			},
			"heading": {
				name: "heading",
				action: toggleHeadingSmaller,
				className: "fa fa-header",
				title: "Heading",
				default: true
			},
			"heading-smaller": {
				name: "heading-smaller",
				action: toggleHeadingSmaller,
				className: "fa fa-header fa-header-x fa-header-smaller",
				title: "Smaller Heading"
			},
			"heading-bigger": {
				name: "heading-bigger",
				action: toggleHeadingBigger,
				className: "fa fa-header fa-header-x fa-header-bigger",
				title: "Bigger Heading"
			},
			"heading-1": {
				name: "heading-1",
				action: toggleHeading1,
				className: "fa fa-header fa-header-x fa-header-1",
				title: "Big Heading"
			},
			"heading-2": {
				name: "heading-2",
				action: toggleHeading2,
				className: "fa fa-header fa-header-x fa-header-2",
				title: "Medium Heading"
			},
			"heading-3": {
				name: "heading-3",
				action: toggleHeading3,
				className: "fa fa-header fa-header-x fa-header-3",
				title: "Small Heading"
			},
			"separator-1": {
				name: "separator-1"
			},
			"code": {
				name: "code",
				action: toggleCodeBlock,
				className: "fa fa-code",
				title: "Code"
			},
			"quote": {
				name: "quote",
				action: toggleBlockquote,
				className: "fa fa-quote-left",
				title: "Quote",
				default: true
			},
			"unordered-list": {
				name: "unordered-list",
				action: toggleUnorderedList,
				className: "fa fa-list-ul",
				title: "Generic List",
				default: true
			},
			"ordered-list": {
				name: "ordered-list",
				action: toggleOrderedList,
				className: "fa fa-list-ol",
				title: "Numbered List",
				default: true
			},
			"clean-block": {
				name: "clean-block",
				action: cleanBlock,
				className: "fa fa-eraser fa-clean-block",
				title: "Clean block"
			},
			"separator-2": {
				name: "separator-2"
			},
			"link": {
				name: "link",
				action: drawLink,
				className: "fa fa-link",
				title: "Create Link",
				default: true
			},
			"image": {
				name: "image",
				action: drawImage,
				className: "fa fa-picture-o",
				title: "Insert Image",
				default: true
			},
			"table": {
				name: "table",
				action: drawTable,
				className: "fa fa-table",
				title: "Insert Table"
			},
			"horizontal-rule": {
				name: "horizontal-rule",
				action: drawHorizontalRule,
				className: "fa fa-minus",
				title: "Insert Horizontal Line"
			},
			"separator-3": {
				name: "separator-3"
			},
			"preview": {
				name: "preview",
				action: togglePreview,
				className: "fa fa-eye no-disable",
				title: "Toggle Preview",
				default: true
			},
			"side-by-side": {
				name: "side-by-side",
				action: toggleSideBySide,
				className: "fa fa-columns no-disable no-mobile",
				title: "Toggle Side by Side",
				default: true
			},
			"fullscreen": {
				name: "fullscreen",
				action: toggleFullScreen,
				className: "fa fa-arrows-alt no-disable no-mobile",
				title: "Toggle Fullscreen",
				default: true
			},
			"separator-4": {
				name: "separator-4"
			},
			"guide": {
				name: "guide",
				action: "https://simplemde.com/markdown-guide",
				className: "fa fa-question-circle",
				title: "Markdown Guide",
				default: true
			},
			"separator-5": {
				name: "separator-5"
			},
			"undo": {
				name: "undo",
				action: undo,
				className: "fa fa-undo no-disable",
				title: "Undo"
			},
			"redo": {
				name: "redo",
				action: redo,
				className: "fa fa-repeat no-disable",
				title: "Redo"
			}
		};
		
		var insertTexts = {
			link: ["[", "](#url#)"],
			image: ["![](", "#url#)"],
			table: ["", "\n\n| Column 1 | Column 2 | Column 3 |\n| -------- | -------- | -------- |\n| Text     | Text     | Text     |\n\n"],
			horizontalRule: ["", "\n\n-----\n\n"]
		};
		
		var promptTexts = {
			link: "URL for the link:",
			image: "URL of the image:"
		};
		
		var blockStyles = {
			"bold": "**",
			"code": "```",
			"italic": "*"
		};
		
		/**
		 * Interface of SimpleMDE.
		 */
		function SimpleMDE(options) {
			// Handle options parameter
			options = options || {};
		
		
			// Used later to refer to it"s parent
			options.parent = this;
		
		
			// Check if Font Awesome needs to be auto downloaded
			var autoDownloadFA = true;
		
			if(options.autoDownloadFontAwesome === false) {
				autoDownloadFA = false;
			}
		
			if(options.autoDownloadFontAwesome !== true) {
				var styleSheets = document.styleSheets;
				for(var i = 0; i < styleSheets.length; i++) {
					if(!styleSheets[i].href)
						continue;
		
					if(styleSheets[i].href.indexOf("//maxcdn.bootstrapcdn.com/font-awesome/") > -1) {
						autoDownloadFA = false;
					}
				}
			}
		
			if(autoDownloadFA) {
				var link = document.createElement("link");
				link.rel = "stylesheet";
				link.href = "https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css";
				document.getElementsByTagName("head")[0].appendChild(link);
			}
		
		
			// Find the textarea to use
			if(options.element) {
				this.element = options.element;
			} else if(options.element === null) {
				// This means that the element option was specified, but no element was found
				console.log("SimpleMDE: Error. No element was found.");
				return;
			}
		
		
			// Handle toolbar
			if(options.toolbar === undefined) {
				// Initialize
				options.toolbar = [];
		
		
				// Loop over the built in buttons, to get the preferred order
				for(var key in toolbarBuiltInButtons) {
					if(toolbarBuiltInButtons.hasOwnProperty(key)) {
						if(key.indexOf("separator-") != -1) {
							options.toolbar.push("|");
						}
		
						if(toolbarBuiltInButtons[key].default === true || (options.showIcons && options.showIcons.constructor === Array && options.showIcons.indexOf(key) != -1)) {
							options.toolbar.push(key);
						}
					}
				}
			}
		
		
			// Handle status bar
			if(!options.hasOwnProperty("status")) {
				options.status = ["autosave", "lines", "words", "cursor"];
			}
		
		
			// Add default preview rendering function
			if(!options.previewRender) {
				options.previewRender = function(plainText) {
					// Note: "this" refers to the options object
					return this.parent.markdown(plainText);
				};
			}
		
		
			// Set default options for parsing config
			options.parsingConfig = extend({
				highlightFormatting: true // needed for toggleCodeBlock to detect types of code
			}, options.parsingConfig || {});
		
		
			// Merging the insertTexts, with the given options
			options.insertTexts = extend({}, insertTexts, options.insertTexts || {});
		
		
			// Merging the promptTexts, with the given options
			options.promptTexts = promptTexts;
		
		
			// Merging the blockStyles, with the given options
			options.blockStyles = extend({}, blockStyles, options.blockStyles || {});
		
		
			// Merging the shortcuts, with the given options
			options.shortcuts = extend({}, shortcuts, options.shortcuts || {});
		
		
			// Change unique_id to uniqueId for backwards compatibility
			if(options.autosave != undefined && options.autosave.unique_id != undefined && options.autosave.unique_id != "")
				options.autosave.uniqueId = options.autosave.unique_id;
		
		
			// Update this options
			this.options = options;
		
		
			// Auto render
			this.render();
		
		
			// The codemirror component is only available after rendering
			// so, the setter for the initialValue can only run after
			// the element has been rendered
			if(options.initialValue && (!this.options.autosave || this.options.autosave.foundSavedValue !== true)) {
				this.value(options.initialValue);
			}
		}
		
		/**
		 * Default markdown render.
		 */
		SimpleMDE.prototype.markdown = function(text) {
			if(marked) {
				// Initialize
				var markedOptions = {};
		
		
				// Update options
				if(this.options && this.options.renderingConfig && this.options.renderingConfig.singleLineBreaks === false) {
					markedOptions.breaks = false;
				} else {
					markedOptions.breaks = true;
				}
		
				if(this.options && this.options.renderingConfig && this.options.renderingConfig.codeSyntaxHighlighting === true && window.hljs) {
					markedOptions.highlight = function(code) {
						return window.hljs.highlightAuto(code).value;
					};
				}
		
		
				// Set options
				marked.setOptions(markedOptions);
		
		
				// Return
				return marked(text);
			}
		};
		
		/**
		 * Render editor to the given element.
		 */
		SimpleMDE.prototype.render = function(el) {
			if(!el) {
				el = this.element || document.getElementsByTagName("textarea")[0];
			}
		
			if(this._rendered && this._rendered === el) {
				// Already rendered.
				return;
			}
		
			this.element = el;
			var options = this.options;
		
			var self = this;
			var keyMaps = {};
		
			for(var key in options.shortcuts) {
				// null stands for "do not bind this command"
				if(options.shortcuts[key] !== null && bindings[key] !== null) {
					(function(key) {
						keyMaps[fixShortcut(options.shortcuts[key])] = function() {
							bindings[key](self);
						};
					})(key);
				}
			}
		
			keyMaps["Enter"] = "newlineAndIndentContinueMarkdownList";
			keyMaps["Tab"] = "tabAndIndentMarkdownList";
			keyMaps["Shift-Tab"] = "shiftTabAndUnindentMarkdownList";
			keyMaps["Esc"] = function(cm) {
				if(cm.getOption("fullScreen")) toggleFullScreen(self);
			};
		
			document.addEventListener("keydown", function(e) {
				e = e || window.event;
		
				if(e.keyCode == 27) {
					if(self.codemirror.getOption("fullScreen")) toggleFullScreen(self);
				}
			}, false);
		
			var mode, backdrop;
			if(options.spellChecker !== false) {
				mode = "spell-checker";
				backdrop = options.parsingConfig;
				backdrop.name = "gfm";
				backdrop.gitHubSpice = false;
		
				CodeMirrorSpellChecker({
					codeMirrorInstance: CodeMirror
				});
			} else {
				mode = options.parsingConfig;
				mode.name = "gfm";
				mode.gitHubSpice = false;
			}
		
			this.codemirror = CodeMirror.fromTextArea(el, {
				mode: mode,
				backdrop: backdrop,
				theme: "paper",
				tabSize: (options.tabSize != undefined) ? options.tabSize : 2,
				indentUnit: (options.tabSize != undefined) ? options.tabSize : 2,
				indentWithTabs: (options.indentWithTabs === false) ? false : true,
				lineNumbers: false,
				autofocus: (options.autofocus === true) ? true : false,
				extraKeys: keyMaps,
				lineWrapping: (options.lineWrapping === false) ? false : true,
				allowDropFileTypes: ["text/plain"],
				placeholder: options.placeholder || el.getAttribute("placeholder") || "",
				styleSelectedText: (options.styleSelectedText != undefined) ? options.styleSelectedText : true
			});
		
			if(options.forceSync === true) {
				var cm = this.codemirror;
				cm.on("change", function() {
					cm.save();
				});
			}
		
			this.gui = {};
		
			if(options.toolbar !== false) {
				this.gui.toolbar = this.createToolbar();
			}
			if(options.status !== false) {
				this.gui.statusbar = this.createStatusbar();
			}
			if(options.autosave != undefined && options.autosave.enabled === true) {
				this.autosave();
			}
		
			this.gui.sideBySide = this.createSideBySide();
		
			this._rendered = this.element;
		
		
			// Fixes CodeMirror bug (#344)
			var temp_cm = this.codemirror;
			setTimeout(function() {
				temp_cm.refresh();
			}.bind(temp_cm), 0);
		};
		
		// Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem throw QuotaExceededError. We're going to detect this and set a variable accordingly.
		function isLocalStorageAvailable() {
			if(typeof localStorage === "object") {
				try {
					localStorage.setItem("smde_localStorage", 1);
					localStorage.removeItem("smde_localStorage");
				} catch(e) {
					return false;
				}
			} else {
				return false;
			}
		
			return true;
		}
		
		SimpleMDE.prototype.autosave = function() {
			if(isLocalStorageAvailable()) {
				var simplemde = this;
		
				if(this.options.autosave.uniqueId == undefined || this.options.autosave.uniqueId == "") {
					console.log("SimpleMDE: You must set a uniqueId to use the autosave feature");
					return;
				}
		
				if(simplemde.element.form != null && simplemde.element.form != undefined) {
					simplemde.element.form.addEventListener("submit", function() {
						localStorage.removeItem("smde_" + simplemde.options.autosave.uniqueId);
					});
				}
		
				if(this.options.autosave.loaded !== true) {
					if(typeof localStorage.getItem("smde_" + this.options.autosave.uniqueId) == "string" && localStorage.getItem("smde_" + this.options.autosave.uniqueId) != "") {
						this.codemirror.setValue(localStorage.getItem("smde_" + this.options.autosave.uniqueId));
						this.options.autosave.foundSavedValue = true;
					}
		
					this.options.autosave.loaded = true;
				}
		
				localStorage.setItem("smde_" + this.options.autosave.uniqueId, simplemde.value());
		
				var el = document.getElementById("autosaved");
				if(el != null && el != undefined && el != "") {
					var d = new Date();
					var hh = d.getHours();
					var m = d.getMinutes();
					var dd = "am";
					var h = hh;
					if(h >= 12) {
						h = hh - 12;
						dd = "pm";
					}
					if(h == 0) {
						h = 12;
					}
					m = m < 10 ? "0" + m : m;
		
					el.innerHTML = "Autosaved: " + h + ":" + m + " " + dd;
				}
		
				this.autosaveTimeoutId = setTimeout(function() {
					simplemde.autosave();
				}, this.options.autosave.delay || 10000);
			} else {
				console.log("SimpleMDE: localStorage not available, cannot autosave");
			}
		};
		
		SimpleMDE.prototype.clearAutosavedValue = function() {
			if(isLocalStorageAvailable()) {
				if(this.options.autosave == undefined || this.options.autosave.uniqueId == undefined || this.options.autosave.uniqueId == "") {
					console.log("SimpleMDE: You must set a uniqueId to clear the autosave value");
					return;
				}
		
				localStorage.removeItem("smde_" + this.options.autosave.uniqueId);
			} else {
				console.log("SimpleMDE: localStorage not available, cannot autosave");
			}
		};
		
		SimpleMDE.prototype.createSideBySide = function() {
			var cm = this.codemirror;
			var wrapper = cm.getWrapperElement();
			var preview = wrapper.nextSibling;
		
			if(!preview || !/editor-preview-side/.test(preview.className)) {
				preview = document.createElement("div");
				preview.className = "editor-preview-side";
				wrapper.parentNode.insertBefore(preview, wrapper.nextSibling);
			}
		
			// Syncs scroll  editor -> preview
			var cScroll = false;
			var pScroll = false;
			cm.on("scroll", function(v) {
				if(cScroll) {
					cScroll = false;
					return;
				}
				pScroll = true;
				var height = v.getScrollInfo().height - v.getScrollInfo().clientHeight;
				var ratio = parseFloat(v.getScrollInfo().top) / height;
				var move = (preview.scrollHeight - preview.clientHeight) * ratio;
				preview.scrollTop = move;
			});
		
			// Syncs scroll  preview -> editor
			preview.onscroll = function() {
				if(pScroll) {
					pScroll = false;
					return;
				}
				cScroll = true;
				var height = preview.scrollHeight - preview.clientHeight;
				var ratio = parseFloat(preview.scrollTop) / height;
				var move = (cm.getScrollInfo().height - cm.getScrollInfo().clientHeight) * ratio;
				cm.scrollTo(0, move);
			};
			return preview;
		};
		
		SimpleMDE.prototype.createToolbar = function(items) {
			items = items || this.options.toolbar;
		
			if(!items || items.length === 0) {
				return;
			}
			var i;
			for(i = 0; i < items.length; i++) {
				if(toolbarBuiltInButtons[items[i]] != undefined) {
					items[i] = toolbarBuiltInButtons[items[i]];
				}
			}
		
			var bar = document.createElement("div");
			bar.className = "editor-toolbar";
		
			var self = this;
		
			var toolbarData = {};
			self.toolbar = items;
		
			for(i = 0; i < items.length; i++) {
				if(items[i].name == "guide" && self.options.toolbarGuideIcon === false)
					continue;
		
				if(self.options.hideIcons && self.options.hideIcons.indexOf(items[i].name) != -1)
					continue;
		
				// Fullscreen does not work well on mobile devices (even tablets)
				// In the future, hopefully this can be resolved
				if((items[i].name == "fullscreen" || items[i].name == "side-by-side") && isMobile())
					continue;
		
		
				// Don't include trailing separators
				if(items[i] === "|") {
					var nonSeparatorIconsFollow = false;
		
					for(var x = (i + 1); x < items.length; x++) {
						if(items[x] !== "|" && (!self.options.hideIcons || self.options.hideIcons.indexOf(items[x].name) == -1)) {
							nonSeparatorIconsFollow = true;
						}
					}
		
					if(!nonSeparatorIconsFollow)
						continue;
				}
		
		
				// Create the icon and append to the toolbar
				(function(item) {
					var el;
					if(item === "|") {
						el = createSep();
					} else {
						el = createIcon(item, self.options.toolbarTips, self.options.shortcuts);
					}
		
					// bind events, special for info
					if(item.action) {
						if(typeof item.action === "function") {
							el.onclick = function(e) {
								e.preventDefault();
								item.action(self);
							};
						} else if(typeof item.action === "string") {
							el.href = item.action;
							el.target = "_blank";
						}
					}
		
					toolbarData[item.name || item] = el;
					bar.appendChild(el);
				})(items[i]);
			}
		
			self.toolbarElements = toolbarData;
		
			var cm = this.codemirror;
			cm.on("cursorActivity", function() {
				var stat = getState(cm);
		
				for(var key in toolbarData) {
					(function(key) {
						var el = toolbarData[key];
						if(stat[key]) {
							el.className += " active";
						} else if(key != "fullscreen" && key != "side-by-side") {
							el.className = el.className.replace(/\s*active\s*/g, "");
						}
					})(key);
				}
			});
		
			var cmWrapper = cm.getWrapperElement();
			cmWrapper.parentNode.insertBefore(bar, cmWrapper);
			return bar;
		};
		
		SimpleMDE.prototype.createStatusbar = function(status) {
			// Initialize
			status = status || this.options.status;
			var options = this.options;
			var cm = this.codemirror;
		
		
			// Make sure the status variable is valid
			if(!status || status.length === 0)
				return;
		
		
			// Set up the built-in items
			var items = [];
			var i, onUpdate, defaultValue;
		
			for(i = 0; i < status.length; i++) {
				// Reset some values
				onUpdate = undefined;
				defaultValue = undefined;
		
		
				// Handle if custom or not
				if(typeof status[i] === "object") {
					items.push({
						className: status[i].className,
						defaultValue: status[i].defaultValue,
						onUpdate: status[i].onUpdate
					});
				} else {
					var name = status[i];
		
					if(name === "words") {
						defaultValue = function(el) {
							el.innerHTML = wordCount(cm.getValue());
						};
						onUpdate = function(el) {
							el.innerHTML = wordCount(cm.getValue());
						};
					} else if(name === "lines") {
						defaultValue = function(el) {
							el.innerHTML = cm.lineCount();
						};
						onUpdate = function(el) {
							el.innerHTML = cm.lineCount();
						};
					} else if(name === "cursor") {
						defaultValue = function(el) {
							el.innerHTML = "0:0";
						};
						onUpdate = function(el) {
							var pos = cm.getCursor();
							el.innerHTML = pos.line + ":" + pos.ch;
						};
					} else if(name === "autosave") {
						defaultValue = function(el) {
							if(options.autosave != undefined && options.autosave.enabled === true) {
								el.setAttribute("id", "autosaved");
							}
						};
					}
		
					items.push({
						className: name,
						defaultValue: defaultValue,
						onUpdate: onUpdate
					});
				}
			}
		
		
			// Create element for the status bar
			var bar = document.createElement("div");
			bar.className = "editor-statusbar";
		
		
			// Create a new span for each item
			for(i = 0; i < items.length; i++) {
				// Store in temporary variable
				var item = items[i];
		
		
				// Create span element
				var el = document.createElement("span");
				el.className = item.className;
		
		
				// Ensure the defaultValue is a function
				if(typeof item.defaultValue === "function") {
					item.defaultValue(el);
				}
		
		
				// Ensure the onUpdate is a function
				if(typeof item.onUpdate === "function") {
					// Create a closure around the span of the current action, then execute the onUpdate handler
					this.codemirror.on("update", (function(el, item) {
						return function() {
							item.onUpdate(el);
						};
					}(el, item)));
				}
		
		
				// Append the item to the status bar
				bar.appendChild(el);
			}
		
		
			// Insert the status bar into the DOM
			var cmWrapper = this.codemirror.getWrapperElement();
			cmWrapper.parentNode.insertBefore(bar, cmWrapper.nextSibling);
			return bar;
		};
		
		/**
		 * Get or set the text content.
		 */
		SimpleMDE.prototype.value = function(val) {
			if(val === undefined) {
				return this.codemirror.getValue();
			} else {
				this.codemirror.getDoc().setValue(val);
				return this;
			}
		};
		
		
		/**
		 * Bind static methods for exports.
		 */
		SimpleMDE.toggleBold = toggleBold;
		SimpleMDE.toggleItalic = toggleItalic;
		SimpleMDE.toggleStrikethrough = toggleStrikethrough;
		SimpleMDE.toggleBlockquote = toggleBlockquote;
		SimpleMDE.toggleHeadingSmaller = toggleHeadingSmaller;
		SimpleMDE.toggleHeadingBigger = toggleHeadingBigger;
		SimpleMDE.toggleHeading1 = toggleHeading1;
		SimpleMDE.toggleHeading2 = toggleHeading2;
		SimpleMDE.toggleHeading3 = toggleHeading3;
		SimpleMDE.toggleCodeBlock = toggleCodeBlock;
		SimpleMDE.toggleUnorderedList = toggleUnorderedList;
		SimpleMDE.toggleOrderedList = toggleOrderedList;
		SimpleMDE.cleanBlock = cleanBlock;
		SimpleMDE.drawLink = drawLink;
		SimpleMDE.drawImage = drawImage;
		SimpleMDE.drawTable = drawTable;
		SimpleMDE.drawHorizontalRule = drawHorizontalRule;
		SimpleMDE.undo = undo;
		SimpleMDE.redo = redo;
		SimpleMDE.togglePreview = togglePreview;
		SimpleMDE.toggleSideBySide = toggleSideBySide;
		SimpleMDE.toggleFullScreen = toggleFullScreen;
		
		/**
		 * Bind instance methods for exports.
		 */
		SimpleMDE.prototype.toggleBold = function() {
			toggleBold(this);
		};
		SimpleMDE.prototype.toggleItalic = function() {
			toggleItalic(this);
		};
		SimpleMDE.prototype.toggleStrikethrough = function() {
			toggleStrikethrough(this);
		};
		SimpleMDE.prototype.toggleBlockquote = function() {
			toggleBlockquote(this);
		};
		SimpleMDE.prototype.toggleHeadingSmaller = function() {
			toggleHeadingSmaller(this);
		};
		SimpleMDE.prototype.toggleHeadingBigger = function() {
			toggleHeadingBigger(this);
		};
		SimpleMDE.prototype.toggleHeading1 = function() {
			toggleHeading1(this);
		};
		SimpleMDE.prototype.toggleHeading2 = function() {
			toggleHeading2(this);
		};
		SimpleMDE.prototype.toggleHeading3 = function() {
			toggleHeading3(this);
		};
		SimpleMDE.prototype.toggleCodeBlock = function() {
			toggleCodeBlock(this);
		};
		SimpleMDE.prototype.toggleUnorderedList = function() {
			toggleUnorderedList(this);
		};
		SimpleMDE.prototype.toggleOrderedList = function() {
			toggleOrderedList(this);
		};
		SimpleMDE.prototype.cleanBlock = function() {
			cleanBlock(this);
		};
		SimpleMDE.prototype.drawLink = function() {
			drawLink(this);
		};
		SimpleMDE.prototype.drawImage = function() {
			drawImage(this);
		};
		SimpleMDE.prototype.drawTable = function() {
			drawTable(this);
		};
		SimpleMDE.prototype.drawHorizontalRule = function() {
			drawHorizontalRule(this);
		};
		SimpleMDE.prototype.undo = function() {
			undo(this);
		};
		SimpleMDE.prototype.redo = function() {
			redo(this);
		};
		SimpleMDE.prototype.togglePreview = function() {
			togglePreview(this);
		};
		SimpleMDE.prototype.toggleSideBySide = function() {
			toggleSideBySide(this);
		};
		SimpleMDE.prototype.toggleFullScreen = function() {
			toggleFullScreen(this);
		};
		
		SimpleMDE.prototype.isPreviewActive = function() {
			var cm = this.codemirror;
			var wrapper = cm.getWrapperElement();
			var preview = wrapper.lastChild;
		
			return /editor-preview-active/.test(preview.className);
		};
		
		SimpleMDE.prototype.isSideBySideActive = function() {
			var cm = this.codemirror;
			var wrapper = cm.getWrapperElement();
			var preview = wrapper.nextSibling;
		
			return /editor-preview-active-side/.test(preview.className);
		};
		
		SimpleMDE.prototype.isFullscreenActive = function() {
			var cm = this.codemirror;
		
			return cm.getOption("fullScreen");
		};
		
		SimpleMDE.prototype.getState = function() {
			var cm = this.codemirror;
		
			return getState(cm);
		};
		
		SimpleMDE.prototype.toTextArea = function() {
			var cm = this.codemirror;
			var wrapper = cm.getWrapperElement();
		
			if(wrapper.parentNode) {
				if(this.gui.toolbar) {
					wrapper.parentNode.removeChild(this.gui.toolbar);
				}
				if(this.gui.statusbar) {
					wrapper.parentNode.removeChild(this.gui.statusbar);
				}
				if(this.gui.sideBySide) {
					wrapper.parentNode.removeChild(this.gui.sideBySide);
				}
			}
		
			cm.toTextArea();
		
			if(this.autosaveTimeoutId) {
				clearTimeout(this.autosaveTimeoutId);
				this.autosaveTimeoutId = undefined;
				this.clearAutosavedValue();
			}
		};
		
		module.exports = SimpleMDE;
	
	/***/ },
	/* 161 */
	/***/ function(module, exports, __webpack_require__) {
	
		// CodeMirror, copyright (c) by Marijn Haverbeke and others
		// Distributed under an MIT license: http://codemirror.net/LICENSE
		
		// This is CodeMirror (http://codemirror.net), a code editor
		// implemented in JavaScript on top of the browser's DOM.
		//
		// You can find some technical background for some of the code below
		// at http://marijnhaverbeke.nl/blog/#cm-internals .
		
		(function (global, factory) {
			 true ? module.exports = factory() :
			typeof define === 'function' && define.amd ? define(factory) :
			(global.CodeMirror = factory());
		}(this, (function () { 'use strict';
		
		// Kludges for bugs and behavior differences that can't be feature
		// detected are enabled based on userAgent etc sniffing.
		var userAgent = navigator.userAgent;
		var platform = navigator.platform;
		
		var gecko = /gecko\/\d/i.test(userAgent);
		var ie_upto10 = /MSIE \d/.test(userAgent);
		var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
		var edge = /Edge\/(\d+)/.exec(userAgent);
		var ie = ie_upto10 || ie_11up || edge;
		var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
		var webkit = !edge && /WebKit\//.test(userAgent);
		var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
		var chrome = !edge && /Chrome\//.test(userAgent);
		var presto = /Opera\//.test(userAgent);
		var safari = /Apple Computer/.test(navigator.vendor);
		var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
		var phantom = /PhantomJS/.test(userAgent);
		
		var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
		var android = /Android/.test(userAgent);
		// This is woefully incomplete. Suggestions for alternative methods welcome.
		var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
		var mac = ios || /Mac/.test(platform);
		var chromeOS = /\bCrOS\b/.test(userAgent);
		var windows = /win/i.test(platform);
		
		var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
		if (presto_version) { presto_version = Number(presto_version[1]); }
		if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
		// Some browsers use the wrong event properties to signal cmd/ctrl on OS X
		var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
		var captureRightClick = gecko || (ie && ie_version >= 9);
		
		function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }
		
		var rmClass = function(node, cls) {
		  var current = node.className;
		  var match = classTest(cls).exec(current);
		  if (match) {
		    var after = current.slice(match.index + match[0].length);
		    node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
		  }
		};
		
		function removeChildren(e) {
		  for (var count = e.childNodes.length; count > 0; --count)
		    { e.removeChild(e.firstChild); }
		  return e
		}
		
		function removeChildrenAndAdd(parent, e) {
		  return removeChildren(parent).appendChild(e)
		}
		
		function elt(tag, content, className, style) {
		  var e = document.createElement(tag);
		  if (className) { e.className = className; }
		  if (style) { e.style.cssText = style; }
		  if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }
		  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }
		  return e
		}
		// wrapper for elt, which removes the elt from the accessibility tree
		function eltP(tag, content, className, style) {
		  var e = elt(tag, content, className, style);
		  e.setAttribute("role", "presentation");
		  return e
		}
		
		var range;
		if (document.createRange) { range = function(node, start, end, endNode) {
		  var r = document.createRange();
		  r.setEnd(endNode || node, end);
		  r.setStart(node, start);
		  return r
		}; }
		else { range = function(node, start, end) {
		  var r = document.body.createTextRange();
		  try { r.moveToElementText(node.parentNode); }
		  catch(e) { return r }
		  r.collapse(true);
		  r.moveEnd("character", end);
		  r.moveStart("character", start);
		  return r
		}; }
		
		function contains(parent, child) {
		  if (child.nodeType == 3) // Android browser always returns false when child is a textnode
		    { child = child.parentNode; }
		  if (parent.contains)
		    { return parent.contains(child) }
		  do {
		    if (child.nodeType == 11) { child = child.host; }
		    if (child == parent) { return true }
		  } while (child = child.parentNode)
		}
		
		function activeElt() {
		  // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
		  // IE < 10 will throw when accessed while the page is loading or in an iframe.
		  // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
		  var activeElement;
		  try {
		    activeElement = document.activeElement;
		  } catch(e) {
		    activeElement = document.body || null;
		  }
		  while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
		    { activeElement = activeElement.shadowRoot.activeElement; }
		  return activeElement
		}
		
		function addClass(node, cls) {
		  var current = node.className;
		  if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }
		}
		function joinClasses(a, b) {
		  var as = a.split(" ");
		  for (var i = 0; i < as.length; i++)
		    { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }
		  return b
		}
		
		var selectInput = function(node) { node.select(); };
		if (ios) // Mobile Safari apparently has a bug where select() is broken.
		  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }
		else if (ie) // Suppress mysterious IE10 errors
		  { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }
		
		function bind(f) {
		  var args = Array.prototype.slice.call(arguments, 1);
		  return function(){return f.apply(null, args)}
		}
		
		function copyObj(obj, target, overwrite) {
		  if (!target) { target = {}; }
		  for (var prop in obj)
		    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
		      { target[prop] = obj[prop]; } }
		  return target
		}
		
		// Counts the column offset in a string, taking tabs into account.
		// Used mostly to find indentation.
		function countColumn(string, end, tabSize, startIndex, startValue) {
		  if (end == null) {
		    end = string.search(/[^\s\u00a0]/);
		    if (end == -1) { end = string.length; }
		  }
		  for (var i = startIndex || 0, n = startValue || 0;;) {
		    var nextTab = string.indexOf("\t", i);
		    if (nextTab < 0 || nextTab >= end)
		      { return n + (end - i) }
		    n += nextTab - i;
		    n += tabSize - (n % tabSize);
		    i = nextTab + 1;
		  }
		}
		
		var Delayed = function() {this.id = null;};
		Delayed.prototype.set = function (ms, f) {
		  clearTimeout(this.id);
		  this.id = setTimeout(f, ms);
		};
		
		function indexOf(array, elt) {
		  for (var i = 0; i < array.length; ++i)
		    { if (array[i] == elt) { return i } }
		  return -1
		}
		
		// Number of pixels added to scroller and sizer to hide scrollbar
		var scrollerGap = 30;
		
		// Returned or thrown by various protocols to signal 'I'm not
		// handling this'.
		var Pass = {toString: function(){return "CodeMirror.Pass"}};
		
		// Reused option objects for setSelection & friends
		var sel_dontScroll = {scroll: false};
		var sel_mouse = {origin: "*mouse"};
		var sel_move = {origin: "+move"};
		
		// The inverse of countColumn -- find the offset that corresponds to
		// a particular column.
		function findColumn(string, goal, tabSize) {
		  for (var pos = 0, col = 0;;) {
		    var nextTab = string.indexOf("\t", pos);
		    if (nextTab == -1) { nextTab = string.length; }
		    var skipped = nextTab - pos;
		    if (nextTab == string.length || col + skipped >= goal)
		      { return pos + Math.min(skipped, goal - col) }
		    col += nextTab - pos;
		    col += tabSize - (col % tabSize);
		    pos = nextTab + 1;
		    if (col >= goal) { return pos }
		  }
		}
		
		var spaceStrs = [""];
		function spaceStr(n) {
		  while (spaceStrs.length <= n)
		    { spaceStrs.push(lst(spaceStrs) + " "); }
		  return spaceStrs[n]
		}
		
		function lst(arr) { return arr[arr.length-1] }
		
		function map(array, f) {
		  var out = [];
		  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }
		  return out
		}
		
		function insertSorted(array, value, score) {
		  var pos = 0, priority = score(value);
		  while (pos < array.length && score(array[pos]) <= priority) { pos++; }
		  array.splice(pos, 0, value);
		}
		
		function nothing() {}
		
		function createObj(base, props) {
		  var inst;
		  if (Object.create) {
		    inst = Object.create(base);
		  } else {
		    nothing.prototype = base;
		    inst = new nothing();
		  }
		  if (props) { copyObj(props, inst); }
		  return inst
		}
		
		var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
		function isWordCharBasic(ch) {
		  return /\w/.test(ch) || ch > "\x80" &&
		    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
		}
		function isWordChar(ch, helper) {
		  if (!helper) { return isWordCharBasic(ch) }
		  if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
		  return helper.test(ch)
		}
		
		function isEmpty(obj) {
		  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
		  return true
		}
		
		// Extending unicode characters. A series of a non-extending char +
		// any number of extending chars is treated as a single unit as far
		// as editing and measuring is concerned. This is not fully correct,
		// since some scripts/fonts/browsers also treat other configurations
		// of code points as a group.
		var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
		function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }
		
		// Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
		function skipExtendingChars(str, pos, dir) {
		  while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }
		  return pos
		}
		
		// Returns the value from the range [`from`; `to`] that satisfies
		// `pred` and is closest to `from`. Assumes that at least `to` satisfies `pred`.
		function findFirst(pred, from, to) {
		  for (;;) {
		    if (Math.abs(from - to) <= 1) { return pred(from) ? from : to }
		    var mid = Math.floor((from + to) / 2);
		    if (pred(mid)) { to = mid; }
		    else { from = mid; }
		  }
		}
		
		// The display handles the DOM integration, both for input reading
		// and content drawing. It holds references to DOM nodes and
		// display-related state.
		
		function Display(place, doc, input) {
		  var d = this;
		  this.input = input;
		
		  // Covers bottom-right square when both scrollbars are present.
		  d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
		  d.scrollbarFiller.setAttribute("cm-not-content", "true");
		  // Covers bottom of gutter when coverGutterNextToScrollbar is on
		  // and h scrollbar is present.
		  d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
		  d.gutterFiller.setAttribute("cm-not-content", "true");
		  // Will contain the actual code, positioned to cover the viewport.
		  d.lineDiv = eltP("div", null, "CodeMirror-code");
		  // Elements are added to these to represent selection and cursors.
		  d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
		  d.cursorDiv = elt("div", null, "CodeMirror-cursors");
		  // A visibility: hidden element used to find the size of things.
		  d.measure = elt("div", null, "CodeMirror-measure");
		  // When lines outside of the viewport are measured, they are drawn in this.
		  d.lineMeasure = elt("div", null, "CodeMirror-measure");
		  // Wraps everything that needs to exist inside the vertically-padded coordinate system
		  d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
		                    null, "position: relative; outline: none");
		  var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
		  // Moved around its parent to cover visible view.
		  d.mover = elt("div", [lines], null, "position: relative");
		  // Set to the height of the document, allowing scrolling.
		  d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
		  d.sizerWidth = null;
		  // Behavior of elts with overflow: auto and padding is
		  // inconsistent across browsers. This is used to ensure the
		  // scrollable area is big enough.
		  d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
		  // Will contain the gutters, if any.
		  d.gutters = elt("div", null, "CodeMirror-gutters");
		  d.lineGutter = null;
		  // Actual scrollable element.
		  d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
		  d.scroller.setAttribute("tabIndex", "-1");
		  // The element in which the editor lives.
		  d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
		
		  // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
		  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
		  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }
		
		  if (place) {
		    if (place.appendChild) { place.appendChild(d.wrapper); }
		    else { place(d.wrapper); }
		  }
		
		  // Current rendered range (may be bigger than the view window).
		  d.viewFrom = d.viewTo = doc.first;
		  d.reportedViewFrom = d.reportedViewTo = doc.first;
		  // Information about the rendered lines.
		  d.view = [];
		  d.renderedView = null;
		  // Holds info about a single rendered line when it was rendered
		  // for measurement, while not in view.
		  d.externalMeasured = null;
		  // Empty space (in pixels) above the view
		  d.viewOffset = 0;
		  d.lastWrapHeight = d.lastWrapWidth = 0;
		  d.updateLineNumbers = null;
		
		  d.nativeBarWidth = d.barHeight = d.barWidth = 0;
		  d.scrollbarsClipped = false;
		
		  // Used to only resize the line number gutter when necessary (when
		  // the amount of lines crosses a boundary that makes its width change)
		  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
		  // Set to true when a non-horizontal-scrolling line widget is
		  // added. As an optimization, line widget aligning is skipped when
		  // this is false.
		  d.alignWidgets = false;
		
		  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
		
		  // Tracks the maximum line length so that the horizontal scrollbar
		  // can be kept static when scrolling.
		  d.maxLine = null;
		  d.maxLineLength = 0;
		  d.maxLineChanged = false;
		
		  // Used for measuring wheel scrolling granularity
		  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
		
		  // True when shift is held down.
		  d.shift = false;
		
		  // Used to track whether anything happened since the context menu
		  // was opened.
		  d.selForContextMenu = null;
		
		  d.activeTouch = null;
		
		  input.init(d);
		}
		
		// Find the line object corresponding to the given line number.
		function getLine(doc, n) {
		  n -= doc.first;
		  if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
		  var chunk = doc;
		  while (!chunk.lines) {
		    for (var i = 0;; ++i) {
		      var child = chunk.children[i], sz = child.chunkSize();
		      if (n < sz) { chunk = child; break }
		      n -= sz;
		    }
		  }
		  return chunk.lines[n]
		}
		
		// Get the part of a document between two positions, as an array of
		// strings.
		function getBetween(doc, start, end) {
		  var out = [], n = start.line;
		  doc.iter(start.line, end.line + 1, function (line) {
		    var text = line.text;
		    if (n == end.line) { text = text.slice(0, end.ch); }
		    if (n == start.line) { text = text.slice(start.ch); }
		    out.push(text);
		    ++n;
		  });
		  return out
		}
		// Get the lines between from and to, as array of strings.
		function getLines(doc, from, to) {
		  var out = [];
		  doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value
		  return out
		}
		
		// Update the height of a line, propagating the height change
		// upwards to parent nodes.
		function updateLineHeight(line, height) {
		  var diff = height - line.height;
		  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }
		}
		
		// Given a line object, find its line number by walking up through
		// its parent links.
		function lineNo(line) {
		  if (line.parent == null) { return null }
		  var cur = line.parent, no = indexOf(cur.lines, line);
		  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
		    for (var i = 0;; ++i) {
		      if (chunk.children[i] == cur) { break }
		      no += chunk.children[i].chunkSize();
		    }
		  }
		  return no + cur.first
		}
		
		// Find the line at the given vertical position, using the height
		// information in the document tree.
		function lineAtHeight(chunk, h) {
		  var n = chunk.first;
		  outer: do {
		    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
		      var child = chunk.children[i$1], ch = child.height;
		      if (h < ch) { chunk = child; continue outer }
		      h -= ch;
		      n += child.chunkSize();
		    }
		    return n
		  } while (!chunk.lines)
		  var i = 0;
		  for (; i < chunk.lines.length; ++i) {
		    var line = chunk.lines[i], lh = line.height;
		    if (h < lh) { break }
		    h -= lh;
		  }
		  return n + i
		}
		
		function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}
		
		function lineNumberFor(options, i) {
		  return String(options.lineNumberFormatter(i + options.firstLineNumber))
		}
		
		// A Pos instance represents a position within the text.
		function Pos(line, ch, sticky) {
		  if ( sticky === void 0 ) sticky = null;
		
		  if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
		  this.line = line;
		  this.ch = ch;
		  this.sticky = sticky;
		}
		
		// Compare two positions, return 0 if they are the same, a negative
		// number when a is less, and a positive number otherwise.
		function cmp(a, b) { return a.line - b.line || a.ch - b.ch }
		
		function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }
		
		function copyPos(x) {return Pos(x.line, x.ch)}
		function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
		function minPos(a, b) { return cmp(a, b) < 0 ? a : b }
		
		// Most of the external API clips given positions to make sure they
		// actually exist within the document.
		function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
		function clipPos(doc, pos) {
		  if (pos.line < doc.first) { return Pos(doc.first, 0) }
		  var last = doc.first + doc.size - 1;
		  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
		  return clipToLen(pos, getLine(doc, pos.line).text.length)
		}
		function clipToLen(pos, linelen) {
		  var ch = pos.ch;
		  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
		  else if (ch < 0) { return Pos(pos.line, 0) }
		  else { return pos }
		}
		function clipPosArray(doc, array) {
		  var out = [];
		  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }
		  return out
		}
		
		// Optimize some code when these features are not used.
		var sawReadOnlySpans = false;
		var sawCollapsedSpans = false;
		
		function seeReadOnlySpans() {
		  sawReadOnlySpans = true;
		}
		
		function seeCollapsedSpans() {
		  sawCollapsedSpans = true;
		}
		
		// TEXTMARKER SPANS
		
		function MarkedSpan(marker, from, to) {
		  this.marker = marker;
		  this.from = from; this.to = to;
		}
		
		// Search an array of spans for a span matching the given marker.
		function getMarkedSpanFor(spans, marker) {
		  if (spans) { for (var i = 0; i < spans.length; ++i) {
		    var span = spans[i];
		    if (span.marker == marker) { return span }
		  } }
		}
		// Remove a span from an array, returning undefined if no spans are
		// left (we don't store arrays for lines without spans).
		function removeMarkedSpan(spans, span) {
		  var r;
		  for (var i = 0; i < spans.length; ++i)
		    { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }
		  return r
		}
		// Add a span to a line.
		function addMarkedSpan(line, span) {
		  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
		  span.marker.attachLine(line);
		}
		
		// Used for the algorithm that adjusts markers for a change in the
		// document. These functions cut an array of spans at a given
		// character position, returning an array of remaining chunks (or
		// undefined if nothing remains).
		function markedSpansBefore(old, startCh, isInsert) {
		  var nw;
		  if (old) { for (var i = 0; i < old.length; ++i) {
		    var span = old[i], marker = span.marker;
		    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
		    if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
		      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
		    }
		  } }
		  return nw
		}
		function markedSpansAfter(old, endCh, isInsert) {
		  var nw;
		  if (old) { for (var i = 0; i < old.length; ++i) {
		    var span = old[i], marker = span.marker;
		    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
		    if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
		      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
		                                            span.to == null ? null : span.to - endCh));
		    }
		  } }
		  return nw
		}
		
		// Given a change object, compute the new set of marker spans that
		// cover the line in which the change took place. Removes spans
		// entirely within the change, reconnects spans belonging to the
		// same marker that appear on both sides of the change, and cuts off
		// spans partially within the change. Returns an array of span
		// arrays with one element for each line in (after) the change.
		function stretchSpansOverChange(doc, change) {
		  if (change.full) { return null }
		  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
		  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
		  if (!oldFirst && !oldLast) { return null }
		
		  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
		  // Get the spans that 'stick out' on both sides
		  var first = markedSpansBefore(oldFirst, startCh, isInsert);
		  var last = markedSpansAfter(oldLast, endCh, isInsert);
		
		  // Next, merge those two ends
		  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
		  if (first) {
		    // Fix up .to properties of first
		    for (var i = 0; i < first.length; ++i) {
		      var span = first[i];
		      if (span.to == null) {
		        var found = getMarkedSpanFor(last, span.marker);
		        if (!found) { span.to = startCh; }
		        else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }
		      }
		    }
		  }
		  if (last) {
		    // Fix up .from in last (or move them into first in case of sameLine)
		    for (var i$1 = 0; i$1 < last.length; ++i$1) {
		      var span$1 = last[i$1];
		      if (span$1.to != null) { span$1.to += offset; }
		      if (span$1.from == null) {
		        var found$1 = getMarkedSpanFor(first, span$1.marker);
		        if (!found$1) {
		          span$1.from = offset;
		          if (sameLine) { (first || (first = [])).push(span$1); }
		        }
		      } else {
		        span$1.from += offset;
		        if (sameLine) { (first || (first = [])).push(span$1); }
		      }
		    }
		  }
		  // Make sure we didn't create any zero-length spans
		  if (first) { first = clearEmptySpans(first); }
		  if (last && last != first) { last = clearEmptySpans(last); }
		
		  var newMarkers = [first];
		  if (!sameLine) {
		    // Fill gap with whole-line-spans
		    var gap = change.text.length - 2, gapMarkers;
		    if (gap > 0 && first)
		      { for (var i$2 = 0; i$2 < first.length; ++i$2)
		        { if (first[i$2].to == null)
		          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }
		    for (var i$3 = 0; i$3 < gap; ++i$3)
		      { newMarkers.push(gapMarkers); }
		    newMarkers.push(last);
		  }
		  return newMarkers
		}
		
		// Remove spans that are empty and don't have a clearWhenEmpty
		// option of false.
		function clearEmptySpans(spans) {
		  for (var i = 0; i < spans.length; ++i) {
		    var span = spans[i];
		    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
		      { spans.splice(i--, 1); }
		  }
		  if (!spans.length) { return null }
		  return spans
		}
		
		// Used to 'clip' out readOnly ranges when making a change.
		function removeReadOnlyRanges(doc, from, to) {
		  var markers = null;
		  doc.iter(from.line, to.line + 1, function (line) {
		    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
		      var mark = line.markedSpans[i].marker;
		      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
		        { (markers || (markers = [])).push(mark); }
		    } }
		  });
		  if (!markers) { return null }
		  var parts = [{from: from, to: to}];
		  for (var i = 0; i < markers.length; ++i) {
		    var mk = markers[i], m = mk.find(0);
		    for (var j = 0; j < parts.length; ++j) {
		      var p = parts[j];
		      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
		      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
		      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
		        { newParts.push({from: p.from, to: m.from}); }
		      if (dto > 0 || !mk.inclusiveRight && !dto)
		        { newParts.push({from: m.to, to: p.to}); }
		      parts.splice.apply(parts, newParts);
		      j += newParts.length - 3;
		    }
		  }
		  return parts
		}
		
		// Connect or disconnect spans from a line.
		function detachMarkedSpans(line) {
		  var spans = line.markedSpans;
		  if (!spans) { return }
		  for (var i = 0; i < spans.length; ++i)
		    { spans[i].marker.detachLine(line); }
		  line.markedSpans = null;
		}
		function attachMarkedSpans(line, spans) {
		  if (!spans) { return }
		  for (var i = 0; i < spans.length; ++i)
		    { spans[i].marker.attachLine(line); }
		  line.markedSpans = spans;
		}
		
		// Helpers used when computing which overlapping collapsed span
		// counts as the larger one.
		function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
		function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }
		
		// Returns a number indicating which of two overlapping collapsed
		// spans is larger (and thus includes the other). Falls back to
		// comparing ids when the spans cover exactly the same range.
		function compareCollapsedMarkers(a, b) {
		  var lenDiff = a.lines.length - b.lines.length;
		  if (lenDiff != 0) { return lenDiff }
		  var aPos = a.find(), bPos = b.find();
		  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
		  if (fromCmp) { return -fromCmp }
		  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
		  if (toCmp) { return toCmp }
		  return b.id - a.id
		}
		
		// Find out whether a line ends or starts in a collapsed span. If
		// so, return the marker for that span.
		function collapsedSpanAtSide(line, start) {
		  var sps = sawCollapsedSpans && line.markedSpans, found;
		  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
		    sp = sps[i];
		    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
		        (!found || compareCollapsedMarkers(found, sp.marker) < 0))
		      { found = sp.marker; }
		  } }
		  return found
		}
		function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
		function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }
		
		// Test whether there exists a collapsed span that partially
		// overlaps (covers the start or end, but not both) of a new span.
		// Such overlap is not allowed.
		function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {
		  var line = getLine(doc, lineNo$$1);
		  var sps = sawCollapsedSpans && line.markedSpans;
		  if (sps) { for (var i = 0; i < sps.length; ++i) {
		    var sp = sps[i];
		    if (!sp.marker.collapsed) { continue }
		    var found = sp.marker.find(0);
		    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
		    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
		    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
		    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
		        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
		      { return true }
		  } }
		}
		
		// A visual line is a line as drawn on the screen. Folding, for
		// example, can cause multiple logical lines to appear on the same
		// visual line. This finds the start of the visual line that the
		// given line is part of (usually that is the line itself).
		function visualLine(line) {
		  var merged;
		  while (merged = collapsedSpanAtStart(line))
		    { line = merged.find(-1, true).line; }
		  return line
		}
		
		function visualLineEnd(line) {
		  var merged;
		  while (merged = collapsedSpanAtEnd(line))
		    { line = merged.find(1, true).line; }
		  return line
		}
		
		// Returns an array of logical lines that continue the visual line
		// started by the argument, or undefined if there are no such lines.
		function visualLineContinued(line) {
		  var merged, lines;
		  while (merged = collapsedSpanAtEnd(line)) {
		    line = merged.find(1, true).line
		    ;(lines || (lines = [])).push(line);
		  }
		  return lines
		}
		
		// Get the line number of the start of the visual line that the
		// given line number is part of.
		function visualLineNo(doc, lineN) {
		  var line = getLine(doc, lineN), vis = visualLine(line);
		  if (line == vis) { return lineN }
		  return lineNo(vis)
		}
		
		// Get the line number of the start of the next visual line after
		// the given line.
		function visualLineEndNo(doc, lineN) {
		  if (lineN > doc.lastLine()) { return lineN }
		  var line = getLine(doc, lineN), merged;
		  if (!lineIsHidden(doc, line)) { return lineN }
		  while (merged = collapsedSpanAtEnd(line))
		    { line = merged.find(1, true).line; }
		  return lineNo(line) + 1
		}
		
		// Compute whether a line is hidden. Lines count as hidden when they
		// are part of a visual line that starts with another line, or when
		// they are entirely covered by collapsed, non-widget span.
		function lineIsHidden(doc, line) {
		  var sps = sawCollapsedSpans && line.markedSpans;
		  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
		    sp = sps[i];
		    if (!sp.marker.collapsed) { continue }
		    if (sp.from == null) { return true }
		    if (sp.marker.widgetNode) { continue }
		    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
		      { return true }
		  } }
		}
		function lineIsHiddenInner(doc, line, span) {
		  if (span.to == null) {
		    var end = span.marker.find(1, true);
		    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
		  }
		  if (span.marker.inclusiveRight && span.to == line.text.length)
		    { return true }
		  for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
		    sp = line.markedSpans[i];
		    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
		        (sp.to == null || sp.to != span.from) &&
		        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
		        lineIsHiddenInner(doc, line, sp)) { return true }
		  }
		}
		
		// Find the height above the given line.
		function heightAtLine(lineObj) {
		  lineObj = visualLine(lineObj);
		
		  var h = 0, chunk = lineObj.parent;
		  for (var i = 0; i < chunk.lines.length; ++i) {
		    var line = chunk.lines[i];
		    if (line == lineObj) { break }
		    else { h += line.height; }
		  }
		  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
		    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
		      var cur = p.children[i$1];
		      if (cur == chunk) { break }
		      else { h += cur.height; }
		    }
		  }
		  return h
		}
		
		// Compute the character length of a line, taking into account
		// collapsed ranges (see markText) that might hide parts, and join
		// other lines onto it.
		function lineLength(line) {
		  if (line.height == 0) { return 0 }
		  var len = line.text.length, merged, cur = line;
		  while (merged = collapsedSpanAtStart(cur)) {
		    var found = merged.find(0, true);
		    cur = found.from.line;
		    len += found.from.ch - found.to.ch;
		  }
		  cur = line;
		  while (merged = collapsedSpanAtEnd(cur)) {
		    var found$1 = merged.find(0, true);
		    len -= cur.text.length - found$1.from.ch;
		    cur = found$1.to.line;
		    len += cur.text.length - found$1.to.ch;
		  }
		  return len
		}
		
		// Find the longest line in the document.
		function findMaxLine(cm) {
		  var d = cm.display, doc = cm.doc;
		  d.maxLine = getLine(doc, doc.first);
		  d.maxLineLength = lineLength(d.maxLine);
		  d.maxLineChanged = true;
		  doc.iter(function (line) {
		    var len = lineLength(line);
		    if (len > d.maxLineLength) {
		      d.maxLineLength = len;
		      d.maxLine = line;
		    }
		  });
		}
		
		// BIDI HELPERS
		
		function iterateBidiSections(order, from, to, f) {
		  if (!order) { return f(from, to, "ltr") }
		  var found = false;
		  for (var i = 0; i < order.length; ++i) {
		    var part = order[i];
		    if (part.from < to && part.to > from || from == to && part.to == from) {
		      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
		      found = true;
		    }
		  }
		  if (!found) { f(from, to, "ltr"); }
		}
		
		var bidiOther = null;
		function getBidiPartAt(order, ch, sticky) {
		  var found;
		  bidiOther = null;
		  for (var i = 0; i < order.length; ++i) {
		    var cur = order[i];
		    if (cur.from < ch && cur.to > ch) { return i }
		    if (cur.to == ch) {
		      if (cur.from != cur.to && sticky == "before") { found = i; }
		      else { bidiOther = i; }
		    }
		    if (cur.from == ch) {
		      if (cur.from != cur.to && sticky != "before") { found = i; }
		      else { bidiOther = i; }
		    }
		  }
		  return found != null ? found : bidiOther
		}
		
		// Bidirectional ordering algorithm
		// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
		// that this (partially) implements.
		
		// One-char codes used for character types:
		// L (L):   Left-to-Right
		// R (R):   Right-to-Left
		// r (AL):  Right-to-Left Arabic
		// 1 (EN):  European Number
		// + (ES):  European Number Separator
		// % (ET):  European Number Terminator
		// n (AN):  Arabic Number
		// , (CS):  Common Number Separator
		// m (NSM): Non-Spacing Mark
		// b (BN):  Boundary Neutral
		// s (B):   Paragraph Separator
		// t (S):   Segment Separator
		// w (WS):  Whitespace
		// N (ON):  Other Neutrals
		
		// Returns null if characters are ordered as they appear
		// (left-to-right), or an array of sections ({from, to, level}
		// objects) in the order in which they occur visually.
		var bidiOrdering = (function() {
		  // Character types for codepoints 0 to 0xff
		  var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
		  // Character types for codepoints 0x600 to 0x6f9
		  var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
		  function charType(code) {
		    if (code <= 0xf7) { return lowTypes.charAt(code) }
		    else if (0x590 <= code && code <= 0x5f4) { return "R" }
		    else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
		    else if (0x6ee <= code && code <= 0x8ac) { return "r" }
		    else if (0x2000 <= code && code <= 0x200b) { return "w" }
		    else if (code == 0x200c) { return "b" }
		    else { return "L" }
		  }
		
		  var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
		  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
		
		  function BidiSpan(level, from, to) {
		    this.level = level;
		    this.from = from; this.to = to;
		  }
		
		  return function(str, direction) {
		    var outerType = direction == "ltr" ? "L" : "R";
		
		    if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
		    var len = str.length, types = [];
		    for (var i = 0; i < len; ++i)
		      { types.push(charType(str.charCodeAt(i))); }
		
		    // W1. Examine each non-spacing mark (NSM) in the level run, and
		    // change the type of the NSM to the type of the previous
		    // character. If the NSM is at the start of the level run, it will
		    // get the type of sor.
		    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
		      var type = types[i$1];
		      if (type == "m") { types[i$1] = prev; }
		      else { prev = type; }
		    }
		
		    // W2. Search backwards from each instance of a European number
		    // until the first strong type (R, L, AL, or sor) is found. If an
		    // AL is found, change the type of the European number to Arabic
		    // number.
		    // W3. Change all ALs to R.
		    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
		      var type$1 = types[i$2];
		      if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }
		      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }
		    }
		
		    // W4. A single European separator between two European numbers
		    // changes to a European number. A single common separator between
		    // two numbers of the same type changes to that type.
		    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
		      var type$2 = types[i$3];
		      if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1"; }
		      else if (type$2 == "," && prev$1 == types[i$3+1] &&
		               (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }
		      prev$1 = type$2;
		    }
		
		    // W5. A sequence of European terminators adjacent to European
		    // numbers changes to all European numbers.
		    // W6. Otherwise, separators and terminators change to Other
		    // Neutral.
		    for (var i$4 = 0; i$4 < len; ++i$4) {
		      var type$3 = types[i$4];
		      if (type$3 == ",") { types[i$4] = "N"; }
		      else if (type$3 == "%") {
		        var end = (void 0);
		        for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
		        var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
		        for (var j = i$4; j < end; ++j) { types[j] = replace; }
		        i$4 = end - 1;
		      }
		    }
		
		    // W7. Search backwards from each instance of a European number
		    // until the first strong type (R, L, or sor) is found. If an L is
		    // found, then change the type of the European number to L.
		    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
		      var type$4 = types[i$5];
		      if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }
		      else if (isStrong.test(type$4)) { cur$1 = type$4; }
		    }
		
		    // N1. A sequence of neutrals takes the direction of the
		    // surrounding strong text if the text on both sides has the same
		    // direction. European and Arabic numbers act as if they were R in
		    // terms of their influence on neutrals. Start-of-level-run (sor)
		    // and end-of-level-run (eor) are used at level run boundaries.
		    // N2. Any remaining neutrals take the embedding direction.
		    for (var i$6 = 0; i$6 < len; ++i$6) {
		      if (isNeutral.test(types[i$6])) {
		        var end$1 = (void 0);
		        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
		        var before = (i$6 ? types[i$6-1] : outerType) == "L";
		        var after = (end$1 < len ? types[end$1] : outerType) == "L";
		        var replace$1 = before == after ? (before ? "L" : "R") : outerType;
		        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }
		        i$6 = end$1 - 1;
		      }
		    }
		
		    // Here we depart from the documented algorithm, in order to avoid
		    // building up an actual levels array. Since there are only three
		    // levels (0, 1, 2) in an implementation that doesn't take
		    // explicit embedding into account, we can build up the order on
		    // the fly, without following the level-based algorithm.
		    var order = [], m;
		    for (var i$7 = 0; i$7 < len;) {
		      if (countsAsLeft.test(types[i$7])) {
		        var start = i$7;
		        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
		        order.push(new BidiSpan(0, start, i$7));
		      } else {
		        var pos = i$7, at = order.length;
		        for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
		        for (var j$2 = pos; j$2 < i$7;) {
		          if (countsAsNum.test(types[j$2])) {
		            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }
		            var nstart = j$2;
		            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
		            order.splice(at, 0, new BidiSpan(2, nstart, j$2));
		            pos = j$2;
		          } else { ++j$2; }
		        }
		        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }
		      }
		    }
		    if (order[0].level == 1 && (m = str.match(/^\s+/))) {
		      order[0].from = m[0].length;
		      order.unshift(new BidiSpan(0, 0, m[0].length));
		    }
		    if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
		      lst(order).to -= m[0].length;
		      order.push(new BidiSpan(0, len - m[0].length, len));
		    }
		
		    return direction == "rtl" ? order.reverse() : order
		  }
		})();
		
		// Get the bidi ordering for the given line (and cache it). Returns
		// false for lines that are fully left-to-right, and an array of
		// BidiSpan objects otherwise.
		function getOrder(line, direction) {
		  var order = line.order;
		  if (order == null) { order = line.order = bidiOrdering(line.text, direction); }
		  return order
		}
		
		function moveCharLogically(line, ch, dir) {
		  var target = skipExtendingChars(line.text, ch + dir, dir);
		  return target < 0 || target > line.text.length ? null : target
		}
		
		function moveLogically(line, start, dir) {
		  var ch = moveCharLogically(line, start.ch, dir);
		  return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
		}
		
		function endOfLine(visually, cm, lineObj, lineNo, dir) {
		  if (visually) {
		    var order = getOrder(lineObj, cm.doc.direction);
		    if (order) {
		      var part = dir < 0 ? lst(order) : order[0];
		      var moveInStorageOrder = (dir < 0) == (part.level == 1);
		      var sticky = moveInStorageOrder ? "after" : "before";
		      var ch;
		      // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
		      // it could be that the last bidi part is not on the last visual line,
		      // since visual lines contain content order-consecutive chunks.
		      // Thus, in rtl, we are looking for the first (content-order) character
		      // in the rtl chunk that is on the last line (that is, the same line
		      // as the last (content-order) character).
		      if (part.level > 0) {
		        var prep = prepareMeasureForLine(cm, lineObj);
		        ch = dir < 0 ? lineObj.text.length - 1 : 0;
		        var targetTop = measureCharPrepared(cm, prep, ch).top;
		        ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);
		        if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1, true); }
		      } else { ch = dir < 0 ? part.to : part.from; }
		      return new Pos(lineNo, ch, sticky)
		    }
		  }
		  return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
		}
		
		function moveVisually(cm, line, start, dir) {
		  var bidi = getOrder(line, cm.doc.direction);
		  if (!bidi) { return moveLogically(line, start, dir) }
		  if (start.ch >= line.text.length) {
		    start.ch = line.text.length;
		    start.sticky = "before";
		  } else if (start.ch <= 0) {
		    start.ch = 0;
		    start.sticky = "after";
		  }
		  var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
		  if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
		    // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
		    // nothing interesting happens.
		    return moveLogically(line, start, dir)
		  }
		
		  var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };
		  var prep;
		  var getWrappedLineExtent = function (ch) {
		    if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
		    prep = prep || prepareMeasureForLine(cm, line);
		    return wrappedLineExtentChar(cm, line, prep, ch)
		  };
		  var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);
		
		  if (cm.doc.direction == "rtl" || part.level == 1) {
		    var moveInStorageOrder = (part.level == 1) == (dir < 0);
		    var ch = mv(start, moveInStorageOrder ? 1 : -1);
		    if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
		      // Case 2: We move within an rtl part or in an rtl editor on the same visual line
		      var sticky = moveInStorageOrder ? "before" : "after";
		      return new Pos(start.line, ch, sticky)
		    }
		  }
		
		  // Case 3: Could not move within this bidi part in this visual line, so leave
		  // the current bidi part
		
		  var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
		    var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
		      ? new Pos(start.line, mv(ch, 1), "before")
		      : new Pos(start.line, ch, "after"); };
		
		    for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
		      var part = bidi[partPos];
		      var moveInStorageOrder = (dir > 0) == (part.level != 1);
		      var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
		      if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
		      ch = moveInStorageOrder ? part.from : mv(part.to, -1);
		      if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
		    }
		  };
		
		  // Case 3a: Look for other bidi parts on the same visual line
		  var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
		  if (res) { return res }
		
		  // Case 3b: Look for other bidi parts on the next visual line
		  var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
		  if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
		    res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
		    if (res) { return res }
		  }
		
		  // Case 4: Nowhere to move
		  return null
		}
		
		// EVENT HANDLING
		
		// Lightweight event framework. on/off also work on DOM nodes,
		// registering native DOM handlers.
		
		var noHandlers = [];
		
		var on = function(emitter, type, f) {
		  if (emitter.addEventListener) {
		    emitter.addEventListener(type, f, false);
		  } else if (emitter.attachEvent) {
		    emitter.attachEvent("on" + type, f);
		  } else {
		    var map$$1 = emitter._handlers || (emitter._handlers = {});
		    map$$1[type] = (map$$1[type] || noHandlers).concat(f);
		  }
		};
		
		function getHandlers(emitter, type) {
		  return emitter._handlers && emitter._handlers[type] || noHandlers
		}
		
		function off(emitter, type, f) {
		  if (emitter.removeEventListener) {
		    emitter.removeEventListener(type, f, false);
		  } else if (emitter.detachEvent) {
		    emitter.detachEvent("on" + type, f);
		  } else {
		    var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];
		    if (arr) {
		      var index = indexOf(arr, f);
		      if (index > -1)
		        { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }
		    }
		  }
		}
		
		function signal(emitter, type /*, values...*/) {
		  var handlers = getHandlers(emitter, type);
		  if (!handlers.length) { return }
		  var args = Array.prototype.slice.call(arguments, 2);
		  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }
		}
		
		// The DOM events that CodeMirror handles can be overridden by
		// registering a (non-DOM) handler on the editor for the event name,
		// and preventDefault-ing the event in that handler.
		function signalDOMEvent(cm, e, override) {
		  if (typeof e == "string")
		    { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }
		  signal(cm, override || e.type, cm, e);
		  return e_defaultPrevented(e) || e.codemirrorIgnore
		}
		
		function signalCursorActivity(cm) {
		  var arr = cm._handlers && cm._handlers.cursorActivity;
		  if (!arr) { return }
		  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
		  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
		    { set.push(arr[i]); } }
		}
		
		function hasHandler(emitter, type) {
		  return getHandlers(emitter, type).length > 0
		}
		
		// Add on and off methods to a constructor's prototype, to make
		// registering events on such objects more convenient.
		function eventMixin(ctor) {
		  ctor.prototype.on = function(type, f) {on(this, type, f);};
		  ctor.prototype.off = function(type, f) {off(this, type, f);};
		}
		
		// Due to the fact that we still support jurassic IE versions, some
		// compatibility wrappers are needed.
		
		function e_preventDefault(e) {
		  if (e.preventDefault) { e.preventDefault(); }
		  else { e.returnValue = false; }
		}
		function e_stopPropagation(e) {
		  if (e.stopPropagation) { e.stopPropagation(); }
		  else { e.cancelBubble = true; }
		}
		function e_defaultPrevented(e) {
		  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
		}
		function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}
		
		function e_target(e) {return e.target || e.srcElement}
		function e_button(e) {
		  var b = e.which;
		  if (b == null) {
		    if (e.button & 1) { b = 1; }
		    else if (e.button & 2) { b = 3; }
		    else if (e.button & 4) { b = 2; }
		  }
		  if (mac && e.ctrlKey && b == 1) { b = 3; }
		  return b
		}
		
		// Detect drag-and-drop
		var dragAndDrop = function() {
		  // There is *some* kind of drag-and-drop support in IE6-8, but I
		  // couldn't get it to work yet.
		  if (ie && ie_version < 9) { return false }
		  var div = elt('div');
		  return "draggable" in div || "dragDrop" in div
		}();
		
		var zwspSupported;
		function zeroWidthElement(measure) {
		  if (zwspSupported == null) {
		    var test = elt("span", "\u200b");
		    removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
		    if (measure.firstChild.offsetHeight != 0)
		      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }
		  }
		  var node = zwspSupported ? elt("span", "\u200b") :
		    elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
		  node.setAttribute("cm-text", "");
		  return node
		}
		
		// Feature-detect IE's crummy client rect reporting for bidi text
		var badBidiRects;
		function hasBadBidiRects(measure) {
		  if (badBidiRects != null) { return badBidiRects }
		  var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
		  var r0 = range(txt, 0, 1).getBoundingClientRect();
		  var r1 = range(txt, 1, 2).getBoundingClientRect();
		  removeChildren(measure);
		  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
		  return badBidiRects = (r1.right - r0.right < 3)
		}
		
		// See if "".split is the broken IE version, if so, provide an
		// alternative way to split lines.
		var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
		  var pos = 0, result = [], l = string.length;
		  while (pos <= l) {
		    var nl = string.indexOf("\n", pos);
		    if (nl == -1) { nl = string.length; }
		    var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
		    var rt = line.indexOf("\r");
		    if (rt != -1) {
		      result.push(line.slice(0, rt));
		      pos += rt + 1;
		    } else {
		      result.push(line);
		      pos = nl + 1;
		    }
		  }
		  return result
		} : function (string) { return string.split(/\r\n?|\n/); };
		
		var hasSelection = window.getSelection ? function (te) {
		  try { return te.selectionStart != te.selectionEnd }
		  catch(e) { return false }
		} : function (te) {
		  var range$$1;
		  try {range$$1 = te.ownerDocument.selection.createRange();}
		  catch(e) {}
		  if (!range$$1 || range$$1.parentElement() != te) { return false }
		  return range$$1.compareEndPoints("StartToEnd", range$$1) != 0
		};
		
		var hasCopyEvent = (function () {
		  var e = elt("div");
		  if ("oncopy" in e) { return true }
		  e.setAttribute("oncopy", "return;");
		  return typeof e.oncopy == "function"
		})();
		
		var badZoomedRects = null;
		function hasBadZoomedRects(measure) {
		  if (badZoomedRects != null) { return badZoomedRects }
		  var node = removeChildrenAndAdd(measure, elt("span", "x"));
		  var normal = node.getBoundingClientRect();
		  var fromRange = range(node, 0, 1).getBoundingClientRect();
		  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
		}
		
		// Known modes, by name and by MIME
		var modes = {};
		var mimeModes = {};
		
		// Extra arguments are stored as the mode's dependencies, which is
		// used by (legacy) mechanisms like loadmode.js to automatically
		// load a mode. (Preferred mechanism is the require/define calls.)
		function defineMode(name, mode) {
		  if (arguments.length > 2)
		    { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
		  modes[name] = mode;
		}
		
		function defineMIME(mime, spec) {
		  mimeModes[mime] = spec;
		}
		
		// Given a MIME type, a {name, ...options} config object, or a name
		// string, return a mode config object.
		function resolveMode(spec) {
		  if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
		    spec = mimeModes[spec];
		  } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
		    var found = mimeModes[spec.name];
		    if (typeof found == "string") { found = {name: found}; }
		    spec = createObj(found, spec);
		    spec.name = found.name;
		  } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
		    return resolveMode("application/xml")
		  } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
		    return resolveMode("application/json")
		  }
		  if (typeof spec == "string") { return {name: spec} }
		  else { return spec || {name: "null"} }
		}
		
		// Given a mode spec (anything that resolveMode accepts), find and
		// initialize an actual mode object.
		function getMode(options, spec) {
		  spec = resolveMode(spec);
		  var mfactory = modes[spec.name];
		  if (!mfactory) { return getMode(options, "text/plain") }
		  var modeObj = mfactory(options, spec);
		  if (modeExtensions.hasOwnProperty(spec.name)) {
		    var exts = modeExtensions[spec.name];
		    for (var prop in exts) {
		      if (!exts.hasOwnProperty(prop)) { continue }
		      if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
		      modeObj[prop] = exts[prop];
		    }
		  }
		  modeObj.name = spec.name;
		  if (spec.helperType) { modeObj.helperType = spec.helperType; }
		  if (spec.modeProps) { for (var prop$1 in spec.modeProps)
		    { modeObj[prop$1] = spec.modeProps[prop$1]; } }
		
		  return modeObj
		}
		
		// This can be used to attach properties to mode objects from
		// outside the actual mode definition.
		var modeExtensions = {};
		function extendMode(mode, properties) {
		  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
		  copyObj(properties, exts);
		}
		
		function copyState(mode, state) {
		  if (state === true) { return state }
		  if (mode.copyState) { return mode.copyState(state) }
		  var nstate = {};
		  for (var n in state) {
		    var val = state[n];
		    if (val instanceof Array) { val = val.concat([]); }
		    nstate[n] = val;
		  }
		  return nstate
		}
		
		// Given a mode and a state (for that mode), find the inner mode and
		// state at the position that the state refers to.
		function innerMode(mode, state) {
		  var info;
		  while (mode.innerMode) {
		    info = mode.innerMode(state);
		    if (!info || info.mode == mode) { break }
		    state = info.state;
		    mode = info.mode;
		  }
		  return info || {mode: mode, state: state}
		}
		
		function startState(mode, a1, a2) {
		  return mode.startState ? mode.startState(a1, a2) : true
		}
		
		// STRING STREAM
		
		// Fed to the mode parsers, provides helper functions to make
		// parsers more succinct.
		
		var StringStream = function(string, tabSize) {
		  this.pos = this.start = 0;
		  this.string = string;
		  this.tabSize = tabSize || 8;
		  this.lastColumnPos = this.lastColumnValue = 0;
		  this.lineStart = 0;
		};
		
		StringStream.prototype.eol = function () {return this.pos >= this.string.length};
		StringStream.prototype.sol = function () {return this.pos == this.lineStart};
		StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
		StringStream.prototype.next = function () {
		  if (this.pos < this.string.length)
		    { return this.string.charAt(this.pos++) }
		};
		StringStream.prototype.eat = function (match) {
		  var ch = this.string.charAt(this.pos);
		  var ok;
		  if (typeof match == "string") { ok = ch == match; }
		  else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
		  if (ok) {++this.pos; return ch}
		};
		StringStream.prototype.eatWhile = function (match) {
		  var start = this.pos;
		  while (this.eat(match)){}
		  return this.pos > start
		};
		StringStream.prototype.eatSpace = function () {
		    var this$1 = this;
		
		  var start = this.pos;
		  while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }
		  return this.pos > start
		};
		StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
		StringStream.prototype.skipTo = function (ch) {
		  var found = this.string.indexOf(ch, this.pos);
		  if (found > -1) {this.pos = found; return true}
		};
		StringStream.prototype.backUp = function (n) {this.pos -= n;};
		StringStream.prototype.column = function () {
		  if (this.lastColumnPos < this.start) {
		    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
		    this.lastColumnPos = this.start;
		  }
		  return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
		};
		StringStream.prototype.indentation = function () {
		  return countColumn(this.string, null, this.tabSize) -
		    (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
		};
		StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
		  if (typeof pattern == "string") {
		    var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
		    var substr = this.string.substr(this.pos, pattern.length);
		    if (cased(substr) == cased(pattern)) {
		      if (consume !== false) { this.pos += pattern.length; }
		      return true
		    }
		  } else {
		    var match = this.string.slice(this.pos).match(pattern);
		    if (match && match.index > 0) { return null }
		    if (match && consume !== false) { this.pos += match[0].length; }
		    return match
		  }
		};
		StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
		StringStream.prototype.hideFirstChars = function (n, inner) {
		  this.lineStart += n;
		  try { return inner() }
		  finally { this.lineStart -= n; }
		};
		
		// Compute a style array (an array starting with a mode generation
		// -- for invalidation -- followed by pairs of end positions and
		// style strings), which is used to highlight the tokens on the
		// line.
		function highlightLine(cm, line, state, forceToEnd) {
		  // A styles array always starts with a number identifying the
		  // mode/overlays that it is based on (for easy invalidation).
		  var st = [cm.state.modeGen], lineClasses = {};
		  // Compute the base array of styles
		  runMode(cm, line.text, cm.doc.mode, state, function (end, style) { return st.push(end, style); },
		    lineClasses, forceToEnd);
		
		  // Run overlays, adjust style array.
		  var loop = function ( o ) {
		    var overlay = cm.state.overlays[o], i = 1, at = 0;
		    runMode(cm, line.text, overlay.mode, true, function (end, style) {
		      var start = i;
		      // Ensure there's a token end at the current position, and that i points at it
		      while (at < end) {
		        var i_end = st[i];
		        if (i_end > end)
		          { st.splice(i, 1, end, st[i+1], i_end); }
		        i += 2;
		        at = Math.min(end, i_end);
		      }
		      if (!style) { return }
		      if (overlay.opaque) {
		        st.splice(start, i - start, end, "overlay " + style);
		        i = start + 2;
		      } else {
		        for (; start < i; start += 2) {
		          var cur = st[start+1];
		          st[start+1] = (cur ? cur + " " : "") + "overlay " + style;
		        }
		      }
		    }, lineClasses);
		  };
		
		  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );
		
		  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
		}
		
		function getLineStyles(cm, line, updateFrontier) {
		  if (!line.styles || line.styles[0] != cm.state.modeGen) {
		    var state = getStateBefore(cm, lineNo(line));
		    var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);
		    line.stateAfter = state;
		    line.styles = result.styles;
		    if (result.classes) { line.styleClasses = result.classes; }
		    else if (line.styleClasses) { line.styleClasses = null; }
		    if (updateFrontier === cm.doc.frontier) { cm.doc.frontier++; }
		  }
		  return line.styles
		}
		
		function getStateBefore(cm, n, precise) {
		  var doc = cm.doc, display = cm.display;
		  if (!doc.mode.startState) { return true }
		  var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;
		  if (!state) { state = startState(doc.mode); }
		  else { state = copyState(doc.mode, state); }
		  doc.iter(pos, n, function (line) {
		    processLine(cm, line.text, state);
		    var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
		    line.stateAfter = save ? copyState(doc.mode, state) : null;
		    ++pos;
		  });
		  if (precise) { doc.frontier = pos; }
		  return state
		}
		
		// Lightweight form of highlight -- proceed over this line and
		// update state, but don't save a style array. Used for lines that
		// aren't currently visible.
		function processLine(cm, text, state, startAt) {
		  var mode = cm.doc.mode;
		  var stream = new StringStream(text, cm.options.tabSize);
		  stream.start = stream.pos = startAt || 0;
		  if (text == "") { callBlankLine(mode, state); }
		  while (!stream.eol()) {
		    readToken(mode, stream, state);
		    stream.start = stream.pos;
		  }
		}
		
		function callBlankLine(mode, state) {
		  if (mode.blankLine) { return mode.blankLine(state) }
		  if (!mode.innerMode) { return }
		  var inner = innerMode(mode, state);
		  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
		}
		
		function readToken(mode, stream, state, inner) {
		  for (var i = 0; i < 10; i++) {
		    if (inner) { inner[0] = innerMode(mode, state).mode; }
		    var style = mode.token(stream, state);
		    if (stream.pos > stream.start) { return style }
		  }
		  throw new Error("Mode " + mode.name + " failed to advance stream.")
		}
		
		// Utility for getTokenAt and getLineTokens
		function takeToken(cm, pos, precise, asArray) {
		  var getObj = function (copy) { return ({
		    start: stream.start, end: stream.pos,
		    string: stream.current(),
		    type: style || null,
		    state: copy ? copyState(doc.mode, state) : state
		  }); };
		
		  var doc = cm.doc, mode = doc.mode, style;
		  pos = clipPos(doc, pos);
		  var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);
		  var stream = new StringStream(line.text, cm.options.tabSize), tokens;
		  if (asArray) { tokens = []; }
		  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
		    stream.start = stream.pos;
		    style = readToken(mode, stream, state);
		    if (asArray) { tokens.push(getObj(true)); }
		  }
		  return asArray ? tokens : getObj()
		}
		
		function extractLineClasses(type, output) {
		  if (type) { for (;;) {
		    var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
		    if (!lineClass) { break }
		    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
		    var prop = lineClass[1] ? "bgClass" : "textClass";
		    if (output[prop] == null)
		      { output[prop] = lineClass[2]; }
		    else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
		      { output[prop] += " " + lineClass[2]; }
		  } }
		  return type
		}
		
		// Run the given mode's parser over a line, calling f for each token.
		function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
		  var flattenSpans = mode.flattenSpans;
		  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }
		  var curStart = 0, curStyle = null;
		  var stream = new StringStream(text, cm.options.tabSize), style;
		  var inner = cm.options.addModeClass && [null];
		  if (text == "") { extractLineClasses(callBlankLine(mode, state), lineClasses); }
		  while (!stream.eol()) {
		    if (stream.pos > cm.options.maxHighlightLength) {
		      flattenSpans = false;
		      if (forceToEnd) { processLine(cm, text, state, stream.pos); }
		      stream.pos = text.length;
		      style = null;
		    } else {
		      style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);
		    }
		    if (inner) {
		      var mName = inner[0].name;
		      if (mName) { style = "m-" + (style ? mName + " " + style : mName); }
		    }
		    if (!flattenSpans || curStyle != style) {
		      while (curStart < stream.start) {
		        curStart = Math.min(stream.start, curStart + 5000);
		        f(curStart, curStyle);
		      }
		      curStyle = style;
		    }
		    stream.start = stream.pos;
		  }
		  while (curStart < stream.pos) {
		    // Webkit seems to refuse to render text nodes longer than 57444
		    // characters, and returns inaccurate measurements in nodes
		    // starting around 5000 chars.
		    var pos = Math.min(stream.pos, curStart + 5000);
		    f(pos, curStyle);
		    curStart = pos;
		  }
		}
		
		// Finds the line to start with when starting a parse. Tries to
		// find a line with a stateAfter, so that it can start with a
		// valid state. If that fails, it returns the line with the
		// smallest indentation, which tends to need the least context to
		// parse correctly.
		function findStartLine(cm, n, precise) {
		  var minindent, minline, doc = cm.doc;
		  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
		  for (var search = n; search > lim; --search) {
		    if (search <= doc.first) { return doc.first }
		    var line = getLine(doc, search - 1);
		    if (line.stateAfter && (!precise || search <= doc.frontier)) { return search }
		    var indented = countColumn(line.text, null, cm.options.tabSize);
		    if (minline == null || minindent > indented) {
		      minline = search - 1;
		      minindent = indented;
		    }
		  }
		  return minline
		}
		
		// LINE DATA STRUCTURE
		
		// Line objects. These hold state related to a line, including
		// highlighting info (the styles array).
		var Line = function(text, markedSpans, estimateHeight) {
		  this.text = text;
		  attachMarkedSpans(this, markedSpans);
		  this.height = estimateHeight ? estimateHeight(this) : 1;
		};
		
		Line.prototype.lineNo = function () { return lineNo(this) };
		eventMixin(Line);
		
		// Change the content (text, markers) of a line. Automatically
		// invalidates cached information and tries to re-estimate the
		// line's height.
		function updateLine(line, text, markedSpans, estimateHeight) {
		  line.text = text;
		  if (line.stateAfter) { line.stateAfter = null; }
		  if (line.styles) { line.styles = null; }
		  if (line.order != null) { line.order = null; }
		  detachMarkedSpans(line);
		  attachMarkedSpans(line, markedSpans);
		  var estHeight = estimateHeight ? estimateHeight(line) : 1;
		  if (estHeight != line.height) { updateLineHeight(line, estHeight); }
		}
		
		// Detach a line from the document tree and its markers.
		function cleanUpLine(line) {
		  line.parent = null;
		  detachMarkedSpans(line);
		}
		
		// Convert a style as returned by a mode (either null, or a string
		// containing one or more styles) to a CSS style. This is cached,
		// and also looks for line-wide styles.
		var styleToClassCache = {};
		var styleToClassCacheWithMode = {};
		function interpretTokenStyle(style, options) {
		  if (!style || /^\s*$/.test(style)) { return null }
		  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
		  return cache[style] ||
		    (cache[style] = style.replace(/\S+/g, "cm-$&"))
		}
		
		// Render the DOM representation of the text of a line. Also builds
		// up a 'line map', which points at the DOM nodes that represent
		// specific stretches of text, and is used by the measuring code.
		// The returned object contains the DOM node, this map, and
		// information about line-wide styles that were set by the mode.
		function buildLineContent(cm, lineView) {
		  // The padding-right forces the element to have a 'border', which
		  // is needed on Webkit to be able to get line-level bounding
		  // rectangles for it (in measureChar).
		  var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
		  var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,
		                 col: 0, pos: 0, cm: cm,
		                 trailingSpace: false,
		                 splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")};
		  lineView.measure = {};
		
		  // Iterate over the logical lines that make up this visual line.
		  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
		    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);
		    builder.pos = 0;
		    builder.addToken = buildToken;
		    // Optionally wire in some hacks into the token-rendering
		    // algorithm, to deal with browser quirks.
		    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))
		      { builder.addToken = buildTokenBadBidi(builder.addToken, order); }
		    builder.map = [];
		    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
		    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
		    if (line.styleClasses) {
		      if (line.styleClasses.bgClass)
		        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }
		      if (line.styleClasses.textClass)
		        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }
		    }
		
		    // Ensure at least a single node is present, for measuring.
		    if (builder.map.length == 0)
		      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }
		
		    // Store the map and a cache object for the current logical line
		    if (i == 0) {
		      lineView.measure.map = builder.map;
		      lineView.measure.cache = {};
		    } else {
		      (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
		      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});
		    }
		  }
		
		  // See issue #2901
		  if (webkit) {
		    var last = builder.content.lastChild;
		    if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
		      { builder.content.className = "cm-tab-wrap-hack"; }
		  }
		
		  signal(cm, "renderLine", cm, lineView.line, builder.pre);
		  if (builder.pre.className)
		    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }
		
		  return builder
		}
		
		function defaultSpecialCharPlaceholder(ch) {
		  var token = elt("span", "\u2022", "cm-invalidchar");
		  token.title = "\\u" + ch.charCodeAt(0).toString(16);
		  token.setAttribute("aria-label", token.title);
		  return token
		}
		
		// Build up the DOM representation for a single token, and add it to
		// the line map. Takes care to render special characters separately.
		function buildToken(builder, text, style, startStyle, endStyle, title, css) {
		  if (!text) { return }
		  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
		  var special = builder.cm.state.specialChars, mustWrap = false;
		  var content;
		  if (!special.test(text)) {
		    builder.col += text.length;
		    content = document.createTextNode(displayText);
		    builder.map.push(builder.pos, builder.pos + text.length, content);
		    if (ie && ie_version < 9) { mustWrap = true; }
		    builder.pos += text.length;
		  } else {
		    content = document.createDocumentFragment();
		    var pos = 0;
		    while (true) {
		      special.lastIndex = pos;
		      var m = special.exec(text);
		      var skipped = m ? m.index - pos : text.length - pos;
		      if (skipped) {
		        var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
		        if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }
		        else { content.appendChild(txt); }
		        builder.map.push(builder.pos, builder.pos + skipped, txt);
		        builder.col += skipped;
		        builder.pos += skipped;
		      }
		      if (!m) { break }
		      pos += skipped + 1;
		      var txt$1 = (void 0);
		      if (m[0] == "\t") {
		        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
		        txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
		        txt$1.setAttribute("role", "presentation");
		        txt$1.setAttribute("cm-text", "\t");
		        builder.col += tabWidth;
		      } else if (m[0] == "\r" || m[0] == "\n") {
		        txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
		        txt$1.setAttribute("cm-text", m[0]);
		        builder.col += 1;
		      } else {
		        txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
		        txt$1.setAttribute("cm-text", m[0]);
		        if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }
		        else { content.appendChild(txt$1); }
		        builder.col += 1;
		      }
		      builder.map.push(builder.pos, builder.pos + 1, txt$1);
		      builder.pos++;
		    }
		  }
		  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
		  if (style || startStyle || endStyle || mustWrap || css) {
		    var fullStyle = style || "";
		    if (startStyle) { fullStyle += startStyle; }
		    if (endStyle) { fullStyle += endStyle; }
		    var token = elt("span", [content], fullStyle, css);
		    if (title) { token.title = title; }
		    return builder.content.appendChild(token)
		  }
		  builder.content.appendChild(content);
		}
		
		function splitSpaces(text, trailingBefore) {
		  if (text.length > 1 && !/  /.test(text)) { return text }
		  var spaceBefore = trailingBefore, result = "";
		  for (var i = 0; i < text.length; i++) {
		    var ch = text.charAt(i);
		    if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
		      { ch = "\u00a0"; }
		    result += ch;
		    spaceBefore = ch == " ";
		  }
		  return result
		}
		
		// Work around nonsense dimensions being reported for stretches of
		// right-to-left text.
		function buildTokenBadBidi(inner, order) {
		  return function (builder, text, style, startStyle, endStyle, title, css) {
		    style = style ? style + " cm-force-border" : "cm-force-border";
		    var start = builder.pos, end = start + text.length;
		    for (;;) {
		      // Find the part that overlaps with the start of this text
		      var part = (void 0);
		      for (var i = 0; i < order.length; i++) {
		        part = order[i];
		        if (part.to > start && part.from <= start) { break }
		      }
		      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }
		      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
		      startStyle = null;
		      text = text.slice(part.to - start);
		      start = part.to;
		    }
		  }
		}
		
		function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
		  var widget = !ignoreWidget && marker.widgetNode;
		  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }
		  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
		    if (!widget)
		      { widget = builder.content.appendChild(document.createElement("span")); }
		    widget.setAttribute("cm-marker", marker.id);
		  }
		  if (widget) {
		    builder.cm.display.input.setUneditable(widget);
		    builder.content.appendChild(widget);
		  }
		  builder.pos += size;
		  builder.trailingSpace = false;
		}
		
		// Outputs a number of spans to make up a line, taking highlighting
		// and marked text into account.
		function insertLineContent(line, builder, styles) {
		  var spans = line.markedSpans, allText = line.text, at = 0;
		  if (!spans) {
		    for (var i$1 = 1; i$1 < styles.length; i$1+=2)
		      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }
		    return
		  }
		
		  var len = allText.length, pos = 0, i = 1, text = "", style, css;
		  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
		  for (;;) {
		    if (nextChange == pos) { // Update current marker set
		      spanStyle = spanEndStyle = spanStartStyle = title = css = "";
		      collapsed = null; nextChange = Infinity;
		      var foundBookmarks = [], endStyles = (void 0);
		      for (var j = 0; j < spans.length; ++j) {
		        var sp = spans[j], m = sp.marker;
		        if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
		          foundBookmarks.push(m);
		        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
		          if (sp.to != null && sp.to != pos && nextChange > sp.to) {
		            nextChange = sp.to;
		            spanEndStyle = "";
		          }
		          if (m.className) { spanStyle += " " + m.className; }
		          if (m.css) { css = (css ? css + ";" : "") + m.css; }
		          if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }
		          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }
		          if (m.title && !title) { title = m.title; }
		          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
		            { collapsed = sp; }
		        } else if (sp.from > pos && nextChange > sp.from) {
		          nextChange = sp.from;
		        }
		      }
		      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
		        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } } }
		
		      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
		        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }
		      if (collapsed && (collapsed.from || 0) == pos) {
		        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
		                           collapsed.marker, collapsed.from == null);
		        if (collapsed.to == null) { return }
		        if (collapsed.to == pos) { collapsed = false; }
		      }
		    }
		    if (pos >= len) { break }
		
		    var upto = Math.min(len, nextChange);
		    while (true) {
		      if (text) {
		        var end = pos + text.length;
		        if (!collapsed) {
		          var tokenText = end > upto ? text.slice(0, upto - pos) : text;
		          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
		                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
		        }
		        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
		        pos = end;
		        spanStartStyle = "";
		      }
		      text = allText.slice(at, at = styles[i++]);
		      style = interpretTokenStyle(styles[i++], builder.cm.options);
		    }
		  }
		}
		
		
		// These objects are used to represent the visible (currently drawn)
		// part of the document. A LineView may correspond to multiple
		// logical lines, if those are connected by collapsed ranges.
		function LineView(doc, line, lineN) {
		  // The starting line
		  this.line = line;
		  // Continuing lines, if any
		  this.rest = visualLineContinued(line);
		  // Number of logical lines in this visual line
		  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
		  this.node = this.text = null;
		  this.hidden = lineIsHidden(doc, line);
		}
		
		// Create a range of LineView objects for the given lines.
		function buildViewArray(cm, from, to) {
		  var array = [], nextPos;
		  for (var pos = from; pos < to; pos = nextPos) {
		    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
		    nextPos = pos + view.size;
		    array.push(view);
		  }
		  return array
		}
		
		var operationGroup = null;
		
		function pushOperation(op) {
		  if (operationGroup) {
		    operationGroup.ops.push(op);
		  } else {
		    op.ownsGroup = operationGroup = {
		      ops: [op],
		      delayedCallbacks: []
		    };
		  }
		}
		
		function fireCallbacksForOps(group) {
		  // Calls delayed callbacks and cursorActivity handlers until no
		  // new ones appear
		  var callbacks = group.delayedCallbacks, i = 0;
		  do {
		    for (; i < callbacks.length; i++)
		      { callbacks[i].call(null); }
		    for (var j = 0; j < group.ops.length; j++) {
		      var op = group.ops[j];
		      if (op.cursorActivityHandlers)
		        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
		          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }
		    }
		  } while (i < callbacks.length)
		}
		
		function finishOperation(op, endCb) {
		  var group = op.ownsGroup;
		  if (!group) { return }
		
		  try { fireCallbacksForOps(group); }
		  finally {
		    operationGroup = null;
		    endCb(group);
		  }
		}
		
		var orphanDelayedCallbacks = null;
		
		// Often, we want to signal events at a point where we are in the
		// middle of some work, but don't want the handler to start calling
		// other methods on the editor, which might be in an inconsistent
		// state or simply not expect any other events to happen.
		// signalLater looks whether there are any handlers, and schedules
		// them to be executed when the last operation ends, or, if no
		// operation is active, when a timeout fires.
		function signalLater(emitter, type /*, values...*/) {
		  var arr = getHandlers(emitter, type);
		  if (!arr.length) { return }
		  var args = Array.prototype.slice.call(arguments, 2), list;
		  if (operationGroup) {
		    list = operationGroup.delayedCallbacks;
		  } else if (orphanDelayedCallbacks) {
		    list = orphanDelayedCallbacks;
		  } else {
		    list = orphanDelayedCallbacks = [];
		    setTimeout(fireOrphanDelayed, 0);
		  }
		  var loop = function ( i ) {
		    list.push(function () { return arr[i].apply(null, args); });
		  };
		
		  for (var i = 0; i < arr.length; ++i)
		    loop( i );
		}
		
		function fireOrphanDelayed() {
		  var delayed = orphanDelayedCallbacks;
		  orphanDelayedCallbacks = null;
		  for (var i = 0; i < delayed.length; ++i) { delayed[i](); }
		}
		
		// When an aspect of a line changes, a string is added to
		// lineView.changes. This updates the relevant part of the line's
		// DOM structure.
		function updateLineForChanges(cm, lineView, lineN, dims) {
		  for (var j = 0; j < lineView.changes.length; j++) {
		    var type = lineView.changes[j];
		    if (type == "text") { updateLineText(cm, lineView); }
		    else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }
		    else if (type == "class") { updateLineClasses(cm, lineView); }
		    else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }
		  }
		  lineView.changes = null;
		}
		
		// Lines with gutter elements, widgets or a background class need to
		// be wrapped, and have the extra elements added to the wrapper div
		function ensureLineWrapped(lineView) {
		  if (lineView.node == lineView.text) {
		    lineView.node = elt("div", null, null, "position: relative");
		    if (lineView.text.parentNode)
		      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }
		    lineView.node.appendChild(lineView.text);
		    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }
		  }
		  return lineView.node
		}
		
		function updateLineBackground(cm, lineView) {
		  var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
		  if (cls) { cls += " CodeMirror-linebackground"; }
		  if (lineView.background) {
		    if (cls) { lineView.background.className = cls; }
		    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
		  } else if (cls) {
		    var wrap = ensureLineWrapped(lineView);
		    lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
		    cm.display.input.setUneditable(lineView.background);
		  }
		}
		
		// Wrapper around buildLineContent which will reuse the structure
		// in display.externalMeasured when possible.
		function getLineContent(cm, lineView) {
		  var ext = cm.display.externalMeasured;
		  if (ext && ext.line == lineView.line) {
		    cm.display.externalMeasured = null;
		    lineView.measure = ext.measure;
		    return ext.built
		  }
		  return buildLineContent(cm, lineView)
		}
		
		// Redraw the line's text. Interacts with the background and text
		// classes because the mode may output tokens that influence these
		// classes.
		function updateLineText(cm, lineView) {
		  var cls = lineView.text.className;
		  var built = getLineContent(cm, lineView);
		  if (lineView.text == lineView.node) { lineView.node = built.pre; }
		  lineView.text.parentNode.replaceChild(built.pre, lineView.text);
		  lineView.text = built.pre;
		  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
		    lineView.bgClass = built.bgClass;
		    lineView.textClass = built.textClass;
		    updateLineClasses(cm, lineView);
		  } else if (cls) {
		    lineView.text.className = cls;
		  }
		}
		
		function updateLineClasses(cm, lineView) {
		  updateLineBackground(cm, lineView);
		  if (lineView.line.wrapClass)
		    { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }
		  else if (lineView.node != lineView.text)
		    { lineView.node.className = ""; }
		  var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
		  lineView.text.className = textClass || "";
		}
		
		function updateLineGutter(cm, lineView, lineN, dims) {
		  if (lineView.gutter) {
		    lineView.node.removeChild(lineView.gutter);
		    lineView.gutter = null;
		  }
		  if (lineView.gutterBackground) {
		    lineView.node.removeChild(lineView.gutterBackground);
		    lineView.gutterBackground = null;
		  }
		  if (lineView.line.gutterClass) {
		    var wrap = ensureLineWrapped(lineView);
		    lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
		                                    ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));
		    cm.display.input.setUneditable(lineView.gutterBackground);
		    wrap.insertBefore(lineView.gutterBackground, lineView.text);
		  }
		  var markers = lineView.line.gutterMarkers;
		  if (cm.options.lineNumbers || markers) {
		    var wrap$1 = ensureLineWrapped(lineView);
		    var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));
		    cm.display.input.setUneditable(gutterWrap);
		    wrap$1.insertBefore(gutterWrap, lineView.text);
		    if (lineView.line.gutterClass)
		      { gutterWrap.className += " " + lineView.line.gutterClass; }
		    if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
		      { lineView.lineNumber = gutterWrap.appendChild(
		        elt("div", lineNumberFor(cm.options, lineN),
		            "CodeMirror-linenumber CodeMirror-gutter-elt",
		            ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))); }
		    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {
		      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
		      if (found)
		        { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
		                                   ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))); }
		    } }
		  }
		}
		
		function updateLineWidgets(cm, lineView, dims) {
		  if (lineView.alignable) { lineView.alignable = null; }
		  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
		    next = node.nextSibling;
		    if (node.className == "CodeMirror-linewidget")
		      { lineView.node.removeChild(node); }
		  }
		  insertLineWidgets(cm, lineView, dims);
		}
		
		// Build a line's DOM representation from scratch
		function buildLineElement(cm, lineView, lineN, dims) {
		  var built = getLineContent(cm, lineView);
		  lineView.text = lineView.node = built.pre;
		  if (built.bgClass) { lineView.bgClass = built.bgClass; }
		  if (built.textClass) { lineView.textClass = built.textClass; }
		
		  updateLineClasses(cm, lineView);
		  updateLineGutter(cm, lineView, lineN, dims);
		  insertLineWidgets(cm, lineView, dims);
		  return lineView.node
		}
		
		// A lineView may contain multiple logical lines (when merged by
		// collapsed spans). The widgets for all of them need to be drawn.
		function insertLineWidgets(cm, lineView, dims) {
		  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
		  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
		    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }
		}
		
		function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
		  if (!line.widgets) { return }
		  var wrap = ensureLineWrapped(lineView);
		  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
		    var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
		    if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }
		    positionLineWidget(widget, node, lineView, dims);
		    cm.display.input.setUneditable(node);
		    if (allowAbove && widget.above)
		      { wrap.insertBefore(node, lineView.gutter || lineView.text); }
		    else
		      { wrap.appendChild(node); }
		    signalLater(widget, "redraw");
		  }
		}
		
		function positionLineWidget(widget, node, lineView, dims) {
		  if (widget.noHScroll) {
		    (lineView.alignable || (lineView.alignable = [])).push(node);
		    var width = dims.wrapperWidth;
		    node.style.left = dims.fixedPos + "px";
		    if (!widget.coverGutter) {
		      width -= dims.gutterTotalWidth;
		      node.style.paddingLeft = dims.gutterTotalWidth + "px";
		    }
		    node.style.width = width + "px";
		  }
		  if (widget.coverGutter) {
		    node.style.zIndex = 5;
		    node.style.position = "relative";
		    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }
		  }
		}
		
		function widgetHeight(widget) {
		  if (widget.height != null) { return widget.height }
		  var cm = widget.doc.cm;
		  if (!cm) { return 0 }
		  if (!contains(document.body, widget.node)) {
		    var parentStyle = "position: relative;";
		    if (widget.coverGutter)
		      { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }
		    if (widget.noHScroll)
		      { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }
		    removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
		  }
		  return widget.height = widget.node.parentNode.offsetHeight
		}
		
		// Return true when the given mouse event happened in a widget
		function eventInWidget(display, e) {
		  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
		    if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
		        (n.parentNode == display.sizer && n != display.mover))
		      { return true }
		  }
		}
		
		// POSITION MEASUREMENT
		
		function paddingTop(display) {return display.lineSpace.offsetTop}
		function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
		function paddingH(display) {
		  if (display.cachedPaddingH) { return display.cachedPaddingH }
		  var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
		  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
		  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
		  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }
		  return data
		}
		
		function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
		function displayWidth(cm) {
		  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
		}
		function displayHeight(cm) {
		  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
		}
		
		// Ensure the lineView.wrapping.heights array is populated. This is
		// an array of bottom offsets for the lines that make up a drawn
		// line. When lineWrapping is on, there might be more than one
		// height.
		function ensureLineHeights(cm, lineView, rect) {
		  var wrapping = cm.options.lineWrapping;
		  var curWidth = wrapping && displayWidth(cm);
		  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
		    var heights = lineView.measure.heights = [];
		    if (wrapping) {
		      lineView.measure.width = curWidth;
		      var rects = lineView.text.firstChild.getClientRects();
		      for (var i = 0; i < rects.length - 1; i++) {
		        var cur = rects[i], next = rects[i + 1];
		        if (Math.abs(cur.bottom - next.bottom) > 2)
		          { heights.push((cur.bottom + next.top) / 2 - rect.top); }
		      }
		    }
		    heights.push(rect.bottom - rect.top);
		  }
		}
		
		// Find a line map (mapping character offsets to text nodes) and a
		// measurement cache for the given line number. (A line view might
		// contain multiple lines when collapsed ranges are present.)
		function mapFromLineView(lineView, line, lineN) {
		  if (lineView.line == line)
		    { return {map: lineView.measure.map, cache: lineView.measure.cache} }
		  for (var i = 0; i < lineView.rest.length; i++)
		    { if (lineView.rest[i] == line)
		      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
		  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
		    { if (lineNo(lineView.rest[i$1]) > lineN)
		      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
		}
		
		// Render a line into the hidden node display.externalMeasured. Used
		// when measurement is needed for a line that's not in the viewport.
		function updateExternalMeasurement(cm, line) {
		  line = visualLine(line);
		  var lineN = lineNo(line);
		  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
		  view.lineN = lineN;
		  var built = view.built = buildLineContent(cm, view);
		  view.text = built.pre;
		  removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
		  return view
		}
		
		// Get a {top, bottom, left, right} box (in line-local coordinates)
		// for a given character.
		function measureChar(cm, line, ch, bias) {
		  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
		}
		
		// Find a line view that corresponds to the given line number.
		function findViewForLine(cm, lineN) {
		  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
		    { return cm.display.view[findViewIndex(cm, lineN)] }
		  var ext = cm.display.externalMeasured;
		  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
		    { return ext }
		}
		
		// Measurement can be split in two steps, the set-up work that
		// applies to the whole line, and the measurement of the actual
		// character. Functions like coordsChar, that need to do a lot of
		// measurements in a row, can thus ensure that the set-up work is
		// only done once.
		function prepareMeasureForLine(cm, line) {
		  var lineN = lineNo(line);
		  var view = findViewForLine(cm, lineN);
		  if (view && !view.text) {
		    view = null;
		  } else if (view && view.changes) {
		    updateLineForChanges(cm, view, lineN, getDimensions(cm));
		    cm.curOp.forceUpdate = true;
		  }
		  if (!view)
		    { view = updateExternalMeasurement(cm, line); }
		
		  var info = mapFromLineView(view, line, lineN);
		  return {
		    line: line, view: view, rect: null,
		    map: info.map, cache: info.cache, before: info.before,
		    hasHeights: false
		  }
		}
		
		// Given a prepared measurement object, measures the position of an
		// actual character (or fetches it from the cache).
		function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
		  if (prepared.before) { ch = -1; }
		  var key = ch + (bias || ""), found;
		  if (prepared.cache.hasOwnProperty(key)) {
		    found = prepared.cache[key];
		  } else {
		    if (!prepared.rect)
		      { prepared.rect = prepared.view.text.getBoundingClientRect(); }
		    if (!prepared.hasHeights) {
		      ensureLineHeights(cm, prepared.view, prepared.rect);
		      prepared.hasHeights = true;
		    }
		    found = measureCharInner(cm, prepared, ch, bias);
		    if (!found.bogus) { prepared.cache[key] = found; }
		  }
		  return {left: found.left, right: found.right,
		          top: varHeight ? found.rtop : found.top,
		          bottom: varHeight ? found.rbottom : found.bottom}
		}
		
		var nullRect = {left: 0, right: 0, top: 0, bottom: 0};
		
		function nodeAndOffsetInLineMap(map$$1, ch, bias) {
		  var node, start, end, collapse, mStart, mEnd;
		  // First, search the line map for the text node corresponding to,
		  // or closest to, the target character.
		  for (var i = 0; i < map$$1.length; i += 3) {
		    mStart = map$$1[i];
		    mEnd = map$$1[i + 1];
		    if (ch < mStart) {
		      start = 0; end = 1;
		      collapse = "left";
		    } else if (ch < mEnd) {
		      start = ch - mStart;
		      end = start + 1;
		    } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {
		      end = mEnd - mStart;
		      start = end - 1;
		      if (ch >= mEnd) { collapse = "right"; }
		    }
		    if (start != null) {
		      node = map$$1[i + 2];
		      if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
		        { collapse = bias; }
		      if (bias == "left" && start == 0)
		        { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {
		          node = map$$1[(i -= 3) + 2];
		          collapse = "left";
		        } }
		      if (bias == "right" && start == mEnd - mStart)
		        { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {
		          node = map$$1[(i += 3) + 2];
		          collapse = "right";
		        } }
		      break
		    }
		  }
		  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
		}
		
		function getUsefulRect(rects, bias) {
		  var rect = nullRect;
		  if (bias == "left") { for (var i = 0; i < rects.length; i++) {
		    if ((rect = rects[i]).left != rect.right) { break }
		  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
		    if ((rect = rects[i$1]).left != rect.right) { break }
		  } }
		  return rect
		}
		
		function measureCharInner(cm, prepared, ch, bias) {
		  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
		  var node = place.node, start = place.start, end = place.end, collapse = place.collapse;
		
		  var rect;
		  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
		    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
		      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }
		      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }
		      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
		        { rect = node.parentNode.getBoundingClientRect(); }
		      else
		        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }
		      if (rect.left || rect.right || start == 0) { break }
		      end = start;
		      start = start - 1;
		      collapse = "right";
		    }
		    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }
		  } else { // If it is a widget, simply get the box for the whole widget.
		    if (start > 0) { collapse = bias = "right"; }
		    var rects;
		    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
		      { rect = rects[bias == "right" ? rects.length - 1 : 0]; }
		    else
		      { rect = node.getBoundingClientRect(); }
		  }
		  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
		    var rSpan = node.parentNode.getClientRects()[0];
		    if (rSpan)
		      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }
		    else
		      { rect = nullRect; }
		  }
		
		  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
		  var mid = (rtop + rbot) / 2;
		  var heights = prepared.view.measure.heights;
		  var i = 0;
		  for (; i < heights.length - 1; i++)
		    { if (mid < heights[i]) { break } }
		  var top = i ? heights[i - 1] : 0, bot = heights[i];
		  var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
		                right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
		                top: top, bottom: bot};
		  if (!rect.left && !rect.right) { result.bogus = true; }
		  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }
		
		  return result
		}
		
		// Work around problem with bounding client rects on ranges being
		// returned incorrectly when zoomed on IE10 and below.
		function maybeUpdateRectForZooming(measure, rect) {
		  if (!window.screen || screen.logicalXDPI == null ||
		      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
		    { return rect }
		  var scaleX = screen.logicalXDPI / screen.deviceXDPI;
		  var scaleY = screen.logicalYDPI / screen.deviceYDPI;
		  return {left: rect.left * scaleX, right: rect.right * scaleX,
		          top: rect.top * scaleY, bottom: rect.bottom * scaleY}
		}
		
		function clearLineMeasurementCacheFor(lineView) {
		  if (lineView.measure) {
		    lineView.measure.cache = {};
		    lineView.measure.heights = null;
		    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
		      { lineView.measure.caches[i] = {}; } }
		  }
		}
		
		function clearLineMeasurementCache(cm) {
		  cm.display.externalMeasure = null;
		  removeChildren(cm.display.lineMeasure);
		  for (var i = 0; i < cm.display.view.length; i++)
		    { clearLineMeasurementCacheFor(cm.display.view[i]); }
		}
		
		function clearCaches(cm) {
		  clearLineMeasurementCache(cm);
		  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
		  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }
		  cm.display.lineNumChars = null;
		}
		
		function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft }
		function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop }
		
		// Converts a {top, bottom, left, right} box from line-local
		// coordinates into another coordinate system. Context may be one of
		// "line", "div" (display.lineDiv), "local"./null (editor), "window",
		// or "page".
		function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
		  if (!includeWidgets && lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above) {
		    var size = widgetHeight(lineObj.widgets[i]);
		    rect.top += size; rect.bottom += size;
		  } } }
		  if (context == "line") { return rect }
		  if (!context) { context = "local"; }
		  var yOff = heightAtLine(lineObj);
		  if (context == "local") { yOff += paddingTop(cm.display); }
		  else { yOff -= cm.display.viewOffset; }
		  if (context == "page" || context == "window") {
		    var lOff = cm.display.lineSpace.getBoundingClientRect();
		    yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
		    var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
		    rect.left += xOff; rect.right += xOff;
		  }
		  rect.top += yOff; rect.bottom += yOff;
		  return rect
		}
		
		// Coverts a box from "div" coords to another coordinate system.
		// Context may be "window", "page", "div", or "local"./null.
		function fromCoordSystem(cm, coords, context) {
		  if (context == "div") { return coords }
		  var left = coords.left, top = coords.top;
		  // First move into "page" coordinate system
		  if (context == "page") {
		    left -= pageScrollX();
		    top -= pageScrollY();
		  } else if (context == "local" || !context) {
		    var localBox = cm.display.sizer.getBoundingClientRect();
		    left += localBox.left;
		    top += localBox.top;
		  }
		
		  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
		  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
		}
		
		function charCoords(cm, pos, context, lineObj, bias) {
		  if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }
		  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
		}
		
		// Returns a box for a given cursor position, which may have an
		// 'other' property containing the position of the secondary cursor
		// on a bidi boundary.
		// A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
		// and after `char - 1` in writing order of `char - 1`
		// A cursor Pos(line, char, "after") is on the same visual line as `char`
		// and before `char` in writing order of `char`
		// Examples (upper-case letters are RTL, lower-case are LTR):
		//     Pos(0, 1, ...)
		//     before   after
		// ab     a|b     a|b
		// aB     a|B     aB|
		// Ab     |Ab     A|b
		// AB     B|A     B|A
		// Every position after the last character on a line is considered to stick
		// to the last character on the line.
		function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
		  lineObj = lineObj || getLine(cm.doc, pos.line);
		  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
		  function get(ch, right) {
		    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
		    if (right) { m.left = m.right; } else { m.right = m.left; }
		    return intoCoordSystem(cm, lineObj, m, context)
		  }
		  var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
		  if (ch >= lineObj.text.length) {
		    ch = lineObj.text.length;
		    sticky = "before";
		  } else if (ch <= 0) {
		    ch = 0;
		    sticky = "after";
		  }
		  if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }
		
		  function getBidi(ch, partPos, invert) {
		    var part = order[partPos], right = (part.level % 2) != 0;
		    return get(invert ? ch - 1 : ch, right != invert)
		  }
		  var partPos = getBidiPartAt(order, ch, sticky);
		  var other = bidiOther;
		  var val = getBidi(ch, partPos, sticky == "before");
		  if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }
		  return val
		}
		
		// Used to cheaply estimate the coordinates for a position. Used for
		// intermediate scroll updates.
		function estimateCoords(cm, pos) {
		  var left = 0;
		  pos = clipPos(cm.doc, pos);
		  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }
		  var lineObj = getLine(cm.doc, pos.line);
		  var top = heightAtLine(lineObj) + paddingTop(cm.display);
		  return {left: left, right: left, top: top, bottom: top + lineObj.height}
		}
		
		// Positions returned by coordsChar contain some extra information.
		// xRel is the relative x position of the input coordinates compared
		// to the found position (so xRel > 0 means the coordinates are to
		// the right of the character position, for example). When outside
		// is true, that means the coordinates lie outside the line's
		// vertical range.
		function PosWithInfo(line, ch, sticky, outside, xRel) {
		  var pos = Pos(line, ch, sticky);
		  pos.xRel = xRel;
		  if (outside) { pos.outside = true; }
		  return pos
		}
		
		// Compute the character position closest to the given coordinates.
		// Input must be lineSpace-local ("div" coordinate system).
		function coordsChar(cm, x, y) {
		  var doc = cm.doc;
		  y += cm.display.viewOffset;
		  if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }
		  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
		  if (lineN > last)
		    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }
		  if (x < 0) { x = 0; }
		
		  var lineObj = getLine(doc, lineN);
		  for (;;) {
		    var found = coordsCharInner(cm, lineObj, lineN, x, y);
		    var merged = collapsedSpanAtEnd(lineObj);
		    var mergedPos = merged && merged.find(0, true);
		    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
		      { lineN = lineNo(lineObj = mergedPos.to.line); }
		    else
		      { return found }
		  }
		}
		
		function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
		  var measure = function (ch) { return intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), "line"); };
		  var end = lineObj.text.length;
		  var begin = findFirst(function (ch) { return measure(ch - 1).bottom <= y; }, end, 0);
		  end = findFirst(function (ch) { return measure(ch).top > y; }, begin, end);
		  return {begin: begin, end: end}
		}
		
		function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
		  var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
		  return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
		}
		
		function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {
		  y -= heightAtLine(lineObj);
		  var begin = 0, end = lineObj.text.length;
		  var preparedMeasure = prepareMeasureForLine(cm, lineObj);
		  var pos;
		  var order = getOrder(lineObj, cm.doc.direction);
		  if (order) {
		    if (cm.options.lineWrapping) {
		      var assign;
		      ((assign = wrappedLineExtent(cm, lineObj, preparedMeasure, y), begin = assign.begin, end = assign.end, assign));
		    }
		    pos = new Pos(lineNo$$1, begin);
		    var beginLeft = cursorCoords(cm, pos, "line", lineObj, preparedMeasure).left;
		    var dir = beginLeft < x ? 1 : -1;
		    var prevDiff, diff = beginLeft - x, prevPos;
		    do {
		      prevDiff = diff;
		      prevPos = pos;
		      pos = moveVisually(cm, lineObj, pos, dir);
		      if (pos == null || pos.ch < begin || end <= (pos.sticky == "before" ? pos.ch - 1 : pos.ch)) {
		        pos = prevPos;
		        break
		      }
		      diff = cursorCoords(cm, pos, "line", lineObj, preparedMeasure).left - x;
		    } while ((dir < 0) != (diff < 0) && (Math.abs(diff) <= Math.abs(prevDiff)))
		    if (Math.abs(diff) > Math.abs(prevDiff)) {
		      if ((diff < 0) == (prevDiff < 0)) { throw new Error("Broke out of infinite loop in coordsCharInner") }
		      pos = prevPos;
		    }
		  } else {
		    var ch = findFirst(function (ch) {
		      var box = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), "line");
		      if (box.top > y) {
		        // For the cursor stickiness
		        end = Math.min(ch, end);
		        return true
		      }
		      else if (box.bottom <= y) { return false }
		      else if (box.left > x) { return true }
		      else if (box.right < x) { return false }
		      else { return (x - box.left < box.right - x) }
		    }, begin, end);
		    ch = skipExtendingChars(lineObj.text, ch, 1);
		    pos = new Pos(lineNo$$1, ch, ch == end ? "before" : "after");
		  }
		  var coords = cursorCoords(cm, pos, "line", lineObj, preparedMeasure);
		  if (y < coords.top || coords.bottom < y) { pos.outside = true; }
		  pos.xRel = x < coords.left ? -1 : (x > coords.right ? 1 : 0);
		  return pos
		}
		
		var measureText;
		// Compute the default text height.
		function textHeight(display) {
		  if (display.cachedTextHeight != null) { return display.cachedTextHeight }
		  if (measureText == null) {
		    measureText = elt("pre");
		    // Measure a bunch of lines, for browsers that compute
		    // fractional heights.
		    for (var i = 0; i < 49; ++i) {
		      measureText.appendChild(document.createTextNode("x"));
		      measureText.appendChild(elt("br"));
		    }
		    measureText.appendChild(document.createTextNode("x"));
		  }
		  removeChildrenAndAdd(display.measure, measureText);
		  var height = measureText.offsetHeight / 50;
		  if (height > 3) { display.cachedTextHeight = height; }
		  removeChildren(display.measure);
		  return height || 1
		}
		
		// Compute the default character width.
		function charWidth(display) {
		  if (display.cachedCharWidth != null) { return display.cachedCharWidth }
		  var anchor = elt("span", "xxxxxxxxxx");
		  var pre = elt("pre", [anchor]);
		  removeChildrenAndAdd(display.measure, pre);
		  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
		  if (width > 2) { display.cachedCharWidth = width; }
		  return width || 10
		}
		
		// Do a bulk-read of the DOM positions and sizes needed to draw the
		// view, so that we don't interleave reading and writing to the DOM.
		function getDimensions(cm) {
		  var d = cm.display, left = {}, width = {};
		  var gutterLeft = d.gutters.clientLeft;
		  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
		    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
		    width[cm.options.gutters[i]] = n.clientWidth;
		  }
		  return {fixedPos: compensateForHScroll(d),
		          gutterTotalWidth: d.gutters.offsetWidth,
		          gutterLeft: left,
		          gutterWidth: width,
		          wrapperWidth: d.wrapper.clientWidth}
		}
		
		// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
		// but using getBoundingClientRect to get a sub-pixel-accurate
		// result.
		function compensateForHScroll(display) {
		  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
		}
		
		// Returns a function that estimates the height of a line, to use as
		// first approximation until the line becomes visible (and is thus
		// properly measurable).
		function estimateHeight(cm) {
		  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
		  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
		  return function (line) {
		    if (lineIsHidden(cm.doc, line)) { return 0 }
		
		    var widgetsHeight = 0;
		    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
		      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }
		    } }
		
		    if (wrapping)
		      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
		    else
		      { return widgetsHeight + th }
		  }
		}
		
		function estimateLineHeights(cm) {
		  var doc = cm.doc, est = estimateHeight(cm);
		  doc.iter(function (line) {
		    var estHeight = est(line);
		    if (estHeight != line.height) { updateLineHeight(line, estHeight); }
		  });
		}
		
		// Given a mouse event, find the corresponding position. If liberal
		// is false, it checks whether a gutter or scrollbar was clicked,
		// and returns null if it was. forRect is used by rectangular
		// selections, and tries to estimate a character position even for
		// coordinates beyond the right of the text.
		function posFromMouse(cm, e, liberal, forRect) {
		  var display = cm.display;
		  if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }
		
		  var x, y, space = display.lineSpace.getBoundingClientRect();
		  // Fails unpredictably on IE[67] when mouse is dragged around quickly.
		  try { x = e.clientX - space.left; y = e.clientY - space.top; }
		  catch (e) { return null }
		  var coords = coordsChar(cm, x, y), line;
		  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
		    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
		    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
		  }
		  return coords
		}
		
		// Find the view element corresponding to a given line. Return null
		// when the line isn't visible.
		function findViewIndex(cm, n) {
		  if (n >= cm.display.viewTo) { return null }
		  n -= cm.display.viewFrom;
		  if (n < 0) { return null }
		  var view = cm.display.view;
		  for (var i = 0; i < view.length; i++) {
		    n -= view[i].size;
		    if (n < 0) { return i }
		  }
		}
		
		function updateSelection(cm) {
		  cm.display.input.showSelection(cm.display.input.prepareSelection());
		}
		
		function prepareSelection(cm, primary) {
		  var doc = cm.doc, result = {};
		  var curFragment = result.cursors = document.createDocumentFragment();
		  var selFragment = result.selection = document.createDocumentFragment();
		
		  for (var i = 0; i < doc.sel.ranges.length; i++) {
		    if (primary === false && i == doc.sel.primIndex) { continue }
		    var range$$1 = doc.sel.ranges[i];
		    if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }
		    var collapsed = range$$1.empty();
		    if (collapsed || cm.options.showCursorWhenSelecting)
		      { drawSelectionCursor(cm, range$$1.head, curFragment); }
		    if (!collapsed)
		      { drawSelectionRange(cm, range$$1, selFragment); }
		  }
		  return result
		}
		
		// Draws a cursor for the given range
		function drawSelectionCursor(cm, head, output) {
		  var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
		
		  var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
		  cursor.style.left = pos.left + "px";
		  cursor.style.top = pos.top + "px";
		  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
		
		  if (pos.other) {
		    // Secondary cursor, shown when on a 'jump' in bi-directional text
		    var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
		    otherCursor.style.display = "";
		    otherCursor.style.left = pos.other.left + "px";
		    otherCursor.style.top = pos.other.top + "px";
		    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
		  }
		}
		
		// Draws the given range as a highlighted selection
		function drawSelectionRange(cm, range$$1, output) {
		  var display = cm.display, doc = cm.doc;
		  var fragment = document.createDocumentFragment();
		  var padding = paddingH(cm.display), leftSide = padding.left;
		  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
		
		  function add(left, top, width, bottom) {
		    if (top < 0) { top = 0; }
		    top = Math.round(top);
		    bottom = Math.round(bottom);
		    fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")));
		  }
		
		  function drawForLine(line, fromArg, toArg) {
		    var lineObj = getLine(doc, line);
		    var lineLen = lineObj.text.length;
		    var start, end;
		    function coords(ch, bias) {
		      return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
		    }
		
		    iterateBidiSections(getOrder(lineObj, doc.direction), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {
		      var leftPos = coords(from, "left"), rightPos, left, right;
		      if (from == to) {
		        rightPos = leftPos;
		        left = right = leftPos.left;
		      } else {
		        rightPos = coords(to - 1, "right");
		        if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }
		        left = leftPos.left;
		        right = rightPos.right;
		      }
		      if (fromArg == null && from == 0) { left = leftSide; }
		      if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part
		        add(left, leftPos.top, null, leftPos.bottom);
		        left = leftSide;
		        if (leftPos.bottom < rightPos.top) { add(left, leftPos.bottom, null, rightPos.top); }
		      }
		      if (toArg == null && to == lineLen) { right = rightSide; }
		      if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
		        { start = leftPos; }
		      if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
		        { end = rightPos; }
		      if (left < leftSide + 1) { left = leftSide; }
		      add(left, rightPos.top, right - left, rightPos.bottom);
		    });
		    return {start: start, end: end}
		  }
		
		  var sFrom = range$$1.from(), sTo = range$$1.to();
		  if (sFrom.line == sTo.line) {
		    drawForLine(sFrom.line, sFrom.ch, sTo.ch);
		  } else {
		    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
		    var singleVLine = visualLine(fromLine) == visualLine(toLine);
		    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
		    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
		    if (singleVLine) {
		      if (leftEnd.top < rightStart.top - 2) {
		        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
		        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
		      } else {
		        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
		      }
		    }
		    if (leftEnd.bottom < rightStart.top)
		      { add(leftSide, leftEnd.bottom, null, rightStart.top); }
		  }
		
		  output.appendChild(fragment);
		}
		
		// Cursor-blinking
		function restartBlink(cm) {
		  if (!cm.state.focused) { return }
		  var display = cm.display;
		  clearInterval(display.blinker);
		  var on = true;
		  display.cursorDiv.style.visibility = "";
		  if (cm.options.cursorBlinkRate > 0)
		    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden"; },
		      cm.options.cursorBlinkRate); }
		  else if (cm.options.cursorBlinkRate < 0)
		    { display.cursorDiv.style.visibility = "hidden"; }
		}
		
		function ensureFocus(cm) {
		  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
		}
		
		function delayBlurEvent(cm) {
		  cm.state.delayingBlurEvent = true;
		  setTimeout(function () { if (cm.state.delayingBlurEvent) {
		    cm.state.delayingBlurEvent = false;
		    onBlur(cm);
		  } }, 100);
		}
		
		function onFocus(cm, e) {
		  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }
		
		  if (cm.options.readOnly == "nocursor") { return }
		  if (!cm.state.focused) {
		    signal(cm, "focus", cm, e);
		    cm.state.focused = true;
		    addClass(cm.display.wrapper, "CodeMirror-focused");
		    // This test prevents this from firing when a context
		    // menu is closed (since the input reset would kill the
		    // select-all detection hack)
		    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
		      cm.display.input.reset();
		      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730
		    }
		    cm.display.input.receivedFocus();
		  }
		  restartBlink(cm);
		}
		function onBlur(cm, e) {
		  if (cm.state.delayingBlurEvent) { return }
		
		  if (cm.state.focused) {
		    signal(cm, "blur", cm, e);
		    cm.state.focused = false;
		    rmClass(cm.display.wrapper, "CodeMirror-focused");
		  }
		  clearInterval(cm.display.blinker);
		  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);
		}
		
		// Re-align line numbers and gutter marks to compensate for
		// horizontal scrolling.
		function alignHorizontally(cm) {
		  var display = cm.display, view = display.view;
		  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
		  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
		  var gutterW = display.gutters.offsetWidth, left = comp + "px";
		  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
		    if (cm.options.fixedGutter) {
		      if (view[i].gutter)
		        { view[i].gutter.style.left = left; }
		      if (view[i].gutterBackground)
		        { view[i].gutterBackground.style.left = left; }
		    }
		    var align = view[i].alignable;
		    if (align) { for (var j = 0; j < align.length; j++)
		      { align[j].style.left = left; } }
		  } }
		  if (cm.options.fixedGutter)
		    { display.gutters.style.left = (comp + gutterW) + "px"; }
		}
		
		// Used to ensure that the line number gutter is still the right
		// size for the current document size. Returns true when an update
		// is needed.
		function maybeUpdateLineNumberWidth(cm) {
		  if (!cm.options.lineNumbers) { return false }
		  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
		  if (last.length != display.lineNumChars) {
		    var test = display.measure.appendChild(elt("div", [elt("div", last)],
		                                               "CodeMirror-linenumber CodeMirror-gutter-elt"));
		    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
		    display.lineGutter.style.width = "";
		    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
		    display.lineNumWidth = display.lineNumInnerWidth + padding;
		    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
		    display.lineGutter.style.width = display.lineNumWidth + "px";
		    updateGutterSpace(cm);
		    return true
		  }
		  return false
		}
		
		// Read the actual heights of the rendered lines, and update their
		// stored heights to match.
		function updateHeightsInViewport(cm) {
		  var display = cm.display;
		  var prevBottom = display.lineDiv.offsetTop;
		  for (var i = 0; i < display.view.length; i++) {
		    var cur = display.view[i], height = (void 0);
		    if (cur.hidden) { continue }
		    if (ie && ie_version < 8) {
		      var bot = cur.node.offsetTop + cur.node.offsetHeight;
		      height = bot - prevBottom;
		      prevBottom = bot;
		    } else {
		      var box = cur.node.getBoundingClientRect();
		      height = box.bottom - box.top;
		    }
		    var diff = cur.line.height - height;
		    if (height < 2) { height = textHeight(display); }
		    if (diff > .001 || diff < -.001) {
		      updateLineHeight(cur.line, height);
		      updateWidgetHeight(cur.line);
		      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
		        { updateWidgetHeight(cur.rest[j]); } }
		    }
		  }
		}
		
		// Read and store the height of line widgets associated with the
		// given line.
		function updateWidgetHeight(line) {
		  if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i)
		    { line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight; } }
		}
		
		// Compute the lines that are visible in a given viewport (defaults
		// the the current scroll position). viewport may contain top,
		// height, and ensure (see op.scrollToPos) properties.
		function visibleLines(display, doc, viewport) {
		  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
		  top = Math.floor(top - paddingTop(display));
		  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
		
		  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
		  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
		  // forces those lines into the viewport (if possible).
		  if (viewport && viewport.ensure) {
		    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
		    if (ensureFrom < from) {
		      from = ensureFrom;
		      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
		    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
		      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
		      to = ensureTo;
		    }
		  }
		  return {from: from, to: Math.max(to, from + 1)}
		}
		
		// Sync the scrollable area and scrollbars, ensure the viewport
		// covers the visible area.
		function setScrollTop(cm, val) {
		  if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
		  cm.doc.scrollTop = val;
		  if (!gecko) { updateDisplaySimple(cm, {top: val}); }
		  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }
		  cm.display.scrollbars.setScrollTop(val);
		  if (gecko) { updateDisplaySimple(cm); }
		  startWorker(cm, 100);
		}
		// Sync scroller and scrollbar, ensure the gutter elements are
		// aligned.
		function setScrollLeft(cm, val, isScroller) {
		  if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) { return }
		  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
		  cm.doc.scrollLeft = val;
		  alignHorizontally(cm);
		  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }
		  cm.display.scrollbars.setScrollLeft(val);
		}
		
		// Since the delta values reported on mouse wheel events are
		// unstandardized between browsers and even browser versions, and
		// generally horribly unpredictable, this code starts by measuring
		// the scroll effect that the first few mouse wheel events have,
		// and, from that, detects the way it can convert deltas to pixel
		// offsets afterwards.
		//
		// The reason we want to know the amount a wheel event will scroll
		// is that it gives us a chance to update the display before the
		// actual scrolling happens, reducing flickering.
		
		var wheelSamples = 0;
		var wheelPixelsPerUnit = null;
		// Fill in a browser-detected starting value on browsers where we
		// know one. These don't have to be accurate -- the result of them
		// being wrong would just be a slight flicker on the first wheel
		// scroll (if it is large enough).
		if (ie) { wheelPixelsPerUnit = -.53; }
		else if (gecko) { wheelPixelsPerUnit = 15; }
		else if (chrome) { wheelPixelsPerUnit = -.7; }
		else if (safari) { wheelPixelsPerUnit = -1/3; }
		
		function wheelEventDelta(e) {
		  var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
		  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }
		  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }
		  else if (dy == null) { dy = e.wheelDelta; }
		  return {x: dx, y: dy}
		}
		function wheelEventPixels(e) {
		  var delta = wheelEventDelta(e);
		  delta.x *= wheelPixelsPerUnit;
		  delta.y *= wheelPixelsPerUnit;
		  return delta
		}
		
		function onScrollWheel(cm, e) {
		  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;
		
		  var display = cm.display, scroll = display.scroller;
		  // Quit if there's nothing to scroll here
		  var canScrollX = scroll.scrollWidth > scroll.clientWidth;
		  var canScrollY = scroll.scrollHeight > scroll.clientHeight;
		  if (!(dx && canScrollX || dy && canScrollY)) { return }
		
		  // Webkit browsers on OS X abort momentum scrolls when the target
		  // of the scroll event is removed from the scrollable element.
		  // This hack (see related code in patchDisplay) makes sure the
		  // element is kept around.
		  if (dy && mac && webkit) {
		    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
		      for (var i = 0; i < view.length; i++) {
		        if (view[i].node == cur) {
		          cm.display.currentWheelTarget = cur;
		          break outer
		        }
		      }
		    }
		  }
		
		  // On some browsers, horizontal scrolling will cause redraws to
		  // happen before the gutter has been realigned, causing it to
		  // wriggle around in a most unseemly way. When we have an
		  // estimated pixels/delta value, we just handle horizontal
		  // scrolling entirely here. It'll be slightly off from native, but
		  // better than glitching out.
		  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
		    if (dy && canScrollY)
		      { setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight))); }
		    setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
		    // Only prevent default scrolling if vertical scrolling is
		    // actually possible. Otherwise, it causes vertical scroll
		    // jitter on OSX trackpads when deltaX is small and deltaY
		    // is large (issue #3579)
		    if (!dy || (dy && canScrollY))
		      { e_preventDefault(e); }
		    display.wheelStartX = null; // Abort measurement, if in progress
		    return
		  }
		
		  // 'Project' the visible viewport to cover the area that is being
		  // scrolled into view (if we know enough to estimate it).
		  if (dy && wheelPixelsPerUnit != null) {
		    var pixels = dy * wheelPixelsPerUnit;
		    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
		    if (pixels < 0) { top = Math.max(0, top + pixels - 50); }
		    else { bot = Math.min(cm.doc.height, bot + pixels + 50); }
		    updateDisplaySimple(cm, {top: top, bottom: bot});
		  }
		
		  if (wheelSamples < 20) {
		    if (display.wheelStartX == null) {
		      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
		      display.wheelDX = dx; display.wheelDY = dy;
		      setTimeout(function () {
		        if (display.wheelStartX == null) { return }
		        var movedX = scroll.scrollLeft - display.wheelStartX;
		        var movedY = scroll.scrollTop - display.wheelStartY;
		        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
		          (movedX && display.wheelDX && movedX / display.wheelDX);
		        display.wheelStartX = display.wheelStartY = null;
		        if (!sample) { return }
		        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
		        ++wheelSamples;
		      }, 200);
		    } else {
		      display.wheelDX += dx; display.wheelDY += dy;
		    }
		  }
		}
		
		// SCROLLBARS
		
		// Prepare DOM reads needed to update the scrollbars. Done in one
		// shot to minimize update/measure roundtrips.
		function measureForScrollbars(cm) {
		  var d = cm.display, gutterW = d.gutters.offsetWidth;
		  var docH = Math.round(cm.doc.height + paddingVert(cm.display));
		  return {
		    clientHeight: d.scroller.clientHeight,
		    viewHeight: d.wrapper.clientHeight,
		    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
		    viewWidth: d.wrapper.clientWidth,
		    barLeft: cm.options.fixedGutter ? gutterW : 0,
		    docHeight: docH,
		    scrollHeight: docH + scrollGap(cm) + d.barHeight,
		    nativeBarWidth: d.nativeBarWidth,
		    gutterWidth: gutterW
		  }
		}
		
		var NativeScrollbars = function(place, scroll, cm) {
		  this.cm = cm;
		  var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
		  var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
		  place(vert); place(horiz);
		
		  on(vert, "scroll", function () {
		    if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }
		  });
		  on(horiz, "scroll", function () {
		    if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }
		  });
		
		  this.checkedZeroWidth = false;
		  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
		  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }
		};
		
		NativeScrollbars.prototype.update = function (measure) {
		  var needsH = measure.scrollWidth > measure.clientWidth + 1;
		  var needsV = measure.scrollHeight > measure.clientHeight + 1;
		  var sWidth = measure.nativeBarWidth;
		
		  if (needsV) {
		    this.vert.style.display = "block";
		    this.vert.style.bottom = needsH ? sWidth + "px" : "0";
		    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
		    // A bug in IE8 can cause this value to be negative, so guard it.
		    this.vert.firstChild.style.height =
		      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
		  } else {
		    this.vert.style.display = "";
		    this.vert.firstChild.style.height = "0";
		  }
		
		  if (needsH) {
		    this.horiz.style.display = "block";
		    this.horiz.style.right = needsV ? sWidth + "px" : "0";
		    this.horiz.style.left = measure.barLeft + "px";
		    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
		    this.horiz.firstChild.style.width =
		      Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
		  } else {
		    this.horiz.style.display = "";
		    this.horiz.firstChild.style.width = "0";
		  }
		
		  if (!this.checkedZeroWidth && measure.clientHeight > 0) {
		    if (sWidth == 0) { this.zeroWidthHack(); }
		    this.checkedZeroWidth = true;
		  }
		
		  return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
		};
		
		NativeScrollbars.prototype.setScrollLeft = function (pos) {
		  if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }
		  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz); }
		};
		
		NativeScrollbars.prototype.setScrollTop = function (pos) {
		  if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }
		  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert); }
		};
		
		NativeScrollbars.prototype.zeroWidthHack = function () {
		  var w = mac && !mac_geMountainLion ? "12px" : "18px";
		  this.horiz.style.height = this.vert.style.width = w;
		  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
		  this.disableHoriz = new Delayed;
		  this.disableVert = new Delayed;
		};
		
		NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay) {
		  bar.style.pointerEvents = "auto";
		  function maybeDisable() {
		    // To find out whether the scrollbar is still visible, we
		    // check whether the element under the pixel in the bottom
		    // left corner of the scrollbar box is the scrollbar box
		    // itself (when the bar is still visible) or its filler child
		    // (when the bar is hidden). If it is still visible, we keep
		    // it enabled, if it's hidden, we disable pointer events.
		    var box = bar.getBoundingClientRect();
		    var elt$$1 = document.elementFromPoint(box.left + 1, box.bottom - 1);
		    if (elt$$1 != bar) { bar.style.pointerEvents = "none"; }
		    else { delay.set(1000, maybeDisable); }
		  }
		  delay.set(1000, maybeDisable);
		};
		
		NativeScrollbars.prototype.clear = function () {
		  var parent = this.horiz.parentNode;
		  parent.removeChild(this.horiz);
		  parent.removeChild(this.vert);
		};
		
		var NullScrollbars = function () {};
		
		NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
		NullScrollbars.prototype.setScrollLeft = function () {};
		NullScrollbars.prototype.setScrollTop = function () {};
		NullScrollbars.prototype.clear = function () {};
		
		function updateScrollbars(cm, measure) {
		  if (!measure) { measure = measureForScrollbars(cm); }
		  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
		  updateScrollbarsInner(cm, measure);
		  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
		    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
		      { updateHeightsInViewport(cm); }
		    updateScrollbarsInner(cm, measureForScrollbars(cm));
		    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
		  }
		}
		
		// Re-synchronize the fake scrollbars with the actual size of the
		// content.
		function updateScrollbarsInner(cm, measure) {
		  var d = cm.display;
		  var sizes = d.scrollbars.update(measure);
		
		  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
		  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
		  d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
		
		  if (sizes.right && sizes.bottom) {
		    d.scrollbarFiller.style.display = "block";
		    d.scrollbarFiller.style.height = sizes.bottom + "px";
		    d.scrollbarFiller.style.width = sizes.right + "px";
		  } else { d.scrollbarFiller.style.display = ""; }
		  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
		    d.gutterFiller.style.display = "block";
		    d.gutterFiller.style.height = sizes.bottom + "px";
		    d.gutterFiller.style.width = measure.gutterWidth + "px";
		  } else { d.gutterFiller.style.display = ""; }
		}
		
		var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};
		
		function initScrollbars(cm) {
		  if (cm.display.scrollbars) {
		    cm.display.scrollbars.clear();
		    if (cm.display.scrollbars.addClass)
		      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
		  }
		
		  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
		    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
		    // Prevent clicks in the scrollbars from killing focus
		    on(node, "mousedown", function () {
		      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }
		    });
		    node.setAttribute("cm-not-content", "true");
		  }, function (pos, axis) {
		    if (axis == "horizontal") { setScrollLeft(cm, pos); }
		    else { setScrollTop(cm, pos); }
		  }, cm);
		  if (cm.display.scrollbars.addClass)
		    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
		}
		
		// SCROLLING THINGS INTO VIEW
		
		// If an editor sits on the top or bottom of the window, partially
		// scrolled out of view, this ensures that the cursor is visible.
		function maybeScrollWindow(cm, rect) {
		  if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }
		
		  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
		  if (rect.top + box.top < 0) { doScroll = true; }
		  else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }
		  if (doScroll != null && !phantom) {
		    var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));
		    cm.display.lineSpace.appendChild(scrollNode);
		    scrollNode.scrollIntoView(doScroll);
		    cm.display.lineSpace.removeChild(scrollNode);
		  }
		}
		
		// Scroll a given position into view (immediately), verifying that
		// it actually became visible (as line heights are accurately
		// measured, the position of something may 'drift' during drawing).
		function scrollPosIntoView(cm, pos, end, margin) {
		  if (margin == null) { margin = 0; }
		  var rect;
		  for (var limit = 0; limit < 5; limit++) {
		    var changed = false;
		    var coords = cursorCoords(cm, pos);
		    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
		    rect = {left: Math.min(coords.left, endCoords.left),
		            top: Math.min(coords.top, endCoords.top) - margin,
		            right: Math.max(coords.left, endCoords.left),
		            bottom: Math.max(coords.bottom, endCoords.bottom) + margin};
		    var scrollPos = calculateScrollPos(cm, rect);
		    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
		    if (scrollPos.scrollTop != null) {
		      setScrollTop(cm, scrollPos.scrollTop);
		      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }
		    }
		    if (scrollPos.scrollLeft != null) {
		      setScrollLeft(cm, scrollPos.scrollLeft);
		      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }
		    }
		    if (!changed) { break }
		  }
		  return rect
		}
		
		// Scroll a given set of coordinates into view (immediately).
		function scrollIntoView(cm, rect) {
		  var scrollPos = calculateScrollPos(cm, rect);
		  if (scrollPos.scrollTop != null) { setScrollTop(cm, scrollPos.scrollTop); }
		  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }
		}
		
		// Calculate a new scroll position needed to scroll the given
		// rectangle into view. Returns an object with scrollTop and
		// scrollLeft properties. When these are undefined, the
		// vertical/horizontal position does not need to be adjusted.
		function calculateScrollPos(cm, rect) {
		  var display = cm.display, snapMargin = textHeight(cm.display);
		  if (rect.top < 0) { rect.top = 0; }
		  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
		  var screen = displayHeight(cm), result = {};
		  if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }
		  var docBottom = cm.doc.height + paddingVert(display);
		  var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
		  if (rect.top < screentop) {
		    result.scrollTop = atTop ? 0 : rect.top;
		  } else if (rect.bottom > screentop + screen) {
		    var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
		    if (newTop != screentop) { result.scrollTop = newTop; }
		  }
		
		  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
		  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
		  var tooWide = rect.right - rect.left > screenw;
		  if (tooWide) { rect.right = rect.left + screenw; }
		  if (rect.left < 10)
		    { result.scrollLeft = 0; }
		  else if (rect.left < screenleft)
		    { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }
		  else if (rect.right > screenw + screenleft - 3)
		    { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }
		  return result
		}
		
		// Store a relative adjustment to the scroll position in the current
		// operation (to be applied when the operation finishes).
		function addToScrollPos(cm, left, top) {
		  if (left != null || top != null) { resolveScrollToPos(cm); }
		  if (left != null)
		    { cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left; }
		  if (top != null)
		    { cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top; }
		}
		
		// Make sure that at the end of the operation the current cursor is
		// shown.
		function ensureCursorVisible(cm) {
		  resolveScrollToPos(cm);
		  var cur = cm.getCursor(), from = cur, to = cur;
		  if (!cm.options.lineWrapping) {
		    from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
		    to = Pos(cur.line, cur.ch + 1);
		  }
		  cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin};
		}
		
		// When an operation has its scrollToPos property set, and another
		// scroll action is applied before the end of the operation, this
		// 'simulates' scrolling that position into view in a cheap way, so
		// that the effect of intermediate scroll commands is not ignored.
		function resolveScrollToPos(cm) {
		  var range$$1 = cm.curOp.scrollToPos;
		  if (range$$1) {
		    cm.curOp.scrollToPos = null;
		    var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);
		    var sPos = calculateScrollPos(cm, {
		      left: Math.min(from.left, to.left),
		      top: Math.min(from.top, to.top) - range$$1.margin,
		      right: Math.max(from.right, to.right),
		      bottom: Math.max(from.bottom, to.bottom) + range$$1.margin
		    });
		    cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
		  }
		}
		
		// Operations are used to wrap a series of changes to the editor
		// state in such a way that each change won't have to update the
		// cursor and display (which would be awkward, slow, and
		// error-prone). Instead, display updates are batched and then all
		// combined and executed at once.
		
		var nextOpId = 0;
		// Start a new operation.
		function startOperation(cm) {
		  cm.curOp = {
		    cm: cm,
		    viewChanged: false,      // Flag that indicates that lines might need to be redrawn
		    startHeight: cm.doc.height, // Used to detect need to update scrollbar
		    forceUpdate: false,      // Used to force a redraw
		    updateInput: null,       // Whether to reset the input textarea
		    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
		    changeObjs: null,        // Accumulated changes, for firing change events
		    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
		    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
		    selectionChanged: false, // Whether the selection needs to be redrawn
		    updateMaxLine: false,    // Set when the widest line needs to be determined anew
		    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
		    scrollToPos: null,       // Used to scroll to a specific position
		    focus: false,
		    id: ++nextOpId           // Unique ID
		  };
		  pushOperation(cm.curOp);
		}
		
		// Finish an operation, updating the display and signalling delayed events
		function endOperation(cm) {
		  var op = cm.curOp;
		  finishOperation(op, function (group) {
		    for (var i = 0; i < group.ops.length; i++)
		      { group.ops[i].cm.curOp = null; }
		    endOperations(group);
		  });
		}
		
		// The DOM updates done when an operation finishes are batched so
		// that the minimum number of relayouts are required.
		function endOperations(group) {
		  var ops = group.ops;
		  for (var i = 0; i < ops.length; i++) // Read DOM
		    { endOperation_R1(ops[i]); }
		  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
		    { endOperation_W1(ops[i$1]); }
		  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
		    { endOperation_R2(ops[i$2]); }
		  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
		    { endOperation_W2(ops[i$3]); }
		  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
		    { endOperation_finish(ops[i$4]); }
		}
		
		function endOperation_R1(op) {
		  var cm = op.cm, display = cm.display;
		  maybeClipScrollbars(cm);
		  if (op.updateMaxLine) { findMaxLine(cm); }
		
		  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
		    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
		                       op.scrollToPos.to.line >= display.viewTo) ||
		    display.maxLineChanged && cm.options.lineWrapping;
		  op.update = op.mustUpdate &&
		    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
		}
		
		function endOperation_W1(op) {
		  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
		}
		
		function endOperation_R2(op) {
		  var cm = op.cm, display = cm.display;
		  if (op.updatedDisplay) { updateHeightsInViewport(cm); }
		
		  op.barMeasure = measureForScrollbars(cm);
		
		  // If the max line changed since it was last measured, measure it,
		  // and ensure the document's width matches it.
		  // updateDisplay_W2 will use these properties to do the actual resizing
		  if (display.maxLineChanged && !cm.options.lineWrapping) {
		    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
		    cm.display.sizerWidth = op.adjustWidthTo;
		    op.barMeasure.scrollWidth =
		      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
		    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
		  }
		
		  if (op.updatedDisplay || op.selectionChanged)
		    { op.preparedSelection = display.input.prepareSelection(op.focus); }
		}
		
		function endOperation_W2(op) {
		  var cm = op.cm;
		
		  if (op.adjustWidthTo != null) {
		    cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
		    if (op.maxScrollLeft < cm.doc.scrollLeft)
		      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }
		    cm.display.maxLineChanged = false;
		  }
		
		  var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus());
		  if (op.preparedSelection)
		    { cm.display.input.showSelection(op.preparedSelection, takeFocus); }
		  if (op.updatedDisplay || op.startHeight != cm.doc.height)
		    { updateScrollbars(cm, op.barMeasure); }
		  if (op.updatedDisplay)
		    { setDocumentHeight(cm, op.barMeasure); }
		
		  if (op.selectionChanged) { restartBlink(cm); }
		
		  if (cm.state.focused && op.updateInput)
		    { cm.display.input.reset(op.typing); }
		  if (takeFocus) { ensureFocus(op.cm); }
		}
		
		function endOperation_finish(op) {
		  var cm = op.cm, display = cm.display, doc = cm.doc;
		
		  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }
		
		  // Abort mouse wheel delta measurement, when scrolling explicitly
		  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
		    { display.wheelStartX = display.wheelStartY = null; }
		
		  // Propagate the scroll position to the actual DOM scroller
		  if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {
		    doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
		    display.scrollbars.setScrollTop(doc.scrollTop);
		    display.scroller.scrollTop = doc.scrollTop;
		  }
		  if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {
		    doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));
		    display.scrollbars.setScrollLeft(doc.scrollLeft);
		    display.scroller.scrollLeft = doc.scrollLeft;
		    alignHorizontally(cm);
		  }
		  // If we need to scroll a specific position into view, do so.
		  if (op.scrollToPos) {
		    var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
		                                 clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
		    maybeScrollWindow(cm, rect);
		  }
		
		  // Fire events for markers that are hidden/unidden by editing or
		  // undoing
		  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
		  if (hidden) { for (var i = 0; i < hidden.length; ++i)
		    { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } } }
		  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
		    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } } }
		
		  if (display.wrapper.offsetHeight)
		    { doc.scrollTop = cm.display.scroller.scrollTop; }
		
		  // Fire change events, and delayed event handlers
		  if (op.changeObjs)
		    { signal(cm, "changes", cm, op.changeObjs); }
		  if (op.update)
		    { op.update.finish(); }
		}
		
		// Run the given function in an operation
		function runInOp(cm, f) {
		  if (cm.curOp) { return f() }
		  startOperation(cm);
		  try { return f() }
		  finally { endOperation(cm); }
		}
		// Wraps a function in an operation. Returns the wrapped function.
		function operation(cm, f) {
		  return function() {
		    if (cm.curOp) { return f.apply(cm, arguments) }
		    startOperation(cm);
		    try { return f.apply(cm, arguments) }
		    finally { endOperation(cm); }
		  }
		}
		// Used to add methods to editor and doc instances, wrapping them in
		// operations.
		function methodOp(f) {
		  return function() {
		    if (this.curOp) { return f.apply(this, arguments) }
		    startOperation(this);
		    try { return f.apply(this, arguments) }
		    finally { endOperation(this); }
		  }
		}
		function docMethodOp(f) {
		  return function() {
		    var cm = this.cm;
		    if (!cm || cm.curOp) { return f.apply(this, arguments) }
		    startOperation(cm);
		    try { return f.apply(this, arguments) }
		    finally { endOperation(cm); }
		  }
		}
		
		// Updates the display.view data structure for a given change to the
		// document. From and to are in pre-change coordinates. Lendiff is
		// the amount of lines added or subtracted by the change. This is
		// used for changes that span multiple lines, or change the way
		// lines are divided into visual lines. regLineChange (below)
		// registers single-line changes.
		function regChange(cm, from, to, lendiff) {
		  if (from == null) { from = cm.doc.first; }
		  if (to == null) { to = cm.doc.first + cm.doc.size; }
		  if (!lendiff) { lendiff = 0; }
		
		  var display = cm.display;
		  if (lendiff && to < display.viewTo &&
		      (display.updateLineNumbers == null || display.updateLineNumbers > from))
		    { display.updateLineNumbers = from; }
		
		  cm.curOp.viewChanged = true;
		
		  if (from >= display.viewTo) { // Change after
		    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
		      { resetView(cm); }
		  } else if (to <= display.viewFrom) { // Change before
		    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
		      resetView(cm);
		    } else {
		      display.viewFrom += lendiff;
		      display.viewTo += lendiff;
		    }
		  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
		    resetView(cm);
		  } else if (from <= display.viewFrom) { // Top overlap
		    var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
		    if (cut) {
		      display.view = display.view.slice(cut.index);
		      display.viewFrom = cut.lineN;
		      display.viewTo += lendiff;
		    } else {
		      resetView(cm);
		    }
		  } else if (to >= display.viewTo) { // Bottom overlap
		    var cut$1 = viewCuttingPoint(cm, from, from, -1);
		    if (cut$1) {
		      display.view = display.view.slice(0, cut$1.index);
		      display.viewTo = cut$1.lineN;
		    } else {
		      resetView(cm);
		    }
		  } else { // Gap in the middle
		    var cutTop = viewCuttingPoint(cm, from, from, -1);
		    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
		    if (cutTop && cutBot) {
		      display.view = display.view.slice(0, cutTop.index)
		        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
		        .concat(display.view.slice(cutBot.index));
		      display.viewTo += lendiff;
		    } else {
		      resetView(cm);
		    }
		  }
		
		  var ext = display.externalMeasured;
		  if (ext) {
		    if (to < ext.lineN)
		      { ext.lineN += lendiff; }
		    else if (from < ext.lineN + ext.size)
		      { display.externalMeasured = null; }
		  }
		}
		
		// Register a change to a single line. Type must be one of "text",
		// "gutter", "class", "widget"
		function regLineChange(cm, line, type) {
		  cm.curOp.viewChanged = true;
		  var display = cm.display, ext = cm.display.externalMeasured;
		  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
		    { display.externalMeasured = null; }
		
		  if (line < display.viewFrom || line >= display.viewTo) { return }
		  var lineView = display.view[findViewIndex(cm, line)];
		  if (lineView.node == null) { return }
		  var arr = lineView.changes || (lineView.changes = []);
		  if (indexOf(arr, type) == -1) { arr.push(type); }
		}
		
		// Clear the view.
		function resetView(cm) {
		  cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
		  cm.display.view = [];
		  cm.display.viewOffset = 0;
		}
		
		function viewCuttingPoint(cm, oldN, newN, dir) {
		  var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
		  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
		    { return {index: index, lineN: newN} }
		  var n = cm.display.viewFrom;
		  for (var i = 0; i < index; i++)
		    { n += view[i].size; }
		  if (n != oldN) {
		    if (dir > 0) {
		      if (index == view.length - 1) { return null }
		      diff = (n + view[index].size) - oldN;
		      index++;
		    } else {
		      diff = n - oldN;
		    }
		    oldN += diff; newN += diff;
		  }
		  while (visualLineNo(cm.doc, newN) != newN) {
		    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
		    newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
		    index += dir;
		  }
		  return {index: index, lineN: newN}
		}
		
		// Force the view to cover a given range, adding empty view element
		// or clipping off existing ones as needed.
		function adjustView(cm, from, to) {
		  var display = cm.display, view = display.view;
		  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
		    display.view = buildViewArray(cm, from, to);
		    display.viewFrom = from;
		  } else {
		    if (display.viewFrom > from)
		      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }
		    else if (display.viewFrom < from)
		      { display.view = display.view.slice(findViewIndex(cm, from)); }
		    display.viewFrom = from;
		    if (display.viewTo < to)
		      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }
		    else if (display.viewTo > to)
		      { display.view = display.view.slice(0, findViewIndex(cm, to)); }
		  }
		  display.viewTo = to;
		}
		
		// Count the number of lines in the view whose DOM representation is
		// out of date (or nonexistent).
		function countDirtyView(cm) {
		  var view = cm.display.view, dirty = 0;
		  for (var i = 0; i < view.length; i++) {
		    var lineView = view[i];
		    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }
		  }
		  return dirty
		}
		
		// HIGHLIGHT WORKER
		
		function startWorker(cm, time) {
		  if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
		    { cm.state.highlight.set(time, bind(highlightWorker, cm)); }
		}
		
		function highlightWorker(cm) {
		  var doc = cm.doc;
		  if (doc.frontier < doc.first) { doc.frontier = doc.first; }
		  if (doc.frontier >= cm.display.viewTo) { return }
		  var end = +new Date + cm.options.workTime;
		  var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
		  var changedLines = [];
		
		  doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
		    if (doc.frontier >= cm.display.viewFrom) { // Visible
		      var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;
		      var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);
		      line.styles = highlighted.styles;
		      var oldCls = line.styleClasses, newCls = highlighted.classes;
		      if (newCls) { line.styleClasses = newCls; }
		      else if (oldCls) { line.styleClasses = null; }
		      var ischange = !oldStyles || oldStyles.length != line.styles.length ||
		        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
		      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }
		      if (ischange) { changedLines.push(doc.frontier); }
		      line.stateAfter = tooLong ? state : copyState(doc.mode, state);
		    } else {
		      if (line.text.length <= cm.options.maxHighlightLength)
		        { processLine(cm, line.text, state); }
		      line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
		    }
		    ++doc.frontier;
		    if (+new Date > end) {
		      startWorker(cm, cm.options.workDelay);
		      return true
		    }
		  });
		  if (changedLines.length) { runInOp(cm, function () {
		    for (var i = 0; i < changedLines.length; i++)
		      { regLineChange(cm, changedLines[i], "text"); }
		  }); }
		}
		
		// DISPLAY DRAWING
		
		var DisplayUpdate = function(cm, viewport, force) {
		  var display = cm.display;
		
		  this.viewport = viewport;
		  // Store some values that we'll need later (but don't want to force a relayout for)
		  this.visible = visibleLines(display, cm.doc, viewport);
		  this.editorIsHidden = !display.wrapper.offsetWidth;
		  this.wrapperHeight = display.wrapper.clientHeight;
		  this.wrapperWidth = display.wrapper.clientWidth;
		  this.oldDisplayWidth = displayWidth(cm);
		  this.force = force;
		  this.dims = getDimensions(cm);
		  this.events = [];
		};
		
		DisplayUpdate.prototype.signal = function (emitter, type) {
		  if (hasHandler(emitter, type))
		    { this.events.push(arguments); }
		};
		DisplayUpdate.prototype.finish = function () {
		    var this$1 = this;
		
		  for (var i = 0; i < this.events.length; i++)
		    { signal.apply(null, this$1.events[i]); }
		};
		
		function maybeClipScrollbars(cm) {
		  var display = cm.display;
		  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
		    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
		    display.heightForcer.style.height = scrollGap(cm) + "px";
		    display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
		    display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
		    display.scrollbarsClipped = true;
		  }
		}
		
		// Does the actual updating of the line display. Bails out
		// (returning false) when there is nothing to be done and forced is
		// false.
		function updateDisplayIfNeeded(cm, update) {
		  var display = cm.display, doc = cm.doc;
		
		  if (update.editorIsHidden) {
		    resetView(cm);
		    return false
		  }
		
		  // Bail out if the visible area is already rendered and nothing changed.
		  if (!update.force &&
		      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
		      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
		      display.renderedView == display.view && countDirtyView(cm) == 0)
		    { return false }
		
		  if (maybeUpdateLineNumberWidth(cm)) {
		    resetView(cm);
		    update.dims = getDimensions(cm);
		  }
		
		  // Compute a suitable new viewport (from & to)
		  var end = doc.first + doc.size;
		  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
		  var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
		  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }
		  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }
		  if (sawCollapsedSpans) {
		    from = visualLineNo(cm.doc, from);
		    to = visualLineEndNo(cm.doc, to);
		  }
		
		  var different = from != display.viewFrom || to != display.viewTo ||
		    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
		  adjustView(cm, from, to);
		
		  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
		  // Position the mover div to align with the current scroll position
		  cm.display.mover.style.top = display.viewOffset + "px";
		
		  var toUpdate = countDirtyView(cm);
		  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
		      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
		    { return false }
		
		  // For big changes, we hide the enclosing element during the
		  // update, since that speeds up the operations on most browsers.
		  var focused = activeElt();
		  if (toUpdate > 4) { display.lineDiv.style.display = "none"; }
		  patchDisplay(cm, display.updateLineNumbers, update.dims);
		  if (toUpdate > 4) { display.lineDiv.style.display = ""; }
		  display.renderedView = display.view;
		  // There might have been a widget with a focused element that got
		  // hidden or updated, if so re-focus it.
		  if (focused && activeElt() != focused && focused.offsetHeight) { focused.focus(); }
		
		  // Prevent selection and cursors from interfering with the scroll
		  // width and height.
		  removeChildren(display.cursorDiv);
		  removeChildren(display.selectionDiv);
		  display.gutters.style.height = display.sizer.style.minHeight = 0;
		
		  if (different) {
		    display.lastWrapHeight = update.wrapperHeight;
		    display.lastWrapWidth = update.wrapperWidth;
		    startWorker(cm, 400);
		  }
		
		  display.updateLineNumbers = null;
		
		  return true
		}
		
		function postUpdateDisplay(cm, update) {
		  var viewport = update.viewport;
		
		  for (var first = true;; first = false) {
		    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
		      // Clip forced viewport to actual scrollable area.
		      if (viewport && viewport.top != null)
		        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }
		      // Updated line heights might result in the drawn area not
		      // actually covering the viewport. Keep looping until it does.
		      update.visible = visibleLines(cm.display, cm.doc, viewport);
		      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
		        { break }
		    }
		    if (!updateDisplayIfNeeded(cm, update)) { break }
		    updateHeightsInViewport(cm);
		    var barMeasure = measureForScrollbars(cm);
		    updateSelection(cm);
		    updateScrollbars(cm, barMeasure);
		    setDocumentHeight(cm, barMeasure);
		  }
		
		  update.signal(cm, "update", cm);
		  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
		    update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
		    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
		  }
		}
		
		function updateDisplaySimple(cm, viewport) {
		  var update = new DisplayUpdate(cm, viewport);
		  if (updateDisplayIfNeeded(cm, update)) {
		    updateHeightsInViewport(cm);
		    postUpdateDisplay(cm, update);
		    var barMeasure = measureForScrollbars(cm);
		    updateSelection(cm);
		    updateScrollbars(cm, barMeasure);
		    setDocumentHeight(cm, barMeasure);
		    update.finish();
		  }
		}
		
		// Sync the actual display DOM structure with display.view, removing
		// nodes for lines that are no longer in view, and creating the ones
		// that are not there yet, and updating the ones that are out of
		// date.
		function patchDisplay(cm, updateNumbersFrom, dims) {
		  var display = cm.display, lineNumbers = cm.options.lineNumbers;
		  var container = display.lineDiv, cur = container.firstChild;
		
		  function rm(node) {
		    var next = node.nextSibling;
		    // Works around a throw-scroll bug in OS X Webkit
		    if (webkit && mac && cm.display.currentWheelTarget == node)
		      { node.style.display = "none"; }
		    else
		      { node.parentNode.removeChild(node); }
		    return next
		  }
		
		  var view = display.view, lineN = display.viewFrom;
		  // Loop over the elements in the view, syncing cur (the DOM nodes
		  // in display.lineDiv) with the view as we go.
		  for (var i = 0; i < view.length; i++) {
		    var lineView = view[i];
		    if (lineView.hidden) {
		    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
		      var node = buildLineElement(cm, lineView, lineN, dims);
		      container.insertBefore(node, cur);
		    } else { // Already drawn
		      while (cur != lineView.node) { cur = rm(cur); }
		      var updateNumber = lineNumbers && updateNumbersFrom != null &&
		        updateNumbersFrom <= lineN && lineView.lineNumber;
		      if (lineView.changes) {
		        if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }
		        updateLineForChanges(cm, lineView, lineN, dims);
		      }
		      if (updateNumber) {
		        removeChildren(lineView.lineNumber);
		        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
		      }
		      cur = lineView.node.nextSibling;
		    }
		    lineN += lineView.size;
		  }
		  while (cur) { cur = rm(cur); }
		}
		
		function updateGutterSpace(cm) {
		  var width = cm.display.gutters.offsetWidth;
		  cm.display.sizer.style.marginLeft = width + "px";
		}
		
		function setDocumentHeight(cm, measure) {
		  cm.display.sizer.style.minHeight = measure.docHeight + "px";
		  cm.display.heightForcer.style.top = measure.docHeight + "px";
		  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
		}
		
		// Rebuild the gutter elements, ensure the margin to the left of the
		// code matches their width.
		function updateGutters(cm) {
		  var gutters = cm.display.gutters, specs = cm.options.gutters;
		  removeChildren(gutters);
		  var i = 0;
		  for (; i < specs.length; ++i) {
		    var gutterClass = specs[i];
		    var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
		    if (gutterClass == "CodeMirror-linenumbers") {
		      cm.display.lineGutter = gElt;
		      gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
		    }
		  }
		  gutters.style.display = i ? "" : "none";
		  updateGutterSpace(cm);
		}
		
		// Make sure the gutters options contains the element
		// "CodeMirror-linenumbers" when the lineNumbers option is true.
		function setGuttersForLineNumbers(options) {
		  var found = indexOf(options.gutters, "CodeMirror-linenumbers");
		  if (found == -1 && options.lineNumbers) {
		    options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
		  } else if (found > -1 && !options.lineNumbers) {
		    options.gutters = options.gutters.slice(0);
		    options.gutters.splice(found, 1);
		  }
		}
		
		// Selection objects are immutable. A new one is created every time
		// the selection changes. A selection is one or more non-overlapping
		// (and non-touching) ranges, sorted, and an integer that indicates
		// which one is the primary selection (the one that's scrolled into
		// view, that getCursor returns, etc).
		var Selection = function(ranges, primIndex) {
		  this.ranges = ranges;
		  this.primIndex = primIndex;
		};
		
		Selection.prototype.primary = function () { return this.ranges[this.primIndex] };
		
		Selection.prototype.equals = function (other) {
		    var this$1 = this;
		
		  if (other == this) { return true }
		  if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
		  for (var i = 0; i < this.ranges.length; i++) {
		    var here = this$1.ranges[i], there = other.ranges[i];
		    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
		  }
		  return true
		};
		
		Selection.prototype.deepCopy = function () {
		    var this$1 = this;
		
		  var out = [];
		  for (var i = 0; i < this.ranges.length; i++)
		    { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }
		  return new Selection(out, this.primIndex)
		};
		
		Selection.prototype.somethingSelected = function () {
		    var this$1 = this;
		
		  for (var i = 0; i < this.ranges.length; i++)
		    { if (!this$1.ranges[i].empty()) { return true } }
		  return false
		};
		
		Selection.prototype.contains = function (pos, end) {
		    var this$1 = this;
		
		  if (!end) { end = pos; }
		  for (var i = 0; i < this.ranges.length; i++) {
		    var range = this$1.ranges[i];
		    if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
		      { return i }
		  }
		  return -1
		};
		
		var Range = function(anchor, head) {
		  this.anchor = anchor; this.head = head;
		};
		
		Range.prototype.from = function () { return minPos(this.anchor, this.head) };
		Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
		Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };
		
		// Take an unsorted, potentially overlapping set of ranges, and
		// build a selection out of it. 'Consumes' ranges array (modifying
		// it).
		function normalizeSelection(ranges, primIndex) {
		  var prim = ranges[primIndex];
		  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });
		  primIndex = indexOf(ranges, prim);
		  for (var i = 1; i < ranges.length; i++) {
		    var cur = ranges[i], prev = ranges[i - 1];
		    if (cmp(prev.to(), cur.from()) >= 0) {
		      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
		      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
		      if (i <= primIndex) { --primIndex; }
		      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
		    }
		  }
		  return new Selection(ranges, primIndex)
		}
		
		function simpleSelection(anchor, head) {
		  return new Selection([new Range(anchor, head || anchor)], 0)
		}
		
		// Compute the position of the end of a change (its 'to' property
		// refers to the pre-change end).
		function changeEnd(change) {
		  if (!change.text) { return change.to }
		  return Pos(change.from.line + change.text.length - 1,
		             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
		}
		
		// Adjust a position to refer to the post-change position of the
		// same text, or the end of the change if the change covers it.
		function adjustForChange(pos, change) {
		  if (cmp(pos, change.from) < 0) { return pos }
		  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }
		
		  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
		  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }
		  return Pos(line, ch)
		}
		
		function computeSelAfterChange(doc, change) {
		  var out = [];
		  for (var i = 0; i < doc.sel.ranges.length; i++) {
		    var range = doc.sel.ranges[i];
		    out.push(new Range(adjustForChange(range.anchor, change),
		                       adjustForChange(range.head, change)));
		  }
		  return normalizeSelection(out, doc.sel.primIndex)
		}
		
		function offsetPos(pos, old, nw) {
		  if (pos.line == old.line)
		    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
		  else
		    { return Pos(nw.line + (pos.line - old.line), pos.ch) }
		}
		
		// Used by replaceSelections to allow moving the selection to the
		// start or around the replaced test. Hint may be "start" or "around".
		function computeReplacedSel(doc, changes, hint) {
		  var out = [];
		  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
		  for (var i = 0; i < changes.length; i++) {
		    var change = changes[i];
		    var from = offsetPos(change.from, oldPrev, newPrev);
		    var to = offsetPos(changeEnd(change), oldPrev, newPrev);
		    oldPrev = change.to;
		    newPrev = to;
		    if (hint == "around") {
		      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
		      out[i] = new Range(inv ? to : from, inv ? from : to);
		    } else {
		      out[i] = new Range(from, from);
		    }
		  }
		  return new Selection(out, doc.sel.primIndex)
		}
		
		// Used to get the editor into a consistent state again when options change.
		
		function loadMode(cm) {
		  cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
		  resetModeState(cm);
		}
		
		function resetModeState(cm) {
		  cm.doc.iter(function (line) {
		    if (line.stateAfter) { line.stateAfter = null; }
		    if (line.styles) { line.styles = null; }
		  });
		  cm.doc.frontier = cm.doc.first;
		  startWorker(cm, 100);
		  cm.state.modeGen++;
		  if (cm.curOp) { regChange(cm); }
		}
		
		// DOCUMENT DATA STRUCTURE
		
		// By default, updates that start and end at the beginning of a line
		// are treated specially, in order to make the association of line
		// widgets and marker elements with the text behave more intuitive.
		function isWholeLineUpdate(doc, change) {
		  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
		    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
		}
		
		// Perform a change on the document data structure.
		function updateDoc(doc, change, markedSpans, estimateHeight$$1) {
		  function spansFor(n) {return markedSpans ? markedSpans[n] : null}
		  function update(line, text, spans) {
		    updateLine(line, text, spans, estimateHeight$$1);
		    signalLater(line, "change", line, change);
		  }
		  function linesFor(start, end) {
		    var result = [];
		    for (var i = start; i < end; ++i)
		      { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }
		    return result
		  }
		
		  var from = change.from, to = change.to, text = change.text;
		  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
		  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
		
		  // Adjust the line structure
		  if (change.full) {
		    doc.insert(0, linesFor(0, text.length));
		    doc.remove(text.length, doc.size - text.length);
		  } else if (isWholeLineUpdate(doc, change)) {
		    // This is a whole-line replace. Treated specially to make
		    // sure line objects move the way they are supposed to.
		    var added = linesFor(0, text.length - 1);
		    update(lastLine, lastLine.text, lastSpans);
		    if (nlines) { doc.remove(from.line, nlines); }
		    if (added.length) { doc.insert(from.line, added); }
		  } else if (firstLine == lastLine) {
		    if (text.length == 1) {
		      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
		    } else {
		      var added$1 = linesFor(1, text.length - 1);
		      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));
		      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
		      doc.insert(from.line + 1, added$1);
		    }
		  } else if (text.length == 1) {
		    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
		    doc.remove(from.line + 1, nlines);
		  } else {
		    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
		    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
		    var added$2 = linesFor(1, text.length - 1);
		    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }
		    doc.insert(from.line + 1, added$2);
		  }
		
		  signalLater(doc, "change", doc, change);
		}
		
		// Call f for all linked documents.
		function linkedDocs(doc, f, sharedHistOnly) {
		  function propagate(doc, skip, sharedHist) {
		    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
		      var rel = doc.linked[i];
		      if (rel.doc == skip) { continue }
		      var shared = sharedHist && rel.sharedHist;
		      if (sharedHistOnly && !shared) { continue }
		      f(rel.doc, shared);
		      propagate(rel.doc, doc, shared);
		    } }
		  }
		  propagate(doc, null, true);
		}
		
		// Attach a document to an editor.
		function attachDoc(cm, doc) {
		  if (doc.cm) { throw new Error("This document is already in use.") }
		  cm.doc = doc;
		  doc.cm = cm;
		  estimateLineHeights(cm);
		  loadMode(cm);
		  setDirectionClass(cm);
		  if (!cm.options.lineWrapping) { findMaxLine(cm); }
		  cm.options.mode = doc.modeOption;
		  regChange(cm);
		}
		
		function setDirectionClass(cm) {
		  (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
		}
		
		function directionChanged(cm) {
		  runInOp(cm, function () {
		    setDirectionClass(cm);
		    regChange(cm);
		  });
		}
		
		function History(startGen) {
		  // Arrays of change events and selections. Doing something adds an
		  // event to done and clears undo. Undoing moves events from done
		  // to undone, redoing moves them in the other direction.
		  this.done = []; this.undone = [];
		  this.undoDepth = Infinity;
		  // Used to track when changes can be merged into a single undo
		  // event
		  this.lastModTime = this.lastSelTime = 0;
		  this.lastOp = this.lastSelOp = null;
		  this.lastOrigin = this.lastSelOrigin = null;
		  // Used by the isClean() method
		  this.generation = this.maxGeneration = startGen || 1;
		}
		
		// Create a history change event from an updateDoc-style change
		// object.
		function historyChangeFromChange(doc, change) {
		  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
		  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
		  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);
		  return histChange
		}
		
		// Pop all selection events off the end of a history array. Stop at
		// a change event.
		function clearSelectionEvents(array) {
		  while (array.length) {
		    var last = lst(array);
		    if (last.ranges) { array.pop(); }
		    else { break }
		  }
		}
		
		// Find the top change event in the history. Pop off selection
		// events that are in the way.
		function lastChangeEvent(hist, force) {
		  if (force) {
		    clearSelectionEvents(hist.done);
		    return lst(hist.done)
		  } else if (hist.done.length && !lst(hist.done).ranges) {
		    return lst(hist.done)
		  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
		    hist.done.pop();
		    return lst(hist.done)
		  }
		}
		
		// Register a change in the history. Merges changes that are within
		// a single operation, or are close together with an origin that
		// allows merging (starting with "+") into a single event.
		function addChangeToHistory(doc, change, selAfter, opId) {
		  var hist = doc.history;
		  hist.undone.length = 0;
		  var time = +new Date, cur;
		  var last;
		
		  if ((hist.lastOp == opId ||
		       hist.lastOrigin == change.origin && change.origin &&
		       ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||
		        change.origin.charAt(0) == "*")) &&
		      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
		    // Merge this change into the last event
		    last = lst(cur.changes);
		    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
		      // Optimized case for simple insertion -- don't want to add
		      // new changesets for every character typed
		      last.to = changeEnd(change);
		    } else {
		      // Add new sub-event
		      cur.changes.push(historyChangeFromChange(doc, change));
		    }
		  } else {
		    // Can not be merged, start a new event.
		    var before = lst(hist.done);
		    if (!before || !before.ranges)
		      { pushSelectionToHistory(doc.sel, hist.done); }
		    cur = {changes: [historyChangeFromChange(doc, change)],
		           generation: hist.generation};
		    hist.done.push(cur);
		    while (hist.done.length > hist.undoDepth) {
		      hist.done.shift();
		      if (!hist.done[0].ranges) { hist.done.shift(); }
		    }
		  }
		  hist.done.push(selAfter);
		  hist.generation = ++hist.maxGeneration;
		  hist.lastModTime = hist.lastSelTime = time;
		  hist.lastOp = hist.lastSelOp = opId;
		  hist.lastOrigin = hist.lastSelOrigin = change.origin;
		
		  if (!last) { signal(doc, "historyAdded"); }
		}
		
		function selectionEventCanBeMerged(doc, origin, prev, sel) {
		  var ch = origin.charAt(0);
		  return ch == "*" ||
		    ch == "+" &&
		    prev.ranges.length == sel.ranges.length &&
		    prev.somethingSelected() == sel.somethingSelected() &&
		    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
		}
		
		// Called whenever the selection changes, sets the new selection as
		// the pending selection in the history, and pushes the old pending
		// selection into the 'done' array when it was significantly
		// different (in number of selected ranges, emptiness, or time).
		function addSelectionToHistory(doc, sel, opId, options) {
		  var hist = doc.history, origin = options && options.origin;
		
		  // A new event is started when the previous origin does not match
		  // the current, or the origins don't allow matching. Origins
		  // starting with * are always merged, those starting with + are
		  // merged when similar and close together in time.
		  if (opId == hist.lastSelOp ||
		      (origin && hist.lastSelOrigin == origin &&
		       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
		        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
		    { hist.done[hist.done.length - 1] = sel; }
		  else
		    { pushSelectionToHistory(sel, hist.done); }
		
		  hist.lastSelTime = +new Date;
		  hist.lastSelOrigin = origin;
		  hist.lastSelOp = opId;
		  if (options && options.clearRedo !== false)
		    { clearSelectionEvents(hist.undone); }
		}
		
		function pushSelectionToHistory(sel, dest) {
		  var top = lst(dest);
		  if (!(top && top.ranges && top.equals(sel)))
		    { dest.push(sel); }
		}
		
		// Used to store marked span information in the history.
		function attachLocalSpans(doc, change, from, to) {
		  var existing = change["spans_" + doc.id], n = 0;
		  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
		    if (line.markedSpans)
		      { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }
		    ++n;
		  });
		}
		
		// When un/re-doing restores text containing marked spans, those
		// that have been explicitly cleared should not be restored.
		function removeClearedSpans(spans) {
		  if (!spans) { return null }
		  var out;
		  for (var i = 0; i < spans.length; ++i) {
		    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }
		    else if (out) { out.push(spans[i]); }
		  }
		  return !out ? spans : out.length ? out : null
		}
		
		// Retrieve and filter the old marked spans stored in a change event.
		function getOldSpans(doc, change) {
		  var found = change["spans_" + doc.id];
		  if (!found) { return null }
		  var nw = [];
		  for (var i = 0; i < change.text.length; ++i)
		    { nw.push(removeClearedSpans(found[i])); }
		  return nw
		}
		
		// Used for un/re-doing changes from the history. Combines the
		// result of computing the existing spans with the set of spans that
		// existed in the history (so that deleting around a span and then
		// undoing brings back the span).
		function mergeOldSpans(doc, change) {
		  var old = getOldSpans(doc, change);
		  var stretched = stretchSpansOverChange(doc, change);
		  if (!old) { return stretched }
		  if (!stretched) { return old }
		
		  for (var i = 0; i < old.length; ++i) {
		    var oldCur = old[i], stretchCur = stretched[i];
		    if (oldCur && stretchCur) {
		      spans: for (var j = 0; j < stretchCur.length; ++j) {
		        var span = stretchCur[j];
		        for (var k = 0; k < oldCur.length; ++k)
		          { if (oldCur[k].marker == span.marker) { continue spans } }
		        oldCur.push(span);
		      }
		    } else if (stretchCur) {
		      old[i] = stretchCur;
		    }
		  }
		  return old
		}
		
		// Used both to provide a JSON-safe object in .getHistory, and, when
		// detaching a document, to split the history in two
		function copyHistoryArray(events, newGroup, instantiateSel) {
		  var copy = [];
		  for (var i = 0; i < events.length; ++i) {
		    var event = events[i];
		    if (event.ranges) {
		      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
		      continue
		    }
		    var changes = event.changes, newChanges = [];
		    copy.push({changes: newChanges});
		    for (var j = 0; j < changes.length; ++j) {
		      var change = changes[j], m = (void 0);
		      newChanges.push({from: change.from, to: change.to, text: change.text});
		      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
		        if (indexOf(newGroup, Number(m[1])) > -1) {
		          lst(newChanges)[prop] = change[prop];
		          delete change[prop];
		        }
		      } } }
		    }
		  }
		  return copy
		}
		
		// The 'scroll' parameter given to many of these indicated whether
		// the new cursor position should be scrolled into view after
		// modifying the selection.
		
		// If shift is held or the extend flag is set, extends a range to
		// include a given position (and optionally a second position).
		// Otherwise, simply returns the range between the given positions.
		// Used for cursor motion and such.
		function extendRange(doc, range, head, other) {
		  if (doc.cm && doc.cm.display.shift || doc.extend) {
		    var anchor = range.anchor;
		    if (other) {
		      var posBefore = cmp(head, anchor) < 0;
		      if (posBefore != (cmp(other, anchor) < 0)) {
		        anchor = head;
		        head = other;
		      } else if (posBefore != (cmp(head, other) < 0)) {
		        head = other;
		      }
		    }
		    return new Range(anchor, head)
		  } else {
		    return new Range(other || head, head)
		  }
		}
		
		// Extend the primary selection range, discard the rest.
		function extendSelection(doc, head, other, options) {
		  setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
		}
		
		// Extend all selections (pos is an array of selections with length
		// equal the number of selections)
		function extendSelections(doc, heads, options) {
		  var out = [];
		  for (var i = 0; i < doc.sel.ranges.length; i++)
		    { out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null); }
		  var newSel = normalizeSelection(out, doc.sel.primIndex);
		  setSelection(doc, newSel, options);
		}
		
		// Updates a single range in the selection.
		function replaceOneSelection(doc, i, range, options) {
		  var ranges = doc.sel.ranges.slice(0);
		  ranges[i] = range;
		  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
		}
		
		// Reset the selection to a single range.
		function setSimpleSelection(doc, anchor, head, options) {
		  setSelection(doc, simpleSelection(anchor, head), options);
		}
		
		// Give beforeSelectionChange handlers a change to influence a
		// selection update.
		function filterSelectionChange(doc, sel, options) {
		  var obj = {
		    ranges: sel.ranges,
		    update: function(ranges) {
		      var this$1 = this;
		
		      this.ranges = [];
		      for (var i = 0; i < ranges.length; i++)
		        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
		                                   clipPos(doc, ranges[i].head)); }
		    },
		    origin: options && options.origin
		  };
		  signal(doc, "beforeSelectionChange", doc, obj);
		  if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }
		  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }
		  else { return sel }
		}
		
		function setSelectionReplaceHistory(doc, sel, options) {
		  var done = doc.history.done, last = lst(done);
		  if (last && last.ranges) {
		    done[done.length - 1] = sel;
		    setSelectionNoUndo(doc, sel, options);
		  } else {
		    setSelection(doc, sel, options);
		  }
		}
		
		// Set a new selection.
		function setSelection(doc, sel, options) {
		  setSelectionNoUndo(doc, sel, options);
		  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
		}
		
		function setSelectionNoUndo(doc, sel, options) {
		  if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
		    { sel = filterSelectionChange(doc, sel, options); }
		
		  var bias = options && options.bias ||
		    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
		  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));
		
		  if (!(options && options.scroll === false) && doc.cm)
		    { ensureCursorVisible(doc.cm); }
		}
		
		function setSelectionInner(doc, sel) {
		  if (sel.equals(doc.sel)) { return }
		
		  doc.sel = sel;
		
		  if (doc.cm) {
		    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
		    signalCursorActivity(doc.cm);
		  }
		  signalLater(doc, "cursorActivity", doc);
		}
		
		// Verify that the selection does not partially select any atomic
		// marked ranges.
		function reCheckSelection(doc) {
		  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
		}
		
		// Return a selection that does not partially select any atomic
		// ranges.
		function skipAtomicInSelection(doc, sel, bias, mayClear) {
		  var out;
		  for (var i = 0; i < sel.ranges.length; i++) {
		    var range = sel.ranges[i];
		    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
		    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
		    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
		    if (out || newAnchor != range.anchor || newHead != range.head) {
		      if (!out) { out = sel.ranges.slice(0, i); }
		      out[i] = new Range(newAnchor, newHead);
		    }
		  }
		  return out ? normalizeSelection(out, sel.primIndex) : sel
		}
		
		function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
		  var line = getLine(doc, pos.line);
		  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
		    var sp = line.markedSpans[i], m = sp.marker;
		    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
		        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
		      if (mayClear) {
		        signal(m, "beforeCursorEnter");
		        if (m.explicitlyCleared) {
		          if (!line.markedSpans) { break }
		          else {--i; continue}
		        }
		      }
		      if (!m.atomic) { continue }
		
		      if (oldPos) {
		        var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);
		        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)
		          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }
		        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
		          { return skipAtomicInner(doc, near, pos, dir, mayClear) }
		      }
		
		      var far = m.find(dir < 0 ? -1 : 1);
		      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)
		        { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }
		      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
		    }
		  } }
		  return pos
		}
		
		// Ensure a given position is not inside an atomic range.
		function skipAtomic(doc, pos, oldPos, bias, mayClear) {
		  var dir = bias || 1;
		  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
		      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
		      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
		      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
		  if (!found) {
		    doc.cantEdit = true;
		    return Pos(doc.first, 0)
		  }
		  return found
		}
		
		function movePos(doc, pos, dir, line) {
		  if (dir < 0 && pos.ch == 0) {
		    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
		    else { return null }
		  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
		    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
		    else { return null }
		  } else {
		    return new Pos(pos.line, pos.ch + dir)
		  }
		}
		
		function selectAll(cm) {
		  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
		}
		
		// UPDATING
		
		// Allow "beforeChange" event handlers to influence a change
		function filterChange(doc, change, update) {
		  var obj = {
		    canceled: false,
		    from: change.from,
		    to: change.to,
		    text: change.text,
		    origin: change.origin,
		    cancel: function () { return obj.canceled = true; }
		  };
		  if (update) { obj.update = function (from, to, text, origin) {
		    if (from) { obj.from = clipPos(doc, from); }
		    if (to) { obj.to = clipPos(doc, to); }
		    if (text) { obj.text = text; }
		    if (origin !== undefined) { obj.origin = origin; }
		  }; }
		  signal(doc, "beforeChange", doc, obj);
		  if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }
		
		  if (obj.canceled) { return null }
		  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
		}
		
		// Apply a change to a document, and add it to the document's
		// history, and propagating it to all linked documents.
		function makeChange(doc, change, ignoreReadOnly) {
		  if (doc.cm) {
		    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
		    if (doc.cm.state.suppressEdits) { return }
		  }
		
		  if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
		    change = filterChange(doc, change, true);
		    if (!change) { return }
		  }
		
		  // Possibly split or suppress the update based on the presence
		  // of read-only spans in its range.
		  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
		  if (split) {
		    for (var i = split.length - 1; i >= 0; --i)
		      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text}); }
		  } else {
		    makeChangeInner(doc, change);
		  }
		}
		
		function makeChangeInner(doc, change) {
		  if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
		  var selAfter = computeSelAfterChange(doc, change);
		  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
		
		  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
		  var rebased = [];
		
		  linkedDocs(doc, function (doc, sharedHist) {
		    if (!sharedHist && indexOf(rebased, doc.history) == -1) {
		      rebaseHist(doc.history, change);
		      rebased.push(doc.history);
		    }
		    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
		  });
		}
		
		// Revert a change stored in a document's history.
		function makeChangeFromHistory(doc, type, allowSelectionOnly) {
		  if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) { return }
		
		  var hist = doc.history, event, selAfter = doc.sel;
		  var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;
		
		  // Verify that there is a useable event (so that ctrl-z won't
		  // needlessly clear selection events)
		  var i = 0;
		  for (; i < source.length; i++) {
		    event = source[i];
		    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
		      { break }
		  }
		  if (i == source.length) { return }
		  hist.lastOrigin = hist.lastSelOrigin = null;
		
		  for (;;) {
		    event = source.pop();
		    if (event.ranges) {
		      pushSelectionToHistory(event, dest);
		      if (allowSelectionOnly && !event.equals(doc.sel)) {
		        setSelection(doc, event, {clearRedo: false});
		        return
		      }
		      selAfter = event;
		    }
		    else { break }
		  }
		
		  // Build up a reverse change object to add to the opposite history
		  // stack (redo when undoing, and vice versa).
		  var antiChanges = [];
		  pushSelectionToHistory(selAfter, dest);
		  dest.push({changes: antiChanges, generation: hist.generation});
		  hist.generation = event.generation || ++hist.maxGeneration;
		
		  var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");
		
		  var loop = function ( i ) {
		    var change = event.changes[i];
		    change.origin = type;
		    if (filter && !filterChange(doc, change, false)) {
		      source.length = 0;
		      return {}
		    }
		
		    antiChanges.push(historyChangeFromChange(doc, change));
		
		    var after = i ? computeSelAfterChange(doc, change) : lst(source);
		    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
		    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }
		    var rebased = [];
		
		    // Propagate to the linked documents
		    linkedDocs(doc, function (doc, sharedHist) {
		      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
		        rebaseHist(doc.history, change);
		        rebased.push(doc.history);
		      }
		      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
		    });
		  };
		
		  for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
		    var returned = loop( i$1 );
		
		    if ( returned ) return returned.v;
		  }
		}
		
		// Sub-views need their line numbers shifted when text is added
		// above or below them in the parent document.
		function shiftDoc(doc, distance) {
		  if (distance == 0) { return }
		  doc.first += distance;
		  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
		    Pos(range.anchor.line + distance, range.anchor.ch),
		    Pos(range.head.line + distance, range.head.ch)
		  ); }), doc.sel.primIndex);
		  if (doc.cm) {
		    regChange(doc.cm, doc.first, doc.first - distance, distance);
		    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
		      { regLineChange(doc.cm, l, "gutter"); }
		  }
		}
		
		// More lower-level change function, handling only a single document
		// (not linked ones).
		function makeChangeSingleDoc(doc, change, selAfter, spans) {
		  if (doc.cm && !doc.cm.curOp)
		    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }
		
		  if (change.to.line < doc.first) {
		    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
		    return
		  }
		  if (change.from.line > doc.lastLine()) { return }
		
		  // Clip the change to the size of this doc
		  if (change.from.line < doc.first) {
		    var shift = change.text.length - 1 - (doc.first - change.from.line);
		    shiftDoc(doc, shift);
		    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
		              text: [lst(change.text)], origin: change.origin};
		  }
		  var last = doc.lastLine();
		  if (change.to.line > last) {
		    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
		              text: [change.text[0]], origin: change.origin};
		  }
		
		  change.removed = getBetween(doc, change.from, change.to);
		
		  if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }
		  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }
		  else { updateDoc(doc, change, spans); }
		  setSelectionNoUndo(doc, selAfter, sel_dontScroll);
		}
		
		// Handle the interaction of a change to a document with the editor
		// that this document is part of.
		function makeChangeSingleDocInEditor(cm, change, spans) {
		  var doc = cm.doc, display = cm.display, from = change.from, to = change.to;
		
		  var recomputeMaxLength = false, checkWidthStart = from.line;
		  if (!cm.options.lineWrapping) {
		    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
		    doc.iter(checkWidthStart, to.line + 1, function (line) {
		      if (line == display.maxLine) {
		        recomputeMaxLength = true;
		        return true
		      }
		    });
		  }
		
		  if (doc.sel.contains(change.from, change.to) > -1)
		    { signalCursorActivity(cm); }
		
		  updateDoc(doc, change, spans, estimateHeight(cm));
		
		  if (!cm.options.lineWrapping) {
		    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
		      var len = lineLength(line);
		      if (len > display.maxLineLength) {
		        display.maxLine = line;
		        display.maxLineLength = len;
		        display.maxLineChanged = true;
		        recomputeMaxLength = false;
		      }
		    });
		    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }
		  }
		
		  // Adjust frontier, schedule worker
		  doc.frontier = Math.min(doc.frontier, from.line);
		  startWorker(cm, 400);
		
		  var lendiff = change.text.length - (to.line - from.line) - 1;
		  // Remember that these lines changed, for updating the display
		  if (change.full)
		    { regChange(cm); }
		  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
		    { regLineChange(cm, from.line, "text"); }
		  else
		    { regChange(cm, from.line, to.line + 1, lendiff); }
		
		  var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
		  if (changeHandler || changesHandler) {
		    var obj = {
		      from: from, to: to,
		      text: change.text,
		      removed: change.removed,
		      origin: change.origin
		    };
		    if (changeHandler) { signalLater(cm, "change", cm, obj); }
		    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }
		  }
		  cm.display.selForContextMenu = null;
		}
		
		function replaceRange(doc, code, from, to, origin) {
		  if (!to) { to = from; }
		  if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }
		  if (typeof code == "string") { code = doc.splitLines(code); }
		  makeChange(doc, {from: from, to: to, text: code, origin: origin});
		}
		
		// Rebasing/resetting history to deal with externally-sourced changes
		
		function rebaseHistSelSingle(pos, from, to, diff) {
		  if (to < pos.line) {
		    pos.line += diff;
		  } else if (from < pos.line) {
		    pos.line = from;
		    pos.ch = 0;
		  }
		}
		
		// Tries to rebase an array of history events given a change in the
		// document. If the change touches the same lines as the event, the
		// event, and everything 'behind' it, is discarded. If the change is
		// before the event, the event's positions are updated. Uses a
		// copy-on-write scheme for the positions, to avoid having to
		// reallocate them all on every rebase, but also avoid problems with
		// shared position objects being unsafely updated.
		function rebaseHistArray(array, from, to, diff) {
		  for (var i = 0; i < array.length; ++i) {
		    var sub = array[i], ok = true;
		    if (sub.ranges) {
		      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
		      for (var j = 0; j < sub.ranges.length; j++) {
		        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
		        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
		      }
		      continue
		    }
		    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
		      var cur = sub.changes[j$1];
		      if (to < cur.from.line) {
		        cur.from = Pos(cur.from.line + diff, cur.from.ch);
		        cur.to = Pos(cur.to.line + diff, cur.to.ch);
		      } else if (from <= cur.to.line) {
		        ok = false;
		        break
		      }
		    }
		    if (!ok) {
		      array.splice(0, i + 1);
		      i = 0;
		    }
		  }
		}
		
		function rebaseHist(hist, change) {
		  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
		  rebaseHistArray(hist.done, from, to, diff);
		  rebaseHistArray(hist.undone, from, to, diff);
		}
		
		// Utility for applying a change to a line by handle or number,
		// returning the number and optionally registering the line as
		// changed.
		function changeLine(doc, handle, changeType, op) {
		  var no = handle, line = handle;
		  if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }
		  else { no = lineNo(handle); }
		  if (no == null) { return null }
		  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }
		  return line
		}
		
		// The document is represented as a BTree consisting of leaves, with
		// chunk of lines in them, and branches, with up to ten leaves or
		// other branch nodes below them. The top node is always a branch
		// node, and is the document object itself (meaning it has
		// additional methods and properties).
		//
		// All nodes have parent links. The tree is used both to go from
		// line numbers to line objects, and to go from objects to numbers.
		// It also indexes by height, and is used to convert between height
		// and line object, and to find the total height of the document.
		//
		// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html
		
		var LeafChunk = function(lines) {
		  var this$1 = this;
		
		  this.lines = lines;
		  this.parent = null;
		  var height = 0;
		  for (var i = 0; i < lines.length; ++i) {
		    lines[i].parent = this$1;
		    height += lines[i].height;
		  }
		  this.height = height;
		};
		
		LeafChunk.prototype.chunkSize = function () { return this.lines.length };
		
		// Remove the n lines at offset 'at'.
		LeafChunk.prototype.removeInner = function (at, n) {
		    var this$1 = this;
		
		  for (var i = at, e = at + n; i < e; ++i) {
		    var line = this$1.lines[i];
		    this$1.height -= line.height;
		    cleanUpLine(line);
		    signalLater(line, "delete");
		  }
		  this.lines.splice(at, n);
		};
		
		// Helper used to collapse a small branch into a single leaf.
		LeafChunk.prototype.collapse = function (lines) {
		  lines.push.apply(lines, this.lines);
		};
		
		// Insert the given array of lines at offset 'at', count them as
		// having the given height.
		LeafChunk.prototype.insertInner = function (at, lines, height) {
		    var this$1 = this;
		
		  this.height += height;
		  this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
		  for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }
		};
		
		// Used to iterate over a part of the tree.
		LeafChunk.prototype.iterN = function (at, n, op) {
		    var this$1 = this;
		
		  for (var e = at + n; at < e; ++at)
		    { if (op(this$1.lines[at])) { return true } }
		};
		
		var BranchChunk = function(children) {
		  var this$1 = this;
		
		  this.children = children;
		  var size = 0, height = 0;
		  for (var i = 0; i < children.length; ++i) {
		    var ch = children[i];
		    size += ch.chunkSize(); height += ch.height;
		    ch.parent = this$1;
		  }
		  this.size = size;
		  this.height = height;
		  this.parent = null;
		};
		
		BranchChunk.prototype.chunkSize = function () { return this.size };
		
		BranchChunk.prototype.removeInner = function (at, n) {
		    var this$1 = this;
		
		  this.size -= n;
		  for (var i = 0; i < this.children.length; ++i) {
		    var child = this$1.children[i], sz = child.chunkSize();
		    if (at < sz) {
		      var rm = Math.min(n, sz - at), oldHeight = child.height;
		      child.removeInner(at, rm);
		      this$1.height -= oldHeight - child.height;
		      if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }
		      if ((n -= rm) == 0) { break }
		      at = 0;
		    } else { at -= sz; }
		  }
		  // If the result is smaller than 25 lines, ensure that it is a
		  // single leaf node.
		  if (this.size - n < 25 &&
		      (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
		    var lines = [];
		    this.collapse(lines);
		    this.children = [new LeafChunk(lines)];
		    this.children[0].parent = this;
		  }
		};
		
		BranchChunk.prototype.collapse = function (lines) {
		    var this$1 = this;
		
		  for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }
		};
		
		BranchChunk.prototype.insertInner = function (at, lines, height) {
		    var this$1 = this;
		
		  this.size += lines.length;
		  this.height += height;
		  for (var i = 0; i < this.children.length; ++i) {
		    var child = this$1.children[i], sz = child.chunkSize();
		    if (at <= sz) {
		      child.insertInner(at, lines, height);
		      if (child.lines && child.lines.length > 50) {
		        // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
		        // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
		        var remaining = child.lines.length % 25 + 25;
		        for (var pos = remaining; pos < child.lines.length;) {
		          var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
		          child.height -= leaf.height;
		          this$1.children.splice(++i, 0, leaf);
		          leaf.parent = this$1;
		        }
		        child.lines = child.lines.slice(0, remaining);
		        this$1.maybeSpill();
		      }
		      break
		    }
		    at -= sz;
		  }
		};
		
		// When a node has grown, check whether it should be split.
		BranchChunk.prototype.maybeSpill = function () {
		  if (this.children.length <= 10) { return }
		  var me = this;
		  do {
		    var spilled = me.children.splice(me.children.length - 5, 5);
		    var sibling = new BranchChunk(spilled);
		    if (!me.parent) { // Become the parent node
		      var copy = new BranchChunk(me.children);
		      copy.parent = me;
		      me.children = [copy, sibling];
		      me = copy;
		   } else {
		      me.size -= sibling.size;
		      me.height -= sibling.height;
		      var myIndex = indexOf(me.parent.children, me);
		      me.parent.children.splice(myIndex + 1, 0, sibling);
		    }
		    sibling.parent = me.parent;
		  } while (me.children.length > 10)
		  me.parent.maybeSpill();
		};
		
		BranchChunk.prototype.iterN = function (at, n, op) {
		    var this$1 = this;
		
		  for (var i = 0; i < this.children.length; ++i) {
		    var child = this$1.children[i], sz = child.chunkSize();
		    if (at < sz) {
		      var used = Math.min(n, sz - at);
		      if (child.iterN(at, used, op)) { return true }
		      if ((n -= used) == 0) { break }
		      at = 0;
		    } else { at -= sz; }
		  }
		};
		
		// Line widgets are block elements displayed above or below a line.
		
		var LineWidget = function(doc, node, options) {
		  var this$1 = this;
		
		  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
		    { this$1[opt] = options[opt]; } } }
		  this.doc = doc;
		  this.node = node;
		};
		
		LineWidget.prototype.clear = function () {
		    var this$1 = this;
		
		  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
		  if (no == null || !ws) { return }
		  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }
		  if (!ws.length) { line.widgets = null; }
		  var height = widgetHeight(this);
		  updateLineHeight(line, Math.max(0, line.height - height));
		  if (cm) {
		    runInOp(cm, function () {
		      adjustScrollWhenAboveVisible(cm, line, -height);
		      regLineChange(cm, no, "widget");
		    });
		    signalLater(cm, "lineWidgetCleared", cm, this, no);
		  }
		};
		
		LineWidget.prototype.changed = function () {
		    var this$1 = this;
		
		  var oldH = this.height, cm = this.doc.cm, line = this.line;
		  this.height = null;
		  var diff = widgetHeight(this) - oldH;
		  if (!diff) { return }
		  updateLineHeight(line, line.height + diff);
		  if (cm) {
		    runInOp(cm, function () {
		      cm.curOp.forceUpdate = true;
		      adjustScrollWhenAboveVisible(cm, line, diff);
		      signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
		    });
		  }
		};
		eventMixin(LineWidget);
		
		function adjustScrollWhenAboveVisible(cm, line, diff) {
		  if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
		    { addToScrollPos(cm, null, diff); }
		}
		
		function addLineWidget(doc, handle, node, options) {
		  var widget = new LineWidget(doc, node, options);
		  var cm = doc.cm;
		  if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }
		  changeLine(doc, handle, "widget", function (line) {
		    var widgets = line.widgets || (line.widgets = []);
		    if (widget.insertAt == null) { widgets.push(widget); }
		    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }
		    widget.line = line;
		    if (cm && !lineIsHidden(doc, line)) {
		      var aboveVisible = heightAtLine(line) < doc.scrollTop;
		      updateLineHeight(line, line.height + widgetHeight(widget));
		      if (aboveVisible) { addToScrollPos(cm, null, widget.height); }
		      cm.curOp.forceUpdate = true;
		    }
		    return true
		  });
		  signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
		  return widget
		}
		
		// TEXTMARKERS
		
		// Created with markText and setBookmark methods. A TextMarker is a
		// handle that can be used to clear or find a marked position in the
		// document. Line objects hold arrays (markedSpans) containing
		// {from, to, marker} object pointing to such marker objects, and
		// indicating that such a marker is present on that line. Multiple
		// lines may point to the same marker when it spans across lines.
		// The spans will have null for their from/to properties when the
		// marker continues beyond the start/end of the line. Markers have
		// links back to the lines they currently touch.
		
		// Collapsed markers have unique ids, in order to be able to order
		// them, which is needed for uniquely determining an outer marker
		// when they overlap (they may nest, but not partially overlap).
		var nextMarkerId = 0;
		
		var TextMarker = function(doc, type) {
		  this.lines = [];
		  this.type = type;
		  this.doc = doc;
		  this.id = ++nextMarkerId;
		};
		
		// Clear the marker.
		TextMarker.prototype.clear = function () {
		    var this$1 = this;
		
		  if (this.explicitlyCleared) { return }
		  var cm = this.doc.cm, withOp = cm && !cm.curOp;
		  if (withOp) { startOperation(cm); }
		  if (hasHandler(this, "clear")) {
		    var found = this.find();
		    if (found) { signalLater(this, "clear", found.from, found.to); }
		  }
		  var min = null, max = null;
		  for (var i = 0; i < this.lines.length; ++i) {
		    var line = this$1.lines[i];
		    var span = getMarkedSpanFor(line.markedSpans, this$1);
		    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), "text"); }
		    else if (cm) {
		      if (span.to != null) { max = lineNo(line); }
		      if (span.from != null) { min = lineNo(line); }
		    }
		    line.markedSpans = removeMarkedSpan(line.markedSpans, span);
		    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)
		      { updateLineHeight(line, textHeight(cm.display)); }
		  }
		  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
		    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);
		    if (len > cm.display.maxLineLength) {
		      cm.display.maxLine = visual;
		      cm.display.maxLineLength = len;
		      cm.display.maxLineChanged = true;
		    }
		  } }
		
		  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }
		  this.lines.length = 0;
		  this.explicitlyCleared = true;
		  if (this.atomic && this.doc.cantEdit) {
		    this.doc.cantEdit = false;
		    if (cm) { reCheckSelection(cm.doc); }
		  }
		  if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }
		  if (withOp) { endOperation(cm); }
		  if (this.parent) { this.parent.clear(); }
		};
		
		// Find the position of the marker in the document. Returns a {from,
		// to} object by default. Side can be passed to get a specific side
		// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
		// Pos objects returned contain a line object, rather than a line
		// number (used to prevent looking up the same line twice).
		TextMarker.prototype.find = function (side, lineObj) {
		    var this$1 = this;
		
		  if (side == null && this.type == "bookmark") { side = 1; }
		  var from, to;
		  for (var i = 0; i < this.lines.length; ++i) {
		    var line = this$1.lines[i];
		    var span = getMarkedSpanFor(line.markedSpans, this$1);
		    if (span.from != null) {
		      from = Pos(lineObj ? line : lineNo(line), span.from);
		      if (side == -1) { return from }
		    }
		    if (span.to != null) {
		      to = Pos(lineObj ? line : lineNo(line), span.to);
		      if (side == 1) { return to }
		    }
		  }
		  return from && {from: from, to: to}
		};
		
		// Signals that the marker's widget changed, and surrounding layout
		// should be recomputed.
		TextMarker.prototype.changed = function () {
		    var this$1 = this;
		
		  var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
		  if (!pos || !cm) { return }
		  runInOp(cm, function () {
		    var line = pos.line, lineN = lineNo(pos.line);
		    var view = findViewForLine(cm, lineN);
		    if (view) {
		      clearLineMeasurementCacheFor(view);
		      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
		    }
		    cm.curOp.updateMaxLine = true;
		    if (!lineIsHidden(widget.doc, line) && widget.height != null) {
		      var oldHeight = widget.height;
		      widget.height = null;
		      var dHeight = widgetHeight(widget) - oldHeight;
		      if (dHeight)
		        { updateLineHeight(line, line.height + dHeight); }
		    }
		    signalLater(cm, "markerChanged", cm, this$1);
		  });
		};
		
		TextMarker.prototype.attachLine = function (line) {
		  if (!this.lines.length && this.doc.cm) {
		    var op = this.doc.cm.curOp;
		    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
		      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }
		  }
		  this.lines.push(line);
		};
		
		TextMarker.prototype.detachLine = function (line) {
		  this.lines.splice(indexOf(this.lines, line), 1);
		  if (!this.lines.length && this.doc.cm) {
		    var op = this.doc.cm.curOp;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
		  }
		};
		eventMixin(TextMarker);
		
		// Create a marker, wire it up to the right lines, and
		function markText(doc, from, to, options, type) {
		  // Shared markers (across linked documents) are handled separately
		  // (markTextShared will call out to this again, once per
		  // document).
		  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
		  // Ensure we are in an operation.
		  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }
		
		  var marker = new TextMarker(doc, type), diff = cmp(from, to);
		  if (options) { copyObj(options, marker, false); }
		  // Don't connect empty markers unless clearWhenEmpty is false
		  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
		    { return marker }
		  if (marker.replacedWith) {
		    // Showing up as a widget implies collapsed (widget replaces text)
		    marker.collapsed = true;
		    marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
		    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }
		    if (options.insertLeft) { marker.widgetNode.insertLeft = true; }
		  }
		  if (marker.collapsed) {
		    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
		        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
		      { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
		    seeCollapsedSpans();
		  }
		
		  if (marker.addToHistory)
		    { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN); }
		
		  var curLine = from.line, cm = doc.cm, updateMaxLine;
		  doc.iter(curLine, to.line + 1, function (line) {
		    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
		      { updateMaxLine = true; }
		    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }
		    addMarkedSpan(line, new MarkedSpan(marker,
		                                       curLine == from.line ? from.ch : null,
		                                       curLine == to.line ? to.ch : null));
		    ++curLine;
		  });
		  // lineIsHidden depends on the presence of the spans, so needs a second pass
		  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
		    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }
		  }); }
		
		  if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }
		
		  if (marker.readOnly) {
		    seeReadOnlySpans();
		    if (doc.history.done.length || doc.history.undone.length)
		      { doc.clearHistory(); }
		  }
		  if (marker.collapsed) {
		    marker.id = ++nextMarkerId;
		    marker.atomic = true;
		  }
		  if (cm) {
		    // Sync editor state
		    if (updateMaxLine) { cm.curOp.updateMaxLine = true; }
		    if (marker.collapsed)
		      { regChange(cm, from.line, to.line + 1); }
		    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
		      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }
		    if (marker.atomic) { reCheckSelection(cm.doc); }
		    signalLater(cm, "markerAdded", cm, marker);
		  }
		  return marker
		}
		
		// SHARED TEXTMARKERS
		
		// A shared marker spans multiple linked documents. It is
		// implemented as a meta-marker-object controlling multiple normal
		// markers.
		var SharedTextMarker = function(markers, primary) {
		  var this$1 = this;
		
		  this.markers = markers;
		  this.primary = primary;
		  for (var i = 0; i < markers.length; ++i)
		    { markers[i].parent = this$1; }
		};
		
		SharedTextMarker.prototype.clear = function () {
		    var this$1 = this;
		
		  if (this.explicitlyCleared) { return }
		  this.explicitlyCleared = true;
		  for (var i = 0; i < this.markers.length; ++i)
		    { this$1.markers[i].clear(); }
		  signalLater(this, "clear");
		};
		
		SharedTextMarker.prototype.find = function (side, lineObj) {
		  return this.primary.find(side, lineObj)
		};
		eventMixin(SharedTextMarker);
		
		function markTextShared(doc, from, to, options, type) {
		  options = copyObj(options);
		  options.shared = false;
		  var markers = [markText(doc, from, to, options, type)], primary = markers[0];
		  var widget = options.widgetNode;
		  linkedDocs(doc, function (doc) {
		    if (widget) { options.widgetNode = widget.cloneNode(true); }
		    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
		    for (var i = 0; i < doc.linked.length; ++i)
		      { if (doc.linked[i].isParent) { return } }
		    primary = lst(markers);
		  });
		  return new SharedTextMarker(markers, primary)
		}
		
		function findSharedMarkers(doc) {
		  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
		}
		
		function copySharedMarkers(doc, markers) {
		  for (var i = 0; i < markers.length; i++) {
		    var marker = markers[i], pos = marker.find();
		    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
		    if (cmp(mFrom, mTo)) {
		      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
		      marker.markers.push(subMark);
		      subMark.parent = marker;
		    }
		  }
		}
		
		function detachSharedMarkers(markers) {
		  var loop = function ( i ) {
		    var marker = markers[i], linked = [marker.primary.doc];
		    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });
		    for (var j = 0; j < marker.markers.length; j++) {
		      var subMarker = marker.markers[j];
		      if (indexOf(linked, subMarker.doc) == -1) {
		        subMarker.parent = null;
		        marker.markers.splice(j--, 1);
		      }
		    }
		  };
		
		  for (var i = 0; i < markers.length; i++) loop( i );
		}
		
		var nextDocId = 0;
		var Doc = function(text, mode, firstLine, lineSep, direction) {
		  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
		  if (firstLine == null) { firstLine = 0; }
		
		  BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
		  this.first = firstLine;
		  this.scrollTop = this.scrollLeft = 0;
		  this.cantEdit = false;
		  this.cleanGeneration = 1;
		  this.frontier = firstLine;
		  var start = Pos(firstLine, 0);
		  this.sel = simpleSelection(start);
		  this.history = new History(null);
		  this.id = ++nextDocId;
		  this.modeOption = mode;
		  this.lineSep = lineSep;
		  this.direction = (direction == "rtl") ? "rtl" : "ltr";
		  this.extend = false;
		
		  if (typeof text == "string") { text = this.splitLines(text); }
		  updateDoc(this, {from: start, to: start, text: text});
		  setSelection(this, simpleSelection(start), sel_dontScroll);
		};
		
		Doc.prototype = createObj(BranchChunk.prototype, {
		  constructor: Doc,
		  // Iterate over the document. Supports two forms -- with only one
		  // argument, it calls that for each line in the document. With
		  // three, it iterates over the range given by the first two (with
		  // the second being non-inclusive).
		  iter: function(from, to, op) {
		    if (op) { this.iterN(from - this.first, to - from, op); }
		    else { this.iterN(this.first, this.first + this.size, from); }
		  },
		
		  // Non-public interface for adding and removing lines.
		  insert: function(at, lines) {
		    var height = 0;
		    for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }
		    this.insertInner(at - this.first, lines, height);
		  },
		  remove: function(at, n) { this.removeInner(at - this.first, n); },
		
		  // From here, the methods are part of the public interface. Most
		  // are also available from CodeMirror (editor) instances.
		
		  getValue: function(lineSep) {
		    var lines = getLines(this, this.first, this.first + this.size);
		    if (lineSep === false) { return lines }
		    return lines.join(lineSep || this.lineSeparator())
		  },
		  setValue: docMethodOp(function(code) {
		    var top = Pos(this.first, 0), last = this.first + this.size - 1;
		    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
		                      text: this.splitLines(code), origin: "setValue", full: true}, true);
		    setSelection(this, simpleSelection(top));
		  }),
		  replaceRange: function(code, from, to, origin) {
		    from = clipPos(this, from);
		    to = to ? clipPos(this, to) : from;
		    replaceRange(this, code, from, to, origin);
		  },
		  getRange: function(from, to, lineSep) {
		    var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
		    if (lineSep === false) { return lines }
		    return lines.join(lineSep || this.lineSeparator())
		  },
		
		  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},
		
		  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
		  getLineNumber: function(line) {return lineNo(line)},
		
		  getLineHandleVisualStart: function(line) {
		    if (typeof line == "number") { line = getLine(this, line); }
		    return visualLine(line)
		  },
		
		  lineCount: function() {return this.size},
		  firstLine: function() {return this.first},
		  lastLine: function() {return this.first + this.size - 1},
		
		  clipPos: function(pos) {return clipPos(this, pos)},
		
		  getCursor: function(start) {
		    var range$$1 = this.sel.primary(), pos;
		    if (start == null || start == "head") { pos = range$$1.head; }
		    else if (start == "anchor") { pos = range$$1.anchor; }
		    else if (start == "end" || start == "to" || start === false) { pos = range$$1.to(); }
		    else { pos = range$$1.from(); }
		    return pos
		  },
		  listSelections: function() { return this.sel.ranges },
		  somethingSelected: function() {return this.sel.somethingSelected()},
		
		  setCursor: docMethodOp(function(line, ch, options) {
		    setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
		  }),
		  setSelection: docMethodOp(function(anchor, head, options) {
		    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
		  }),
		  extendSelection: docMethodOp(function(head, other, options) {
		    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
		  }),
		  extendSelections: docMethodOp(function(heads, options) {
		    extendSelections(this, clipPosArray(this, heads), options);
		  }),
		  extendSelectionsBy: docMethodOp(function(f, options) {
		    var heads = map(this.sel.ranges, f);
		    extendSelections(this, clipPosArray(this, heads), options);
		  }),
		  setSelections: docMethodOp(function(ranges, primary, options) {
		    var this$1 = this;
		
		    if (!ranges.length) { return }
		    var out = [];
		    for (var i = 0; i < ranges.length; i++)
		      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),
		                         clipPos(this$1, ranges[i].head)); }
		    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }
		    setSelection(this, normalizeSelection(out, primary), options);
		  }),
		  addSelection: docMethodOp(function(anchor, head, options) {
		    var ranges = this.sel.ranges.slice(0);
		    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
		    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
		  }),
		
		  getSelection: function(lineSep) {
		    var this$1 = this;
		
		    var ranges = this.sel.ranges, lines;
		    for (var i = 0; i < ranges.length; i++) {
		      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
		      lines = lines ? lines.concat(sel) : sel;
		    }
		    if (lineSep === false) { return lines }
		    else { return lines.join(lineSep || this.lineSeparator()) }
		  },
		  getSelections: function(lineSep) {
		    var this$1 = this;
		
		    var parts = [], ranges = this.sel.ranges;
		    for (var i = 0; i < ranges.length; i++) {
		      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
		      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }
		      parts[i] = sel;
		    }
		    return parts
		  },
		  replaceSelection: function(code, collapse, origin) {
		    var dup = [];
		    for (var i = 0; i < this.sel.ranges.length; i++)
		      { dup[i] = code; }
		    this.replaceSelections(dup, collapse, origin || "+input");
		  },
		  replaceSelections: docMethodOp(function(code, collapse, origin) {
		    var this$1 = this;
		
		    var changes = [], sel = this.sel;
		    for (var i = 0; i < sel.ranges.length; i++) {
		      var range$$1 = sel.ranges[i];
		      changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};
		    }
		    var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
		    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
		      { makeChange(this$1, changes[i$1]); }
		    if (newSel) { setSelectionReplaceHistory(this, newSel); }
		    else if (this.cm) { ensureCursorVisible(this.cm); }
		  }),
		  undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
		  redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
		  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
		  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),
		
		  setExtending: function(val) {this.extend = val;},
		  getExtending: function() {return this.extend},
		
		  historySize: function() {
		    var hist = this.history, done = 0, undone = 0;
		    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }
		    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }
		    return {undo: done, redo: undone}
		  },
		  clearHistory: function() {this.history = new History(this.history.maxGeneration);},
		
		  markClean: function() {
		    this.cleanGeneration = this.changeGeneration(true);
		  },
		  changeGeneration: function(forceSplit) {
		    if (forceSplit)
		      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }
		    return this.history.generation
		  },
		  isClean: function (gen) {
		    return this.history.generation == (gen || this.cleanGeneration)
		  },
		
		  getHistory: function() {
		    return {done: copyHistoryArray(this.history.done),
		            undone: copyHistoryArray(this.history.undone)}
		  },
		  setHistory: function(histData) {
		    var hist = this.history = new History(this.history.maxGeneration);
		    hist.done = copyHistoryArray(histData.done.slice(0), null, true);
		    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
		  },
		
		  setGutterMarker: docMethodOp(function(line, gutterID, value) {
		    return changeLine(this, line, "gutter", function (line) {
		      var markers = line.gutterMarkers || (line.gutterMarkers = {});
		      markers[gutterID] = value;
		      if (!value && isEmpty(markers)) { line.gutterMarkers = null; }
		      return true
		    })
		  }),
		
		  clearGutter: docMethodOp(function(gutterID) {
		    var this$1 = this;
		
		    this.iter(function (line) {
		      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
		        changeLine(this$1, line, "gutter", function () {
		          line.gutterMarkers[gutterID] = null;
		          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }
		          return true
		        });
		      }
		    });
		  }),
		
		  lineInfo: function(line) {
		    var n;
		    if (typeof line == "number") {
		      if (!isLine(this, line)) { return null }
		      n = line;
		      line = getLine(this, line);
		      if (!line) { return null }
		    } else {
		      n = lineNo(line);
		      if (n == null) { return null }
		    }
		    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
		            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
		            widgets: line.widgets}
		  },
		
		  addLineClass: docMethodOp(function(handle, where, cls) {
		    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
		      var prop = where == "text" ? "textClass"
		               : where == "background" ? "bgClass"
		               : where == "gutter" ? "gutterClass" : "wrapClass";
		      if (!line[prop]) { line[prop] = cls; }
		      else if (classTest(cls).test(line[prop])) { return false }
		      else { line[prop] += " " + cls; }
		      return true
		    })
		  }),
		  removeLineClass: docMethodOp(function(handle, where, cls) {
		    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
		      var prop = where == "text" ? "textClass"
		               : where == "background" ? "bgClass"
		               : where == "gutter" ? "gutterClass" : "wrapClass";
		      var cur = line[prop];
		      if (!cur) { return false }
		      else if (cls == null) { line[prop] = null; }
		      else {
		        var found = cur.match(classTest(cls));
		        if (!found) { return false }
		        var end = found.index + found[0].length;
		        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
		      }
		      return true
		    })
		  }),
		
		  addLineWidget: docMethodOp(function(handle, node, options) {
		    return addLineWidget(this, handle, node, options)
		  }),
		  removeLineWidget: function(widget) { widget.clear(); },
		
		  markText: function(from, to, options) {
		    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
		  },
		  setBookmark: function(pos, options) {
		    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
		                    insertLeft: options && options.insertLeft,
		                    clearWhenEmpty: false, shared: options && options.shared,
		                    handleMouseEvents: options && options.handleMouseEvents};
		    pos = clipPos(this, pos);
		    return markText(this, pos, pos, realOpts, "bookmark")
		  },
		  findMarksAt: function(pos) {
		    pos = clipPos(this, pos);
		    var markers = [], spans = getLine(this, pos.line).markedSpans;
		    if (spans) { for (var i = 0; i < spans.length; ++i) {
		      var span = spans[i];
		      if ((span.from == null || span.from <= pos.ch) &&
		          (span.to == null || span.to >= pos.ch))
		        { markers.push(span.marker.parent || span.marker); }
		    } }
		    return markers
		  },
		  findMarks: function(from, to, filter) {
		    from = clipPos(this, from); to = clipPos(this, to);
		    var found = [], lineNo$$1 = from.line;
		    this.iter(from.line, to.line + 1, function (line) {
		      var spans = line.markedSpans;
		      if (spans) { for (var i = 0; i < spans.length; i++) {
		        var span = spans[i];
		        if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||
		              span.from == null && lineNo$$1 != from.line ||
		              span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&
		            (!filter || filter(span.marker)))
		          { found.push(span.marker.parent || span.marker); }
		      } }
		      ++lineNo$$1;
		    });
		    return found
		  },
		  getAllMarks: function() {
		    var markers = [];
		    this.iter(function (line) {
		      var sps = line.markedSpans;
		      if (sps) { for (var i = 0; i < sps.length; ++i)
		        { if (sps[i].from != null) { markers.push(sps[i].marker); } } }
		    });
		    return markers
		  },
		
		  posFromIndex: function(off) {
		    var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;
		    this.iter(function (line) {
		      var sz = line.text.length + sepSize;
		      if (sz > off) { ch = off; return true }
		      off -= sz;
		      ++lineNo$$1;
		    });
		    return clipPos(this, Pos(lineNo$$1, ch))
		  },
		  indexFromPos: function (coords) {
		    coords = clipPos(this, coords);
		    var index = coords.ch;
		    if (coords.line < this.first || coords.ch < 0) { return 0 }
		    var sepSize = this.lineSeparator().length;
		    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
		      index += line.text.length + sepSize;
		    });
		    return index
		  },
		
		  copy: function(copyHistory) {
		    var doc = new Doc(getLines(this, this.first, this.first + this.size),
		                      this.modeOption, this.first, this.lineSep, this.direction);
		    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
		    doc.sel = this.sel;
		    doc.extend = false;
		    if (copyHistory) {
		      doc.history.undoDepth = this.history.undoDepth;
		      doc.setHistory(this.getHistory());
		    }
		    return doc
		  },
		
		  linkedDoc: function(options) {
		    if (!options) { options = {}; }
		    var from = this.first, to = this.first + this.size;
		    if (options.from != null && options.from > from) { from = options.from; }
		    if (options.to != null && options.to < to) { to = options.to; }
		    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
		    if (options.sharedHist) { copy.history = this.history
		    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
		    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
		    copySharedMarkers(copy, findSharedMarkers(this));
		    return copy
		  },
		  unlinkDoc: function(other) {
		    var this$1 = this;
		
		    if (other instanceof CodeMirror$1) { other = other.doc; }
		    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
		      var link = this$1.linked[i];
		      if (link.doc != other) { continue }
		      this$1.linked.splice(i, 1);
		      other.unlinkDoc(this$1);
		      detachSharedMarkers(findSharedMarkers(this$1));
		      break
		    } }
		    // If the histories were shared, split them again
		    if (other.history == this.history) {
		      var splitIds = [other.id];
		      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);
		      other.history = new History(null);
		      other.history.done = copyHistoryArray(this.history.done, splitIds);
		      other.history.undone = copyHistoryArray(this.history.undone, splitIds);
		    }
		  },
		  iterLinkedDocs: function(f) {linkedDocs(this, f);},
		
		  getMode: function() {return this.mode},
		  getEditor: function() {return this.cm},
		
		  splitLines: function(str) {
		    if (this.lineSep) { return str.split(this.lineSep) }
		    return splitLinesAuto(str)
		  },
		  lineSeparator: function() { return this.lineSep || "\n" },
		
		  setDirection: docMethodOp(function (dir) {
		    if (dir != "rtl") { dir = "ltr"; }
		    if (dir == this.direction) { return }
		    this.direction = dir;
		    this.iter(function (line) { return line.order = null; });
		    if (this.cm) { directionChanged(this.cm); }
		  })
		});
		
		// Public alias.
		Doc.prototype.eachLine = Doc.prototype.iter;
		
		// Kludge to work around strange IE behavior where it'll sometimes
		// re-fire a series of drag-related events right after the drop (#1551)
		var lastDrop = 0;
		
		function onDrop(e) {
		  var cm = this;
		  clearDragCursor(cm);
		  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
		    { return }
		  e_preventDefault(e);
		  if (ie) { lastDrop = +new Date; }
		  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
		  if (!pos || cm.isReadOnly()) { return }
		  // Might be a file drop, in which case we simply extract the text
		  // and insert it.
		  if (files && files.length && window.FileReader && window.File) {
		    var n = files.length, text = Array(n), read = 0;
		    var loadFile = function (file, i) {
		      if (cm.options.allowDropFileTypes &&
		          indexOf(cm.options.allowDropFileTypes, file.type) == -1)
		        { return }
		
		      var reader = new FileReader;
		      reader.onload = operation(cm, function () {
		        var content = reader.result;
		        if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) { content = ""; }
		        text[i] = content;
		        if (++read == n) {
		          pos = clipPos(cm.doc, pos);
		          var change = {from: pos, to: pos,
		                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
		                        origin: "paste"};
		          makeChange(cm.doc, change);
		          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
		        }
		      });
		      reader.readAsText(file);
		    };
		    for (var i = 0; i < n; ++i) { loadFile(files[i], i); }
		  } else { // Normal drop
		    // Don't do a replace if the drop happened inside of the selected text.
		    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
		      cm.state.draggingText(e);
		      // Ensure the editor is re-focused
		      setTimeout(function () { return cm.display.input.focus(); }, 20);
		      return
		    }
		    try {
		      var text$1 = e.dataTransfer.getData("Text");
		      if (text$1) {
		        var selected;
		        if (cm.state.draggingText && !cm.state.draggingText.copy)
		          { selected = cm.listSelections(); }
		        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
		        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
		          { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); } }
		        cm.replaceSelection(text$1, "around", "paste");
		        cm.display.input.focus();
		      }
		    }
		    catch(e){}
		  }
		}
		
		function onDragStart(cm, e) {
		  if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
		  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }
		
		  e.dataTransfer.setData("Text", cm.getSelection());
		  e.dataTransfer.effectAllowed = "copyMove";
		
		  // Use dummy image instead of default browsers image.
		  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
		  if (e.dataTransfer.setDragImage && !safari) {
		    var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
		    img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
		    if (presto) {
		      img.width = img.height = 1;
		      cm.display.wrapper.appendChild(img);
		      // Force a relayout, or Opera won't use our image for some obscure reason
		      img._top = img.offsetTop;
		    }
		    e.dataTransfer.setDragImage(img, 0, 0);
		    if (presto) { img.parentNode.removeChild(img); }
		  }
		}
		
		function onDragOver(cm, e) {
		  var pos = posFromMouse(cm, e);
		  if (!pos) { return }
		  var frag = document.createDocumentFragment();
		  drawSelectionCursor(cm, pos, frag);
		  if (!cm.display.dragCursor) {
		    cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
		    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
		  }
		  removeChildrenAndAdd(cm.display.dragCursor, frag);
		}
		
		function clearDragCursor(cm) {
		  if (cm.display.dragCursor) {
		    cm.display.lineSpace.removeChild(cm.display.dragCursor);
		    cm.display.dragCursor = null;
		  }
		}
		
		// These must be handled carefully, because naively registering a
		// handler for each editor will cause the editors to never be
		// garbage collected.
		
		function forEachCodeMirror(f) {
		  if (!document.body.getElementsByClassName) { return }
		  var byClass = document.body.getElementsByClassName("CodeMirror");
		  for (var i = 0; i < byClass.length; i++) {
		    var cm = byClass[i].CodeMirror;
		    if (cm) { f(cm); }
		  }
		}
		
		var globalsRegistered = false;
		function ensureGlobalHandlers() {
		  if (globalsRegistered) { return }
		  registerGlobalHandlers();
		  globalsRegistered = true;
		}
		function registerGlobalHandlers() {
		  // When the window resizes, we need to refresh active editors.
		  var resizeTimer;
		  on(window, "resize", function () {
		    if (resizeTimer == null) { resizeTimer = setTimeout(function () {
		      resizeTimer = null;
		      forEachCodeMirror(onResize);
		    }, 100); }
		  });
		  // When the window loses focus, we want to show the editor as blurred
		  on(window, "blur", function () { return forEachCodeMirror(onBlur); });
		}
		// Called when the window resizes
		function onResize(cm) {
		  var d = cm.display;
		  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
		    { return }
		  // Might be a text scaling operation, clear size caches.
		  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
		  d.scrollbarsClipped = false;
		  cm.setSize();
		}
		
		var keyNames = {
		  3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
		  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
		  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
		  46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
		  106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 127: "Delete",
		  173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
		  221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
		  63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
		};
		
		// Number keys
		for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }
		// Alphabetic keys
		for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }
		// Function keys
		for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }
		
		var keyMap = {};
		
		keyMap.basic = {
		  "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
		  "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
		  "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
		  "Tab": "defaultTab", "Shift-Tab": "indentAuto",
		  "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
		  "Esc": "singleSelection"
		};
		// Note that the save and find-related commands aren't defined by
		// default. User code or addons can define them. Unknown commands
		// are simply ignored.
		keyMap.pcDefault = {
		  "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
		  "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
		  "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
		  "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
		  "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
		  "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
		  "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
		  fallthrough: "basic"
		};
		// Very basic readline/emacs-style bindings, which are standard on Mac.
		keyMap.emacsy = {
		  "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
		  "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
		  "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
		  "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
		  "Ctrl-O": "openLine"
		};
		keyMap.macDefault = {
		  "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
		  "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
		  "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
		  "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
		  "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
		  "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
		  "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
		  fallthrough: ["basic", "emacsy"]
		};
		keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
		
		// KEYMAP DISPATCH
		
		function normalizeKeyName(name) {
		  var parts = name.split(/-(?!$)/);
		  name = parts[parts.length - 1];
		  var alt, ctrl, shift, cmd;
		  for (var i = 0; i < parts.length - 1; i++) {
		    var mod = parts[i];
		    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }
		    else if (/^a(lt)?$/i.test(mod)) { alt = true; }
		    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
		    else if (/^s(hift)?$/i.test(mod)) { shift = true; }
		    else { throw new Error("Unrecognized modifier name: " + mod) }
		  }
		  if (alt) { name = "Alt-" + name; }
		  if (ctrl) { name = "Ctrl-" + name; }
		  if (cmd) { name = "Cmd-" + name; }
		  if (shift) { name = "Shift-" + name; }
		  return name
		}
		
		// This is a kludge to keep keymaps mostly working as raw objects
		// (backwards compatibility) while at the same time support features
		// like normalization and multi-stroke key bindings. It compiles a
		// new normalized keymap, and then updates the old object to reflect
		// this.
		function normalizeKeyMap(keymap) {
		  var copy = {};
		  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
		    var value = keymap[keyname];
		    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
		    if (value == "...") { delete keymap[keyname]; continue }
		
		    var keys = map(keyname.split(" "), normalizeKeyName);
		    for (var i = 0; i < keys.length; i++) {
		      var val = (void 0), name = (void 0);
		      if (i == keys.length - 1) {
		        name = keys.join(" ");
		        val = value;
		      } else {
		        name = keys.slice(0, i + 1).join(" ");
		        val = "...";
		      }
		      var prev = copy[name];
		      if (!prev) { copy[name] = val; }
		      else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
		    }
		    delete keymap[keyname];
		  } }
		  for (var prop in copy) { keymap[prop] = copy[prop]; }
		  return keymap
		}
		
		function lookupKey(key, map$$1, handle, context) {
		  map$$1 = getKeyMap(map$$1);
		  var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];
		  if (found === false) { return "nothing" }
		  if (found === "...") { return "multi" }
		  if (found != null && handle(found)) { return "handled" }
		
		  if (map$$1.fallthrough) {
		    if (Object.prototype.toString.call(map$$1.fallthrough) != "[object Array]")
		      { return lookupKey(key, map$$1.fallthrough, handle, context) }
		    for (var i = 0; i < map$$1.fallthrough.length; i++) {
		      var result = lookupKey(key, map$$1.fallthrough[i], handle, context);
		      if (result) { return result }
		    }
		  }
		}
		
		// Modifier key presses don't count as 'real' key presses for the
		// purpose of keymap fallthrough.
		function isModifierKey(value) {
		  var name = typeof value == "string" ? value : keyNames[value.keyCode];
		  return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
		}
		
		// Look up the name of a key as indicated by an event object.
		function keyName(event, noShift) {
		  if (presto && event.keyCode == 34 && event["char"]) { return false }
		  var base = keyNames[event.keyCode], name = base;
		  if (name == null || event.altGraphKey) { return false }
		  if (event.altKey && base != "Alt") { name = "Alt-" + name; }
		  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }
		  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") { name = "Cmd-" + name; }
		  if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }
		  return name
		}
		
		function getKeyMap(val) {
		  return typeof val == "string" ? keyMap[val] : val
		}
		
		// Helper for deleting text near the selection(s), used to implement
		// backspace, delete, and similar functionality.
		function deleteNearSelection(cm, compute) {
		  var ranges = cm.doc.sel.ranges, kill = [];
		  // Build up a set of ranges to kill first, merging overlapping
		  // ranges.
		  for (var i = 0; i < ranges.length; i++) {
		    var toKill = compute(ranges[i]);
		    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
		      var replaced = kill.pop();
		      if (cmp(replaced.from, toKill.from) < 0) {
		        toKill.from = replaced.from;
		        break
		      }
		    }
		    kill.push(toKill);
		  }
		  // Next, remove those actual ranges.
		  runInOp(cm, function () {
		    for (var i = kill.length - 1; i >= 0; i--)
		      { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }
		    ensureCursorVisible(cm);
		  });
		}
		
		// Commands are parameter-less actions that can be performed on an
		// editor, mostly used for keybindings.
		var commands = {
		  selectAll: selectAll,
		  singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
		  killLine: function (cm) { return deleteNearSelection(cm, function (range) {
		    if (range.empty()) {
		      var len = getLine(cm.doc, range.head.line).text.length;
		      if (range.head.ch == len && range.head.line < cm.lastLine())
		        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
		      else
		        { return {from: range.head, to: Pos(range.head.line, len)} }
		    } else {
		      return {from: range.from(), to: range.to()}
		    }
		  }); },
		  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
		    from: Pos(range.from().line, 0),
		    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
		  }); }); },
		  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
		    from: Pos(range.from().line, 0), to: range.from()
		  }); }); },
		  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
		    var top = cm.charCoords(range.head, "div").top + 5;
		    var leftPos = cm.coordsChar({left: 0, top: top}, "div");
		    return {from: leftPos, to: range.from()}
		  }); },
		  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
		    var top = cm.charCoords(range.head, "div").top + 5;
		    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
		    return {from: range.from(), to: rightPos }
		  }); },
		  undo: function (cm) { return cm.undo(); },
		  redo: function (cm) { return cm.redo(); },
		  undoSelection: function (cm) { return cm.undoSelection(); },
		  redoSelection: function (cm) { return cm.redoSelection(); },
		  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
		  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
		  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
		    {origin: "+move", bias: 1}
		  ); },
		  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
		    {origin: "+move", bias: 1}
		  ); },
		  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
		    {origin: "+move", bias: -1}
		  ); },
		  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
		    var top = cm.charCoords(range.head, "div").top + 5;
		    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
		  }, sel_move); },
		  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
		    var top = cm.charCoords(range.head, "div").top + 5;
		    return cm.coordsChar({left: 0, top: top}, "div")
		  }, sel_move); },
		  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
		    var top = cm.charCoords(range.head, "div").top + 5;
		    var pos = cm.coordsChar({left: 0, top: top}, "div");
		    if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
		    return pos
		  }, sel_move); },
		  goLineUp: function (cm) { return cm.moveV(-1, "line"); },
		  goLineDown: function (cm) { return cm.moveV(1, "line"); },
		  goPageUp: function (cm) { return cm.moveV(-1, "page"); },
		  goPageDown: function (cm) { return cm.moveV(1, "page"); },
		  goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
		  goCharRight: function (cm) { return cm.moveH(1, "char"); },
		  goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
		  goColumnRight: function (cm) { return cm.moveH(1, "column"); },
		  goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
		  goGroupRight: function (cm) { return cm.moveH(1, "group"); },
		  goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
		  goWordRight: function (cm) { return cm.moveH(1, "word"); },
		  delCharBefore: function (cm) { return cm.deleteH(-1, "char"); },
		  delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
		  delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
		  delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
		  delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
		  delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
		  indentAuto: function (cm) { return cm.indentSelection("smart"); },
		  indentMore: function (cm) { return cm.indentSelection("add"); },
		  indentLess: function (cm) { return cm.indentSelection("subtract"); },
		  insertTab: function (cm) { return cm.replaceSelection("\t"); },
		  insertSoftTab: function (cm) {
		    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
		    for (var i = 0; i < ranges.length; i++) {
		      var pos = ranges[i].from();
		      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
		      spaces.push(spaceStr(tabSize - col % tabSize));
		    }
		    cm.replaceSelections(spaces);
		  },
		  defaultTab: function (cm) {
		    if (cm.somethingSelected()) { cm.indentSelection("add"); }
		    else { cm.execCommand("insertTab"); }
		  },
		  // Swap the two chars left and right of each selection's head.
		  // Move cursor behind the two swapped characters afterwards.
		  //
		  // Doesn't consider line feeds a character.
		  // Doesn't scan more than one line above to find a character.
		  // Doesn't do anything on an empty line.
		  // Doesn't do anything with non-empty selections.
		  transposeChars: function (cm) { return runInOp(cm, function () {
		    var ranges = cm.listSelections(), newSel = [];
		    for (var i = 0; i < ranges.length; i++) {
		      if (!ranges[i].empty()) { continue }
		      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
		      if (line) {
		        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }
		        if (cur.ch > 0) {
		          cur = new Pos(cur.line, cur.ch + 1);
		          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
		                          Pos(cur.line, cur.ch - 2), cur, "+transpose");
		        } else if (cur.line > cm.doc.first) {
		          var prev = getLine(cm.doc, cur.line - 1).text;
		          if (prev) {
		            cur = new Pos(cur.line, 1);
		            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
		                            prev.charAt(prev.length - 1),
		                            Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
		          }
		        }
		      }
		      newSel.push(new Range(cur, cur));
		    }
		    cm.setSelections(newSel);
		  }); },
		  newlineAndIndent: function (cm) { return runInOp(cm, function () {
		    var sels = cm.listSelections();
		    for (var i = sels.length - 1; i >= 0; i--)
		      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }
		    sels = cm.listSelections();
		    for (var i$1 = 0; i$1 < sels.length; i$1++)
		      { cm.indentLine(sels[i$1].from().line, null, true); }
		    ensureCursorVisible(cm);
		  }); },
		  openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
		  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
		};
		
		
		function lineStart(cm, lineN) {
		  var line = getLine(cm.doc, lineN);
		  var visual = visualLine(line);
		  if (visual != line) { lineN = lineNo(visual); }
		  return endOfLine(true, cm, visual, lineN, 1)
		}
		function lineEnd(cm, lineN) {
		  var line = getLine(cm.doc, lineN);
		  var visual = visualLineEnd(line);
		  if (visual != line) { lineN = lineNo(visual); }
		  return endOfLine(true, cm, line, lineN, -1)
		}
		function lineStartSmart(cm, pos) {
		  var start = lineStart(cm, pos.line);
		  var line = getLine(cm.doc, start.line);
		  var order = getOrder(line, cm.doc.direction);
		  if (!order || order[0].level == 0) {
		    var firstNonWS = Math.max(0, line.text.search(/\S/));
		    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
		    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
		  }
		  return start
		}
		
		// Run a handler that was bound to a key.
		function doHandleBinding(cm, bound, dropShift) {
		  if (typeof bound == "string") {
		    bound = commands[bound];
		    if (!bound) { return false }
		  }
		  // Ensure previous input has been read, so that the handler sees a
		  // consistent view of the document
		  cm.display.input.ensurePolled();
		  var prevShift = cm.display.shift, done = false;
		  try {
		    if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
		    if (dropShift) { cm.display.shift = false; }
		    done = bound(cm) != Pass;
		  } finally {
		    cm.display.shift = prevShift;
		    cm.state.suppressEdits = false;
		  }
		  return done
		}
		
		function lookupKeyForEditor(cm, name, handle) {
		  for (var i = 0; i < cm.state.keyMaps.length; i++) {
		    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
		    if (result) { return result }
		  }
		  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
		    || lookupKey(name, cm.options.keyMap, handle, cm)
		}
		
		var stopSeq = new Delayed;
		function dispatchKey(cm, name, e, handle) {
		  var seq = cm.state.keySeq;
		  if (seq) {
		    if (isModifierKey(name)) { return "handled" }
		    stopSeq.set(50, function () {
		      if (cm.state.keySeq == seq) {
		        cm.state.keySeq = null;
		        cm.display.input.reset();
		      }
		    });
		    name = seq + " " + name;
		  }
		  var result = lookupKeyForEditor(cm, name, handle);
		
		  if (result == "multi")
		    { cm.state.keySeq = name; }
		  if (result == "handled")
		    { signalLater(cm, "keyHandled", cm, name, e); }
		
		  if (result == "handled" || result == "multi") {
		    e_preventDefault(e);
		    restartBlink(cm);
		  }
		
		  if (seq && !result && /\'$/.test(name)) {
		    e_preventDefault(e);
		    return true
		  }
		  return !!result
		}
		
		// Handle a key from the keydown event.
		function handleKeyBinding(cm, e) {
		  var name = keyName(e, true);
		  if (!name) { return false }
		
		  if (e.shiftKey && !cm.state.keySeq) {
		    // First try to resolve full name (including 'Shift-'). Failing
		    // that, see if there is a cursor-motion command (starting with
		    // 'go') bound to the keyname without 'Shift-'.
		    return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
		        || dispatchKey(cm, name, e, function (b) {
		             if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
		               { return doHandleBinding(cm, b) }
		           })
		  } else {
		    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
		  }
		}
		
		// Handle a key from the keypress event
		function handleCharBinding(cm, e, ch) {
		  return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
		}
		
		var lastStoppedKey = null;
		function onKeyDown(e) {
		  var cm = this;
		  cm.curOp.focus = activeElt();
		  if (signalDOMEvent(cm, e)) { return }
		  // IE does strange things with escape.
		  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }
		  var code = e.keyCode;
		  cm.display.shift = code == 16 || e.shiftKey;
		  var handled = handleKeyBinding(cm, e);
		  if (presto) {
		    lastStoppedKey = handled ? code : null;
		    // Opera has no cut event... we try to at least catch the key combo
		    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
		      { cm.replaceSelection("", null, "cut"); }
		  }
		
		  // Turn mouse into crosshair when Alt is held on Mac.
		  if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
		    { showCrossHair(cm); }
		}
		
		function showCrossHair(cm) {
		  var lineDiv = cm.display.lineDiv;
		  addClass(lineDiv, "CodeMirror-crosshair");
		
		  function up(e) {
		    if (e.keyCode == 18 || !e.altKey) {
		      rmClass(lineDiv, "CodeMirror-crosshair");
		      off(document, "keyup", up);
		      off(document, "mouseover", up);
		    }
		  }
		  on(document, "keyup", up);
		  on(document, "mouseover", up);
		}
		
		function onKeyUp(e) {
		  if (e.keyCode == 16) { this.doc.sel.shift = false; }
		  signalDOMEvent(this, e);
		}
		
		function onKeyPress(e) {
		  var cm = this;
		  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
		  var keyCode = e.keyCode, charCode = e.charCode;
		  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
		  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
		  var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
		  // Some browsers fire keypress events for backspace
		  if (ch == "\x08") { return }
		  if (handleCharBinding(cm, e, ch)) { return }
		  cm.display.input.onKeyPress(e);
		}
		
		// A mouse down can be a single click, double click, triple click,
		// start of selection drag, start of text drag, new cursor
		// (ctrl-click), rectangle drag (alt-drag), or xwin
		// middle-click-paste. Or it might be a click on something we should
		// not interfere with, such as a scrollbar or widget.
		function onMouseDown(e) {
		  var cm = this, display = cm.display;
		  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
		  display.input.ensurePolled();
		  display.shift = e.shiftKey;
		
		  if (eventInWidget(display, e)) {
		    if (!webkit) {
		      // Briefly turn off draggability, to allow widgets to do
		      // normal dragging things.
		      display.scroller.draggable = false;
		      setTimeout(function () { return display.scroller.draggable = true; }, 100);
		    }
		    return
		  }
		  if (clickInGutter(cm, e)) { return }
		  var start = posFromMouse(cm, e);
		  window.focus();
		
		  switch (e_button(e)) {
		  case 1:
		    // #3261: make sure, that we're not starting a second selection
		    if (cm.state.selectingText)
		      { cm.state.selectingText(e); }
		    else if (start)
		      { leftButtonDown(cm, e, start); }
		    else if (e_target(e) == display.scroller)
		      { e_preventDefault(e); }
		    break
		  case 2:
		    if (webkit) { cm.state.lastMiddleDown = +new Date; }
		    if (start) { extendSelection(cm.doc, start); }
		    setTimeout(function () { return display.input.focus(); }, 20);
		    e_preventDefault(e);
		    break
		  case 3:
		    if (captureRightClick) { onContextMenu(cm, e); }
		    else { delayBlurEvent(cm); }
		    break
		  }
		}
		
		var lastClick;
		var lastDoubleClick;
		function leftButtonDown(cm, e, start) {
		  if (ie) { setTimeout(bind(ensureFocus, cm), 0); }
		  else { cm.curOp.focus = activeElt(); }
		
		  var now = +new Date, type;
		  if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
		    type = "triple";
		  } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
		    type = "double";
		    lastDoubleClick = {time: now, pos: start};
		  } else {
		    type = "single";
		    lastClick = {time: now, pos: start};
		  }
		
		  var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;
		  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
		      type == "single" && (contained = sel.contains(start)) > -1 &&
		      (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&
		      (cmp(contained.to(), start) > 0 || start.xRel < 0))
		    { leftButtonStartDrag(cm, e, start, modifier); }
		  else
		    { leftButtonSelect(cm, e, start, type, modifier); }
		}
		
		// Start a text drag. When it ends, see if any dragging actually
		// happen, and treat as a click if it didn't.
		function leftButtonStartDrag(cm, e, start, modifier) {
		  var display = cm.display, startTime = +new Date;
		  var dragEnd = operation(cm, function (e2) {
		    if (webkit) { display.scroller.draggable = false; }
		    cm.state.draggingText = false;
		    off(document, "mouseup", dragEnd);
		    off(display.scroller, "drop", dragEnd);
		    if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
		      e_preventDefault(e2);
		      if (!modifier && +new Date - 200 < startTime)
		        { extendSelection(cm.doc, start); }
		      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
		      if (webkit || ie && ie_version == 9)
		        { setTimeout(function () {document.body.focus(); display.input.focus();}, 20); }
		      else
		        { display.input.focus(); }
		    }
		  });
		  // Let the drag handler handle this.
		  if (webkit) { display.scroller.draggable = true; }
		  cm.state.draggingText = dragEnd;
		  dragEnd.copy = mac ? e.altKey : e.ctrlKey;
		  // IE's approach to draggable
		  if (display.scroller.dragDrop) { display.scroller.dragDrop(); }
		  on(document, "mouseup", dragEnd);
		  on(display.scroller, "drop", dragEnd);
		}
		
		// Normal selection, as opposed to text dragging.
		function leftButtonSelect(cm, e, start, type, addNew) {
		  var display = cm.display, doc = cm.doc;
		  e_preventDefault(e);
		
		  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
		  if (addNew && !e.shiftKey) {
		    ourIndex = doc.sel.contains(start);
		    if (ourIndex > -1)
		      { ourRange = ranges[ourIndex]; }
		    else
		      { ourRange = new Range(start, start); }
		  } else {
		    ourRange = doc.sel.primary();
		    ourIndex = doc.sel.primIndex;
		  }
		
		  if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {
		    type = "rect";
		    if (!addNew) { ourRange = new Range(start, start); }
		    start = posFromMouse(cm, e, true, true);
		    ourIndex = -1;
		  } else if (type == "double") {
		    var word = cm.findWordAt(start);
		    if (cm.display.shift || doc.extend)
		      { ourRange = extendRange(doc, ourRange, word.anchor, word.head); }
		    else
		      { ourRange = word; }
		  } else if (type == "triple") {
		    var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
		    if (cm.display.shift || doc.extend)
		      { ourRange = extendRange(doc, ourRange, line.anchor, line.head); }
		    else
		      { ourRange = line; }
		  } else {
		    ourRange = extendRange(doc, ourRange, start);
		  }
		
		  if (!addNew) {
		    ourIndex = 0;
		    setSelection(doc, new Selection([ourRange], 0), sel_mouse);
		    startSel = doc.sel;
		  } else if (ourIndex == -1) {
		    ourIndex = ranges.length;
		    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
		                 {scroll: false, origin: "*mouse"});
		  } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == "single" && !e.shiftKey) {
		    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
		                 {scroll: false, origin: "*mouse"});
		    startSel = doc.sel;
		  } else {
		    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
		  }
		
		  var lastPos = start;
		  function extendTo(pos) {
		    if (cmp(lastPos, pos) == 0) { return }
		    lastPos = pos;
		
		    if (type == "rect") {
		      var ranges = [], tabSize = cm.options.tabSize;
		      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
		      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
		      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
		      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
		           line <= end; line++) {
		        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
		        if (left == right)
		          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }
		        else if (text.length > leftPos)
		          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }
		      }
		      if (!ranges.length) { ranges.push(new Range(start, start)); }
		      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
		                   {origin: "*mouse", scroll: false});
		      cm.scrollIntoView(pos);
		    } else {
		      var oldRange = ourRange;
		      var anchor = oldRange.anchor, head = pos;
		      if (type != "single") {
		        var range$$1;
		        if (type == "double")
		          { range$$1 = cm.findWordAt(pos); }
		        else
		          { range$$1 = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0))); }
		        if (cmp(range$$1.anchor, anchor) > 0) {
		          head = range$$1.head;
		          anchor = minPos(oldRange.from(), range$$1.anchor);
		        } else {
		          head = range$$1.anchor;
		          anchor = maxPos(oldRange.to(), range$$1.head);
		        }
		      }
		      var ranges$1 = startSel.ranges.slice(0);
		      ranges$1[ourIndex] = new Range(clipPos(doc, anchor), head);
		      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);
		    }
		  }
		
		  var editorSize = display.wrapper.getBoundingClientRect();
		  // Used to ensure timeout re-tries don't fire when another extend
		  // happened in the meantime (clearTimeout isn't reliable -- at
		  // least on Chrome, the timeouts still happen even when cleared,
		  // if the clear happens after their scheduled firing time).
		  var counter = 0;
		
		  function extend(e) {
		    var curCount = ++counter;
		    var cur = posFromMouse(cm, e, true, type == "rect");
		    if (!cur) { return }
		    if (cmp(cur, lastPos) != 0) {
		      cm.curOp.focus = activeElt();
		      extendTo(cur);
		      var visible = visibleLines(display, doc);
		      if (cur.line >= visible.to || cur.line < visible.from)
		        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }
		    } else {
		      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
		      if (outside) { setTimeout(operation(cm, function () {
		        if (counter != curCount) { return }
		        display.scroller.scrollTop += outside;
		        extend(e);
		      }), 50); }
		    }
		  }
		
		  function done(e) {
		    cm.state.selectingText = false;
		    counter = Infinity;
		    e_preventDefault(e);
		    display.input.focus();
		    off(document, "mousemove", move);
		    off(document, "mouseup", up);
		    doc.history.lastSelOrigin = null;
		  }
		
		  var move = operation(cm, function (e) {
		    if (!e_button(e)) { done(e); }
		    else { extend(e); }
		  });
		  var up = operation(cm, done);
		  cm.state.selectingText = up;
		  on(document, "mousemove", move);
		  on(document, "mouseup", up);
		}
		
		
		// Determines whether an event happened in the gutter, and fires the
		// handlers for the corresponding event.
		function gutterEvent(cm, e, type, prevent) {
		  var mX, mY;
		  try { mX = e.clientX; mY = e.clientY; }
		  catch(e) { return false }
		  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
		  if (prevent) { e_preventDefault(e); }
		
		  var display = cm.display;
		  var lineBox = display.lineDiv.getBoundingClientRect();
		
		  if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
		  mY -= lineBox.top - display.viewOffset;
		
		  for (var i = 0; i < cm.options.gutters.length; ++i) {
		    var g = display.gutters.childNodes[i];
		    if (g && g.getBoundingClientRect().right >= mX) {
		      var line = lineAtHeight(cm.doc, mY);
		      var gutter = cm.options.gutters[i];
		      signal(cm, type, cm, line, gutter, e);
		      return e_defaultPrevented(e)
		    }
		  }
		}
		
		function clickInGutter(cm, e) {
		  return gutterEvent(cm, e, "gutterClick", true)
		}
		
		// CONTEXT MENU HANDLING
		
		// To make the context menu work, we need to briefly unhide the
		// textarea (making it as unobtrusive as possible) to let the
		// right-click take effect on it.
		function onContextMenu(cm, e) {
		  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
		  if (signalDOMEvent(cm, e, "contextmenu")) { return }
		  cm.display.input.onContextMenu(e);
		}
		
		function contextMenuInGutter(cm, e) {
		  if (!hasHandler(cm, "gutterContextMenu")) { return false }
		  return gutterEvent(cm, e, "gutterContextMenu", false)
		}
		
		function themeChanged(cm) {
		  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
		    cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
		  clearCaches(cm);
		}
		
		var Init = {toString: function(){return "CodeMirror.Init"}};
		
		var defaults = {};
		var optionHandlers = {};
		
		function defineOptions(CodeMirror) {
		  var optionHandlers = CodeMirror.optionHandlers;
		
		  function option(name, deflt, handle, notOnInit) {
		    CodeMirror.defaults[name] = deflt;
		    if (handle) { optionHandlers[name] =
		      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }
		  }
		
		  CodeMirror.defineOption = option;
		
		  // Passed to option handlers when there is no old value.
		  CodeMirror.Init = Init;
		
		  // These two are, on init, called from the constructor because they
		  // have to be initialized before the editor can start at all.
		  option("value", "", function (cm, val) { return cm.setValue(val); }, true);
		  option("mode", null, function (cm, val) {
		    cm.doc.modeOption = val;
		    loadMode(cm);
		  }, true);
		
		  option("indentUnit", 2, loadMode, true);
		  option("indentWithTabs", false);
		  option("smartIndent", true);
		  option("tabSize", 4, function (cm) {
		    resetModeState(cm);
		    clearCaches(cm);
		    regChange(cm);
		  }, true);
		  option("lineSeparator", null, function (cm, val) {
		    cm.doc.lineSep = val;
		    if (!val) { return }
		    var newBreaks = [], lineNo = cm.doc.first;
		    cm.doc.iter(function (line) {
		      for (var pos = 0;;) {
		        var found = line.text.indexOf(val, pos);
		        if (found == -1) { break }
		        pos = found + val.length;
		        newBreaks.push(Pos(lineNo, found));
		      }
		      lineNo++;
		    });
		    for (var i = newBreaks.length - 1; i >= 0; i--)
		      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }
		  });
		  option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function (cm, val, old) {
		    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
		    if (old != Init) { cm.refresh(); }
		  });
		  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);
		  option("electricChars", true);
		  option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
		    throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
		  }, true);
		  option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);
		  option("rtlMoveVisually", !windows);
		  option("wholeLineUpdateBefore", true);
		
		  option("theme", "default", function (cm) {
		    themeChanged(cm);
		    guttersChanged(cm);
		  }, true);
		  option("keyMap", "default", function (cm, val, old) {
		    var next = getKeyMap(val);
		    var prev = old != Init && getKeyMap(old);
		    if (prev && prev.detach) { prev.detach(cm, next); }
		    if (next.attach) { next.attach(cm, prev || null); }
		  });
		  option("extraKeys", null);
		
		  option("lineWrapping", false, wrappingChanged, true);
		  option("gutters", [], function (cm) {
		    setGuttersForLineNumbers(cm.options);
		    guttersChanged(cm);
		  }, true);
		  option("fixedGutter", true, function (cm, val) {
		    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
		    cm.refresh();
		  }, true);
		  option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);
		  option("scrollbarStyle", "native", function (cm) {
		    initScrollbars(cm);
		    updateScrollbars(cm);
		    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
		    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
		  }, true);
		  option("lineNumbers", false, function (cm) {
		    setGuttersForLineNumbers(cm.options);
		    guttersChanged(cm);
		  }, true);
		  option("firstLineNumber", 1, guttersChanged, true);
		  option("lineNumberFormatter", function (integer) { return integer; }, guttersChanged, true);
		  option("showCursorWhenSelecting", false, updateSelection, true);
		
		  option("resetSelectionOnContextMenu", true);
		  option("lineWiseCopyCut", true);
		
		  option("readOnly", false, function (cm, val) {
		    if (val == "nocursor") {
		      onBlur(cm);
		      cm.display.input.blur();
		      cm.display.disabled = true;
		    } else {
		      cm.display.disabled = false;
		    }
		    cm.display.input.readOnlyChanged(val);
		  });
		  option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);
		  option("dragDrop", true, dragDropChanged);
		  option("allowDropFileTypes", null);
		
		  option("cursorBlinkRate", 530);
		  option("cursorScrollMargin", 0);
		  option("cursorHeight", 1, updateSelection, true);
		  option("singleCursorHeightPerLine", true, updateSelection, true);
		  option("workTime", 100);
		  option("workDelay", 100);
		  option("flattenSpans", true, resetModeState, true);
		  option("addModeClass", false, resetModeState, true);
		  option("pollInterval", 100);
		  option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });
		  option("historyEventDelay", 1250);
		  option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);
		  option("maxHighlightLength", 10000, resetModeState, true);
		  option("moveInputWithCursor", true, function (cm, val) {
		    if (!val) { cm.display.input.resetPosition(); }
		  });
		
		  option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });
		  option("autofocus", null);
		  option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);
		}
		
		function guttersChanged(cm) {
		  updateGutters(cm);
		  regChange(cm);
		  alignHorizontally(cm);
		}
		
		function dragDropChanged(cm, value, old) {
		  var wasOn = old && old != Init;
		  if (!value != !wasOn) {
		    var funcs = cm.display.dragFunctions;
		    var toggle = value ? on : off;
		    toggle(cm.display.scroller, "dragstart", funcs.start);
		    toggle(cm.display.scroller, "dragenter", funcs.enter);
		    toggle(cm.display.scroller, "dragover", funcs.over);
		    toggle(cm.display.scroller, "dragleave", funcs.leave);
		    toggle(cm.display.scroller, "drop", funcs.drop);
		  }
		}
		
		function wrappingChanged(cm) {
		  if (cm.options.lineWrapping) {
		    addClass(cm.display.wrapper, "CodeMirror-wrap");
		    cm.display.sizer.style.minWidth = "";
		    cm.display.sizerWidth = null;
		  } else {
		    rmClass(cm.display.wrapper, "CodeMirror-wrap");
		    findMaxLine(cm);
		  }
		  estimateLineHeights(cm);
		  regChange(cm);
		  clearCaches(cm);
		  setTimeout(function () { return updateScrollbars(cm); }, 100);
		}
		
		// A CodeMirror instance represents an editor. This is the object
		// that user code is usually dealing with.
		
		function CodeMirror$1(place, options) {
		  var this$1 = this;
		
		  if (!(this instanceof CodeMirror$1)) { return new CodeMirror$1(place, options) }
		
		  this.options = options = options ? copyObj(options) : {};
		  // Determine effective options based on given values and defaults.
		  copyObj(defaults, options, false);
		  setGuttersForLineNumbers(options);
		
		  var doc = options.value;
		  if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }
		  this.doc = doc;
		
		  var input = new CodeMirror$1.inputStyles[options.inputStyle](this);
		  var display = this.display = new Display(place, doc, input);
		  display.wrapper.CodeMirror = this;
		  updateGutters(this);
		  themeChanged(this);
		  if (options.lineWrapping)
		    { this.display.wrapper.className += " CodeMirror-wrap"; }
		  initScrollbars(this);
		
		  this.state = {
		    keyMaps: [],  // stores maps added by addKeyMap
		    overlays: [], // highlighting overlays, as added by addOverlay
		    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
		    overwrite: false,
		    delayingBlurEvent: false,
		    focused: false,
		    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
		    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll
		    selectingText: false,
		    draggingText: false,
		    highlight: new Delayed(), // stores highlight worker timeout
		    keySeq: null,  // Unfinished key sequence
		    specialChars: null
		  };
		
		  if (options.autofocus && !mobile) { display.input.focus(); }
		
		  // Override magic textarea content restore that IE sometimes does
		  // on our hidden textarea on reload
		  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }
		
		  registerEventHandlers(this);
		  ensureGlobalHandlers();
		
		  startOperation(this);
		  this.curOp.forceUpdate = true;
		  attachDoc(this, doc);
		
		  if ((options.autofocus && !mobile) || this.hasFocus())
		    { setTimeout(bind(onFocus, this), 20); }
		  else
		    { onBlur(this); }
		
		  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
		    { optionHandlers[opt](this$1, options[opt], Init); } }
		  maybeUpdateLineNumberWidth(this);
		  if (options.finishInit) { options.finishInit(this); }
		  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }
		  endOperation(this);
		  // Suppress optimizelegibility in Webkit, since it breaks text
		  // measuring on line wrapping boundaries.
		  if (webkit && options.lineWrapping &&
		      getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
		    { display.lineDiv.style.textRendering = "auto"; }
		}
		
		// The default configuration options.
		CodeMirror$1.defaults = defaults;
		// Functions to run when options are changed.
		CodeMirror$1.optionHandlers = optionHandlers;
		
		// Attach the necessary event handlers when initializing the editor
		function registerEventHandlers(cm) {
		  var d = cm.display;
		  on(d.scroller, "mousedown", operation(cm, onMouseDown));
		  // Older IE's will not fire a second mousedown for a double click
		  if (ie && ie_version < 11)
		    { on(d.scroller, "dblclick", operation(cm, function (e) {
		      if (signalDOMEvent(cm, e)) { return }
		      var pos = posFromMouse(cm, e);
		      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
		      e_preventDefault(e);
		      var word = cm.findWordAt(pos);
		      extendSelection(cm.doc, word.anchor, word.head);
		    })); }
		  else
		    { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }
		  // Some browsers fire contextmenu *after* opening the menu, at
		  // which point we can't mess with it anymore. Context menu is
		  // handled in onMouseDown for these browsers.
		  if (!captureRightClick) { on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); }); }
		
		  // Used to suppress mouse event handling when a touch happens
		  var touchFinished, prevTouch = {end: 0};
		  function finishTouch() {
		    if (d.activeTouch) {
		      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);
		      prevTouch = d.activeTouch;
		      prevTouch.end = +new Date;
		    }
		  }
		  function isMouseLikeTouchEvent(e) {
		    if (e.touches.length != 1) { return false }
		    var touch = e.touches[0];
		    return touch.radiusX <= 1 && touch.radiusY <= 1
		  }
		  function farAway(touch, other) {
		    if (other.left == null) { return true }
		    var dx = other.left - touch.left, dy = other.top - touch.top;
		    return dx * dx + dy * dy > 20 * 20
		  }
		  on(d.scroller, "touchstart", function (e) {
		    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {
		      d.input.ensurePolled();
		      clearTimeout(touchFinished);
		      var now = +new Date;
		      d.activeTouch = {start: now, moved: false,
		                       prev: now - prevTouch.end <= 300 ? prevTouch : null};
		      if (e.touches.length == 1) {
		        d.activeTouch.left = e.touches[0].pageX;
		        d.activeTouch.top = e.touches[0].pageY;
		      }
		    }
		  });
		  on(d.scroller, "touchmove", function () {
		    if (d.activeTouch) { d.activeTouch.moved = true; }
		  });
		  on(d.scroller, "touchend", function (e) {
		    var touch = d.activeTouch;
		    if (touch && !eventInWidget(d, e) && touch.left != null &&
		        !touch.moved && new Date - touch.start < 300) {
		      var pos = cm.coordsChar(d.activeTouch, "page"), range;
		      if (!touch.prev || farAway(touch, touch.prev)) // Single tap
		        { range = new Range(pos, pos); }
		      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
		        { range = cm.findWordAt(pos); }
		      else // Triple tap
		        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }
		      cm.setSelection(range.anchor, range.head);
		      cm.focus();
		      e_preventDefault(e);
		    }
		    finishTouch();
		  });
		  on(d.scroller, "touchcancel", finishTouch);
		
		  // Sync scrolling between fake scrollbars and real scrollable
		  // area, ensure viewport is updated when scrolling.
		  on(d.scroller, "scroll", function () {
		    if (d.scroller.clientHeight) {
		      setScrollTop(cm, d.scroller.scrollTop);
		      setScrollLeft(cm, d.scroller.scrollLeft, true);
		      signal(cm, "scroll", cm);
		    }
		  });
		
		  // Listen to wheel events in order to try and update the viewport on time.
		  on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });
		  on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });
		
		  // Prevent wrapper from ever scrolling
		  on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });
		
		  d.dragFunctions = {
		    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},
		    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
		    start: function (e) { return onDragStart(cm, e); },
		    drop: operation(cm, onDrop),
		    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
		  };
		
		  var inp = d.input.getField();
		  on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });
		  on(inp, "keydown", operation(cm, onKeyDown));
		  on(inp, "keypress", operation(cm, onKeyPress));
		  on(inp, "focus", function (e) { return onFocus(cm, e); });
		  on(inp, "blur", function (e) { return onBlur(cm, e); });
		}
		
		var initHooks = [];
		CodeMirror$1.defineInitHook = function (f) { return initHooks.push(f); };
		
		// Indent the given line. The how parameter can be "smart",
		// "add"/null, "subtract", or "prev". When aggressive is false
		// (typically set to true for forced single-line indents), empty
		// lines are not indented, and places where the mode returns Pass
		// are left alone.
		function indentLine(cm, n, how, aggressive) {
		  var doc = cm.doc, state;
		  if (how == null) { how = "add"; }
		  if (how == "smart") {
		    // Fall back to "prev" when the mode doesn't have an indentation
		    // method.
		    if (!doc.mode.indent) { how = "prev"; }
		    else { state = getStateBefore(cm, n); }
		  }
		
		  var tabSize = cm.options.tabSize;
		  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
		  if (line.stateAfter) { line.stateAfter = null; }
		  var curSpaceString = line.text.match(/^\s*/)[0], indentation;
		  if (!aggressive && !/\S/.test(line.text)) {
		    indentation = 0;
		    how = "not";
		  } else if (how == "smart") {
		    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
		    if (indentation == Pass || indentation > 150) {
		      if (!aggressive) { return }
		      how = "prev";
		    }
		  }
		  if (how == "prev") {
		    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }
		    else { indentation = 0; }
		  } else if (how == "add") {
		    indentation = curSpace + cm.options.indentUnit;
		  } else if (how == "subtract") {
		    indentation = curSpace - cm.options.indentUnit;
		  } else if (typeof how == "number") {
		    indentation = curSpace + how;
		  }
		  indentation = Math.max(0, indentation);
		
		  var indentString = "", pos = 0;
		  if (cm.options.indentWithTabs)
		    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";} }
		  if (pos < indentation) { indentString += spaceStr(indentation - pos); }
		
		  if (indentString != curSpaceString) {
		    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
		    line.stateAfter = null;
		    return true
		  } else {
		    // Ensure that, if the cursor was in the whitespace at the start
		    // of the line, it is moved to the end of that space.
		    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
		      var range = doc.sel.ranges[i$1];
		      if (range.head.line == n && range.head.ch < curSpaceString.length) {
		        var pos$1 = Pos(n, curSpaceString.length);
		        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
		        break
		      }
		    }
		  }
		}
		
		// This will be set to a {lineWise: bool, text: [string]} object, so
		// that, when pasting, we know what kind of selections the copied
		// text was made out of.
		var lastCopied = null;
		
		function setLastCopied(newLastCopied) {
		  lastCopied = newLastCopied;
		}
		
		function applyTextInput(cm, inserted, deleted, sel, origin) {
		  var doc = cm.doc;
		  cm.display.shift = false;
		  if (!sel) { sel = doc.sel; }
		
		  var paste = cm.state.pasteIncoming || origin == "paste";
		  var textLines = splitLinesAuto(inserted), multiPaste = null;
		  // When pasing N lines into N selections, insert one line per selection
		  if (paste && sel.ranges.length > 1) {
		    if (lastCopied && lastCopied.text.join("\n") == inserted) {
		      if (sel.ranges.length % lastCopied.text.length == 0) {
		        multiPaste = [];
		        for (var i = 0; i < lastCopied.text.length; i++)
		          { multiPaste.push(doc.splitLines(lastCopied.text[i])); }
		      }
		    } else if (textLines.length == sel.ranges.length) {
		      multiPaste = map(textLines, function (l) { return [l]; });
		    }
		  }
		
		  var updateInput;
		  // Normal behavior is to insert the new text into every selection
		  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
		    var range$$1 = sel.ranges[i$1];
		    var from = range$$1.from(), to = range$$1.to();
		    if (range$$1.empty()) {
		      if (deleted && deleted > 0) // Handle deletion
		        { from = Pos(from.line, from.ch - deleted); }
		      else if (cm.state.overwrite && !paste) // Handle overwrite
		        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }
		      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted)
		        { from = to = Pos(from.line, 0); }
		    }
		    updateInput = cm.curOp.updateInput;
		    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
		                       origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")};
		    makeChange(cm.doc, changeEvent);
		    signalLater(cm, "inputRead", cm, changeEvent);
		  }
		  if (inserted && !paste)
		    { triggerElectric(cm, inserted); }
		
		  ensureCursorVisible(cm);
		  cm.curOp.updateInput = updateInput;
		  cm.curOp.typing = true;
		  cm.state.pasteIncoming = cm.state.cutIncoming = false;
		}
		
		function handlePaste(e, cm) {
		  var pasted = e.clipboardData && e.clipboardData.getData("Text");
		  if (pasted) {
		    e.preventDefault();
		    if (!cm.isReadOnly() && !cm.options.disableInput)
		      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }
		    return true
		  }
		}
		
		function triggerElectric(cm, inserted) {
		  // When an 'electric' character is inserted, immediately trigger a reindent
		  if (!cm.options.electricChars || !cm.options.smartIndent) { return }
		  var sel = cm.doc.sel;
		
		  for (var i = sel.ranges.length - 1; i >= 0; i--) {
		    var range$$1 = sel.ranges[i];
		    if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }
		    var mode = cm.getModeAt(range$$1.head);
		    var indented = false;
		    if (mode.electricChars) {
		      for (var j = 0; j < mode.electricChars.length; j++)
		        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
		          indented = indentLine(cm, range$$1.head.line, "smart");
		          break
		        } }
		    } else if (mode.electricInput) {
		      if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))
		        { indented = indentLine(cm, range$$1.head.line, "smart"); }
		    }
		    if (indented) { signalLater(cm, "electricInput", cm, range$$1.head.line); }
		  }
		}
		
		function copyableRanges(cm) {
		  var text = [], ranges = [];
		  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
		    var line = cm.doc.sel.ranges[i].head.line;
		    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
		    ranges.push(lineRange);
		    text.push(cm.getRange(lineRange.anchor, lineRange.head));
		  }
		  return {text: text, ranges: ranges}
		}
		
		function disableBrowserMagic(field, spellcheck) {
		  field.setAttribute("autocorrect", "off");
		  field.setAttribute("autocapitalize", "off");
		  field.setAttribute("spellcheck", !!spellcheck);
		}
		
		function hiddenTextarea() {
		  var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
		  var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
		  // The textarea is kept positioned near the cursor to prevent the
		  // fact that it'll be scrolled into view on input from scrolling
		  // our fake cursor out of view. On webkit, when wrap=off, paste is
		  // very slow. So make the area wide instead.
		  if (webkit) { te.style.width = "1000px"; }
		  else { te.setAttribute("wrap", "off"); }
		  // If border: 0; -- iOS fails to open keyboard (issue #1287)
		  if (ios) { te.style.border = "1px solid black"; }
		  disableBrowserMagic(te);
		  return div
		}
		
		// The publicly visible API. Note that methodOp(f) means
		// 'wrap f in an operation, performed on its `this` parameter'.
		
		// This is not the complete set of editor methods. Most of the
		// methods defined on the Doc type are also injected into
		// CodeMirror.prototype, for backwards compatibility and
		// convenience.
		
		var addEditorMethods = function(CodeMirror) {
		  var optionHandlers = CodeMirror.optionHandlers;
		
		  var helpers = CodeMirror.helpers = {};
		
		  CodeMirror.prototype = {
		    constructor: CodeMirror,
		    focus: function(){window.focus(); this.display.input.focus();},
		
		    setOption: function(option, value) {
		      var options = this.options, old = options[option];
		      if (options[option] == value && option != "mode") { return }
		      options[option] = value;
		      if (optionHandlers.hasOwnProperty(option))
		        { operation(this, optionHandlers[option])(this, value, old); }
		      signal(this, "optionChange", this, option);
		    },
		
		    getOption: function(option) {return this.options[option]},
		    getDoc: function() {return this.doc},
		
		    addKeyMap: function(map$$1, bottom) {
		      this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map$$1));
		    },
		    removeKeyMap: function(map$$1) {
		      var maps = this.state.keyMaps;
		      for (var i = 0; i < maps.length; ++i)
		        { if (maps[i] == map$$1 || maps[i].name == map$$1) {
		          maps.splice(i, 1);
		          return true
		        } }
		    },
		
		    addOverlay: methodOp(function(spec, options) {
		      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
		      if (mode.startState) { throw new Error("Overlays may not be stateful.") }
		      insertSorted(this.state.overlays,
		                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,
		                    priority: (options && options.priority) || 0},
		                   function (overlay) { return overlay.priority; });
		      this.state.modeGen++;
		      regChange(this);
		    }),
		    removeOverlay: methodOp(function(spec) {
		      var this$1 = this;
		
		      var overlays = this.state.overlays;
		      for (var i = 0; i < overlays.length; ++i) {
		        var cur = overlays[i].modeSpec;
		        if (cur == spec || typeof spec == "string" && cur.name == spec) {
		          overlays.splice(i, 1);
		          this$1.state.modeGen++;
		          regChange(this$1);
		          return
		        }
		      }
		    }),
		
		    indentLine: methodOp(function(n, dir, aggressive) {
		      if (typeof dir != "string" && typeof dir != "number") {
		        if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }
		        else { dir = dir ? "add" : "subtract"; }
		      }
		      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }
		    }),
		    indentSelection: methodOp(function(how) {
		      var this$1 = this;
		
		      var ranges = this.doc.sel.ranges, end = -1;
		      for (var i = 0; i < ranges.length; i++) {
		        var range$$1 = ranges[i];
		        if (!range$$1.empty()) {
		          var from = range$$1.from(), to = range$$1.to();
		          var start = Math.max(end, from.line);
		          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
		          for (var j = start; j < end; ++j)
		            { indentLine(this$1, j, how); }
		          var newRanges = this$1.doc.sel.ranges;
		          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
		            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }
		        } else if (range$$1.head.line > end) {
		          indentLine(this$1, range$$1.head.line, how, true);
		          end = range$$1.head.line;
		          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }
		        }
		      }
		    }),
		
		    // Fetch the parser token for a given character. Useful for hacks
		    // that want to inspect the mode state (say, for completion).
		    getTokenAt: function(pos, precise) {
		      return takeToken(this, pos, precise)
		    },
		
		    getLineTokens: function(line, precise) {
		      return takeToken(this, Pos(line), precise, true)
		    },
		
		    getTokenTypeAt: function(pos) {
		      pos = clipPos(this.doc, pos);
		      var styles = getLineStyles(this, getLine(this.doc, pos.line));
		      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
		      var type;
		      if (ch == 0) { type = styles[2]; }
		      else { for (;;) {
		        var mid = (before + after) >> 1;
		        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }
		        else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }
		        else { type = styles[mid * 2 + 2]; break }
		      } }
		      var cut = type ? type.indexOf("overlay ") : -1;
		      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
		    },
		
		    getModeAt: function(pos) {
		      var mode = this.doc.mode;
		      if (!mode.innerMode) { return mode }
		      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
		    },
		
		    getHelper: function(pos, type) {
		      return this.getHelpers(pos, type)[0]
		    },
		
		    getHelpers: function(pos, type) {
		      var this$1 = this;
		
		      var found = [];
		      if (!helpers.hasOwnProperty(type)) { return found }
		      var help = helpers[type], mode = this.getModeAt(pos);
		      if (typeof mode[type] == "string") {
		        if (help[mode[type]]) { found.push(help[mode[type]]); }
		      } else if (mode[type]) {
		        for (var i = 0; i < mode[type].length; i++) {
		          var val = help[mode[type][i]];
		          if (val) { found.push(val); }
		        }
		      } else if (mode.helperType && help[mode.helperType]) {
		        found.push(help[mode.helperType]);
		      } else if (help[mode.name]) {
		        found.push(help[mode.name]);
		      }
		      for (var i$1 = 0; i$1 < help._global.length; i$1++) {
		        var cur = help._global[i$1];
		        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)
		          { found.push(cur.val); }
		      }
		      return found
		    },
		
		    getStateAfter: function(line, precise) {
		      var doc = this.doc;
		      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
		      return getStateBefore(this, line + 1, precise)
		    },
		
		    cursorCoords: function(start, mode) {
		      var pos, range$$1 = this.doc.sel.primary();
		      if (start == null) { pos = range$$1.head; }
		      else if (typeof start == "object") { pos = clipPos(this.doc, start); }
		      else { pos = start ? range$$1.from() : range$$1.to(); }
		      return cursorCoords(this, pos, mode || "page")
		    },
		
		    charCoords: function(pos, mode) {
		      return charCoords(this, clipPos(this.doc, pos), mode || "page")
		    },
		
		    coordsChar: function(coords, mode) {
		      coords = fromCoordSystem(this, coords, mode || "page");
		      return coordsChar(this, coords.left, coords.top)
		    },
		
		    lineAtHeight: function(height, mode) {
		      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
		      return lineAtHeight(this.doc, height + this.display.viewOffset)
		    },
		    heightAtLine: function(line, mode, includeWidgets) {
		      var end = false, lineObj;
		      if (typeof line == "number") {
		        var last = this.doc.first + this.doc.size - 1;
		        if (line < this.doc.first) { line = this.doc.first; }
		        else if (line > last) { line = last; end = true; }
		        lineObj = getLine(this.doc, line);
		      } else {
		        lineObj = line;
		      }
		      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +
		        (end ? this.doc.height - heightAtLine(lineObj) : 0)
		    },
		
		    defaultTextHeight: function() { return textHeight(this.display) },
		    defaultCharWidth: function() { return charWidth(this.display) },
		
		    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},
		
		    addWidget: function(pos, node, scroll, vert, horiz) {
		      var display = this.display;
		      pos = cursorCoords(this, clipPos(this.doc, pos));
		      var top = pos.bottom, left = pos.left;
		      node.style.position = "absolute";
		      node.setAttribute("cm-ignore-events", "true");
		      this.display.input.setUneditable(node);
		      display.sizer.appendChild(node);
		      if (vert == "over") {
		        top = pos.top;
		      } else if (vert == "above" || vert == "near") {
		        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
		        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
		        // Default to positioning above (if specified and possible); otherwise default to positioning below
		        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
		          { top = pos.top - node.offsetHeight; }
		        else if (pos.bottom + node.offsetHeight <= vspace)
		          { top = pos.bottom; }
		        if (left + node.offsetWidth > hspace)
		          { left = hspace - node.offsetWidth; }
		      }
		      node.style.top = top + "px";
		      node.style.left = node.style.right = "";
		      if (horiz == "right") {
		        left = display.sizer.clientWidth - node.offsetWidth;
		        node.style.right = "0px";
		      } else {
		        if (horiz == "left") { left = 0; }
		        else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }
		        node.style.left = left + "px";
		      }
		      if (scroll)
		        { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }
		    },
		
		    triggerOnKeyDown: methodOp(onKeyDown),
		    triggerOnKeyPress: methodOp(onKeyPress),
		    triggerOnKeyUp: onKeyUp,
		
		    execCommand: function(cmd) {
		      if (commands.hasOwnProperty(cmd))
		        { return commands[cmd].call(null, this) }
		    },
		
		    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),
		
		    findPosH: function(from, amount, unit, visually) {
		      var this$1 = this;
		
		      var dir = 1;
		      if (amount < 0) { dir = -1; amount = -amount; }
		      var cur = clipPos(this.doc, from);
		      for (var i = 0; i < amount; ++i) {
		        cur = findPosH(this$1.doc, cur, dir, unit, visually);
		        if (cur.hitSide) { break }
		      }
		      return cur
		    },
		
		    moveH: methodOp(function(dir, unit) {
		      var this$1 = this;
		
		      this.extendSelectionsBy(function (range$$1) {
		        if (this$1.display.shift || this$1.doc.extend || range$$1.empty())
		          { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }
		        else
		          { return dir < 0 ? range$$1.from() : range$$1.to() }
		      }, sel_move);
		    }),
		
		    deleteH: methodOp(function(dir, unit) {
		      var sel = this.doc.sel, doc = this.doc;
		      if (sel.somethingSelected())
		        { doc.replaceSelection("", null, "+delete"); }
		      else
		        { deleteNearSelection(this, function (range$$1) {
		          var other = findPosH(doc, range$$1.head, dir, unit, false);
		          return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}
		        }); }
		    }),
		
		    findPosV: function(from, amount, unit, goalColumn) {
		      var this$1 = this;
		
		      var dir = 1, x = goalColumn;
		      if (amount < 0) { dir = -1; amount = -amount; }
		      var cur = clipPos(this.doc, from);
		      for (var i = 0; i < amount; ++i) {
		        var coords = cursorCoords(this$1, cur, "div");
		        if (x == null) { x = coords.left; }
		        else { coords.left = x; }
		        cur = findPosV(this$1, coords, dir, unit);
		        if (cur.hitSide) { break }
		      }
		      return cur
		    },
		
		    moveV: methodOp(function(dir, unit) {
		      var this$1 = this;
		
		      var doc = this.doc, goals = [];
		      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
		      doc.extendSelectionsBy(function (range$$1) {
		        if (collapse)
		          { return dir < 0 ? range$$1.from() : range$$1.to() }
		        var headPos = cursorCoords(this$1, range$$1.head, "div");
		        if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }
		        goals.push(headPos.left);
		        var pos = findPosV(this$1, headPos, dir, unit);
		        if (unit == "page" && range$$1 == doc.sel.primary())
		          { addToScrollPos(this$1, null, charCoords(this$1, pos, "div").top - headPos.top); }
		        return pos
		      }, sel_move);
		      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
		        { doc.sel.ranges[i].goalColumn = goals[i]; } }
		    }),
		
		    // Find the word at the given position (as returned by coordsChar).
		    findWordAt: function(pos) {
		      var doc = this.doc, line = getLine(doc, pos.line).text;
		      var start = pos.ch, end = pos.ch;
		      if (line) {
		        var helper = this.getHelper(pos, "wordChars");
		        if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }
		        var startChar = line.charAt(start);
		        var check = isWordChar(startChar, helper)
		          ? function (ch) { return isWordChar(ch, helper); }
		          : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
		          : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); };
		        while (start > 0 && check(line.charAt(start - 1))) { --start; }
		        while (end < line.length && check(line.charAt(end))) { ++end; }
		      }
		      return new Range(Pos(pos.line, start), Pos(pos.line, end))
		    },
		
		    toggleOverwrite: function(value) {
		      if (value != null && value == this.state.overwrite) { return }
		      if (this.state.overwrite = !this.state.overwrite)
		        { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
		      else
		        { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
		
		      signal(this, "overwriteToggle", this, this.state.overwrite);
		    },
		    hasFocus: function() { return this.display.input.getField() == activeElt() },
		    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },
		
		    scrollTo: methodOp(function(x, y) {
		      if (x != null || y != null) { resolveScrollToPos(this); }
		      if (x != null) { this.curOp.scrollLeft = x; }
		      if (y != null) { this.curOp.scrollTop = y; }
		    }),
		    getScrollInfo: function() {
		      var scroller = this.display.scroller;
		      return {left: scroller.scrollLeft, top: scroller.scrollTop,
		              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
		              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
		              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
		    },
		
		    scrollIntoView: methodOp(function(range$$1, margin) {
		      if (range$$1 == null) {
		        range$$1 = {from: this.doc.sel.primary().head, to: null};
		        if (margin == null) { margin = this.options.cursorScrollMargin; }
		      } else if (typeof range$$1 == "number") {
		        range$$1 = {from: Pos(range$$1, 0), to: null};
		      } else if (range$$1.from == null) {
		        range$$1 = {from: range$$1, to: null};
		      }
		      if (!range$$1.to) { range$$1.to = range$$1.from; }
		      range$$1.margin = margin || 0;
		
		      if (range$$1.from.line != null) {
		        resolveScrollToPos(this);
		        this.curOp.scrollToPos = range$$1;
		      } else {
		        var sPos = calculateScrollPos(this, {
		          left: Math.min(range$$1.from.left, range$$1.to.left),
		          top: Math.min(range$$1.from.top, range$$1.to.top) - range$$1.margin,
		          right: Math.max(range$$1.from.right, range$$1.to.right),
		          bottom: Math.max(range$$1.from.bottom, range$$1.to.bottom) + range$$1.margin
		        });
		        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
		      }
		    }),
		
		    setSize: methodOp(function(width, height) {
		      var this$1 = this;
		
		      var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; };
		      if (width != null) { this.display.wrapper.style.width = interpret(width); }
		      if (height != null) { this.display.wrapper.style.height = interpret(height); }
		      if (this.options.lineWrapping) { clearLineMeasurementCache(this); }
		      var lineNo$$1 = this.display.viewFrom;
		      this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {
		        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
		          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, "widget"); break } } }
		        ++lineNo$$1;
		      });
		      this.curOp.forceUpdate = true;
		      signal(this, "refresh", this);
		    }),
		
		    operation: function(f){return runInOp(this, f)},
		
		    refresh: methodOp(function() {
		      var oldHeight = this.display.cachedTextHeight;
		      regChange(this);
		      this.curOp.forceUpdate = true;
		      clearCaches(this);
		      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
		      updateGutterSpace(this);
		      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
		        { estimateLineHeights(this); }
		      signal(this, "refresh", this);
		    }),
		
		    swapDoc: methodOp(function(doc) {
		      var old = this.doc;
		      old.cm = null;
		      attachDoc(this, doc);
		      clearCaches(this);
		      this.display.input.reset();
		      this.scrollTo(doc.scrollLeft, doc.scrollTop);
		      this.curOp.forceScroll = true;
		      signalLater(this, "swapDoc", this, old);
		      return old
		    }),
		
		    getInputField: function(){return this.display.input.getField()},
		    getWrapperElement: function(){return this.display.wrapper},
		    getScrollerElement: function(){return this.display.scroller},
		    getGutterElement: function(){return this.display.gutters}
		  };
		  eventMixin(CodeMirror);
		
		  CodeMirror.registerHelper = function(type, name, value) {
		    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
		    helpers[type][name] = value;
		  };
		  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
		    CodeMirror.registerHelper(type, name, value);
		    helpers[type]._global.push({pred: predicate, val: value});
		  };
		};
		
		// Used for horizontal relative motion. Dir is -1 or 1 (left or
		// right), unit can be "char", "column" (like char, but doesn't
		// cross line boundaries), "word" (across next word), or "group" (to
		// the start of next group of word or non-word-non-whitespace
		// chars). The visually param controls whether, in right-to-left
		// text, direction 1 means to move towards the next index in the
		// string, or towards the character to the right of the current
		// position. The resulting position will have a hitSide=true
		// property if it reached the end of the document.
		function findPosH(doc, pos, dir, unit, visually) {
		  var oldPos = pos;
		  var origDir = dir;
		  var lineObj = getLine(doc, pos.line);
		  function findNextLine() {
		    var l = pos.line + dir;
		    if (l < doc.first || l >= doc.first + doc.size) { return false }
		    pos = new Pos(l, pos.ch, pos.sticky);
		    return lineObj = getLine(doc, l)
		  }
		  function moveOnce(boundToLine) {
		    var next;
		    if (visually) {
		      next = moveVisually(doc.cm, lineObj, pos, dir);
		    } else {
		      next = moveLogically(lineObj, pos, dir);
		    }
		    if (next == null) {
		      if (!boundToLine && findNextLine())
		        { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }
		      else
		        { return false }
		    } else {
		      pos = next;
		    }
		    return true
		  }
		
		  if (unit == "char") {
		    moveOnce();
		  } else if (unit == "column") {
		    moveOnce(true);
		  } else if (unit == "word" || unit == "group") {
		    var sawType = null, group = unit == "group";
		    var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
		    for (var first = true;; first = false) {
		      if (dir < 0 && !moveOnce(!first)) { break }
		      var cur = lineObj.text.charAt(pos.ch) || "\n";
		      var type = isWordChar(cur, helper) ? "w"
		        : group && cur == "\n" ? "n"
		        : !group || /\s/.test(cur) ? null
		        : "p";
		      if (group && !first && !type) { type = "s"; }
		      if (sawType && sawType != type) {
		        if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after";}
		        break
		      }
		
		      if (type) { sawType = type; }
		      if (dir > 0 && !moveOnce(!first)) { break }
		    }
		  }
		  var result = skipAtomic(doc, pos, oldPos, origDir, true);
		  if (equalCursorPos(oldPos, result)) { result.hitSide = true; }
		  return result
		}
		
		// For relative vertical movement. Dir may be -1 or 1. Unit can be
		// "page" or "line". The resulting position will have a hitSide=true
		// property if it reached the end of the document.
		function findPosV(cm, pos, dir, unit) {
		  var doc = cm.doc, x = pos.left, y;
		  if (unit == "page") {
		    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
		    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
		    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
		
		  } else if (unit == "line") {
		    y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
		  }
		  var target;
		  for (;;) {
		    target = coordsChar(cm, x, y);
		    if (!target.outside) { break }
		    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
		    y += dir * 5;
		  }
		  return target
		}
		
		// CONTENTEDITABLE INPUT STYLE
		
		var ContentEditableInput = function(cm) {
		  this.cm = cm;
		  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
		  this.polling = new Delayed();
		  this.composing = null;
		  this.gracePeriod = false;
		  this.readDOMTimeout = null;
		};
		
		ContentEditableInput.prototype.init = function (display) {
		    var this$1 = this;
		
		  var input = this, cm = input.cm;
		  var div = input.div = display.lineDiv;
		  disableBrowserMagic(div, cm.options.spellcheck);
		
		  on(div, "paste", function (e) {
		    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
		    // IE doesn't fire input events, so we schedule a read for the pasted content in this way
		    if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }
		  });
		
		  on(div, "compositionstart", function (e) {
		    this$1.composing = {data: e.data, done: false};
		  });
		  on(div, "compositionupdate", function (e) {
		    if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }
		  });
		  on(div, "compositionend", function (e) {
		    if (this$1.composing) {
		      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }
		      this$1.composing.done = true;
		    }
		  });
		
		  on(div, "touchstart", function () { return input.forceCompositionEnd(); });
		
		  on(div, "input", function () {
		    if (!this$1.composing) { this$1.readFromDOMSoon(); }
		  });
		
		  function onCopyCut(e) {
		    if (signalDOMEvent(cm, e)) { return }
		    if (cm.somethingSelected()) {
		      setLastCopied({lineWise: false, text: cm.getSelections()});
		      if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }
		    } else if (!cm.options.lineWiseCopyCut) {
		      return
		    } else {
		      var ranges = copyableRanges(cm);
		      setLastCopied({lineWise: true, text: ranges.text});
		      if (e.type == "cut") {
		        cm.operation(function () {
		          cm.setSelections(ranges.ranges, 0, sel_dontScroll);
		          cm.replaceSelection("", null, "cut");
		        });
		      }
		    }
		    if (e.clipboardData) {
		      e.clipboardData.clearData();
		      var content = lastCopied.text.join("\n");
		      // iOS exposes the clipboard API, but seems to discard content inserted into it
		      e.clipboardData.setData("Text", content);
		      if (e.clipboardData.getData("Text") == content) {
		        e.preventDefault();
		        return
		      }
		    }
		    // Old-fashioned briefly-focus-a-textarea hack
		    var kludge = hiddenTextarea(), te = kludge.firstChild;
		    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
		    te.value = lastCopied.text.join("\n");
		    var hadFocus = document.activeElement;
		    selectInput(te);
		    setTimeout(function () {
		      cm.display.lineSpace.removeChild(kludge);
		      hadFocus.focus();
		      if (hadFocus == div) { input.showPrimarySelection(); }
		    }, 50);
		  }
		  on(div, "copy", onCopyCut);
		  on(div, "cut", onCopyCut);
		};
		
		ContentEditableInput.prototype.prepareSelection = function () {
		  var result = prepareSelection(this.cm, false);
		  result.focus = this.cm.state.focused;
		  return result
		};
		
		ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
		  if (!info || !this.cm.display.view.length) { return }
		  if (info.focus || takeFocus) { this.showPrimarySelection(); }
		  this.showMultipleSelections(info);
		};
		
		ContentEditableInput.prototype.showPrimarySelection = function () {
		  var sel = window.getSelection(), prim = this.cm.doc.sel.primary();
		  var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);
		  var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);
		  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
		      cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&
		      cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)
		    { return }
		
		  var start = posToDOM(this.cm, prim.from());
		  var end = posToDOM(this.cm, prim.to());
		  if (!start && !end) {
		    sel.removeAllRanges();
		    return
		  }
		
		  var view = this.cm.display.view;
		  var old = sel.rangeCount && sel.getRangeAt(0);
		  if (!start) {
		    start = {node: view[0].measure.map[2], offset: 0};
		  } else if (!end) { // FIXME dangerously hacky
		    var measure = view[view.length - 1].measure;
		    var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
		    end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};
		  }
		
		  var rng;
		  try { rng = range(start.node, start.offset, end.offset, end.node); }
		  catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
		  if (rng) {
		    if (!gecko && this.cm.state.focused) {
		      sel.collapse(start.node, start.offset);
		      if (!rng.collapsed) {
		        sel.removeAllRanges();
		        sel.addRange(rng);
		      }
		    } else {
		      sel.removeAllRanges();
		      sel.addRange(rng);
		    }
		    if (old && sel.anchorNode == null) { sel.addRange(old); }
		    else if (gecko) { this.startGracePeriod(); }
		  }
		  this.rememberSelection();
		};
		
		ContentEditableInput.prototype.startGracePeriod = function () {
		    var this$1 = this;
		
		  clearTimeout(this.gracePeriod);
		  this.gracePeriod = setTimeout(function () {
		    this$1.gracePeriod = false;
		    if (this$1.selectionChanged())
		      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }
		  }, 20);
		};
		
		ContentEditableInput.prototype.showMultipleSelections = function (info) {
		  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
		  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
		};
		
		ContentEditableInput.prototype.rememberSelection = function () {
		  var sel = window.getSelection();
		  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
		  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
		};
		
		ContentEditableInput.prototype.selectionInEditor = function () {
		  var sel = window.getSelection();
		  if (!sel.rangeCount) { return false }
		  var node = sel.getRangeAt(0).commonAncestorContainer;
		  return contains(this.div, node)
		};
		
		ContentEditableInput.prototype.focus = function () {
		  if (this.cm.options.readOnly != "nocursor") {
		    if (!this.selectionInEditor())
		      { this.showSelection(this.prepareSelection(), true); }
		    this.div.focus();
		  }
		};
		ContentEditableInput.prototype.blur = function () { this.div.blur(); };
		ContentEditableInput.prototype.getField = function () { return this.div };
		
		ContentEditableInput.prototype.supportsTouch = function () { return true };
		
		ContentEditableInput.prototype.receivedFocus = function () {
		  var input = this;
		  if (this.selectionInEditor())
		    { this.pollSelection(); }
		  else
		    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }
		
		  function poll() {
		    if (input.cm.state.focused) {
		      input.pollSelection();
		      input.polling.set(input.cm.options.pollInterval, poll);
		    }
		  }
		  this.polling.set(this.cm.options.pollInterval, poll);
		};
		
		ContentEditableInput.prototype.selectionChanged = function () {
		  var sel = window.getSelection();
		  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
		    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
		};
		
		ContentEditableInput.prototype.pollSelection = function () {
		  if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
		  var sel = window.getSelection(), cm = this.cm;
		  // On Android Chrome (version 56, at least), backspacing into an
		  // uneditable block element will put the cursor in that element,
		  // and then, because it's not editable, hide the virtual keyboard.
		  // Because Android doesn't allow us to actually detect backspace
		  // presses in a sane way, this code checks for when that happens
		  // and simulates a backspace press in this case.
		  if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {
		    this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});
		    this.blur();
		    this.focus();
		    return
		  }
		  if (this.composing) { return }
		  this.rememberSelection();
		  var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
		  var head = domToPos(cm, sel.focusNode, sel.focusOffset);
		  if (anchor && head) { runInOp(cm, function () {
		    setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
		    if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }
		  }); }
		};
		
		ContentEditableInput.prototype.pollContent = function () {
		  if (this.readDOMTimeout != null) {
		    clearTimeout(this.readDOMTimeout);
		    this.readDOMTimeout = null;
		  }
		
		  var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
		  var from = sel.from(), to = sel.to();
		  if (from.ch == 0 && from.line > cm.firstLine())
		    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }
		  if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
		    { to = Pos(to.line + 1, 0); }
		  if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }
		
		  var fromIndex, fromLine, fromNode;
		  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
		    fromLine = lineNo(display.view[0].line);
		    fromNode = display.view[0].node;
		  } else {
		    fromLine = lineNo(display.view[fromIndex].line);
		    fromNode = display.view[fromIndex - 1].node.nextSibling;
		  }
		  var toIndex = findViewIndex(cm, to.line);
		  var toLine, toNode;
		  if (toIndex == display.view.length - 1) {
		    toLine = display.viewTo - 1;
		    toNode = display.lineDiv.lastChild;
		  } else {
		    toLine = lineNo(display.view[toIndex + 1].line) - 1;
		    toNode = display.view[toIndex + 1].node.previousSibling;
		  }
		
		  if (!fromNode) { return false }
		  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
		  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
		  while (newText.length > 1 && oldText.length > 1) {
		    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
		    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
		    else { break }
		  }
		
		  var cutFront = 0, cutEnd = 0;
		  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
		  while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
		    { ++cutFront; }
		  var newBot = lst(newText), oldBot = lst(oldText);
		  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
		                           oldBot.length - (oldText.length == 1 ? cutFront : 0));
		  while (cutEnd < maxCutEnd &&
		         newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
		    { ++cutEnd; }
		  // Try to move start of change to start of selection if ambiguous
		  if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
		    while (cutFront && cutFront > from.ch &&
		           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
		      cutFront--;
		      cutEnd++;
		    }
		  }
		
		  newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
		  newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
		
		  var chFrom = Pos(fromLine, cutFront);
		  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
		  if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
		    replaceRange(cm.doc, newText, chFrom, chTo, "+input");
		    return true
		  }
		};
		
		ContentEditableInput.prototype.ensurePolled = function () {
		  this.forceCompositionEnd();
		};
		ContentEditableInput.prototype.reset = function () {
		  this.forceCompositionEnd();
		};
		ContentEditableInput.prototype.forceCompositionEnd = function () {
		  if (!this.composing) { return }
		  clearTimeout(this.readDOMTimeout);
		  this.composing = null;
		  this.updateFromDOM();
		  this.div.blur();
		  this.div.focus();
		};
		ContentEditableInput.prototype.readFromDOMSoon = function () {
		    var this$1 = this;
		
		  if (this.readDOMTimeout != null) { return }
		  this.readDOMTimeout = setTimeout(function () {
		    this$1.readDOMTimeout = null;
		    if (this$1.composing) {
		      if (this$1.composing.done) { this$1.composing = null; }
		      else { return }
		    }
		    this$1.updateFromDOM();
		  }, 80);
		};
		
		ContentEditableInput.prototype.updateFromDOM = function () {
		    var this$1 = this;
		
		  if (this.cm.isReadOnly() || !this.pollContent())
		    { runInOp(this.cm, function () { return regChange(this$1.cm); }); }
		};
		
		ContentEditableInput.prototype.setUneditable = function (node) {
		  node.contentEditable = "false";
		};
		
		ContentEditableInput.prototype.onKeyPress = function (e) {
		  if (e.charCode == 0) { return }
		  e.preventDefault();
		  if (!this.cm.isReadOnly())
		    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }
		};
		
		ContentEditableInput.prototype.readOnlyChanged = function (val) {
		  this.div.contentEditable = String(val != "nocursor");
		};
		
		ContentEditableInput.prototype.onContextMenu = function () {};
		ContentEditableInput.prototype.resetPosition = function () {};
		
		ContentEditableInput.prototype.needsContentAttribute = true;
		
		function posToDOM(cm, pos) {
		  var view = findViewForLine(cm, pos.line);
		  if (!view || view.hidden) { return null }
		  var line = getLine(cm.doc, pos.line);
		  var info = mapFromLineView(view, line, pos.line);
		
		  var order = getOrder(line, cm.doc.direction), side = "left";
		  if (order) {
		    var partPos = getBidiPartAt(order, pos.ch);
		    side = partPos % 2 ? "right" : "left";
		  }
		  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
		  result.offset = result.collapse == "right" ? result.end : result.start;
		  return result
		}
		
		function isInGutter(node) {
		  for (var scan = node; scan; scan = scan.parentNode)
		    { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
		  return false
		}
		
		function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }
		
		function domTextBetween(cm, from, to, fromLine, toLine) {
		  var text = "", closing = false, lineSep = cm.doc.lineSeparator();
		  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
		  function close() {
		    if (closing) {
		      text += lineSep;
		      closing = false;
		    }
		  }
		  function addText(str) {
		    if (str) {
		      close();
		      text += str;
		    }
		  }
		  function walk(node) {
		    if (node.nodeType == 1) {
		      var cmText = node.getAttribute("cm-text");
		      if (cmText != null) {
		        addText(cmText || node.textContent.replace(/\u200b/g, ""));
		        return
		      }
		      var markerID = node.getAttribute("cm-marker"), range$$1;
		      if (markerID) {
		        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
		        if (found.length && (range$$1 = found[0].find()))
		          { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }
		        return
		      }
		      if (node.getAttribute("contenteditable") == "false") { return }
		      var isBlock = /^(pre|div|p)$/i.test(node.nodeName);
		      if (isBlock) { close(); }
		      for (var i = 0; i < node.childNodes.length; i++)
		        { walk(node.childNodes[i]); }
		      if (isBlock) { closing = true; }
		    } else if (node.nodeType == 3) {
		      addText(node.nodeValue);
		    }
		  }
		  for (;;) {
		    walk(from);
		    if (from == to) { break }
		    from = from.nextSibling;
		  }
		  return text
		}
		
		function domToPos(cm, node, offset) {
		  var lineNode;
		  if (node == cm.display.lineDiv) {
		    lineNode = cm.display.lineDiv.childNodes[offset];
		    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
		    node = null; offset = 0;
		  } else {
		    for (lineNode = node;; lineNode = lineNode.parentNode) {
		      if (!lineNode || lineNode == cm.display.lineDiv) { return null }
		      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
		    }
		  }
		  for (var i = 0; i < cm.display.view.length; i++) {
		    var lineView = cm.display.view[i];
		    if (lineView.node == lineNode)
		      { return locateNodeInLineView(lineView, node, offset) }
		  }
		}
		
		function locateNodeInLineView(lineView, node, offset) {
		  var wrapper = lineView.text.firstChild, bad = false;
		  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
		  if (node == wrapper) {
		    bad = true;
		    node = wrapper.childNodes[offset];
		    offset = 0;
		    if (!node) {
		      var line = lineView.rest ? lst(lineView.rest) : lineView.line;
		      return badPos(Pos(lineNo(line), line.text.length), bad)
		    }
		  }
		
		  var textNode = node.nodeType == 3 ? node : null, topNode = node;
		  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
		    textNode = node.firstChild;
		    if (offset) { offset = textNode.nodeValue.length; }
		  }
		  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }
		  var measure = lineView.measure, maps = measure.maps;
		
		  function find(textNode, topNode, offset) {
		    for (var i = -1; i < (maps ? maps.length : 0); i++) {
		      var map$$1 = i < 0 ? measure.map : maps[i];
		      for (var j = 0; j < map$$1.length; j += 3) {
		        var curNode = map$$1[j + 2];
		        if (curNode == textNode || curNode == topNode) {
		          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
		          var ch = map$$1[j] + offset;
		          if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }
		          return Pos(line, ch)
		        }
		      }
		    }
		  }
		  var found = find(textNode, topNode, offset);
		  if (found) { return badPos(found, bad) }
		
		  // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
		  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
		    found = find(after, after.firstChild, 0);
		    if (found)
		      { return badPos(Pos(found.line, found.ch - dist), bad) }
		    else
		      { dist += after.textContent.length; }
		  }
		  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
		    found = find(before, before.firstChild, -1);
		    if (found)
		      { return badPos(Pos(found.line, found.ch + dist$1), bad) }
		    else
		      { dist$1 += before.textContent.length; }
		  }
		}
		
		// TEXTAREA INPUT STYLE
		
		var TextareaInput = function(cm) {
		  this.cm = cm;
		  // See input.poll and input.reset
		  this.prevInput = "";
		
		  // Flag that indicates whether we expect input to appear real soon
		  // now (after some event like 'keypress' or 'input') and are
		  // polling intensively.
		  this.pollingFast = false;
		  // Self-resetting timeout for the poller
		  this.polling = new Delayed();
		  // Tracks when input.reset has punted to just putting a short
		  // string into the textarea instead of the full selection.
		  this.inaccurateSelection = false;
		  // Used to work around IE issue with selection being forgotten when focus moves away from textarea
		  this.hasSelection = false;
		  this.composing = null;
		};
		
		TextareaInput.prototype.init = function (display) {
		    var this$1 = this;
		
		  var input = this, cm = this.cm;
		
		  // Wraps and hides input textarea
		  var div = this.wrapper = hiddenTextarea();
		  // The semihidden textarea that is focused when the editor is
		  // focused, and receives input.
		  var te = this.textarea = div.firstChild;
		  display.wrapper.insertBefore(div, display.wrapper.firstChild);
		
		  // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
		  if (ios) { te.style.width = "0px"; }
		
		  on(te, "input", function () {
		    if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }
		    input.poll();
		  });
		
		  on(te, "paste", function (e) {
		    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
		
		    cm.state.pasteIncoming = true;
		    input.fastPoll();
		  });
		
		  function prepareCopyCut(e) {
		    if (signalDOMEvent(cm, e)) { return }
		    if (cm.somethingSelected()) {
		      setLastCopied({lineWise: false, text: cm.getSelections()});
		      if (input.inaccurateSelection) {
		        input.prevInput = "";
		        input.inaccurateSelection = false;
		        te.value = lastCopied.text.join("\n");
		        selectInput(te);
		      }
		    } else if (!cm.options.lineWiseCopyCut) {
		      return
		    } else {
		      var ranges = copyableRanges(cm);
		      setLastCopied({lineWise: true, text: ranges.text});
		      if (e.type == "cut") {
		        cm.setSelections(ranges.ranges, null, sel_dontScroll);
		      } else {
		        input.prevInput = "";
		        te.value = ranges.text.join("\n");
		        selectInput(te);
		      }
		    }
		    if (e.type == "cut") { cm.state.cutIncoming = true; }
		  }
		  on(te, "cut", prepareCopyCut);
		  on(te, "copy", prepareCopyCut);
		
		  on(display.scroller, "paste", function (e) {
		    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
		    cm.state.pasteIncoming = true;
		    input.focus();
		  });
		
		  // Prevent normal selection in the editor (we handle our own)
		  on(display.lineSpace, "selectstart", function (e) {
		    if (!eventInWidget(display, e)) { e_preventDefault(e); }
		  });
		
		  on(te, "compositionstart", function () {
		    var start = cm.getCursor("from");
		    if (input.composing) { input.composing.range.clear(); }
		    input.composing = {
		      start: start,
		      range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
		    };
		  });
		  on(te, "compositionend", function () {
		    if (input.composing) {
		      input.poll();
		      input.composing.range.clear();
		      input.composing = null;
		    }
		  });
		};
		
		TextareaInput.prototype.prepareSelection = function () {
		  // Redraw the selection and/or cursor
		  var cm = this.cm, display = cm.display, doc = cm.doc;
		  var result = prepareSelection(cm);
		
		  // Move the hidden textarea near the cursor to prevent scrolling artifacts
		  if (cm.options.moveInputWithCursor) {
		    var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
		    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
		    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
		                                        headPos.top + lineOff.top - wrapOff.top));
		    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
		                                         headPos.left + lineOff.left - wrapOff.left));
		  }
		
		  return result
		};
		
		TextareaInput.prototype.showSelection = function (drawn) {
		  var cm = this.cm, display = cm.display;
		  removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
		  removeChildrenAndAdd(display.selectionDiv, drawn.selection);
		  if (drawn.teTop != null) {
		    this.wrapper.style.top = drawn.teTop + "px";
		    this.wrapper.style.left = drawn.teLeft + "px";
		  }
		};
		
		// Reset the input to correspond to the selection (or to be empty,
		// when not typing and nothing is selected)
		TextareaInput.prototype.reset = function (typing) {
		  if (this.contextMenuPending) { return }
		  var minimal, selected, cm = this.cm, doc = cm.doc;
		  if (cm.somethingSelected()) {
		    this.prevInput = "";
		    var range$$1 = doc.sel.primary();
		    minimal = hasCopyEvent &&
		      (range$$1.to().line - range$$1.from().line > 100 || (selected = cm.getSelection()).length > 1000);
		    var content = minimal ? "-" : selected || cm.getSelection();
		    this.textarea.value = content;
		    if (cm.state.focused) { selectInput(this.textarea); }
		    if (ie && ie_version >= 9) { this.hasSelection = content; }
		  } else if (!typing) {
		    this.prevInput = this.textarea.value = "";
		    if (ie && ie_version >= 9) { this.hasSelection = null; }
		  }
		  this.inaccurateSelection = minimal;
		};
		
		TextareaInput.prototype.getField = function () { return this.textarea };
		
		TextareaInput.prototype.supportsTouch = function () { return false };
		
		TextareaInput.prototype.focus = function () {
		  if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
		    try { this.textarea.focus(); }
		    catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
		  }
		};
		
		TextareaInput.prototype.blur = function () { this.textarea.blur(); };
		
		TextareaInput.prototype.resetPosition = function () {
		  this.wrapper.style.top = this.wrapper.style.left = 0;
		};
		
		TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };
		
		// Poll for input changes, using the normal rate of polling. This
		// runs as long as the editor is focused.
		TextareaInput.prototype.slowPoll = function () {
		    var this$1 = this;
		
		  if (this.pollingFast) { return }
		  this.polling.set(this.cm.options.pollInterval, function () {
		    this$1.poll();
		    if (this$1.cm.state.focused) { this$1.slowPoll(); }
		  });
		};
		
		// When an event has just come in that is likely to add or change
		// something in the input textarea, we poll faster, to ensure that
		// the change appears on the screen quickly.
		TextareaInput.prototype.fastPoll = function () {
		  var missed = false, input = this;
		  input.pollingFast = true;
		  function p() {
		    var changed = input.poll();
		    if (!changed && !missed) {missed = true; input.polling.set(60, p);}
		    else {input.pollingFast = false; input.slowPoll();}
		  }
		  input.polling.set(20, p);
		};
		
		// Read input from the textarea, and update the document to match.
		// When something is selected, it is present in the textarea, and
		// selected (unless it is huge, in which case a placeholder is
		// used). When nothing is selected, the cursor sits after previously
		// seen text (can be empty), which is stored in prevInput (we must
		// not reset the textarea when typing, because that breaks IME).
		TextareaInput.prototype.poll = function () {
		    var this$1 = this;
		
		  var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
		  // Since this is called a *lot*, try to bail out as cheaply as
		  // possible when it is clear that nothing happened. hasSelection
		  // will be the case when there is a lot of text in the textarea,
		  // in which case reading its value would be expensive.
		  if (this.contextMenuPending || !cm.state.focused ||
		      (hasSelection(input) && !prevInput && !this.composing) ||
		      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
		    { return false }
		
		  var text = input.value;
		  // If nothing changed, bail.
		  if (text == prevInput && !cm.somethingSelected()) { return false }
		  // Work around nonsensical selection resetting in IE9/10, and
		  // inexplicable appearance of private area unicode characters on
		  // some key combos in Mac (#2689).
		  if (ie && ie_version >= 9 && this.hasSelection === text ||
		      mac && /[\uf700-\uf7ff]/.test(text)) {
		    cm.display.input.reset();
		    return false
		  }
		
		  if (cm.doc.sel == cm.display.selForContextMenu) {
		    var first = text.charCodeAt(0);
		    if (first == 0x200b && !prevInput) { prevInput = "\u200b"; }
		    if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
		  }
		  // Find the part of the input that is actually new
		  var same = 0, l = Math.min(prevInput.length, text.length);
		  while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }
		
		  runInOp(cm, function () {
		    applyTextInput(cm, text.slice(same), prevInput.length - same,
		                   null, this$1.composing ? "*compose" : null);
		
		    // Don't leave long text in the textarea, since it makes further polling slow
		    if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = ""; }
		    else { this$1.prevInput = text; }
		
		    if (this$1.composing) {
		      this$1.composing.range.clear();
		      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
		                                         {className: "CodeMirror-composing"});
		    }
		  });
		  return true
		};
		
		TextareaInput.prototype.ensurePolled = function () {
		  if (this.pollingFast && this.poll()) { this.pollingFast = false; }
		};
		
		TextareaInput.prototype.onKeyPress = function () {
		  if (ie && ie_version >= 9) { this.hasSelection = null; }
		  this.fastPoll();
		};
		
		TextareaInput.prototype.onContextMenu = function (e) {
		  var input = this, cm = input.cm, display = cm.display, te = input.textarea;
		  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
		  if (!pos || presto) { return } // Opera is difficult.
		
		  // Reset the current text selection only if the click is done outside of the selection
		  // and 'resetSelectionOnContextMenu' option is true.
		  var reset = cm.options.resetSelectionOnContextMenu;
		  if (reset && cm.doc.sel.contains(pos) == -1)
		    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }
		
		  var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
		  input.wrapper.style.cssText = "position: absolute";
		  var wrapperBox = input.wrapper.getBoundingClientRect();
		  te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
		  var oldScrollY;
		  if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)
		  display.input.focus();
		  if (webkit) { window.scrollTo(null, oldScrollY); }
		  display.input.reset();
		  // Adds "Select all" to context menu in FF
		  if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }
		  input.contextMenuPending = true;
		  display.selForContextMenu = cm.doc.sel;
		  clearTimeout(display.detectingSelectAll);
		
		  // Select-all will be greyed out if there's nothing to select, so
		  // this adds a zero-width space so that we can later check whether
		  // it got selected.
		  function prepareSelectAllHack() {
		    if (te.selectionStart != null) {
		      var selected = cm.somethingSelected();
		      var extval = "\u200b" + (selected ? te.value : "");
		      te.value = "\u21da"; // Used to catch context-menu undo
		      te.value = extval;
		      input.prevInput = selected ? "" : "\u200b";
		      te.selectionStart = 1; te.selectionEnd = extval.length;
		      // Re-set this, in case some other handler touched the
		      // selection in the meantime.
		      display.selForContextMenu = cm.doc.sel;
		    }
		  }
		  function rehide() {
		    input.contextMenuPending = false;
		    input.wrapper.style.cssText = oldWrapperCSS;
		    te.style.cssText = oldCSS;
		    if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }
		
		    // Try to detect the user choosing select-all
		    if (te.selectionStart != null) {
		      if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }
		      var i = 0, poll = function () {
		        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
		            te.selectionEnd > 0 && input.prevInput == "\u200b") {
		          operation(cm, selectAll)(cm);
		        } else if (i++ < 10) {
		          display.detectingSelectAll = setTimeout(poll, 500);
		        } else {
		          display.selForContextMenu = null;
		          display.input.reset();
		        }
		      };
		      display.detectingSelectAll = setTimeout(poll, 200);
		    }
		  }
		
		  if (ie && ie_version >= 9) { prepareSelectAllHack(); }
		  if (captureRightClick) {
		    e_stop(e);
		    var mouseup = function () {
		      off(window, "mouseup", mouseup);
		      setTimeout(rehide, 20);
		    };
		    on(window, "mouseup", mouseup);
		  } else {
		    setTimeout(rehide, 50);
		  }
		};
		
		TextareaInput.prototype.readOnlyChanged = function (val) {
		  if (!val) { this.reset(); }
		};
		
		TextareaInput.prototype.setUneditable = function () {};
		
		TextareaInput.prototype.needsContentAttribute = false;
		
		function fromTextArea(textarea, options) {
		  options = options ? copyObj(options) : {};
		  options.value = textarea.value;
		  if (!options.tabindex && textarea.tabIndex)
		    { options.tabindex = textarea.tabIndex; }
		  if (!options.placeholder && textarea.placeholder)
		    { options.placeholder = textarea.placeholder; }
		  // Set autofocus to true if this textarea is focused, or if it has
		  // autofocus and no other element is focused.
		  if (options.autofocus == null) {
		    var hasFocus = activeElt();
		    options.autofocus = hasFocus == textarea ||
		      textarea.getAttribute("autofocus") != null && hasFocus == document.body;
		  }
		
		  function save() {textarea.value = cm.getValue();}
		
		  var realSubmit;
		  if (textarea.form) {
		    on(textarea.form, "submit", save);
		    // Deplorable hack to make the submit method do the right thing.
		    if (!options.leaveSubmitMethodAlone) {
		      var form = textarea.form;
		      realSubmit = form.submit;
		      try {
		        var wrappedSubmit = form.submit = function () {
		          save();
		          form.submit = realSubmit;
		          form.submit();
		          form.submit = wrappedSubmit;
		        };
		      } catch(e) {}
		    }
		  }
		
		  options.finishInit = function (cm) {
		    cm.save = save;
		    cm.getTextArea = function () { return textarea; };
		    cm.toTextArea = function () {
		      cm.toTextArea = isNaN; // Prevent this from being ran twice
		      save();
		      textarea.parentNode.removeChild(cm.getWrapperElement());
		      textarea.style.display = "";
		      if (textarea.form) {
		        off(textarea.form, "submit", save);
		        if (typeof textarea.form.submit == "function")
		          { textarea.form.submit = realSubmit; }
		      }
		    };
		  };
		
		  textarea.style.display = "none";
		  var cm = CodeMirror$1(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
		    options);
		  return cm
		}
		
		function addLegacyProps(CodeMirror) {
		  CodeMirror.off = off;
		  CodeMirror.on = on;
		  CodeMirror.wheelEventPixels = wheelEventPixels;
		  CodeMirror.Doc = Doc;
		  CodeMirror.splitLines = splitLinesAuto;
		  CodeMirror.countColumn = countColumn;
		  CodeMirror.findColumn = findColumn;
		  CodeMirror.isWordChar = isWordCharBasic;
		  CodeMirror.Pass = Pass;
		  CodeMirror.signal = signal;
		  CodeMirror.Line = Line;
		  CodeMirror.changeEnd = changeEnd;
		  CodeMirror.scrollbarModel = scrollbarModel;
		  CodeMirror.Pos = Pos;
		  CodeMirror.cmpPos = cmp;
		  CodeMirror.modes = modes;
		  CodeMirror.mimeModes = mimeModes;
		  CodeMirror.resolveMode = resolveMode;
		  CodeMirror.getMode = getMode;
		  CodeMirror.modeExtensions = modeExtensions;
		  CodeMirror.extendMode = extendMode;
		  CodeMirror.copyState = copyState;
		  CodeMirror.startState = startState;
		  CodeMirror.innerMode = innerMode;
		  CodeMirror.commands = commands;
		  CodeMirror.keyMap = keyMap;
		  CodeMirror.keyName = keyName;
		  CodeMirror.isModifierKey = isModifierKey;
		  CodeMirror.lookupKey = lookupKey;
		  CodeMirror.normalizeKeyMap = normalizeKeyMap;
		  CodeMirror.StringStream = StringStream;
		  CodeMirror.SharedTextMarker = SharedTextMarker;
		  CodeMirror.TextMarker = TextMarker;
		  CodeMirror.LineWidget = LineWidget;
		  CodeMirror.e_preventDefault = e_preventDefault;
		  CodeMirror.e_stopPropagation = e_stopPropagation;
		  CodeMirror.e_stop = e_stop;
		  CodeMirror.addClass = addClass;
		  CodeMirror.contains = contains;
		  CodeMirror.rmClass = rmClass;
		  CodeMirror.keyNames = keyNames;
		}
		
		// EDITOR CONSTRUCTOR
		
		defineOptions(CodeMirror$1);
		
		addEditorMethods(CodeMirror$1);
		
		// Set up methods on CodeMirror's prototype to redirect to the editor's document.
		var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
		for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
		  { CodeMirror$1.prototype[prop] = (function(method) {
		    return function() {return method.apply(this.doc, arguments)}
		  })(Doc.prototype[prop]); } }
		
		eventMixin(Doc);
		
		// INPUT HANDLING
		
		CodeMirror$1.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};
		
		// MODE DEFINITION AND QUERYING
		
		// Extra arguments are stored as the mode's dependencies, which is
		// used by (legacy) mechanisms like loadmode.js to automatically
		// load a mode. (Preferred mechanism is the require/define calls.)
		CodeMirror$1.defineMode = function(name/*, mode, …*/) {
		  if (!CodeMirror$1.defaults.mode && name != "null") { CodeMirror$1.defaults.mode = name; }
		  defineMode.apply(this, arguments);
		};
		
		CodeMirror$1.defineMIME = defineMIME;
		
		// Minimal default mode.
		CodeMirror$1.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
		CodeMirror$1.defineMIME("text/plain", "null");
		
		// EXTENSIONS
		
		CodeMirror$1.defineExtension = function (name, func) {
		  CodeMirror$1.prototype[name] = func;
		};
		CodeMirror$1.defineDocExtension = function (name, func) {
		  Doc.prototype[name] = func;
		};
		
		CodeMirror$1.fromTextArea = fromTextArea;
		
		addLegacyProps(CodeMirror$1);
		
		CodeMirror$1.version = "5.25.0";
		
		return CodeMirror$1;
		
		})));
	
	
	/***/ },
	/* 162 */
	/***/ function(module, exports, __webpack_require__) {
	
		// CodeMirror, copyright (c) by Marijn Haverbeke and others
		// Distributed under an MIT license: http://codemirror.net/LICENSE
		
		(function(mod) {
		  if (true) // CommonJS
		    mod(__webpack_require__(161));
		  else if (typeof define == "function" && define.amd) // AMD
		    define(["../../lib/codemirror"], mod);
		  else // Plain browser env
		    mod(CodeMirror);
		})(function(CodeMirror) {
		  "use strict";
		
		  var listRE = /^(\s*)(>[> ]*|[*+-] \[[x ]\]\s|[*+-]\s|(\d+)([.)]))(\s*)/,
		      emptyListRE = /^(\s*)(>[> ]*|[*+-] \[[x ]\]|[*+-]|(\d+)[.)])(\s*)$/,
		      unorderedListRE = /[*+-]\s/;
		
		  CodeMirror.commands.newlineAndIndentContinueMarkdownList = function(cm) {
		    if (cm.getOption("disableInput")) return CodeMirror.Pass;
		    var ranges = cm.listSelections(), replacements = [];
		    for (var i = 0; i < ranges.length; i++) {
		      var pos = ranges[i].head;
		      var eolState = cm.getStateAfter(pos.line);
		      var inList = eolState.list !== false;
		      var inQuote = eolState.quote !== 0;
		
		      var line = cm.getLine(pos.line), match = listRE.exec(line);
		      if (!ranges[i].empty() || (!inList && !inQuote) || !match) {
		        cm.execCommand("newlineAndIndent");
		        return;
		      }
		      if (emptyListRE.test(line)) {
		        if (!/>\s*$/.test(line)) cm.replaceRange("", {
		          line: pos.line, ch: 0
		        }, {
		          line: pos.line, ch: pos.ch + 1
		        });
		        replacements[i] = "\n";
		      } else {
		        var indent = match[1], after = match[5];
		        var bullet = unorderedListRE.test(match[2]) || match[2].indexOf(">") >= 0
		          ? match[2].replace("x", " ")
		          : (parseInt(match[3], 10) + 1) + match[4];
		
		        replacements[i] = "\n" + indent + bullet + after;
		      }
		    }
		
		    cm.replaceSelections(replacements);
		  };
		});
	
	
	/***/ },
	/* 163 */
	/***/ function(module, exports, __webpack_require__) {
	
		// CodeMirror, copyright (c) by Marijn Haverbeke and others
		// Distributed under an MIT license: http://codemirror.net/LICENSE
		
		var CodeMirror = __webpack_require__(161);
		
		CodeMirror.commands.tabAndIndentMarkdownList = function (cm) {
			var ranges = cm.listSelections();
			var pos = ranges[0].head;
			var eolState = cm.getStateAfter(pos.line);
			var inList = eolState.list !== false;
		
			if (inList) {
				cm.execCommand("indentMore");
				return;
			}
		
			if (cm.options.indentWithTabs) {
				cm.execCommand("insertTab");
			}
			else {
				var spaces = Array(cm.options.tabSize + 1).join(" ");
				cm.replaceSelection(spaces);
			}
		};
		
		CodeMirror.commands.shiftTabAndUnindentMarkdownList = function (cm) {
			var ranges = cm.listSelections();
			var pos = ranges[0].head;
			var eolState = cm.getStateAfter(pos.line);
			var inList = eolState.list !== false;
		
			if (inList) {
				cm.execCommand("indentLess");
				return;
			}
		
			if (cm.options.indentWithTabs) {
				cm.execCommand("insertTab");
			}
			else {
				var spaces = Array(cm.options.tabSize + 1).join(" ");
				cm.replaceSelection(spaces);
			}
		};
	
	
	/***/ },
	/* 164 */
	/***/ function(module, exports, __webpack_require__) {
	
		// CodeMirror, copyright (c) by Marijn Haverbeke and others
		// Distributed under an MIT license: http://codemirror.net/LICENSE
		
		(function(mod) {
		  if (true) // CommonJS
		    mod(__webpack_require__(161));
		  else if (typeof define == "function" && define.amd) // AMD
		    define(["../../lib/codemirror"], mod);
		  else // Plain browser env
		    mod(CodeMirror);
		})(function(CodeMirror) {
		  "use strict";
		
		  CodeMirror.defineOption("fullScreen", false, function(cm, val, old) {
		    if (old == CodeMirror.Init) old = false;
		    if (!old == !val) return;
		    if (val) setFullscreen(cm);
		    else setNormal(cm);
		  });
		
		  function setFullscreen(cm) {
		    var wrap = cm.getWrapperElement();
		    cm.state.fullScreenRestore = {scrollTop: window.pageYOffset, scrollLeft: window.pageXOffset,
		                                  width: wrap.style.width, height: wrap.style.height};
		    wrap.style.width = "";
		    wrap.style.height = "auto";
		    wrap.className += " CodeMirror-fullscreen";
		    document.documentElement.style.overflow = "hidden";
		    cm.refresh();
		  }
		
		  function setNormal(cm) {
		    var wrap = cm.getWrapperElement();
		    wrap.className = wrap.className.replace(/\s*CodeMirror-fullscreen\b/, "");
		    document.documentElement.style.overflow = "";
		    var info = cm.state.fullScreenRestore;
		    wrap.style.width = info.width; wrap.style.height = info.height;
		    window.scrollTo(info.scrollLeft, info.scrollTop);
		    cm.refresh();
		  }
		});
	
	
	/***/ },
	/* 165 */
	/***/ function(module, exports, __webpack_require__) {
	
		// CodeMirror, copyright (c) by Marijn Haverbeke and others
		// Distributed under an MIT license: http://codemirror.net/LICENSE
		
		(function(mod) {
		  if (true) // CommonJS
		    mod(__webpack_require__(161), __webpack_require__(166), __webpack_require__(167));
		  else if (typeof define == "function" && define.amd) // AMD
		    define(["../../lib/codemirror", "../xml/xml", "../meta"], mod);
		  else // Plain browser env
		    mod(CodeMirror);
		})(function(CodeMirror) {
		"use strict";
		
		CodeMirror.defineMode("markdown", function(cmCfg, modeCfg) {
		
		  var htmlMode = CodeMirror.getMode(cmCfg, "text/html");
		  var htmlModeMissing = htmlMode.name == "null"
		
		  function getMode(name) {
		    if (CodeMirror.findModeByName) {
		      var found = CodeMirror.findModeByName(name);
		      if (found) name = found.mime || found.mimes[0];
		    }
		    var mode = CodeMirror.getMode(cmCfg, name);
		    return mode.name == "null" ? null : mode;
		  }
		
		  // Should characters that affect highlighting be highlighted separate?
		  // Does not include characters that will be output (such as `1.` and `-` for lists)
		  if (modeCfg.highlightFormatting === undefined)
		    modeCfg.highlightFormatting = false;
		
		  // Maximum number of nested blockquotes. Set to 0 for infinite nesting.
		  // Excess `>` will emit `error` token.
		  if (modeCfg.maxBlockquoteDepth === undefined)
		    modeCfg.maxBlockquoteDepth = 0;
		
		  // Should underscores in words open/close em/strong?
		  if (modeCfg.underscoresBreakWords === undefined)
		    modeCfg.underscoresBreakWords = true;
		
		  // Use `fencedCodeBlocks` to configure fenced code blocks. false to
		  // disable, string to specify a precise regexp that the fence should
		  // match, and true to allow three or more backticks or tildes (as
		  // per CommonMark).
		
		  // Turn on task lists? ("- [ ] " and "- [x] ")
		  if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;
		
		  // Turn on strikethrough syntax
		  if (modeCfg.strikethrough === undefined)
		    modeCfg.strikethrough = false;
		
		  // Allow token types to be overridden by user-provided token types.
		  if (modeCfg.tokenTypeOverrides === undefined)
		    modeCfg.tokenTypeOverrides = {};
		
		  var tokenTypes = {
		    header: "header",
		    code: "comment",
		    quote: "quote",
		    list1: "variable-2",
		    list2: "variable-3",
		    list3: "keyword",
		    hr: "hr",
		    image: "image",
		    imageAltText: "image-alt-text",
		    imageMarker: "image-marker",
		    formatting: "formatting",
		    linkInline: "link",
		    linkEmail: "link",
		    linkText: "link",
		    linkHref: "string",
		    em: "em",
		    strong: "strong",
		    strikethrough: "strikethrough"
		  };
		
		  for (var tokenType in tokenTypes) {
		    if (tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType]) {
		      tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];
		    }
		  }
		
		  var hrRE = /^([*\-_])(?:\s*\1){2,}\s*$/
		  ,   listRE = /^(?:[*\-+]|^[0-9]+([.)]))\s+/
		  ,   taskListRE = /^\[(x| )\](?=\s)/ // Must follow listRE
		  ,   atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/
		  ,   setextHeaderRE = /^ *(?:\={1,}|-{1,})\s*$/
		  ,   textRE = /^[^#!\[\]*_\\<>` "'(~]+/
		  ,   fencedCodeRE = new RegExp("^(" + (modeCfg.fencedCodeBlocks === true ? "~~~+|```+" : modeCfg.fencedCodeBlocks) +
		                                ")[ \\t]*([\\w+#\-]*)");
		
		  function switchInline(stream, state, f) {
		    state.f = state.inline = f;
		    return f(stream, state);
		  }
		
		  function switchBlock(stream, state, f) {
		    state.f = state.block = f;
		    return f(stream, state);
		  }
		
		  function lineIsEmpty(line) {
		    return !line || !/\S/.test(line.string)
		  }
		
		  // Blocks
		
		  function blankLine(state) {
		    // Reset linkTitle state
		    state.linkTitle = false;
		    // Reset EM state
		    state.em = false;
		    // Reset STRONG state
		    state.strong = false;
		    // Reset strikethrough state
		    state.strikethrough = false;
		    // Reset state.quote
		    state.quote = 0;
		    // Reset state.indentedCode
		    state.indentedCode = false;
		    if (state.f == htmlBlock) {
		      state.f = inlineNormal;
		      state.block = blockNormal;
		    }
		    // Reset state.trailingSpace
		    state.trailingSpace = 0;
		    state.trailingSpaceNewLine = false;
		    // Mark this line as blank
		    state.prevLine = state.thisLine
		    state.thisLine = null
		    return null;
		  }
		
		  function blockNormal(stream, state) {
		
		    var sol = stream.sol();
		
		    var prevLineIsList = state.list !== false,
		        prevLineIsIndentedCode = state.indentedCode;
		
		    state.indentedCode = false;
		
		    if (prevLineIsList) {
		      if (state.indentationDiff >= 0) { // Continued list
		        if (state.indentationDiff < 4) { // Only adjust indentation if *not* a code block
		          state.indentation -= state.indentationDiff;
		        }
		        state.list = null;
		      } else if (state.indentation > 0) {
		        state.list = null;
		      } else { // No longer a list
		        state.list = false;
		      }
		    }
		
		    var match = null;
		    if (state.indentationDiff >= 4) {
		      stream.skipToEnd();
		      if (prevLineIsIndentedCode || lineIsEmpty(state.prevLine)) {
		        state.indentation -= 4;
		        state.indentedCode = true;
		        return tokenTypes.code;
		      } else {
		        return null;
		      }
		    } else if (stream.eatSpace()) {
		      return null;
		    } else if ((match = stream.match(atxHeaderRE)) && match[1].length <= 6) {
		      state.header = match[1].length;
		      if (modeCfg.highlightFormatting) state.formatting = "header";
		      state.f = state.inline;
		      return getType(state);
		    } else if (!lineIsEmpty(state.prevLine) && !state.quote && !prevLineIsList &&
		               !prevLineIsIndentedCode && (match = stream.match(setextHeaderRE))) {
		      state.header = match[0].charAt(0) == '=' ? 1 : 2;
		      if (modeCfg.highlightFormatting) state.formatting = "header";
		      state.f = state.inline;
		      return getType(state);
		    } else if (stream.eat('>')) {
		      state.quote = sol ? 1 : state.quote + 1;
		      if (modeCfg.highlightFormatting) state.formatting = "quote";
		      stream.eatSpace();
		      return getType(state);
		    } else if (stream.peek() === '[') {
		      return switchInline(stream, state, footnoteLink);
		    } else if (stream.match(hrRE, true)) {
		      state.hr = true;
		      return tokenTypes.hr;
		    } else if (match = stream.match(listRE)) {
		      var listType = match[1] ? "ol" : "ul";
		      state.indentation = stream.column() + stream.current().length;
		      state.list = true;
		
		      // While this list item's marker's indentation
		      // is less than the deepest list item's content's indentation,
		      // pop the deepest list item indentation off the stack.
		      while (state.listStack && stream.column() < state.listStack[state.listStack.length - 1]) {
		        state.listStack.pop();
		      }
		
		      // Add this list item's content's indentation to the stack
		      state.listStack.push(state.indentation);
		
		      if (modeCfg.taskLists && stream.match(taskListRE, false)) {
		        state.taskList = true;
		      }
		      state.f = state.inline;
		      if (modeCfg.highlightFormatting) state.formatting = ["list", "list-" + listType];
		      return getType(state);
		    } else if (modeCfg.fencedCodeBlocks && (match = stream.match(fencedCodeRE, true))) {
		      state.fencedChars = match[1]
		      // try switching mode
		      state.localMode = getMode(match[2]);
		      if (state.localMode) state.localState = CodeMirror.startState(state.localMode);
		      state.f = state.block = local;
		      if (modeCfg.highlightFormatting) state.formatting = "code-block";
		      state.code = -1
		      return getType(state);
		    }
		
		    return switchInline(stream, state, state.inline);
		  }
		
		  function htmlBlock(stream, state) {
		    var style = htmlMode.token(stream, state.htmlState);
		    if (!htmlModeMissing) {
		      var inner = CodeMirror.innerMode(htmlMode, state.htmlState)
		      if ((inner.mode.name == "xml" && inner.state.tagStart === null &&
		           (!inner.state.context && inner.state.tokenize.isInText)) ||
		          (state.md_inside && stream.current().indexOf(">") > -1)) {
		        state.f = inlineNormal;
		        state.block = blockNormal;
		        state.htmlState = null;
		      }
		    }
		    return style;
		  }
		
		  function local(stream, state) {
		    if (state.fencedChars && stream.match(state.fencedChars)) {
		      if (modeCfg.highlightFormatting) state.formatting = "code-block";
		      var returnType = getType(state)
		      state.localMode = state.localState = null;
		      state.block = blockNormal;
		      state.f = inlineNormal;
		      state.fencedChars = null;
		      state.code = 0
		      return returnType;
		    } else if (state.fencedChars && stream.skipTo(state.fencedChars)) {
		      return "comment"
		    } else if (state.localMode) {
		      return state.localMode.token(stream, state.localState);
		    } else {
		      stream.skipToEnd();
		      return tokenTypes.code;
		    }
		  }
		
		  // Inline
		  function getType(state) {
		    var styles = [];
		
		    if (state.formatting) {
		      styles.push(tokenTypes.formatting);
		
		      if (typeof state.formatting === "string") state.formatting = [state.formatting];
		
		      for (var i = 0; i < state.formatting.length; i++) {
		        styles.push(tokenTypes.formatting + "-" + state.formatting[i]);
		
		        if (state.formatting[i] === "header") {
		          styles.push(tokenTypes.formatting + "-" + state.formatting[i] + "-" + state.header);
		        }
		
		        // Add `formatting-quote` and `formatting-quote-#` for blockquotes
		        // Add `error` instead if the maximum blockquote nesting depth is passed
		        if (state.formatting[i] === "quote") {
		          if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
		            styles.push(tokenTypes.formatting + "-" + state.formatting[i] + "-" + state.quote);
		          } else {
		            styles.push("error");
		          }
		        }
		      }
		    }
		
		    if (state.taskOpen) {
		      styles.push("meta");
		      return styles.length ? styles.join(' ') : null;
		    }
		    if (state.taskClosed) {
		      styles.push("property");
		      return styles.length ? styles.join(' ') : null;
		    }
		
		    if (state.linkHref) {
		      styles.push(tokenTypes.linkHref, "url");
		    } else { // Only apply inline styles to non-url text
		      if (state.strong) { styles.push(tokenTypes.strong); }
		      if (state.em) { styles.push(tokenTypes.em); }
		      if (state.strikethrough) { styles.push(tokenTypes.strikethrough); }
		      if (state.linkText) { styles.push(tokenTypes.linkText); }
		      if (state.code) { styles.push(tokenTypes.code); }
		      if (state.image) { styles.push(tokenTypes.image); }
		      if (state.imageAltText) { styles.push(tokenTypes.imageAltText, "link"); }
		      if (state.imageMarker) { styles.push(tokenTypes.imageMarker); }
		    }
		
		    if (state.header) { styles.push(tokenTypes.header, tokenTypes.header + "-" + state.header); }
		
		    if (state.quote) {
		      styles.push(tokenTypes.quote);
		
		      // Add `quote-#` where the maximum for `#` is modeCfg.maxBlockquoteDepth
		      if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
		        styles.push(tokenTypes.quote + "-" + state.quote);
		      } else {
		        styles.push(tokenTypes.quote + "-" + modeCfg.maxBlockquoteDepth);
		      }
		    }
		
		    if (state.list !== false) {
		      var listMod = (state.listStack.length - 1) % 3;
		      if (!listMod) {
		        styles.push(tokenTypes.list1);
		      } else if (listMod === 1) {
		        styles.push(tokenTypes.list2);
		      } else {
		        styles.push(tokenTypes.list3);
		      }
		    }
		
		    if (state.trailingSpaceNewLine) {
		      styles.push("trailing-space-new-line");
		    } else if (state.trailingSpace) {
		      styles.push("trailing-space-" + (state.trailingSpace % 2 ? "a" : "b"));
		    }
		
		    return styles.length ? styles.join(' ') : null;
		  }
		
		  function handleText(stream, state) {
		    if (stream.match(textRE, true)) {
		      return getType(state);
		    }
		    return undefined;
		  }
		
		  function inlineNormal(stream, state) {
		    var style = state.text(stream, state);
		    if (typeof style !== 'undefined')
		      return style;
		
		    if (state.list) { // List marker (*, +, -, 1., etc)
		      state.list = null;
		      return getType(state);
		    }
		
		    if (state.taskList) {
		      var taskOpen = stream.match(taskListRE, true)[1] !== "x";
		      if (taskOpen) state.taskOpen = true;
		      else state.taskClosed = true;
		      if (modeCfg.highlightFormatting) state.formatting = "task";
		      state.taskList = false;
		      return getType(state);
		    }
		
		    state.taskOpen = false;
		    state.taskClosed = false;
		
		    if (state.header && stream.match(/^#+$/, true)) {
		      if (modeCfg.highlightFormatting) state.formatting = "header";
		      return getType(state);
		    }
		
		    // Get sol() value now, before character is consumed
		    var sol = stream.sol();
		
		    var ch = stream.next();
		
		    // Matches link titles present on next line
		    if (state.linkTitle) {
		      state.linkTitle = false;
		      var matchCh = ch;
		      if (ch === '(') {
		        matchCh = ')';
		      }
		      matchCh = (matchCh+'').replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
		      var regex = '^\\s*(?:[^' + matchCh + '\\\\]+|\\\\\\\\|\\\\.)' + matchCh;
		      if (stream.match(new RegExp(regex), true)) {
		        return tokenTypes.linkHref;
		      }
		    }
		
		    // If this block is changed, it may need to be updated in GFM mode
		    if (ch === '`') {
		      var previousFormatting = state.formatting;
		      if (modeCfg.highlightFormatting) state.formatting = "code";
		      stream.eatWhile('`');
		      var count = stream.current().length
		      if (state.code == 0) {
		        state.code = count
		        return getType(state)
		      } else if (count == state.code) { // Must be exact
		        var t = getType(state)
		        state.code = 0
		        return t
		      } else {
		        state.formatting = previousFormatting
		        return getType(state)
		      }
		    } else if (state.code) {
		      return getType(state);
		    }
		
		    if (ch === '\\') {
		      stream.next();
		      if (modeCfg.highlightFormatting) {
		        var type = getType(state);
		        var formattingEscape = tokenTypes.formatting + "-escape";
		        return type ? type + " " + formattingEscape : formattingEscape;
		      }
		    }
		
		    if (ch === '!' && stream.match(/\[[^\]]*\] ?(?:\(|\[)/, false)) {
		      state.imageMarker = true;
		      state.image = true;
		      if (modeCfg.highlightFormatting) state.formatting = "image";
		      return getType(state);
		    }
		
		    if (ch === '[' && state.imageMarker && stream.match(/[^\]]*\](\(.*?\)| ?\[.*?\])/, false)) {
		      state.imageMarker = false;
		      state.imageAltText = true
		      if (modeCfg.highlightFormatting) state.formatting = "image";
		      return getType(state);
		    }
		
		    if (ch === ']' && state.imageAltText) {
		      if (modeCfg.highlightFormatting) state.formatting = "image";
		      var type = getType(state);
		      state.imageAltText = false;
		      state.image = false;
		      state.inline = state.f = linkHref;
		      return type;
		    }
		
		    if (ch === '[' && stream.match(/[^\]]*\](\(.*\)| ?\[.*?\])/, false) && !state.image) {
		      state.linkText = true;
		      if (modeCfg.highlightFormatting) state.formatting = "link";
		      return getType(state);
		    }
		
		    if (ch === ']' && state.linkText && stream.match(/\(.*?\)| ?\[.*?\]/, false)) {
		      if (modeCfg.highlightFormatting) state.formatting = "link";
		      var type = getType(state);
		      state.linkText = false;
		      state.inline = state.f = linkHref;
		      return type;
		    }
		
		    if (ch === '<' && stream.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, false)) {
		      state.f = state.inline = linkInline;
		      if (modeCfg.highlightFormatting) state.formatting = "link";
		      var type = getType(state);
		      if (type){
		        type += " ";
		      } else {
		        type = "";
		      }
		      return type + tokenTypes.linkInline;
		    }
		
		    if (ch === '<' && stream.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, false)) {
		      state.f = state.inline = linkInline;
		      if (modeCfg.highlightFormatting) state.formatting = "link";
		      var type = getType(state);
		      if (type){
		        type += " ";
		      } else {
		        type = "";
		      }
		      return type + tokenTypes.linkEmail;
		    }
		
		    if (ch === '<' && stream.match(/^(!--|[a-z]+(?:\s+[a-z_:.\-]+(?:\s*=\s*[^ >]+)?)*\s*>)/i, false)) {
		      var end = stream.string.indexOf(">", stream.pos);
		      if (end != -1) {
		        var atts = stream.string.substring(stream.start, end);
		        if (/markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(atts)) state.md_inside = true;
		      }
		      stream.backUp(1);
		      state.htmlState = CodeMirror.startState(htmlMode);
		      return switchBlock(stream, state, htmlBlock);
		    }
		
		    if (ch === '<' && stream.match(/^\/\w*?>/)) {
		      state.md_inside = false;
		      return "tag";
		    }
		
		    var ignoreUnderscore = false;
		    if (!modeCfg.underscoresBreakWords) {
		      if (ch === '_' && stream.peek() !== '_' && stream.match(/(\w)/, false)) {
		        var prevPos = stream.pos - 2;
		        if (prevPos >= 0) {
		          var prevCh = stream.string.charAt(prevPos);
		          if (prevCh !== '_' && prevCh.match(/(\w)/, false)) {
		            ignoreUnderscore = true;
		          }
		        }
		      }
		    }
		    if (ch === '*' || (ch === '_' && !ignoreUnderscore)) {
		      if (sol && stream.peek() === ' ') {
		        // Do nothing, surrounded by newline and space
		      } else if (state.strong === ch && stream.eat(ch)) { // Remove STRONG
		        if (modeCfg.highlightFormatting) state.formatting = "strong";
		        var t = getType(state);
		        state.strong = false;
		        return t;
		      } else if (!state.strong && stream.eat(ch)) { // Add STRONG
		        state.strong = ch;
		        if (modeCfg.highlightFormatting) state.formatting = "strong";
		        return getType(state);
		      } else if (state.em === ch) { // Remove EM
		        if (modeCfg.highlightFormatting) state.formatting = "em";
		        var t = getType(state);
		        state.em = false;
		        return t;
		      } else if (!state.em) { // Add EM
		        state.em = ch;
		        if (modeCfg.highlightFormatting) state.formatting = "em";
		        return getType(state);
		      }
		    } else if (ch === ' ') {
		      if (stream.eat('*') || stream.eat('_')) { // Probably surrounded by spaces
		        if (stream.peek() === ' ') { // Surrounded by spaces, ignore
		          return getType(state);
		        } else { // Not surrounded by spaces, back up pointer
		          stream.backUp(1);
		        }
		      }
		    }
		
		    if (modeCfg.strikethrough) {
		      if (ch === '~' && stream.eatWhile(ch)) {
		        if (state.strikethrough) {// Remove strikethrough
		          if (modeCfg.highlightFormatting) state.formatting = "strikethrough";
		          var t = getType(state);
		          state.strikethrough = false;
		          return t;
		        } else if (stream.match(/^[^\s]/, false)) {// Add strikethrough
		          state.strikethrough = true;
		          if (modeCfg.highlightFormatting) state.formatting = "strikethrough";
		          return getType(state);
		        }
		      } else if (ch === ' ') {
		        if (stream.match(/^~~/, true)) { // Probably surrounded by space
		          if (stream.peek() === ' ') { // Surrounded by spaces, ignore
		            return getType(state);
		          } else { // Not surrounded by spaces, back up pointer
		            stream.backUp(2);
		          }
		        }
		      }
		    }
		
		    if (ch === ' ') {
		      if (stream.match(/ +$/, false)) {
		        state.trailingSpace++;
		      } else if (state.trailingSpace) {
		        state.trailingSpaceNewLine = true;
		      }
		    }
		
		    return getType(state);
		  }
		
		  function linkInline(stream, state) {
		    var ch = stream.next();
		
		    if (ch === ">") {
		      state.f = state.inline = inlineNormal;
		      if (modeCfg.highlightFormatting) state.formatting = "link";
		      var type = getType(state);
		      if (type){
		        type += " ";
		      } else {
		        type = "";
		      }
		      return type + tokenTypes.linkInline;
		    }
		
		    stream.match(/^[^>]+/, true);
		
		    return tokenTypes.linkInline;
		  }
		
		  function linkHref(stream, state) {
		    // Check if space, and return NULL if so (to avoid marking the space)
		    if(stream.eatSpace()){
		      return null;
		    }
		    var ch = stream.next();
		    if (ch === '(' || ch === '[') {
		      state.f = state.inline = getLinkHrefInside(ch === "(" ? ")" : "]", 0);
		      if (modeCfg.highlightFormatting) state.formatting = "link-string";
		      state.linkHref = true;
		      return getType(state);
		    }
		    return 'error';
		  }
		
		  var linkRE = {
		    ")": /^(?:[^\\\(\)]|\\.|\((?:[^\\\(\)]|\\.)*\))*?(?=\))/,
		    "]": /^(?:[^\\\[\]]|\\.|\[(?:[^\\\[\\]]|\\.)*\])*?(?=\])/
		  }
		
		  function getLinkHrefInside(endChar) {
		    return function(stream, state) {
		      var ch = stream.next();
		
		      if (ch === endChar) {
		        state.f = state.inline = inlineNormal;
		        if (modeCfg.highlightFormatting) state.formatting = "link-string";
		        var returnState = getType(state);
		        state.linkHref = false;
		        return returnState;
		      }
		
		      stream.match(linkRE[endChar])
		      state.linkHref = true;
		      return getType(state);
		    };
		  }
		
		  function footnoteLink(stream, state) {
		    if (stream.match(/^([^\]\\]|\\.)*\]:/, false)) {
		      state.f = footnoteLinkInside;
		      stream.next(); // Consume [
		      if (modeCfg.highlightFormatting) state.formatting = "link";
		      state.linkText = true;
		      return getType(state);
		    }
		    return switchInline(stream, state, inlineNormal);
		  }
		
		  function footnoteLinkInside(stream, state) {
		    if (stream.match(/^\]:/, true)) {
		      state.f = state.inline = footnoteUrl;
		      if (modeCfg.highlightFormatting) state.formatting = "link";
		      var returnType = getType(state);
		      state.linkText = false;
		      return returnType;
		    }
		
		    stream.match(/^([^\]\\]|\\.)+/, true);
		
		    return tokenTypes.linkText;
		  }
		
		  function footnoteUrl(stream, state) {
		    // Check if space, and return NULL if so (to avoid marking the space)
		    if(stream.eatSpace()){
		      return null;
		    }
		    // Match URL
		    stream.match(/^[^\s]+/, true);
		    // Check for link title
		    if (stream.peek() === undefined) { // End of line, set flag to check next line
		      state.linkTitle = true;
		    } else { // More content on line, check if link title
		      stream.match(/^(?:\s+(?:"(?:[^"\\]|\\\\|\\.)+"|'(?:[^'\\]|\\\\|\\.)+'|\((?:[^)\\]|\\\\|\\.)+\)))?/, true);
		    }
		    state.f = state.inline = inlineNormal;
		    return tokenTypes.linkHref + " url";
		  }
		
		  var mode = {
		    startState: function() {
		      return {
		        f: blockNormal,
		
		        prevLine: null,
		        thisLine: null,
		
		        block: blockNormal,
		        htmlState: null,
		        indentation: 0,
		
		        inline: inlineNormal,
		        text: handleText,
		
		        formatting: false,
		        linkText: false,
		        linkHref: false,
		        linkTitle: false,
		        code: 0,
		        em: false,
		        strong: false,
		        header: 0,
		        hr: false,
		        taskList: false,
		        list: false,
		        listStack: [],
		        quote: 0,
		        trailingSpace: 0,
		        trailingSpaceNewLine: false,
		        strikethrough: false,
		        fencedChars: null
		      };
		    },
		
		    copyState: function(s) {
		      return {
		        f: s.f,
		
		        prevLine: s.prevLine,
		        thisLine: s.thisLine,
		
		        block: s.block,
		        htmlState: s.htmlState && CodeMirror.copyState(htmlMode, s.htmlState),
		        indentation: s.indentation,
		
		        localMode: s.localMode,
		        localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,
		
		        inline: s.inline,
		        text: s.text,
		        formatting: false,
		        linkTitle: s.linkTitle,
		        code: s.code,
		        em: s.em,
		        strong: s.strong,
		        strikethrough: s.strikethrough,
		        header: s.header,
		        hr: s.hr,
		        taskList: s.taskList,
		        list: s.list,
		        listStack: s.listStack.slice(0),
		        quote: s.quote,
		        indentedCode: s.indentedCode,
		        trailingSpace: s.trailingSpace,
		        trailingSpaceNewLine: s.trailingSpaceNewLine,
		        md_inside: s.md_inside,
		        fencedChars: s.fencedChars
		      };
		    },
		
		    token: function(stream, state) {
		
		      // Reset state.formatting
		      state.formatting = false;
		
		      if (stream != state.thisLine) {
		        var forceBlankLine = state.header || state.hr;
		
		        // Reset state.header and state.hr
		        state.header = 0;
		        state.hr = false;
		
		        if (stream.match(/^\s*$/, true) || forceBlankLine) {
		          blankLine(state);
		          if (!forceBlankLine) return null
		          state.prevLine = null
		        }
		
		        state.prevLine = state.thisLine
		        state.thisLine = stream
		
		        // Reset state.taskList
		        state.taskList = false;
		
		        // Reset state.trailingSpace
		        state.trailingSpace = 0;
		        state.trailingSpaceNewLine = false;
		
		        state.f = state.block;
		        var indentation = stream.match(/^\s*/, true)[0].replace(/\t/g, '    ').length;
		        state.indentationDiff = Math.min(indentation - state.indentation, 4);
		        state.indentation = state.indentation + state.indentationDiff;
		        if (indentation > 0) return null;
		      }
		      return state.f(stream, state);
		    },
		
		    innerMode: function(state) {
		      if (state.block == htmlBlock) return {state: state.htmlState, mode: htmlMode};
		      if (state.localState) return {state: state.localState, mode: state.localMode};
		      return {state: state, mode: mode};
		    },
		
		    blankLine: blankLine,
		
		    getType: getType,
		
		    closeBrackets: "()[]{}''\"\"``",
		    fold: "markdown"
		  };
		  return mode;
		}, "xml");
		
		CodeMirror.defineMIME("text/x-markdown", "markdown");
		
		});
	
	
	/***/ },
	/* 166 */
	/***/ function(module, exports, __webpack_require__) {
	
		// CodeMirror, copyright (c) by Marijn Haverbeke and others
		// Distributed under an MIT license: http://codemirror.net/LICENSE
		
		(function(mod) {
		  if (true) // CommonJS
		    mod(__webpack_require__(161));
		  else if (typeof define == "function" && define.amd) // AMD
		    define(["../../lib/codemirror"], mod);
		  else // Plain browser env
		    mod(CodeMirror);
		})(function(CodeMirror) {
		"use strict";
		
		var htmlConfig = {
		  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
		                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
		                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
		                    'track': true, 'wbr': true, 'menuitem': true},
		  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
		                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
		                     'th': true, 'tr': true},
		  contextGrabbers: {
		    'dd': {'dd': true, 'dt': true},
		    'dt': {'dd': true, 'dt': true},
		    'li': {'li': true},
		    'option': {'option': true, 'optgroup': true},
		    'optgroup': {'optgroup': true},
		    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
		          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
		          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
		          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
		          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},
		    'rp': {'rp': true, 'rt': true},
		    'rt': {'rp': true, 'rt': true},
		    'tbody': {'tbody': true, 'tfoot': true},
		    'td': {'td': true, 'th': true},
		    'tfoot': {'tbody': true},
		    'th': {'td': true, 'th': true},
		    'thead': {'tbody': true, 'tfoot': true},
		    'tr': {'tr': true}
		  },
		  doNotIndent: {"pre": true},
		  allowUnquoted: true,
		  allowMissing: true,
		  caseFold: true
		}
		
		var xmlConfig = {
		  autoSelfClosers: {},
		  implicitlyClosed: {},
		  contextGrabbers: {},
		  doNotIndent: {},
		  allowUnquoted: false,
		  allowMissing: false,
		  caseFold: false
		}
		
		CodeMirror.defineMode("xml", function(editorConf, config_) {
		  var indentUnit = editorConf.indentUnit
		  var config = {}
		  var defaults = config_.htmlMode ? htmlConfig : xmlConfig
		  for (var prop in defaults) config[prop] = defaults[prop]
		  for (var prop in config_) config[prop] = config_[prop]
		
		  // Return variables for tokenizers
		  var type, setStyle;
		
		  function inText(stream, state) {
		    function chain(parser) {
		      state.tokenize = parser;
		      return parser(stream, state);
		    }
		
		    var ch = stream.next();
		    if (ch == "<") {
		      if (stream.eat("!")) {
		        if (stream.eat("[")) {
		          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
		          else return null;
		        } else if (stream.match("--")) {
		          return chain(inBlock("comment", "-->"));
		        } else if (stream.match("DOCTYPE", true, true)) {
		          stream.eatWhile(/[\w\._\-]/);
		          return chain(doctype(1));
		        } else {
		          return null;
		        }
		      } else if (stream.eat("?")) {
		        stream.eatWhile(/[\w\._\-]/);
		        state.tokenize = inBlock("meta", "?>");
		        return "meta";
		      } else {
		        type = stream.eat("/") ? "closeTag" : "openTag";
		        state.tokenize = inTag;
		        return "tag bracket";
		      }
		    } else if (ch == "&") {
		      var ok;
		      if (stream.eat("#")) {
		        if (stream.eat("x")) {
		          ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
		        } else {
		          ok = stream.eatWhile(/[\d]/) && stream.eat(";");
		        }
		      } else {
		        ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
		      }
		      return ok ? "atom" : "error";
		    } else {
		      stream.eatWhile(/[^&<]/);
		      return null;
		    }
		  }
		  inText.isInText = true;
		
		  function inTag(stream, state) {
		    var ch = stream.next();
		    if (ch == ">" || (ch == "/" && stream.eat(">"))) {
		      state.tokenize = inText;
		      type = ch == ">" ? "endTag" : "selfcloseTag";
		      return "tag bracket";
		    } else if (ch == "=") {
		      type = "equals";
		      return null;
		    } else if (ch == "<") {
		      state.tokenize = inText;
		      state.state = baseState;
		      state.tagName = state.tagStart = null;
		      var next = state.tokenize(stream, state);
		      return next ? next + " tag error" : "tag error";
		    } else if (/[\'\"]/.test(ch)) {
		      state.tokenize = inAttribute(ch);
		      state.stringStartCol = stream.column();
		      return state.tokenize(stream, state);
		    } else {
		      stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
		      return "word";
		    }
		  }
		
		  function inAttribute(quote) {
		    var closure = function(stream, state) {
		      while (!stream.eol()) {
		        if (stream.next() == quote) {
		          state.tokenize = inTag;
		          break;
		        }
		      }
		      return "string";
		    };
		    closure.isInAttribute = true;
		    return closure;
		  }
		
		  function inBlock(style, terminator) {
		    return function(stream, state) {
		      while (!stream.eol()) {
		        if (stream.match(terminator)) {
		          state.tokenize = inText;
		          break;
		        }
		        stream.next();
		      }
		      return style;
		    };
		  }
		  function doctype(depth) {
		    return function(stream, state) {
		      var ch;
		      while ((ch = stream.next()) != null) {
		        if (ch == "<") {
		          state.tokenize = doctype(depth + 1);
		          return state.tokenize(stream, state);
		        } else if (ch == ">") {
		          if (depth == 1) {
		            state.tokenize = inText;
		            break;
		          } else {
		            state.tokenize = doctype(depth - 1);
		            return state.tokenize(stream, state);
		          }
		        }
		      }
		      return "meta";
		    };
		  }
		
		  function Context(state, tagName, startOfLine) {
		    this.prev = state.context;
		    this.tagName = tagName;
		    this.indent = state.indented;
		    this.startOfLine = startOfLine;
		    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))
		      this.noIndent = true;
		  }
		  function popContext(state) {
		    if (state.context) state.context = state.context.prev;
		  }
		  function maybePopContext(state, nextTagName) {
		    var parentTagName;
		    while (true) {
		      if (!state.context) {
		        return;
		      }
		      parentTagName = state.context.tagName;
		      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||
		          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
		        return;
		      }
		      popContext(state);
		    }
		  }
		
		  function baseState(type, stream, state) {
		    if (type == "openTag") {
		      state.tagStart = stream.column();
		      return tagNameState;
		    } else if (type == "closeTag") {
		      return closeTagNameState;
		    } else {
		      return baseState;
		    }
		  }
		  function tagNameState(type, stream, state) {
		    if (type == "word") {
		      state.tagName = stream.current();
		      setStyle = "tag";
		      return attrState;
		    } else {
		      setStyle = "error";
		      return tagNameState;
		    }
		  }
		  function closeTagNameState(type, stream, state) {
		    if (type == "word") {
		      var tagName = stream.current();
		      if (state.context && state.context.tagName != tagName &&
		          config.implicitlyClosed.hasOwnProperty(state.context.tagName))
		        popContext(state);
		      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {
		        setStyle = "tag";
		        return closeState;
		      } else {
		        setStyle = "tag error";
		        return closeStateErr;
		      }
		    } else {
		      setStyle = "error";
		      return closeStateErr;
		    }
		  }
		
		  function closeState(type, _stream, state) {
		    if (type != "endTag") {
		      setStyle = "error";
		      return closeState;
		    }
		    popContext(state);
		    return baseState;
		  }
		  function closeStateErr(type, stream, state) {
		    setStyle = "error";
		    return closeState(type, stream, state);
		  }
		
		  function attrState(type, _stream, state) {
		    if (type == "word") {
		      setStyle = "attribute";
		      return attrEqState;
		    } else if (type == "endTag" || type == "selfcloseTag") {
		      var tagName = state.tagName, tagStart = state.tagStart;
		      state.tagName = state.tagStart = null;
		      if (type == "selfcloseTag" ||
		          config.autoSelfClosers.hasOwnProperty(tagName)) {
		        maybePopContext(state, tagName);
		      } else {
		        maybePopContext(state, tagName);
		        state.context = new Context(state, tagName, tagStart == state.indented);
		      }
		      return baseState;
		    }
		    setStyle = "error";
		    return attrState;
		  }
		  function attrEqState(type, stream, state) {
		    if (type == "equals") return attrValueState;
		    if (!config.allowMissing) setStyle = "error";
		    return attrState(type, stream, state);
		  }
		  function attrValueState(type, stream, state) {
		    if (type == "string") return attrContinuedState;
		    if (type == "word" && config.allowUnquoted) {setStyle = "string"; return attrState;}
		    setStyle = "error";
		    return attrState(type, stream, state);
		  }
		  function attrContinuedState(type, stream, state) {
		    if (type == "string") return attrContinuedState;
		    return attrState(type, stream, state);
		  }
		
		  return {
		    startState: function(baseIndent) {
		      var state = {tokenize: inText,
		                   state: baseState,
		                   indented: baseIndent || 0,
		                   tagName: null, tagStart: null,
		                   context: null}
		      if (baseIndent != null) state.baseIndent = baseIndent
		      return state
		    },
		
		    token: function(stream, state) {
		      if (!state.tagName && stream.sol())
		        state.indented = stream.indentation();
		
		      if (stream.eatSpace()) return null;
		      type = null;
		      var style = state.tokenize(stream, state);
		      if ((style || type) && style != "comment") {
		        setStyle = null;
		        state.state = state.state(type || style, stream, state);
		        if (setStyle)
		          style = setStyle == "error" ? style + " error" : setStyle;
		      }
		      return style;
		    },
		
		    indent: function(state, textAfter, fullLine) {
		      var context = state.context;
		      // Indent multi-line strings (e.g. css).
		      if (state.tokenize.isInAttribute) {
		        if (state.tagStart == state.indented)
		          return state.stringStartCol + 1;
		        else
		          return state.indented + indentUnit;
		      }
		      if (context && context.noIndent) return CodeMirror.Pass;
		      if (state.tokenize != inTag && state.tokenize != inText)
		        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
		      // Indent the starts of attribute names.
		      if (state.tagName) {
		        if (config.multilineTagIndentPastTag !== false)
		          return state.tagStart + state.tagName.length + 2;
		        else
		          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
		      }
		      if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
		      var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
		      if (tagAfter && tagAfter[1]) { // Closing tag spotted
		        while (context) {
		          if (context.tagName == tagAfter[2]) {
		            context = context.prev;
		            break;
		          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {
		            context = context.prev;
		          } else {
		            break;
		          }
		        }
		      } else if (tagAfter) { // Opening tag spotted
		        while (context) {
		          var grabbers = config.contextGrabbers[context.tagName];
		          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))
		            context = context.prev;
		          else
		            break;
		        }
		      }
		      while (context && context.prev && !context.startOfLine)
		        context = context.prev;
		      if (context) return context.indent + indentUnit;
		      else return state.baseIndent || 0;
		    },
		
		    electricInput: /<\/[\s\w:]+>$/,
		    blockCommentStart: "<!--",
		    blockCommentEnd: "-->",
		
		    configuration: config.htmlMode ? "html" : "xml",
		    helperType: config.htmlMode ? "html" : "xml",
		
		    skipAttribute: function(state) {
		      if (state.state == attrValueState)
		        state.state = attrState
		    }
		  };
		});
		
		CodeMirror.defineMIME("text/xml", "xml");
		CodeMirror.defineMIME("application/xml", "xml");
		if (!CodeMirror.mimeModes.hasOwnProperty("text/html"))
		  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});
		
		});
	
	
	/***/ },
	/* 167 */
	/***/ function(module, exports, __webpack_require__) {
	
		// CodeMirror, copyright (c) by Marijn Haverbeke and others
		// Distributed under an MIT license: http://codemirror.net/LICENSE
		
		(function(mod) {
		  if (true) // CommonJS
		    mod(__webpack_require__(161));
		  else if (typeof define == "function" && define.amd) // AMD
		    define(["../lib/codemirror"], mod);
		  else // Plain browser env
		    mod(CodeMirror);
		})(function(CodeMirror) {
		  "use strict";
		
		  CodeMirror.modeInfo = [
		    {name: "APL", mime: "text/apl", mode: "apl", ext: ["dyalog", "apl"]},
		    {name: "PGP", mimes: ["application/pgp", "application/pgp-keys", "application/pgp-signature"], mode: "asciiarmor", ext: ["pgp"]},
		    {name: "ASN.1", mime: "text/x-ttcn-asn", mode: "asn.1", ext: ["asn", "asn1"]},
		    {name: "Asterisk", mime: "text/x-asterisk", mode: "asterisk", file: /^extensions\.conf$/i},
		    {name: "Brainfuck", mime: "text/x-brainfuck", mode: "brainfuck", ext: ["b", "bf"]},
		    {name: "C", mime: "text/x-csrc", mode: "clike", ext: ["c", "h"]},
		    {name: "C++", mime: "text/x-c++src", mode: "clike", ext: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"], alias: ["cpp"]},
		    {name: "Cobol", mime: "text/x-cobol", mode: "cobol", ext: ["cob", "cpy"]},
		    {name: "C#", mime: "text/x-csharp", mode: "clike", ext: ["cs"], alias: ["csharp"]},
		    {name: "Clojure", mime: "text/x-clojure", mode: "clojure", ext: ["clj", "cljc", "cljx"]},
		    {name: "ClojureScript", mime: "text/x-clojurescript", mode: "clojure", ext: ["cljs"]},
		    {name: "Closure Stylesheets (GSS)", mime: "text/x-gss", mode: "css", ext: ["gss"]},
		    {name: "CMake", mime: "text/x-cmake", mode: "cmake", ext: ["cmake", "cmake.in"], file: /^CMakeLists.txt$/},
		    {name: "CoffeeScript", mime: "text/x-coffeescript", mode: "coffeescript", ext: ["coffee"], alias: ["coffee", "coffee-script"]},
		    {name: "Common Lisp", mime: "text/x-common-lisp", mode: "commonlisp", ext: ["cl", "lisp", "el"], alias: ["lisp"]},
		    {name: "Cypher", mime: "application/x-cypher-query", mode: "cypher", ext: ["cyp", "cypher"]},
		    {name: "Cython", mime: "text/x-cython", mode: "python", ext: ["pyx", "pxd", "pxi"]},
		    {name: "Crystal", mime: "text/x-crystal", mode: "crystal", ext: ["cr"]},
		    {name: "CSS", mime: "text/css", mode: "css", ext: ["css"]},
		    {name: "CQL", mime: "text/x-cassandra", mode: "sql", ext: ["cql"]},
		    {name: "D", mime: "text/x-d", mode: "d", ext: ["d"]},
		    {name: "Dart", mimes: ["application/dart", "text/x-dart"], mode: "dart", ext: ["dart"]},
		    {name: "diff", mime: "text/x-diff", mode: "diff", ext: ["diff", "patch"]},
		    {name: "Django", mime: "text/x-django", mode: "django"},
		    {name: "Dockerfile", mime: "text/x-dockerfile", mode: "dockerfile", file: /^Dockerfile$/},
		    {name: "DTD", mime: "application/xml-dtd", mode: "dtd", ext: ["dtd"]},
		    {name: "Dylan", mime: "text/x-dylan", mode: "dylan", ext: ["dylan", "dyl", "intr"]},
		    {name: "EBNF", mime: "text/x-ebnf", mode: "ebnf"},
		    {name: "ECL", mime: "text/x-ecl", mode: "ecl", ext: ["ecl"]},
		    {name: "edn", mime: "application/edn", mode: "clojure", ext: ["edn"]},
		    {name: "Eiffel", mime: "text/x-eiffel", mode: "eiffel", ext: ["e"]},
		    {name: "Elm", mime: "text/x-elm", mode: "elm", ext: ["elm"]},
		    {name: "Embedded Javascript", mime: "application/x-ejs", mode: "htmlembedded", ext: ["ejs"]},
		    {name: "Embedded Ruby", mime: "application/x-erb", mode: "htmlembedded", ext: ["erb"]},
		    {name: "Erlang", mime: "text/x-erlang", mode: "erlang", ext: ["erl"]},
		    {name: "Factor", mime: "text/x-factor", mode: "factor", ext: ["factor"]},
		    {name: "FCL", mime: "text/x-fcl", mode: "fcl"},
		    {name: "Forth", mime: "text/x-forth", mode: "forth", ext: ["forth", "fth", "4th"]},
		    {name: "Fortran", mime: "text/x-fortran", mode: "fortran", ext: ["f", "for", "f77", "f90"]},
		    {name: "F#", mime: "text/x-fsharp", mode: "mllike", ext: ["fs"], alias: ["fsharp"]},
		    {name: "Gas", mime: "text/x-gas", mode: "gas", ext: ["s"]},
		    {name: "Gherkin", mime: "text/x-feature", mode: "gherkin", ext: ["feature"]},
		    {name: "GitHub Flavored Markdown", mime: "text/x-gfm", mode: "gfm", file: /^(readme|contributing|history).md$/i},
		    {name: "Go", mime: "text/x-go", mode: "go", ext: ["go"]},
		    {name: "Groovy", mime: "text/x-groovy", mode: "groovy", ext: ["groovy", "gradle"], file: /^Jenkinsfile$/},
		    {name: "HAML", mime: "text/x-haml", mode: "haml", ext: ["haml"]},
		    {name: "Haskell", mime: "text/x-haskell", mode: "haskell", ext: ["hs"]},
		    {name: "Haskell (Literate)", mime: "text/x-literate-haskell", mode: "haskell-literate", ext: ["lhs"]},
		    {name: "Haxe", mime: "text/x-haxe", mode: "haxe", ext: ["hx"]},
		    {name: "HXML", mime: "text/x-hxml", mode: "haxe", ext: ["hxml"]},
		    {name: "ASP.NET", mime: "application/x-aspx", mode: "htmlembedded", ext: ["aspx"], alias: ["asp", "aspx"]},
		    {name: "HTML", mime: "text/html", mode: "htmlmixed", ext: ["html", "htm"], alias: ["xhtml"]},
		    {name: "HTTP", mime: "message/http", mode: "http"},
		    {name: "IDL", mime: "text/x-idl", mode: "idl", ext: ["pro"]},
		    {name: "Pug", mime: "text/x-pug", mode: "pug", ext: ["jade", "pug"], alias: ["jade"]},
		    {name: "Java", mime: "text/x-java", mode: "clike", ext: ["java"]},
		    {name: "Java Server Pages", mime: "application/x-jsp", mode: "htmlembedded", ext: ["jsp"], alias: ["jsp"]},
		    {name: "JavaScript", mimes: ["text/javascript", "text/ecmascript", "application/javascript", "application/x-javascript", "application/ecmascript"],
		     mode: "javascript", ext: ["js"], alias: ["ecmascript", "js", "node"]},
		    {name: "JSON", mimes: ["application/json", "application/x-json"], mode: "javascript", ext: ["json", "map"], alias: ["json5"]},
		    {name: "JSON-LD", mime: "application/ld+json", mode: "javascript", ext: ["jsonld"], alias: ["jsonld"]},
		    {name: "JSX", mime: "text/jsx", mode: "jsx", ext: ["jsx"]},
		    {name: "Jinja2", mime: "null", mode: "jinja2"},
		    {name: "Julia", mime: "text/x-julia", mode: "julia", ext: ["jl"]},
		    {name: "Kotlin", mime: "text/x-kotlin", mode: "clike", ext: ["kt"]},
		    {name: "LESS", mime: "text/x-less", mode: "css", ext: ["less"]},
		    {name: "LiveScript", mime: "text/x-livescript", mode: "livescript", ext: ["ls"], alias: ["ls"]},
		    {name: "Lua", mime: "text/x-lua", mode: "lua", ext: ["lua"]},
		    {name: "Markdown", mime: "text/x-markdown", mode: "markdown", ext: ["markdown", "md", "mkd"]},
		    {name: "mIRC", mime: "text/mirc", mode: "mirc"},
		    {name: "MariaDB SQL", mime: "text/x-mariadb", mode: "sql"},
		    {name: "Mathematica", mime: "text/x-mathematica", mode: "mathematica", ext: ["m", "nb"]},
		    {name: "Modelica", mime: "text/x-modelica", mode: "modelica", ext: ["mo"]},
		    {name: "MUMPS", mime: "text/x-mumps", mode: "mumps", ext: ["mps"]},
		    {name: "MS SQL", mime: "text/x-mssql", mode: "sql"},
		    {name: "mbox", mime: "application/mbox", mode: "mbox", ext: ["mbox"]},
		    {name: "MySQL", mime: "text/x-mysql", mode: "sql"},
		    {name: "Nginx", mime: "text/x-nginx-conf", mode: "nginx", file: /nginx.*\.conf$/i},
		    {name: "NSIS", mime: "text/x-nsis", mode: "nsis", ext: ["nsh", "nsi"]},
		    {name: "NTriples", mime: "text/n-triples", mode: "ntriples", ext: ["nt"]},
		    {name: "Objective C", mime: "text/x-objectivec", mode: "clike", ext: ["m", "mm"], alias: ["objective-c", "objc"]},
		    {name: "OCaml", mime: "text/x-ocaml", mode: "mllike", ext: ["ml", "mli", "mll", "mly"]},
		    {name: "Octave", mime: "text/x-octave", mode: "octave", ext: ["m"]},
		    {name: "Oz", mime: "text/x-oz", mode: "oz", ext: ["oz"]},
		    {name: "Pascal", mime: "text/x-pascal", mode: "pascal", ext: ["p", "pas"]},
		    {name: "PEG.js", mime: "null", mode: "pegjs", ext: ["jsonld"]},
		    {name: "Perl", mime: "text/x-perl", mode: "perl", ext: ["pl", "pm"]},
		    {name: "PHP", mime: "application/x-httpd-php", mode: "php", ext: ["php", "php3", "php4", "php5", "phtml"]},
		    {name: "Pig", mime: "text/x-pig", mode: "pig", ext: ["pig"]},
		    {name: "Plain Text", mime: "text/plain", mode: "null", ext: ["txt", "text", "conf", "def", "list", "log"]},
		    {name: "PLSQL", mime: "text/x-plsql", mode: "sql", ext: ["pls"]},
		    {name: "PowerShell", mime: "application/x-powershell", mode: "powershell", ext: ["ps1", "psd1", "psm1"]},
		    {name: "Properties files", mime: "text/x-properties", mode: "properties", ext: ["properties", "ini", "in"], alias: ["ini", "properties"]},
		    {name: "ProtoBuf", mime: "text/x-protobuf", mode: "protobuf", ext: ["proto"]},
		    {name: "Python", mime: "text/x-python", mode: "python", ext: ["BUILD", "bzl", "py", "pyw"], file: /^(BUCK|BUILD)$/},
		    {name: "Puppet", mime: "text/x-puppet", mode: "puppet", ext: ["pp"]},
		    {name: "Q", mime: "text/x-q", mode: "q", ext: ["q"]},
		    {name: "R", mime: "text/x-rsrc", mode: "r", ext: ["r", "R"], alias: ["rscript"]},
		    {name: "reStructuredText", mime: "text/x-rst", mode: "rst", ext: ["rst"], alias: ["rst"]},
		    {name: "RPM Changes", mime: "text/x-rpm-changes", mode: "rpm"},
		    {name: "RPM Spec", mime: "text/x-rpm-spec", mode: "rpm", ext: ["spec"]},
		    {name: "Ruby", mime: "text/x-ruby", mode: "ruby", ext: ["rb"], alias: ["jruby", "macruby", "rake", "rb", "rbx"]},
		    {name: "Rust", mime: "text/x-rustsrc", mode: "rust", ext: ["rs"]},
		    {name: "SAS", mime: "text/x-sas", mode: "sas", ext: ["sas"]},
		    {name: "Sass", mime: "text/x-sass", mode: "sass", ext: ["sass"]},
		    {name: "Scala", mime: "text/x-scala", mode: "clike", ext: ["scala"]},
		    {name: "Scheme", mime: "text/x-scheme", mode: "scheme", ext: ["scm", "ss"]},
		    {name: "SCSS", mime: "text/x-scss", mode: "css", ext: ["scss"]},
		    {name: "Shell", mime: "text/x-sh", mode: "shell", ext: ["sh", "ksh", "bash"], alias: ["bash", "sh", "zsh"], file: /^PKGBUILD$/},
		    {name: "Sieve", mime: "application/sieve", mode: "sieve", ext: ["siv", "sieve"]},
		    {name: "Slim", mimes: ["text/x-slim", "application/x-slim"], mode: "slim", ext: ["slim"]},
		    {name: "Smalltalk", mime: "text/x-stsrc", mode: "smalltalk", ext: ["st"]},
		    {name: "Smarty", mime: "text/x-smarty", mode: "smarty", ext: ["tpl"]},
		    {name: "Solr", mime: "text/x-solr", mode: "solr"},
		    {name: "Soy", mime: "text/x-soy", mode: "soy", ext: ["soy"], alias: ["closure template"]},
		    {name: "SPARQL", mime: "application/sparql-query", mode: "sparql", ext: ["rq", "sparql"], alias: ["sparul"]},
		    {name: "Spreadsheet", mime: "text/x-spreadsheet", mode: "spreadsheet", alias: ["excel", "formula"]},
		    {name: "SQL", mime: "text/x-sql", mode: "sql", ext: ["sql"]},
		    {name: "SQLite", mime: "text/x-sqlite", mode: "sql"},
		    {name: "Squirrel", mime: "text/x-squirrel", mode: "clike", ext: ["nut"]},
		    {name: "Stylus", mime: "text/x-styl", mode: "stylus", ext: ["styl"]},
		    {name: "Swift", mime: "text/x-swift", mode: "swift", ext: ["swift"]},
		    {name: "sTeX", mime: "text/x-stex", mode: "stex"},
		    {name: "LaTeX", mime: "text/x-latex", mode: "stex", ext: ["text", "ltx"], alias: ["tex"]},
		    {name: "SystemVerilog", mime: "text/x-systemverilog", mode: "verilog", ext: ["v"]},
		    {name: "Tcl", mime: "text/x-tcl", mode: "tcl", ext: ["tcl"]},
		    {name: "Textile", mime: "text/x-textile", mode: "textile", ext: ["textile"]},
		    {name: "TiddlyWiki ", mime: "text/x-tiddlywiki", mode: "tiddlywiki"},
		    {name: "Tiki wiki", mime: "text/tiki", mode: "tiki"},
		    {name: "TOML", mime: "text/x-toml", mode: "toml", ext: ["toml"]},
		    {name: "Tornado", mime: "text/x-tornado", mode: "tornado"},
		    {name: "troff", mime: "text/troff", mode: "troff", ext: ["1", "2", "3", "4", "5", "6", "7", "8", "9"]},
		    {name: "TTCN", mime: "text/x-ttcn", mode: "ttcn", ext: ["ttcn", "ttcn3", "ttcnpp"]},
		    {name: "TTCN_CFG", mime: "text/x-ttcn-cfg", mode: "ttcn-cfg", ext: ["cfg"]},
		    {name: "Turtle", mime: "text/turtle", mode: "turtle", ext: ["ttl"]},
		    {name: "TypeScript", mime: "application/typescript", mode: "javascript", ext: ["ts"], alias: ["ts"]},
		    {name: "TypeScript-JSX", mime: "text/typescript-jsx", mode: "jsx", ext: ["tsx"], alias: ["tsx"]},
		    {name: "Twig", mime: "text/x-twig", mode: "twig"},
		    {name: "Web IDL", mime: "text/x-webidl", mode: "webidl", ext: ["webidl"]},
		    {name: "VB.NET", mime: "text/x-vb", mode: "vb", ext: ["vb"]},
		    {name: "VBScript", mime: "text/vbscript", mode: "vbscript", ext: ["vbs"]},
		    {name: "Velocity", mime: "text/velocity", mode: "velocity", ext: ["vtl"]},
		    {name: "Verilog", mime: "text/x-verilog", mode: "verilog", ext: ["v"]},
		    {name: "VHDL", mime: "text/x-vhdl", mode: "vhdl", ext: ["vhd", "vhdl"]},
		    {name: "Vue.js Component", mimes: ["script/x-vue", "text/x-vue"], mode: "vue", ext: ["vue"]},
		    {name: "XML", mimes: ["application/xml", "text/xml"], mode: "xml", ext: ["xml", "xsl", "xsd", "svg"], alias: ["rss", "wsdl", "xsd"]},
		    {name: "XQuery", mime: "application/xquery", mode: "xquery", ext: ["xy", "xquery"]},
		    {name: "Yacas", mime: "text/x-yacas", mode: "yacas", ext: ["ys"]},
		    {name: "YAML", mimes: ["text/x-yaml", "text/yaml"], mode: "yaml", ext: ["yaml", "yml"], alias: ["yml"]},
		    {name: "Z80", mime: "text/x-z80", mode: "z80", ext: ["z80"]},
		    {name: "mscgen", mime: "text/x-mscgen", mode: "mscgen", ext: ["mscgen", "mscin", "msc"]},
		    {name: "xu", mime: "text/x-xu", mode: "mscgen", ext: ["xu"]},
		    {name: "msgenny", mime: "text/x-msgenny", mode: "mscgen", ext: ["msgenny"]}
		  ];
		  // Ensure all modes have a mime property for backwards compatibility
		  for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
		    var info = CodeMirror.modeInfo[i];
		    if (info.mimes) info.mime = info.mimes[0];
		  }
		
		  CodeMirror.findModeByMIME = function(mime) {
		    mime = mime.toLowerCase();
		    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
		      var info = CodeMirror.modeInfo[i];
		      if (info.mime == mime) return info;
		      if (info.mimes) for (var j = 0; j < info.mimes.length; j++)
		        if (info.mimes[j] == mime) return info;
		    }
		    if (/\+xml$/.test(mime)) return CodeMirror.findModeByMIME("application/xml")
		    if (/\+json$/.test(mime)) return CodeMirror.findModeByMIME("application/json")
		  };
		
		  CodeMirror.findModeByExtension = function(ext) {
		    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
		      var info = CodeMirror.modeInfo[i];
		      if (info.ext) for (var j = 0; j < info.ext.length; j++)
		        if (info.ext[j] == ext) return info;
		    }
		  };
		
		  CodeMirror.findModeByFileName = function(filename) {
		    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
		      var info = CodeMirror.modeInfo[i];
		      if (info.file && info.file.test(filename)) return info;
		    }
		    var dot = filename.lastIndexOf(".");
		    var ext = dot > -1 && filename.substring(dot + 1, filename.length);
		    if (ext) return CodeMirror.findModeByExtension(ext);
		  };
		
		  CodeMirror.findModeByName = function(name) {
		    name = name.toLowerCase();
		    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
		      var info = CodeMirror.modeInfo[i];
		      if (info.name.toLowerCase() == name) return info;
		      if (info.alias) for (var j = 0; j < info.alias.length; j++)
		        if (info.alias[j].toLowerCase() == name) return info;
		    }
		  };
		});
	
	
	/***/ },
	/* 168 */
	/***/ function(module, exports, __webpack_require__) {
	
		// CodeMirror, copyright (c) by Marijn Haverbeke and others
		// Distributed under an MIT license: http://codemirror.net/LICENSE
		
		// Utility function that allows modes to be combined. The mode given
		// as the base argument takes care of most of the normal mode
		// functionality, but a second (typically simple) mode is used, which
		// can override the style of text. Both modes get to parse all of the
		// text, but when both assign a non-null style to a piece of code, the
		// overlay wins, unless the combine argument was true and not overridden,
		// or state.overlay.combineTokens was true, in which case the styles are
		// combined.
		
		(function(mod) {
		  if (true) // CommonJS
		    mod(__webpack_require__(161));
		  else if (typeof define == "function" && define.amd) // AMD
		    define(["../../lib/codemirror"], mod);
		  else // Plain browser env
		    mod(CodeMirror);
		})(function(CodeMirror) {
		"use strict";
		
		CodeMirror.overlayMode = function(base, overlay, combine) {
		  return {
		    startState: function() {
		      return {
		        base: CodeMirror.startState(base),
		        overlay: CodeMirror.startState(overlay),
		        basePos: 0, baseCur: null,
		        overlayPos: 0, overlayCur: null,
		        streamSeen: null
		      };
		    },
		    copyState: function(state) {
		      return {
		        base: CodeMirror.copyState(base, state.base),
		        overlay: CodeMirror.copyState(overlay, state.overlay),
		        basePos: state.basePos, baseCur: null,
		        overlayPos: state.overlayPos, overlayCur: null
		      };
		    },
		
		    token: function(stream, state) {
		      if (stream != state.streamSeen ||
		          Math.min(state.basePos, state.overlayPos) < stream.start) {
		        state.streamSeen = stream;
		        state.basePos = state.overlayPos = stream.start;
		      }
		
		      if (stream.start == state.basePos) {
		        state.baseCur = base.token(stream, state.base);
		        state.basePos = stream.pos;
		      }
		      if (stream.start == state.overlayPos) {
		        stream.pos = stream.start;
		        state.overlayCur = overlay.token(stream, state.overlay);
		        state.overlayPos = stream.pos;
		      }
		      stream.pos = Math.min(state.basePos, state.overlayPos);
		
		      // state.overlay.combineTokens always takes precedence over combine,
		      // unless set to null
		      if (state.overlayCur == null) return state.baseCur;
		      else if (state.baseCur != null &&
		               state.overlay.combineTokens ||
		               combine && state.overlay.combineTokens == null)
		        return state.baseCur + " " + state.overlayCur;
		      else return state.overlayCur;
		    },
		
		    indent: base.indent && function(state, textAfter) {
		      return base.indent(state.base, textAfter);
		    },
		    electricChars: base.electricChars,
		
		    innerMode: function(state) { return {state: state.base, mode: base}; },
		
		    blankLine: function(state) {
		      var baseToken, overlayToken;
		      if (base.blankLine) baseToken = base.blankLine(state.base);
		      if (overlay.blankLine) overlayToken = overlay.blankLine(state.overlay);
		
		      return overlayToken == null ?
		        baseToken :
		        (combine && baseToken != null ? baseToken + " " + overlayToken : overlayToken);
		    }
		  };
		};
		
		});
	
	
	/***/ },
	/* 169 */
	/***/ function(module, exports, __webpack_require__) {
	
		// CodeMirror, copyright (c) by Marijn Haverbeke and others
		// Distributed under an MIT license: http://codemirror.net/LICENSE
		
		(function(mod) {
		  if (true) // CommonJS
		    mod(__webpack_require__(161));
		  else if (typeof define == "function" && define.amd) // AMD
		    define(["../../lib/codemirror"], mod);
		  else // Plain browser env
		    mod(CodeMirror);
		})(function(CodeMirror) {
		  CodeMirror.defineOption("placeholder", "", function(cm, val, old) {
		    var prev = old && old != CodeMirror.Init;
		    if (val && !prev) {
		      cm.on("blur", onBlur);
		      cm.on("change", onChange);
		      cm.on("swapDoc", onChange);
		      onChange(cm);
		    } else if (!val && prev) {
		      cm.off("blur", onBlur);
		      cm.off("change", onChange);
		      cm.off("swapDoc", onChange);
		      clearPlaceholder(cm);
		      var wrapper = cm.getWrapperElement();
		      wrapper.className = wrapper.className.replace(" CodeMirror-empty", "");
		    }
		
		    if (val && !cm.hasFocus()) onBlur(cm);
		  });
		
		  function clearPlaceholder(cm) {
		    if (cm.state.placeholder) {
		      cm.state.placeholder.parentNode.removeChild(cm.state.placeholder);
		      cm.state.placeholder = null;
		    }
		  }
		  function setPlaceholder(cm) {
		    clearPlaceholder(cm);
		    var elt = cm.state.placeholder = document.createElement("pre");
		    elt.style.cssText = "height: 0; overflow: visible";
		    elt.className = "CodeMirror-placeholder";
		    var placeHolder = cm.getOption("placeholder")
		    if (typeof placeHolder == "string") placeHolder = document.createTextNode(placeHolder)
		    elt.appendChild(placeHolder)
		    cm.display.lineSpace.insertBefore(elt, cm.display.lineSpace.firstChild);
		  }
		
		  function onBlur(cm) {
		    if (isEmpty(cm)) setPlaceholder(cm);
		  }
		  function onChange(cm) {
		    var wrapper = cm.getWrapperElement(), empty = isEmpty(cm);
		    wrapper.className = wrapper.className.replace(" CodeMirror-empty", "") + (empty ? " CodeMirror-empty" : "");
		
		    if (empty) setPlaceholder(cm);
		    else clearPlaceholder(cm);
		  }
		
		  function isEmpty(cm) {
		    return (cm.lineCount() === 1) && (cm.getLine(0) === "");
		  }
		});
	
	
	/***/ },
	/* 170 */
	/***/ function(module, exports, __webpack_require__) {
	
		// CodeMirror, copyright (c) by Marijn Haverbeke and others
		// Distributed under an MIT license: http://codemirror.net/LICENSE
		
		// Because sometimes you need to mark the selected *text*.
		//
		// Adds an option 'styleSelectedText' which, when enabled, gives
		// selected text the CSS class given as option value, or
		// "CodeMirror-selectedtext" when the value is not a string.
		
		(function(mod) {
		  if (true) // CommonJS
		    mod(__webpack_require__(161));
		  else if (typeof define == "function" && define.amd) // AMD
		    define(["../../lib/codemirror"], mod);
		  else // Plain browser env
		    mod(CodeMirror);
		})(function(CodeMirror) {
		  "use strict";
		
		  CodeMirror.defineOption("styleSelectedText", false, function(cm, val, old) {
		    var prev = old && old != CodeMirror.Init;
		    if (val && !prev) {
		      cm.state.markedSelection = [];
		      cm.state.markedSelectionStyle = typeof val == "string" ? val : "CodeMirror-selectedtext";
		      reset(cm);
		      cm.on("cursorActivity", onCursorActivity);
		      cm.on("change", onChange);
		    } else if (!val && prev) {
		      cm.off("cursorActivity", onCursorActivity);
		      cm.off("change", onChange);
		      clear(cm);
		      cm.state.markedSelection = cm.state.markedSelectionStyle = null;
		    }
		  });
		
		  function onCursorActivity(cm) {
		    if (cm.state.markedSelection)
		      cm.operation(function() { update(cm); });
		  }
		
		  function onChange(cm) {
		    if (cm.state.markedSelection && cm.state.markedSelection.length)
		      cm.operation(function() { clear(cm); });
		  }
		
		  var CHUNK_SIZE = 8;
		  var Pos = CodeMirror.Pos;
		  var cmp = CodeMirror.cmpPos;
		
		  function coverRange(cm, from, to, addAt) {
		    if (cmp(from, to) == 0) return;
		    var array = cm.state.markedSelection;
		    var cls = cm.state.markedSelectionStyle;
		    for (var line = from.line;;) {
		      var start = line == from.line ? from : Pos(line, 0);
		      var endLine = line + CHUNK_SIZE, atEnd = endLine >= to.line;
		      var end = atEnd ? to : Pos(endLine, 0);
		      var mark = cm.markText(start, end, {className: cls});
		      if (addAt == null) array.push(mark);
		      else array.splice(addAt++, 0, mark);
		      if (atEnd) break;
		      line = endLine;
		    }
		  }
		
		  function clear(cm) {
		    var array = cm.state.markedSelection;
		    for (var i = 0; i < array.length; ++i) array[i].clear();
		    array.length = 0;
		  }
		
		  function reset(cm) {
		    clear(cm);
		    var ranges = cm.listSelections();
		    for (var i = 0; i < ranges.length; i++)
		      coverRange(cm, ranges[i].from(), ranges[i].to());
		  }
		
		  function update(cm) {
		    if (!cm.somethingSelected()) return clear(cm);
		    if (cm.listSelections().length > 1) return reset(cm);
		
		    var from = cm.getCursor("start"), to = cm.getCursor("end");
		
		    var array = cm.state.markedSelection;
		    if (!array.length) return coverRange(cm, from, to);
		
		    var coverStart = array[0].find(), coverEnd = array[array.length - 1].find();
		    if (!coverStart || !coverEnd || to.line - from.line < CHUNK_SIZE ||
		        cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0)
		      return reset(cm);
		
		    while (cmp(from, coverStart.from) > 0) {
		      array.shift().clear();
		      coverStart = array[0].find();
		    }
		    if (cmp(from, coverStart.from) < 0) {
		      if (coverStart.to.line - from.line < CHUNK_SIZE) {
		        array.shift().clear();
		        coverRange(cm, from, coverStart.to, 0);
		      } else {
		        coverRange(cm, from, coverStart.from, 0);
		      }
		    }
		
		    while (cmp(to, coverEnd.to) < 0) {
		      array.pop().clear();
		      coverEnd = array[array.length - 1].find();
		    }
		    if (cmp(to, coverEnd.to) > 0) {
		      if (to.line - coverEnd.from.line < CHUNK_SIZE) {
		        array.pop().clear();
		        coverRange(cm, coverEnd.from, to);
		      } else {
		        coverRange(cm, coverEnd.to, to);
		      }
		    }
		  }
		});
	
	
	/***/ },
	/* 171 */
	/***/ function(module, exports, __webpack_require__) {
	
		// CodeMirror, copyright (c) by Marijn Haverbeke and others
		// Distributed under an MIT license: http://codemirror.net/LICENSE
		
		(function(mod) {
		  if (true) // CommonJS
		    mod(__webpack_require__(161), __webpack_require__(165), __webpack_require__(168));
		  else if (typeof define == "function" && define.amd) // AMD
		    define(["../../lib/codemirror", "../markdown/markdown", "../../addon/mode/overlay"], mod);
		  else // Plain browser env
		    mod(CodeMirror);
		})(function(CodeMirror) {
		"use strict";
		
		var urlRE = /^((?:(?:aaas?|about|acap|adiumxtra|af[ps]|aim|apt|attachment|aw|beshare|bitcoin|bolo|callto|cap|chrome(?:-extension)?|cid|coap|com-eventbrite-attendee|content|crid|cvs|data|dav|dict|dlna-(?:playcontainer|playsingle)|dns|doi|dtn|dvb|ed2k|facetime|feed|file|finger|fish|ftp|geo|gg|git|gizmoproject|go|gopher|gtalk|h323|hcp|https?|iax|icap|icon|im|imap|info|ipn|ipp|irc[6s]?|iris(?:\.beep|\.lwz|\.xpc|\.xpcs)?|itms|jar|javascript|jms|keyparc|lastfm|ldaps?|magnet|mailto|maps|market|message|mid|mms|ms-help|msnim|msrps?|mtqp|mumble|mupdate|mvn|news|nfs|nih?|nntp|notes|oid|opaquelocktoken|palm|paparazzi|platform|pop|pres|proxy|psyc|query|res(?:ource)?|rmi|rsync|rtmp|rtsp|secondlife|service|session|sftp|sgn|shttp|sieve|sips?|skype|sm[bs]|snmp|soap\.beeps?|soldat|spotify|ssh|steam|svn|tag|teamspeak|tel(?:net)?|tftp|things|thismessage|tip|tn3270|tv|udp|unreal|urn|ut2004|vemmi|ventrilo|view-source|webcal|wss?|wtai|wyciwyg|xcon(?:-userid)?|xfire|xmlrpc\.beeps?|xmpp|xri|ymsgr|z39\.50[rs]?):(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]|\([^\s()<>]*\))+(?:\([^\s()<>]*\)|[^\s`*!()\[\]{};:'".,<>?«»“”‘’]))/i
		
		CodeMirror.defineMode("gfm", function(config, modeConfig) {
		  var codeDepth = 0;
		  function blankLine(state) {
		    state.code = false;
		    return null;
		  }
		  var gfmOverlay = {
		    startState: function() {
		      return {
		        code: false,
		        codeBlock: false,
		        ateSpace: false
		      };
		    },
		    copyState: function(s) {
		      return {
		        code: s.code,
		        codeBlock: s.codeBlock,
		        ateSpace: s.ateSpace
		      };
		    },
		    token: function(stream, state) {
		      state.combineTokens = null;
		
		      // Hack to prevent formatting override inside code blocks (block and inline)
		      if (state.codeBlock) {
		        if (stream.match(/^```+/)) {
		          state.codeBlock = false;
		          return null;
		        }
		        stream.skipToEnd();
		        return null;
		      }
		      if (stream.sol()) {
		        state.code = false;
		      }
		      if (stream.sol() && stream.match(/^```+/)) {
		        stream.skipToEnd();
		        state.codeBlock = true;
		        return null;
		      }
		      // If this block is changed, it may need to be updated in Markdown mode
		      if (stream.peek() === '`') {
		        stream.next();
		        var before = stream.pos;
		        stream.eatWhile('`');
		        var difference = 1 + stream.pos - before;
		        if (!state.code) {
		          codeDepth = difference;
		          state.code = true;
		        } else {
		          if (difference === codeDepth) { // Must be exact
		            state.code = false;
		          }
		        }
		        return null;
		      } else if (state.code) {
		        stream.next();
		        return null;
		      }
		      // Check if space. If so, links can be formatted later on
		      if (stream.eatSpace()) {
		        state.ateSpace = true;
		        return null;
		      }
		      if (stream.sol() || state.ateSpace) {
		        state.ateSpace = false;
		        if (modeConfig.gitHubSpice !== false) {
		          if(stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+@)?(?:[a-f0-9]{7,40}\b)/)) {
		            // User/Project@SHA
		            // User@SHA
		            // SHA
		            state.combineTokens = true;
		            return "link";
		          } else if (stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+)?#[0-9]+\b/)) {
		            // User/Project#Num
		            // User#Num
		            // #Num
		            state.combineTokens = true;
		            return "link";
		          }
		        }
		      }
		      if (stream.match(urlRE) &&
		          stream.string.slice(stream.start - 2, stream.start) != "](" &&
		          (stream.start == 0 || /\W/.test(stream.string.charAt(stream.start - 1)))) {
		        // URLs
		        // Taken from http://daringfireball.net/2010/07/improved_regex_for_matching_urls
		        // And then (issue #1160) simplified to make it not crash the Chrome Regexp engine
		        // And then limited url schemes to the CommonMark list, so foo:bar isn't matched as a URL
		        state.combineTokens = true;
		        return "link";
		      }
		      stream.next();
		      return null;
		    },
		    blankLine: blankLine
		  };
		
		  var markdownConfig = {
		    underscoresBreakWords: false,
		    taskLists: true,
		    fencedCodeBlocks: '```',
		    strikethrough: true
		  };
		  for (var attr in modeConfig) {
		    markdownConfig[attr] = modeConfig[attr];
		  }
		  markdownConfig.name = "markdown";
		  return CodeMirror.overlayMode(CodeMirror.getMode(config, markdownConfig), gfmOverlay);
		
		}, "markdown");
		
		  CodeMirror.defineMIME("text/x-gfm", "gfm");
		});
	
	
	/***/ },
	/* 172 */
	/***/ function(module, exports, __webpack_require__) {
	
		// Use strict mode (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)
		"use strict";
		
		
		// Requires
		var Typo = __webpack_require__(173);
		
		
		// Create function
		function CodeMirrorSpellChecker(options) {
			// Initialize
			options = options || {};
		
		
			// Verify
			if(typeof options.codeMirrorInstance !== "function" || typeof options.codeMirrorInstance.defineMode !== "function") {
				console.log("CodeMirror Spell Checker: You must provide an instance of CodeMirror via the option `codeMirrorInstance`");
				return;
			}
		
		
			// Because some browsers don't support this functionality yet
			if(!String.prototype.includes) {
				String.prototype.includes = function() {
					"use strict";
					return String.prototype.indexOf.apply(this, arguments) !== -1;
				};
			}
		
		
			// Define the new mode
			options.codeMirrorInstance.defineMode("spell-checker", function(config) {
				// Load AFF/DIC data
				if(!CodeMirrorSpellChecker.aff_loading) {
					CodeMirrorSpellChecker.aff_loading = true;
					var xhr_aff = new XMLHttpRequest();
					xhr_aff.open("GET", "https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.aff", true);
					xhr_aff.onload = function() {
						if(xhr_aff.readyState === 4 && xhr_aff.status === 200) {
							CodeMirrorSpellChecker.aff_data = xhr_aff.responseText;
							CodeMirrorSpellChecker.num_loaded++;
		
							if(CodeMirrorSpellChecker.num_loaded == 2) {
								CodeMirrorSpellChecker.typo = new Typo("en_US", CodeMirrorSpellChecker.aff_data, CodeMirrorSpellChecker.dic_data, {
									platform: "any"
								});
							}
						}
					};
					xhr_aff.send(null);
				}
		
				if(!CodeMirrorSpellChecker.dic_loading) {
					CodeMirrorSpellChecker.dic_loading = true;
					var xhr_dic = new XMLHttpRequest();
					xhr_dic.open("GET", "https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.dic", true);
					xhr_dic.onload = function() {
						if(xhr_dic.readyState === 4 && xhr_dic.status === 200) {
							CodeMirrorSpellChecker.dic_data = xhr_dic.responseText;
							CodeMirrorSpellChecker.num_loaded++;
		
							if(CodeMirrorSpellChecker.num_loaded == 2) {
								CodeMirrorSpellChecker.typo = new Typo("en_US", CodeMirrorSpellChecker.aff_data, CodeMirrorSpellChecker.dic_data, {
									platform: "any"
								});
							}
						}
					};
					xhr_dic.send(null);
				}
		
		
				// Define what separates a word
				var rx_word = "!\"#$%&()*+,-./:;<=>?@[\\]^_`{|}~ ";
		
		
				// Create the overlay and such
				var overlay = {
					token: function(stream) {
						var ch = stream.peek();
						var word = "";
		
						if(rx_word.includes(ch)) {
							stream.next();
							return null;
						}
		
						while((ch = stream.peek()) != null && !rx_word.includes(ch)) {
							word += ch;
							stream.next();
						}
		
						if(CodeMirrorSpellChecker.typo && !CodeMirrorSpellChecker.typo.check(word))
							return "spell-error"; // CSS class: cm-spell-error
		
						return null;
					}
				};
		
				var mode = options.codeMirrorInstance.getMode(
					config, config.backdrop || "text/plain"
				);
		
				return options.codeMirrorInstance.overlayMode(mode, overlay, true);
			});
		}
		
		
		// Initialize data globally to reduce memory consumption
		CodeMirrorSpellChecker.num_loaded = 0;
		CodeMirrorSpellChecker.aff_loading = false;
		CodeMirrorSpellChecker.dic_loading = false;
		CodeMirrorSpellChecker.aff_data = "";
		CodeMirrorSpellChecker.dic_data = "";
		CodeMirrorSpellChecker.typo;
		
		
		// Export
		module.exports = CodeMirrorSpellChecker;
	
	/***/ },
	/* 173 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(__dirname, Buffer) {/* globals chrome: false */
		/* globals __dirname: false */
		/* globals require: false */
		/* globals Buffer: false */
		/* globals module: false */
		
		/**
		 * Typo is a JavaScript implementation of a spellchecker using hunspell-style 
		 * dictionaries.
		 */
		
		var Typo;
		
		(function () {
		"use strict";
		
		/**
		 * Typo constructor.
		 *
		 * @param {String} [dictionary] The locale code of the dictionary being used. e.g.,
		 *                              "en_US". This is only used to auto-load dictionaries.
		 * @param {String} [affData]    The data from the dictionary's .aff file. If omitted
		 *                              and Typo.js is being used in a Chrome extension, the .aff
		 *                              file will be loaded automatically from
		 *                              lib/typo/dictionaries/[dictionary]/[dictionary].aff
		 *                              In other environments, it will be loaded from
		 *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].aff
		 * @param {String} [wordsData]  The data from the dictionary's .dic file. If omitted
		 *                              and Typo.js is being used in a Chrome extension, the .dic
		 *                              file will be loaded automatically from
		 *                              lib/typo/dictionaries/[dictionary]/[dictionary].dic
		 *                              In other environments, it will be loaded from
		 *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].dic
		 * @param {Object} [settings]   Constructor settings. Available properties are:
		 *                              {String} [dictionaryPath]: path to load dictionary from in non-chrome
		 *                              environment.
		 *                              {Object} [flags]: flag information.
		 *                              {Boolean} [asyncLoad]: If true, affData and wordsData will be loaded
		 *                              asynchronously.
		 *                              {Function} [loadedCallback]: Called when both affData and wordsData
		 *                              have been loaded. Only used if asyncLoad is set to true. The parameter
		 *                              is the instantiated Typo object.
		 *
		 * @returns {Typo} A Typo object.
		 */
		
		Typo = function (dictionary, affData, wordsData, settings) {
			settings = settings || {};
		
			this.dictionary = null;
			
			this.rules = {};
			this.dictionaryTable = {};
			
			this.compoundRules = [];
			this.compoundRuleCodes = {};
			
			this.replacementTable = [];
			
			this.flags = settings.flags || {}; 
			
			this.memoized = {};
		
			this.loaded = false;
			
			var self = this;
			
			var path;
			
			// Loop-control variables.
			var i, j, _len, _jlen;
			
			if (dictionary) {
				self.dictionary = dictionary;
				
				// If the data is preloaded, just setup the Typo object.
				if (affData && wordsData) {
					setup();
				}
				// Loading data for Chrome extentions.
				else if (typeof window !== 'undefined' && 'chrome' in window && 'extension' in window.chrome && 'getURL' in window.chrome.extension) {
					if (settings.dictionaryPath) {
						path = settings.dictionaryPath;
					}
					else {
						path = "typo/dictionaries";
					}
					
					if (!affData) readDataFile(chrome.extension.getURL(path + "/" + dictionary + "/" + dictionary + ".aff"), setAffData);
					if (!wordsData) readDataFile(chrome.extension.getURL(path + "/" + dictionary + "/" + dictionary + ".dic"), setWordsData);
				}
				else {
					if (settings.dictionaryPath) {
						path = settings.dictionaryPath;
					}
					else if (true) {
						path = __dirname + '/dictionaries';
					}
					else {
						path = './dictionaries';
					}
					
					if (!affData) readDataFile(path + "/" + dictionary + "/" + dictionary + ".aff", setAffData);
					if (!wordsData) readDataFile(path + "/" + dictionary + "/" + dictionary + ".dic", setWordsData);
				}
			}
			
			function readDataFile(url, setFunc) {
				var response = self._readFile(url, null, settings.asyncLoad);
				
				if (settings.asyncLoad) {
					response.then(function(data) {
						setFunc(data);
					});
				}
				else {
					setFunc(response);
				}
			}
		
			function setAffData(data) {
				affData = data;
		
				if (wordsData) {
					setup();
				}
			}
		
			function setWordsData(data) {
				wordsData = data;
		
				if (affData) {
					setup();
				}
			}
		
			function setup() {
				self.rules = self._parseAFF(affData);
				
				// Save the rule codes that are used in compound rules.
				self.compoundRuleCodes = {};
				
				for (i = 0, _len = self.compoundRules.length; i < _len; i++) {
					var rule = self.compoundRules[i];
					
					for (j = 0, _jlen = rule.length; j < _jlen; j++) {
						self.compoundRuleCodes[rule[j]] = [];
					}
				}
				
				// If we add this ONLYINCOMPOUND flag to self.compoundRuleCodes, then _parseDIC
				// will do the work of saving the list of words that are compound-only.
				if ("ONLYINCOMPOUND" in self.flags) {
					self.compoundRuleCodes[self.flags.ONLYINCOMPOUND] = [];
				}
				
				self.dictionaryTable = self._parseDIC(wordsData);
				
				// Get rid of any codes from the compound rule codes that are never used 
				// (or that were special regex characters).  Not especially necessary... 
				for (i in self.compoundRuleCodes) {
					if (self.compoundRuleCodes[i].length === 0) {
						delete self.compoundRuleCodes[i];
					}
				}
				
				// Build the full regular expressions for each compound rule.
				// I have a feeling (but no confirmation yet) that this method of 
				// testing for compound words is probably slow.
				for (i = 0, _len = self.compoundRules.length; i < _len; i++) {
					var ruleText = self.compoundRules[i];
					
					var expressionText = "";
					
					for (j = 0, _jlen = ruleText.length; j < _jlen; j++) {
						var character = ruleText[j];
						
						if (character in self.compoundRuleCodes) {
							expressionText += "(" + self.compoundRuleCodes[character].join("|") + ")";
						}
						else {
							expressionText += character;
						}
					}
					
					self.compoundRules[i] = new RegExp(expressionText, "i");
				}
				
				self.loaded = true;
				
				if (settings.asyncLoad && settings.loadedCallback) {
					settings.loadedCallback(self);
				}
			}
			
			return this;
		};
		
		Typo.prototype = {
			/**
			 * Loads a Typo instance from a hash of all of the Typo properties.
			 *
			 * @param object obj A hash of Typo properties, probably gotten from a JSON.parse(JSON.stringify(typo_instance)).
			 */
			
			load : function (obj) {
				for (var i in obj) {
					if (obj.hasOwnProperty(i)) {
						this[i] = obj[i];
					}
				}
				
				return this;
			},
			
			/**
			 * Read the contents of a file.
			 * 
			 * @param {String} path The path (relative) to the file.
			 * @param {String} [charset="ISO8859-1"] The expected charset of the file
			 * @param {Boolean} async If true, the file will be read asynchronously. For node.js this does nothing, all
			 *        files are read synchronously.
			 * @returns {String} The file data if async is false, otherwise a promise object. If running node.js, the data is
			 *          always returned.
			 */
			
			_readFile : function (path, charset, async) {
				charset = charset || "utf8";
				
				if (typeof XMLHttpRequest !== 'undefined') {
					var promise;
					var req = new XMLHttpRequest();
					req.open("GET", path, async);
					
					if (async) {
						promise = new Promise(function(resolve, reject) {
							req.onload = function() {
								if (req.status === 200) {
									resolve(req.responseText);
								}
								else {
									reject(req.statusText);
								}
							};
							
							req.onerror = function() {
								reject(req.statusText);
							}
						});
					}
				
					if (req.overrideMimeType)
						req.overrideMimeType("text/plain; charset=" + charset);
				
					req.send(null);
					
					return async ? promise : req.responseText;
				}
				else if (true) {
					// Node.js
					var fs = __webpack_require__(178);
					
					try {
						if (fs.existsSync(path)) {
							var stats = fs.statSync(path);
							
							var fileDescriptor = fs.openSync(path, 'r');
							
							var buffer = new Buffer(stats.size);
							
							fs.readSync(fileDescriptor, buffer, 0, buffer.length, null);
							
							return buffer.toString(charset, 0, buffer.length);
						}
						else {
							console.log("Path " + path + " does not exist.");
						}
					} catch (e) {
						console.log(e);
						return '';
					}
				}
			},
			
			/**
			 * Parse the rules out from a .aff file.
			 *
			 * @param {String} data The contents of the affix file.
			 * @returns object The rules from the file.
			 */
			
			_parseAFF : function (data) {
				var rules = {};
				
				var line, subline, numEntries, lineParts;
				var i, j, _len, _jlen;
				
				// Remove comment lines
				data = this._removeAffixComments(data);
				
				var lines = data.split("\n");
				
				for (i = 0, _len = lines.length; i < _len; i++) {
					line = lines[i];
					
					var definitionParts = line.split(/\s+/);
					
					var ruleType = definitionParts[0];
					
					if (ruleType == "PFX" || ruleType == "SFX") {
						var ruleCode = definitionParts[1];
						var combineable = definitionParts[2];
						numEntries = parseInt(definitionParts[3], 10);
						
						var entries = [];
						
						for (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {
							subline = lines[j];
							
							lineParts = subline.split(/\s+/);
							var charactersToRemove = lineParts[2];
							
							var additionParts = lineParts[3].split("/");
							
							var charactersToAdd = additionParts[0];
							if (charactersToAdd === "0") charactersToAdd = "";
							
							var continuationClasses = this.parseRuleCodes(additionParts[1]);
							
							var regexToMatch = lineParts[4];
							
							var entry = {};
							entry.add = charactersToAdd;
							
							if (continuationClasses.length > 0) entry.continuationClasses = continuationClasses;
							
							if (regexToMatch !== ".") {
								if (ruleType === "SFX") {
									entry.match = new RegExp(regexToMatch + "$");
								}
								else {
									entry.match = new RegExp("^" + regexToMatch);
								}
							}
							
							if (charactersToRemove != "0") {
								if (ruleType === "SFX") {
									entry.remove = new RegExp(charactersToRemove  + "$");
								}
								else {
									entry.remove = charactersToRemove;
								}
							}
							
							entries.push(entry);
						}
						
						rules[ruleCode] = { "type" : ruleType, "combineable" : (combineable == "Y"), "entries" : entries };
						
						i += numEntries;
					}
					else if (ruleType === "COMPOUNDRULE") {
						numEntries = parseInt(definitionParts[1], 10);
						
						for (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {
							line = lines[j];
							
							lineParts = line.split(/\s+/);
							this.compoundRules.push(lineParts[1]);
						}
						
						i += numEntries;
					}
					else if (ruleType === "REP") {
						lineParts = line.split(/\s+/);
						
						if (lineParts.length === 3) {
							this.replacementTable.push([ lineParts[1], lineParts[2] ]);
						}
					}
					else {
						// ONLYINCOMPOUND
						// COMPOUNDMIN
						// FLAG
						// KEEPCASE
						// NEEDAFFIX
						
						this.flags[ruleType] = definitionParts[1];
					}
				}
				
				return rules;
			},
			
			/**
			 * Removes comment lines and then cleans up blank lines and trailing whitespace.
			 *
			 * @param {String} data The data from an affix file.
			 * @return {String} The cleaned-up data.
			 */
			
			_removeAffixComments : function (data) {
				// Remove comments
				// This used to remove any string starting with '#' up to the end of the line,
				// but some COMPOUNDRULE definitions include '#' as part of the rule.
				// I haven't seen any affix files that use comments on the same line as real data,
				// so I don't think this will break anything.
				data = data.replace(/^\s*#.*$/mg, "");
				
				// Trim each line
				data = data.replace(/^\s\s*/m, '').replace(/\s\s*$/m, '');
				
				// Remove blank lines.
				data = data.replace(/\n{2,}/g, "\n");
				
				// Trim the entire string
				data = data.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
				
				return data;
			},
			
			/**
			 * Parses the words out from the .dic file.
			 *
			 * @param {String} data The data from the dictionary file.
			 * @returns object The lookup table containing all of the words and
			 *                 word forms from the dictionary.
			 */
			
			_parseDIC : function (data) {
				data = this._removeDicComments(data);
				
				var lines = data.split("\n");
				var dictionaryTable = {};
				
				function addWord(word, rules) {
					// Some dictionaries will list the same word multiple times with different rule sets.
					if (!dictionaryTable.hasOwnProperty(word)) {
						dictionaryTable[word] = null;
					}
					
					if (rules.length > 0) {
						if (dictionaryTable[word] === null) {
							dictionaryTable[word] = [];
						}
		
						dictionaryTable[word].push(rules);
					}
				}
				
				// The first line is the number of words in the dictionary.
				for (var i = 1, _len = lines.length; i < _len; i++) {
					var line = lines[i];
					
					var parts = line.split("/", 2);
					
					var word = parts[0];
		
					// Now for each affix rule, generate that form of the word.
					if (parts.length > 1) {
						var ruleCodesArray = this.parseRuleCodes(parts[1]);
						
						// Save the ruleCodes for compound word situations.
						if (!("NEEDAFFIX" in this.flags) || ruleCodesArray.indexOf(this.flags.NEEDAFFIX) == -1) {
							addWord(word, ruleCodesArray);
						}
						
						for (var j = 0, _jlen = ruleCodesArray.length; j < _jlen; j++) {
							var code = ruleCodesArray[j];
							
							var rule = this.rules[code];
							
							if (rule) {
								var newWords = this._applyRule(word, rule);
								
								for (var ii = 0, _iilen = newWords.length; ii < _iilen; ii++) {
									var newWord = newWords[ii];
									
									addWord(newWord, []);
									
									if (rule.combineable) {
										for (var k = j + 1; k < _jlen; k++) {
											var combineCode = ruleCodesArray[k];
											
											var combineRule = this.rules[combineCode];
											
											if (combineRule) {
												if (combineRule.combineable && (rule.type != combineRule.type)) {
													var otherNewWords = this._applyRule(newWord, combineRule);
													
													for (var iii = 0, _iiilen = otherNewWords.length; iii < _iiilen; iii++) {
														var otherNewWord = otherNewWords[iii];
														addWord(otherNewWord, []);
													}
												}
											}
										}
									}
								}
							}
							
							if (code in this.compoundRuleCodes) {
								this.compoundRuleCodes[code].push(word);
							}
						}
					}
					else {
						addWord(word.trim(), []);
					}
				}
				
				return dictionaryTable;
			},
			
			
			/**
			 * Removes comment lines and then cleans up blank lines and trailing whitespace.
			 *
			 * @param {String} data The data from a .dic file.
			 * @return {String} The cleaned-up data.
			 */
			
			_removeDicComments : function (data) {
				// I can't find any official documentation on it, but at least the de_DE
				// dictionary uses tab-indented lines as comments.
				
				// Remove comments
				data = data.replace(/^\t.*$/mg, "");
				
				return data;
			},
			
			parseRuleCodes : function (textCodes) {
				if (!textCodes) {
					return [];
				}
				else if (!("FLAG" in this.flags)) {
					return textCodes.split("");
				}
				else if (this.flags.FLAG === "long") {
					var flags = [];
					
					for (var i = 0, _len = textCodes.length; i < _len; i += 2) {
						flags.push(textCodes.substr(i, 2));
					}
					
					return flags;
				}
				else if (this.flags.FLAG === "num") {
					return textCodes.split(",");
				}
			},
			
			/**
			 * Applies an affix rule to a word.
			 *
			 * @param {String} word The base word.
			 * @param {Object} rule The affix rule.
			 * @returns {String[]} The new words generated by the rule.
			 */
			
			_applyRule : function (word, rule) {
				var entries = rule.entries;
				var newWords = [];
				
				for (var i = 0, _len = entries.length; i < _len; i++) {
					var entry = entries[i];
					
					if (!entry.match || word.match(entry.match)) {
						var newWord = word;
						
						if (entry.remove) {
							newWord = newWord.replace(entry.remove, "");
						}
						
						if (rule.type === "SFX") {
							newWord = newWord + entry.add;
						}
						else {
							newWord = entry.add + newWord;
						}
						
						newWords.push(newWord);
						
						if ("continuationClasses" in entry) {
							for (var j = 0, _jlen = entry.continuationClasses.length; j < _jlen; j++) {
								var continuationRule = this.rules[entry.continuationClasses[j]];
								
								if (continuationRule) {
									newWords = newWords.concat(this._applyRule(newWord, continuationRule));
								}
								/*
								else {
									// This shouldn't happen, but it does, at least in the de_DE dictionary.
									// I think the author mistakenly supplied lower-case rule codes instead 
									// of upper-case.
								}
								*/
							}
						}
					}
				}
				
				return newWords;
			},
			
			/**
			 * Checks whether a word or a capitalization variant exists in the current dictionary.
			 * The word is trimmed and several variations of capitalizations are checked.
			 * If you want to check a word without any changes made to it, call checkExact()
			 *
			 * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function
			 *
			 * @param {String} aWord The word to check.
			 * @returns {Boolean}
			 */
			
			check : function (aWord) {
				if (!this.loaded) {
					throw "Dictionary not loaded.";
				}
				
				// Remove leading and trailing whitespace
				var trimmedWord = aWord.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
				
				if (this.checkExact(trimmedWord)) {
					return true;
				}
				
				// The exact word is not in the dictionary.
				if (trimmedWord.toUpperCase() === trimmedWord) {
					// The word was supplied in all uppercase.
					// Check for a capitalized form of the word.
					var capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();
					
					if (this.hasFlag(capitalizedWord, "KEEPCASE")) {
						// Capitalization variants are not allowed for this word.
						return false;
					}
					
					if (this.checkExact(capitalizedWord)) {
						return true;
					}
				}
				
				var lowercaseWord = trimmedWord.toLowerCase();
				
				if (lowercaseWord !== trimmedWord) {
					if (this.hasFlag(lowercaseWord, "KEEPCASE")) {
						// Capitalization variants are not allowed for this word.
						return false;
					}
					
					// Check for a lowercase form
					if (this.checkExact(lowercaseWord)) {
						return true;
					}
				}
				
				return false;
			},
			
			/**
			 * Checks whether a word exists in the current dictionary.
			 *
			 * @param {String} word The word to check.
			 * @returns {Boolean}
			 */
			
			checkExact : function (word) {
				if (!this.loaded) {
					throw "Dictionary not loaded.";
				}
		
				var ruleCodes = this.dictionaryTable[word];
				
				var i, _len;
				
				if (typeof ruleCodes === 'undefined') {
					// Check if this might be a compound word.
					if ("COMPOUNDMIN" in this.flags && word.length >= this.flags.COMPOUNDMIN) {
						for (i = 0, _len = this.compoundRules.length; i < _len; i++) {
							if (word.match(this.compoundRules[i])) {
								return true;
							}
						}
					}
				}
				else if (ruleCodes === null) {
					// a null (but not undefined) value for an entry in the dictionary table
					// means that the word is in the dictionary but has no flags.
					return true;
				}
				else if (typeof ruleCodes === 'object') { // this.dictionary['hasOwnProperty'] will be a function.
					for (i = 0, _len = ruleCodes.length; i < _len; i++) {
						if (!this.hasFlag(word, "ONLYINCOMPOUND", ruleCodes[i])) {
							return true;
						}
					}
				}
		
				return false;
			},
			
			/**
			 * Looks up whether a given word is flagged with a given flag.
			 *
			 * @param {String} word The word in question.
			 * @param {String} flag The flag in question.
			 * @return {Boolean}
			 */
			 
			hasFlag : function (word, flag, wordFlags) {
				if (!this.loaded) {
					throw "Dictionary not loaded.";
				}
		
				if (flag in this.flags) {
					if (typeof wordFlags === 'undefined') {
						wordFlags = Array.prototype.concat.apply([], this.dictionaryTable[word]);
					}
					
					if (wordFlags && wordFlags.indexOf(this.flags[flag]) !== -1) {
						return true;
					}
				}
				
				return false;
			},
			
			/**
			 * Returns a list of suggestions for a misspelled word.
			 *
			 * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.
			 * This suggestor is primitive, but it works.
			 *
			 * @param {String} word The misspelling.
			 * @param {Number} [limit=5] The maximum number of suggestions to return.
			 * @returns {String[]} The array of suggestions.
			 */
			
			alphabet : "",
			
			suggest : function (word, limit) {
				if (!this.loaded) {
					throw "Dictionary not loaded.";
				}
		
				limit = limit || 5;
		
				if (this.memoized.hasOwnProperty(word)) {
					var memoizedLimit = this.memoized[word]['limit'];
		
					// Only return the cached list if it's big enough or if there weren't enough suggestions
					// to fill a smaller limit.
					if (limit <= memoizedLimit || this.memoized[word]['suggestions'].length < memoizedLimit) {
						return this.memoized[word]['suggestions'].slice(0, limit);
					}
				}
				
				if (this.check(word)) return [];
				
				// Check the replacement table.
				for (var i = 0, _len = this.replacementTable.length; i < _len; i++) {
					var replacementEntry = this.replacementTable[i];
					
					if (word.indexOf(replacementEntry[0]) !== -1) {
						var correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);
						
						if (this.check(correctedWord)) {
							return [ correctedWord ];
						}
					}
				}
				
				var self = this;
				self.alphabet = "abcdefghijklmnopqrstuvwxyz";
				
				/*
				if (!self.alphabet) {
					// Use the alphabet as implicitly defined by the words in the dictionary.
					var alphaHash = {};
					
					for (var i in self.dictionaryTable) {
						for (var j = 0, _len = i.length; j < _len; j++) {
							alphaHash[i[j]] = true;
						}
					}
					
					for (var i in alphaHash) {
						self.alphabet += i;
					}
					
					var alphaArray = self.alphabet.split("");
					alphaArray.sort();
					self.alphabet = alphaArray.join("");
				}
				*/
				
				function edits1(words) {
					var rv = [];
					
					var ii, i, j, _iilen, _len, _jlen;
					
					for (ii = 0, _iilen = words.length; ii < _iilen; ii++) {
						var word = words[ii];
						
						for (i = 0, _len = word.length + 1; i < _len; i++) {
							var s = [ word.substring(0, i), word.substring(i) ];
						
							if (s[1]) {
								rv.push(s[0] + s[1].substring(1));
							}
							
							// Eliminate transpositions of identical letters
							if (s[1].length > 1 && s[1][1] !== s[1][0]) {
								rv.push(s[0] + s[1][1] + s[1][0] + s[1].substring(2));
							}
		
							if (s[1]) {
								for (j = 0, _jlen = self.alphabet.length; j < _jlen; j++) {
									// Eliminate replacement of a letter by itself
									if (self.alphabet[j] != s[1].substring(0,1)){
										rv.push(s[0] + self.alphabet[j] + s[1].substring(1));
									}
								}
							}
		
							if (s[1]) {
								for (j = 0, _jlen = self.alphabet.length; j < _jlen; j++) {
									rv.push(s[0] + self.alphabet[j] + s[1]);
								}
							}
						}
					}
					
					return rv;
				}
				
				function known(words) {
					var rv = [];
					
					for (var i = 0, _len = words.length; i < _len; i++) {
						if (self.check(words[i])) {
							rv.push(words[i]);
						}
					}
					
					return rv;
				}
				
				function correct(word) {
					// Get the edit-distance-1 and edit-distance-2 forms of this word.
					var ed1 = edits1([word]);
					var ed2 = edits1(ed1);
					
					var corrections = known(ed1.concat(ed2));
					
					var i, _len;
					
					// Sort the edits based on how many different ways they were created.
					var weighted_corrections = {};
					
					for (i = 0, _len = corrections.length; i < _len; i++) {
						if (!(corrections[i] in weighted_corrections)) {
							weighted_corrections[corrections[i]] = 1;
						}
						else {
							weighted_corrections[corrections[i]] += 1;
						}
					}
					
					var sorted_corrections = [];
					
					for (i in weighted_corrections) {
						if (weighted_corrections.hasOwnProperty(i)) {
							sorted_corrections.push([ i, weighted_corrections[i] ]);
						}
					}
					
					function sorter(a, b) {
						if (a[1] < b[1]) {
							return -1;
						}
						
						return 1;
					}
					
					sorted_corrections.sort(sorter).reverse();
					
					var rv = [];
		
					var capitalization_scheme = "lowercase";
					
					if (word.toUpperCase() === word) {
						capitalization_scheme = "uppercase";
					}
					else if (word.substr(0, 1).toUpperCase() + word.substr(1).toLowerCase() === word) {
						capitalization_scheme = "capitalized";
					}
					
					for (i = 0, _len = Math.min(limit, sorted_corrections.length); i < _len; i++) {
						if ("uppercase" === capitalization_scheme) {
							sorted_corrections[i][0] = sorted_corrections[i][0].toUpperCase();
						}
						else if ("capitalized" === capitalization_scheme) {
							sorted_corrections[i][0] = sorted_corrections[i][0].substr(0, 1).toUpperCase() + sorted_corrections[i][0].substr(1);
						}
						
						if (!self.hasFlag(sorted_corrections[i][0], "NOSUGGEST")) {
							rv.push(sorted_corrections[i][0]);
						}
					}
					
					return rv;
				}
				
				this.memoized[word] = {
					'suggestions': correct(word),
					'limit': limit
				};
		
				return this.memoized[word]['suggestions'];
			}
		};
		})();
		
		// Support for use as a node.js module.
		if (true) {
			module.exports = Typo;
		}
		/* WEBPACK VAR INJECTION */}.call(exports, "/", __webpack_require__(174).Buffer))
	
	/***/ },
	/* 174 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(global) {/*!
		 * The buffer module from node.js, for the browser.
		 *
		 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
		 * @license  MIT
		 */
		/* eslint-disable no-proto */
		
		'use strict'
		
		var base64 = __webpack_require__(175)
		var ieee754 = __webpack_require__(176)
		var isArray = __webpack_require__(177)
		
		exports.Buffer = Buffer
		exports.SlowBuffer = SlowBuffer
		exports.INSPECT_MAX_BYTES = 50
		
		/**
		 * If `Buffer.TYPED_ARRAY_SUPPORT`:
		 *   === true    Use Uint8Array implementation (fastest)
		 *   === false   Use Object implementation (most compatible, even IE6)
		 *
		 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
		 * Opera 11.6+, iOS 4.2+.
		 *
		 * Due to various browser bugs, sometimes the Object implementation will be used even
		 * when the browser supports typed arrays.
		 *
		 * Note:
		 *
		 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
		 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
		 *
		 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
		 *
		 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
		 *     incorrect length in some situations.
		
		 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
		 * get the Object implementation, which is slower but behaves correctly.
		 */
		Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
		  ? global.TYPED_ARRAY_SUPPORT
		  : typedArraySupport()
		
		/*
		 * Export kMaxLength after typed array support is determined.
		 */
		exports.kMaxLength = kMaxLength()
		
		function typedArraySupport () {
		  try {
		    var arr = new Uint8Array(1)
		    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
		    return arr.foo() === 42 && // typed array instances can be augmented
		        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
		        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
		  } catch (e) {
		    return false
		  }
		}
		
		function kMaxLength () {
		  return Buffer.TYPED_ARRAY_SUPPORT
		    ? 0x7fffffff
		    : 0x3fffffff
		}
		
		function createBuffer (that, length) {
		  if (kMaxLength() < length) {
		    throw new RangeError('Invalid typed array length')
		  }
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    // Return an augmented `Uint8Array` instance, for best performance
		    that = new Uint8Array(length)
		    that.__proto__ = Buffer.prototype
		  } else {
		    // Fallback: Return an object instance of the Buffer class
		    if (that === null) {
		      that = new Buffer(length)
		    }
		    that.length = length
		  }
		
		  return that
		}
		
		/**
		 * The Buffer constructor returns instances of `Uint8Array` that have their
		 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
		 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
		 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
		 * returns a single octet.
		 *
		 * The `Uint8Array` prototype remains unmodified.
		 */
		
		function Buffer (arg, encodingOrOffset, length) {
		  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
		    return new Buffer(arg, encodingOrOffset, length)
		  }
		
		  // Common case.
		  if (typeof arg === 'number') {
		    if (typeof encodingOrOffset === 'string') {
		      throw new Error(
		        'If encoding is specified then the first argument must be a string'
		      )
		    }
		    return allocUnsafe(this, arg)
		  }
		  return from(this, arg, encodingOrOffset, length)
		}
		
		Buffer.poolSize = 8192 // not used by this implementation
		
		// TODO: Legacy, not needed anymore. Remove in next major version.
		Buffer._augment = function (arr) {
		  arr.__proto__ = Buffer.prototype
		  return arr
		}
		
		function from (that, value, encodingOrOffset, length) {
		  if (typeof value === 'number') {
		    throw new TypeError('"value" argument must not be a number')
		  }
		
		  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
		    return fromArrayBuffer(that, value, encodingOrOffset, length)
		  }
		
		  if (typeof value === 'string') {
		    return fromString(that, value, encodingOrOffset)
		  }
		
		  return fromObject(that, value)
		}
		
		/**
		 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
		 * if value is a number.
		 * Buffer.from(str[, encoding])
		 * Buffer.from(array)
		 * Buffer.from(buffer)
		 * Buffer.from(arrayBuffer[, byteOffset[, length]])
		 **/
		Buffer.from = function (value, encodingOrOffset, length) {
		  return from(null, value, encodingOrOffset, length)
		}
		
		if (Buffer.TYPED_ARRAY_SUPPORT) {
		  Buffer.prototype.__proto__ = Uint8Array.prototype
		  Buffer.__proto__ = Uint8Array
		  if (typeof Symbol !== 'undefined' && Symbol.species &&
		      Buffer[Symbol.species] === Buffer) {
		    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
		    Object.defineProperty(Buffer, Symbol.species, {
		      value: null,
		      configurable: true
		    })
		  }
		}
		
		function assertSize (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('"size" argument must be a number')
		  } else if (size < 0) {
		    throw new RangeError('"size" argument must not be negative')
		  }
		}
		
		function alloc (that, size, fill, encoding) {
		  assertSize(size)
		  if (size <= 0) {
		    return createBuffer(that, size)
		  }
		  if (fill !== undefined) {
		    // Only pay attention to encoding if it's a string. This
		    // prevents accidentally sending in a number that would
		    // be interpretted as a start offset.
		    return typeof encoding === 'string'
		      ? createBuffer(that, size).fill(fill, encoding)
		      : createBuffer(that, size).fill(fill)
		  }
		  return createBuffer(that, size)
		}
		
		/**
		 * Creates a new filled Buffer instance.
		 * alloc(size[, fill[, encoding]])
		 **/
		Buffer.alloc = function (size, fill, encoding) {
		  return alloc(null, size, fill, encoding)
		}
		
		function allocUnsafe (that, size) {
		  assertSize(size)
		  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
		  if (!Buffer.TYPED_ARRAY_SUPPORT) {
		    for (var i = 0; i < size; ++i) {
		      that[i] = 0
		    }
		  }
		  return that
		}
		
		/**
		 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
		 * */
		Buffer.allocUnsafe = function (size) {
		  return allocUnsafe(null, size)
		}
		/**
		 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
		 */
		Buffer.allocUnsafeSlow = function (size) {
		  return allocUnsafe(null, size)
		}
		
		function fromString (that, string, encoding) {
		  if (typeof encoding !== 'string' || encoding === '') {
		    encoding = 'utf8'
		  }
		
		  if (!Buffer.isEncoding(encoding)) {
		    throw new TypeError('"encoding" must be a valid string encoding')
		  }
		
		  var length = byteLength(string, encoding) | 0
		  that = createBuffer(that, length)
		
		  var actual = that.write(string, encoding)
		
		  if (actual !== length) {
		    // Writing a hex string, for example, that contains invalid characters will
		    // cause everything after the first invalid character to be ignored. (e.g.
		    // 'abxxcd' will be treated as 'ab')
		    that = that.slice(0, actual)
		  }
		
		  return that
		}
		
		function fromArrayLike (that, array) {
		  var length = array.length < 0 ? 0 : checked(array.length) | 0
		  that = createBuffer(that, length)
		  for (var i = 0; i < length; i += 1) {
		    that[i] = array[i] & 255
		  }
		  return that
		}
		
		function fromArrayBuffer (that, array, byteOffset, length) {
		  array.byteLength // this throws if `array` is not a valid ArrayBuffer
		
		  if (byteOffset < 0 || array.byteLength < byteOffset) {
		    throw new RangeError('\'offset\' is out of bounds')
		  }
		
		  if (array.byteLength < byteOffset + (length || 0)) {
		    throw new RangeError('\'length\' is out of bounds')
		  }
		
		  if (byteOffset === undefined && length === undefined) {
		    array = new Uint8Array(array)
		  } else if (length === undefined) {
		    array = new Uint8Array(array, byteOffset)
		  } else {
		    array = new Uint8Array(array, byteOffset, length)
		  }
		
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    // Return an augmented `Uint8Array` instance, for best performance
		    that = array
		    that.__proto__ = Buffer.prototype
		  } else {
		    // Fallback: Return an object instance of the Buffer class
		    that = fromArrayLike(that, array)
		  }
		  return that
		}
		
		function fromObject (that, obj) {
		  if (Buffer.isBuffer(obj)) {
		    var len = checked(obj.length) | 0
		    that = createBuffer(that, len)
		
		    if (that.length === 0) {
		      return that
		    }
		
		    obj.copy(that, 0, 0, len)
		    return that
		  }
		
		  if (obj) {
		    if ((typeof ArrayBuffer !== 'undefined' &&
		        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
		      if (typeof obj.length !== 'number' || isnan(obj.length)) {
		        return createBuffer(that, 0)
		      }
		      return fromArrayLike(that, obj)
		    }
		
		    if (obj.type === 'Buffer' && isArray(obj.data)) {
		      return fromArrayLike(that, obj.data)
		    }
		  }
		
		  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
		}
		
		function checked (length) {
		  // Note: cannot use `length < kMaxLength()` here because that fails when
		  // length is NaN (which is otherwise coerced to zero.)
		  if (length >= kMaxLength()) {
		    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
		                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
		  }
		  return length | 0
		}
		
		function SlowBuffer (length) {
		  if (+length != length) { // eslint-disable-line eqeqeq
		    length = 0
		  }
		  return Buffer.alloc(+length)
		}
		
		Buffer.isBuffer = function isBuffer (b) {
		  return !!(b != null && b._isBuffer)
		}
		
		Buffer.compare = function compare (a, b) {
		  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
		    throw new TypeError('Arguments must be Buffers')
		  }
		
		  if (a === b) return 0
		
		  var x = a.length
		  var y = b.length
		
		  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
		    if (a[i] !== b[i]) {
		      x = a[i]
		      y = b[i]
		      break
		    }
		  }
		
		  if (x < y) return -1
		  if (y < x) return 1
		  return 0
		}
		
		Buffer.isEncoding = function isEncoding (encoding) {
		  switch (String(encoding).toLowerCase()) {
		    case 'hex':
		    case 'utf8':
		    case 'utf-8':
		    case 'ascii':
		    case 'latin1':
		    case 'binary':
		    case 'base64':
		    case 'ucs2':
		    case 'ucs-2':
		    case 'utf16le':
		    case 'utf-16le':
		      return true
		    default:
		      return false
		  }
		}
		
		Buffer.concat = function concat (list, length) {
		  if (!isArray(list)) {
		    throw new TypeError('"list" argument must be an Array of Buffers')
		  }
		
		  if (list.length === 0) {
		    return Buffer.alloc(0)
		  }
		
		  var i
		  if (length === undefined) {
		    length = 0
		    for (i = 0; i < list.length; ++i) {
		      length += list[i].length
		    }
		  }
		
		  var buffer = Buffer.allocUnsafe(length)
		  var pos = 0
		  for (i = 0; i < list.length; ++i) {
		    var buf = list[i]
		    if (!Buffer.isBuffer(buf)) {
		      throw new TypeError('"list" argument must be an Array of Buffers')
		    }
		    buf.copy(buffer, pos)
		    pos += buf.length
		  }
		  return buffer
		}
		
		function byteLength (string, encoding) {
		  if (Buffer.isBuffer(string)) {
		    return string.length
		  }
		  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
		      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
		    return string.byteLength
		  }
		  if (typeof string !== 'string') {
		    string = '' + string
		  }
		
		  var len = string.length
		  if (len === 0) return 0
		
		  // Use a for loop to avoid recursion
		  var loweredCase = false
		  for (;;) {
		    switch (encoding) {
		      case 'ascii':
		      case 'latin1':
		      case 'binary':
		        return len
		      case 'utf8':
		      case 'utf-8':
		      case undefined:
		        return utf8ToBytes(string).length
		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return len * 2
		      case 'hex':
		        return len >>> 1
		      case 'base64':
		        return base64ToBytes(string).length
		      default:
		        if (loweredCase) return utf8ToBytes(string).length // assume utf8
		        encoding = ('' + encoding).toLowerCase()
		        loweredCase = true
		    }
		  }
		}
		Buffer.byteLength = byteLength
		
		function slowToString (encoding, start, end) {
		  var loweredCase = false
		
		  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
		  // property of a typed array.
		
		  // This behaves neither like String nor Uint8Array in that we set start/end
		  // to their upper/lower bounds if the value passed is out of range.
		  // undefined is handled specially as per ECMA-262 6th Edition,
		  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
		  if (start === undefined || start < 0) {
		    start = 0
		  }
		  // Return early if start > this.length. Done here to prevent potential uint32
		  // coercion fail below.
		  if (start > this.length) {
		    return ''
		  }
		
		  if (end === undefined || end > this.length) {
		    end = this.length
		  }
		
		  if (end <= 0) {
		    return ''
		  }
		
		  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
		  end >>>= 0
		  start >>>= 0
		
		  if (end <= start) {
		    return ''
		  }
		
		  if (!encoding) encoding = 'utf8'
		
		  while (true) {
		    switch (encoding) {
		      case 'hex':
		        return hexSlice(this, start, end)
		
		      case 'utf8':
		      case 'utf-8':
		        return utf8Slice(this, start, end)
		
		      case 'ascii':
		        return asciiSlice(this, start, end)
		
		      case 'latin1':
		      case 'binary':
		        return latin1Slice(this, start, end)
		
		      case 'base64':
		        return base64Slice(this, start, end)
		
		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return utf16leSlice(this, start, end)
		
		      default:
		        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
		        encoding = (encoding + '').toLowerCase()
		        loweredCase = true
		    }
		  }
		}
		
		// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
		// Buffer instances.
		Buffer.prototype._isBuffer = true
		
		function swap (b, n, m) {
		  var i = b[n]
		  b[n] = b[m]
		  b[m] = i
		}
		
		Buffer.prototype.swap16 = function swap16 () {
		  var len = this.length
		  if (len % 2 !== 0) {
		    throw new RangeError('Buffer size must be a multiple of 16-bits')
		  }
		  for (var i = 0; i < len; i += 2) {
		    swap(this, i, i + 1)
		  }
		  return this
		}
		
		Buffer.prototype.swap32 = function swap32 () {
		  var len = this.length
		  if (len % 4 !== 0) {
		    throw new RangeError('Buffer size must be a multiple of 32-bits')
		  }
		  for (var i = 0; i < len; i += 4) {
		    swap(this, i, i + 3)
		    swap(this, i + 1, i + 2)
		  }
		  return this
		}
		
		Buffer.prototype.swap64 = function swap64 () {
		  var len = this.length
		  if (len % 8 !== 0) {
		    throw new RangeError('Buffer size must be a multiple of 64-bits')
		  }
		  for (var i = 0; i < len; i += 8) {
		    swap(this, i, i + 7)
		    swap(this, i + 1, i + 6)
		    swap(this, i + 2, i + 5)
		    swap(this, i + 3, i + 4)
		  }
		  return this
		}
		
		Buffer.prototype.toString = function toString () {
		  var length = this.length | 0
		  if (length === 0) return ''
		  if (arguments.length === 0) return utf8Slice(this, 0, length)
		  return slowToString.apply(this, arguments)
		}
		
		Buffer.prototype.equals = function equals (b) {
		  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
		  if (this === b) return true
		  return Buffer.compare(this, b) === 0
		}
		
		Buffer.prototype.inspect = function inspect () {
		  var str = ''
		  var max = exports.INSPECT_MAX_BYTES
		  if (this.length > 0) {
		    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
		    if (this.length > max) str += ' ... '
		  }
		  return '<Buffer ' + str + '>'
		}
		
		Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
		  if (!Buffer.isBuffer(target)) {
		    throw new TypeError('Argument must be a Buffer')
		  }
		
		  if (start === undefined) {
		    start = 0
		  }
		  if (end === undefined) {
		    end = target ? target.length : 0
		  }
		  if (thisStart === undefined) {
		    thisStart = 0
		  }
		  if (thisEnd === undefined) {
		    thisEnd = this.length
		  }
		
		  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
		    throw new RangeError('out of range index')
		  }
		
		  if (thisStart >= thisEnd && start >= end) {
		    return 0
		  }
		  if (thisStart >= thisEnd) {
		    return -1
		  }
		  if (start >= end) {
		    return 1
		  }
		
		  start >>>= 0
		  end >>>= 0
		  thisStart >>>= 0
		  thisEnd >>>= 0
		
		  if (this === target) return 0
		
		  var x = thisEnd - thisStart
		  var y = end - start
		  var len = Math.min(x, y)
		
		  var thisCopy = this.slice(thisStart, thisEnd)
		  var targetCopy = target.slice(start, end)
		
		  for (var i = 0; i < len; ++i) {
		    if (thisCopy[i] !== targetCopy[i]) {
		      x = thisCopy[i]
		      y = targetCopy[i]
		      break
		    }
		  }
		
		  if (x < y) return -1
		  if (y < x) return 1
		  return 0
		}
		
		// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
		// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
		//
		// Arguments:
		// - buffer - a Buffer to search
		// - val - a string, Buffer, or number
		// - byteOffset - an index into `buffer`; will be clamped to an int32
		// - encoding - an optional encoding, relevant is val is a string
		// - dir - true for indexOf, false for lastIndexOf
		function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
		  // Empty buffer means no match
		  if (buffer.length === 0) return -1
		
		  // Normalize byteOffset
		  if (typeof byteOffset === 'string') {
		    encoding = byteOffset
		    byteOffset = 0
		  } else if (byteOffset > 0x7fffffff) {
		    byteOffset = 0x7fffffff
		  } else if (byteOffset < -0x80000000) {
		    byteOffset = -0x80000000
		  }
		  byteOffset = +byteOffset  // Coerce to Number.
		  if (isNaN(byteOffset)) {
		    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
		    byteOffset = dir ? 0 : (buffer.length - 1)
		  }
		
		  // Normalize byteOffset: negative offsets start from the end of the buffer
		  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
		  if (byteOffset >= buffer.length) {
		    if (dir) return -1
		    else byteOffset = buffer.length - 1
		  } else if (byteOffset < 0) {
		    if (dir) byteOffset = 0
		    else return -1
		  }
		
		  // Normalize val
		  if (typeof val === 'string') {
		    val = Buffer.from(val, encoding)
		  }
		
		  // Finally, search either indexOf (if dir is true) or lastIndexOf
		  if (Buffer.isBuffer(val)) {
		    // Special case: looking for empty string/buffer always fails
		    if (val.length === 0) {
		      return -1
		    }
		    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
		  } else if (typeof val === 'number') {
		    val = val & 0xFF // Search for a byte value [0-255]
		    if (Buffer.TYPED_ARRAY_SUPPORT &&
		        typeof Uint8Array.prototype.indexOf === 'function') {
		      if (dir) {
		        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
		      } else {
		        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
		      }
		    }
		    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
		  }
		
		  throw new TypeError('val must be string, number or Buffer')
		}
		
		function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
		  var indexSize = 1
		  var arrLength = arr.length
		  var valLength = val.length
		
		  if (encoding !== undefined) {
		    encoding = String(encoding).toLowerCase()
		    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
		        encoding === 'utf16le' || encoding === 'utf-16le') {
		      if (arr.length < 2 || val.length < 2) {
		        return -1
		      }
		      indexSize = 2
		      arrLength /= 2
		      valLength /= 2
		      byteOffset /= 2
		    }
		  }
		
		  function read (buf, i) {
		    if (indexSize === 1) {
		      return buf[i]
		    } else {
		      return buf.readUInt16BE(i * indexSize)
		    }
		  }
		
		  var i
		  if (dir) {
		    var foundIndex = -1
		    for (i = byteOffset; i < arrLength; i++) {
		      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
		        if (foundIndex === -1) foundIndex = i
		        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
		      } else {
		        if (foundIndex !== -1) i -= i - foundIndex
		        foundIndex = -1
		      }
		    }
		  } else {
		    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
		    for (i = byteOffset; i >= 0; i--) {
		      var found = true
		      for (var j = 0; j < valLength; j++) {
		        if (read(arr, i + j) !== read(val, j)) {
		          found = false
		          break
		        }
		      }
		      if (found) return i
		    }
		  }
		
		  return -1
		}
		
		Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
		  return this.indexOf(val, byteOffset, encoding) !== -1
		}
		
		Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
		  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
		}
		
		Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
		  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
		}
		
		function hexWrite (buf, string, offset, length) {
		  offset = Number(offset) || 0
		  var remaining = buf.length - offset
		  if (!length) {
		    length = remaining
		  } else {
		    length = Number(length)
		    if (length > remaining) {
		      length = remaining
		    }
		  }
		
		  // must be an even number of digits
		  var strLen = string.length
		  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')
		
		  if (length > strLen / 2) {
		    length = strLen / 2
		  }
		  for (var i = 0; i < length; ++i) {
		    var parsed = parseInt(string.substr(i * 2, 2), 16)
		    if (isNaN(parsed)) return i
		    buf[offset + i] = parsed
		  }
		  return i
		}
		
		function utf8Write (buf, string, offset, length) {
		  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
		}
		
		function asciiWrite (buf, string, offset, length) {
		  return blitBuffer(asciiToBytes(string), buf, offset, length)
		}
		
		function latin1Write (buf, string, offset, length) {
		  return asciiWrite(buf, string, offset, length)
		}
		
		function base64Write (buf, string, offset, length) {
		  return blitBuffer(base64ToBytes(string), buf, offset, length)
		}
		
		function ucs2Write (buf, string, offset, length) {
		  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
		}
		
		Buffer.prototype.write = function write (string, offset, length, encoding) {
		  // Buffer#write(string)
		  if (offset === undefined) {
		    encoding = 'utf8'
		    length = this.length
		    offset = 0
		  // Buffer#write(string, encoding)
		  } else if (length === undefined && typeof offset === 'string') {
		    encoding = offset
		    length = this.length
		    offset = 0
		  // Buffer#write(string, offset[, length][, encoding])
		  } else if (isFinite(offset)) {
		    offset = offset | 0
		    if (isFinite(length)) {
		      length = length | 0
		      if (encoding === undefined) encoding = 'utf8'
		    } else {
		      encoding = length
		      length = undefined
		    }
		  // legacy write(string, encoding, offset, length) - remove in v0.13
		  } else {
		    throw new Error(
		      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
		    )
		  }
		
		  var remaining = this.length - offset
		  if (length === undefined || length > remaining) length = remaining
		
		  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
		    throw new RangeError('Attempt to write outside buffer bounds')
		  }
		
		  if (!encoding) encoding = 'utf8'
		
		  var loweredCase = false
		  for (;;) {
		    switch (encoding) {
		      case 'hex':
		        return hexWrite(this, string, offset, length)
		
		      case 'utf8':
		      case 'utf-8':
		        return utf8Write(this, string, offset, length)
		
		      case 'ascii':
		        return asciiWrite(this, string, offset, length)
		
		      case 'latin1':
		      case 'binary':
		        return latin1Write(this, string, offset, length)
		
		      case 'base64':
		        // Warning: maxLength not taken into account in base64Write
		        return base64Write(this, string, offset, length)
		
		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return ucs2Write(this, string, offset, length)
		
		      default:
		        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
		        encoding = ('' + encoding).toLowerCase()
		        loweredCase = true
		    }
		  }
		}
		
		Buffer.prototype.toJSON = function toJSON () {
		  return {
		    type: 'Buffer',
		    data: Array.prototype.slice.call(this._arr || this, 0)
		  }
		}
		
		function base64Slice (buf, start, end) {
		  if (start === 0 && end === buf.length) {
		    return base64.fromByteArray(buf)
		  } else {
		    return base64.fromByteArray(buf.slice(start, end))
		  }
		}
		
		function utf8Slice (buf, start, end) {
		  end = Math.min(buf.length, end)
		  var res = []
		
		  var i = start
		  while (i < end) {
		    var firstByte = buf[i]
		    var codePoint = null
		    var bytesPerSequence = (firstByte > 0xEF) ? 4
		      : (firstByte > 0xDF) ? 3
		      : (firstByte > 0xBF) ? 2
		      : 1
		
		    if (i + bytesPerSequence <= end) {
		      var secondByte, thirdByte, fourthByte, tempCodePoint
		
		      switch (bytesPerSequence) {
		        case 1:
		          if (firstByte < 0x80) {
		            codePoint = firstByte
		          }
		          break
		        case 2:
		          secondByte = buf[i + 1]
		          if ((secondByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
		            if (tempCodePoint > 0x7F) {
		              codePoint = tempCodePoint
		            }
		          }
		          break
		        case 3:
		          secondByte = buf[i + 1]
		          thirdByte = buf[i + 2]
		          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
		            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
		              codePoint = tempCodePoint
		            }
		          }
		          break
		        case 4:
		          secondByte = buf[i + 1]
		          thirdByte = buf[i + 2]
		          fourthByte = buf[i + 3]
		          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
		            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
		              codePoint = tempCodePoint
		            }
		          }
		      }
		    }
		
		    if (codePoint === null) {
		      // we did not generate a valid codePoint so insert a
		      // replacement char (U+FFFD) and advance only 1 byte
		      codePoint = 0xFFFD
		      bytesPerSequence = 1
		    } else if (codePoint > 0xFFFF) {
		      // encode to utf16 (surrogate pair dance)
		      codePoint -= 0x10000
		      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
		      codePoint = 0xDC00 | codePoint & 0x3FF
		    }
		
		    res.push(codePoint)
		    i += bytesPerSequence
		  }
		
		  return decodeCodePointsArray(res)
		}
		
		// Based on http://stackoverflow.com/a/22747272/680742, the browser with
		// the lowest limit is Chrome, with 0x10000 args.
		// We go 1 magnitude less, for safety
		var MAX_ARGUMENTS_LENGTH = 0x1000
		
		function decodeCodePointsArray (codePoints) {
		  var len = codePoints.length
		  if (len <= MAX_ARGUMENTS_LENGTH) {
		    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
		  }
		
		  // Decode in chunks to avoid "call stack size exceeded".
		  var res = ''
		  var i = 0
		  while (i < len) {
		    res += String.fromCharCode.apply(
		      String,
		      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
		    )
		  }
		  return res
		}
		
		function asciiSlice (buf, start, end) {
		  var ret = ''
		  end = Math.min(buf.length, end)
		
		  for (var i = start; i < end; ++i) {
		    ret += String.fromCharCode(buf[i] & 0x7F)
		  }
		  return ret
		}
		
		function latin1Slice (buf, start, end) {
		  var ret = ''
		  end = Math.min(buf.length, end)
		
		  for (var i = start; i < end; ++i) {
		    ret += String.fromCharCode(buf[i])
		  }
		  return ret
		}
		
		function hexSlice (buf, start, end) {
		  var len = buf.length
		
		  if (!start || start < 0) start = 0
		  if (!end || end < 0 || end > len) end = len
		
		  var out = ''
		  for (var i = start; i < end; ++i) {
		    out += toHex(buf[i])
		  }
		  return out
		}
		
		function utf16leSlice (buf, start, end) {
		  var bytes = buf.slice(start, end)
		  var res = ''
		  for (var i = 0; i < bytes.length; i += 2) {
		    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
		  }
		  return res
		}
		
		Buffer.prototype.slice = function slice (start, end) {
		  var len = this.length
		  start = ~~start
		  end = end === undefined ? len : ~~end
		
		  if (start < 0) {
		    start += len
		    if (start < 0) start = 0
		  } else if (start > len) {
		    start = len
		  }
		
		  if (end < 0) {
		    end += len
		    if (end < 0) end = 0
		  } else if (end > len) {
		    end = len
		  }
		
		  if (end < start) end = start
		
		  var newBuf
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    newBuf = this.subarray(start, end)
		    newBuf.__proto__ = Buffer.prototype
		  } else {
		    var sliceLen = end - start
		    newBuf = new Buffer(sliceLen, undefined)
		    for (var i = 0; i < sliceLen; ++i) {
		      newBuf[i] = this[i + start]
		    }
		  }
		
		  return newBuf
		}
		
		/*
		 * Need to make sure that buffer isn't trying to write out of bounds.
		 */
		function checkOffset (offset, ext, length) {
		  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
		  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
		}
		
		Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
		  offset = offset | 0
		  byteLength = byteLength | 0
		  if (!noAssert) checkOffset(offset, byteLength, this.length)
		
		  var val = this[offset]
		  var mul = 1
		  var i = 0
		  while (++i < byteLength && (mul *= 0x100)) {
		    val += this[offset + i] * mul
		  }
		
		  return val
		}
		
		Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
		  offset = offset | 0
		  byteLength = byteLength | 0
		  if (!noAssert) {
		    checkOffset(offset, byteLength, this.length)
		  }
		
		  var val = this[offset + --byteLength]
		  var mul = 1
		  while (byteLength > 0 && (mul *= 0x100)) {
		    val += this[offset + --byteLength] * mul
		  }
		
		  return val
		}
		
		Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 1, this.length)
		  return this[offset]
		}
		
		Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 2, this.length)
		  return this[offset] | (this[offset + 1] << 8)
		}
		
		Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 2, this.length)
		  return (this[offset] << 8) | this[offset + 1]
		}
		
		Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 4, this.length)
		
		  return ((this[offset]) |
		      (this[offset + 1] << 8) |
		      (this[offset + 2] << 16)) +
		      (this[offset + 3] * 0x1000000)
		}
		
		Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 4, this.length)
		
		  return (this[offset] * 0x1000000) +
		    ((this[offset + 1] << 16) |
		    (this[offset + 2] << 8) |
		    this[offset + 3])
		}
		
		Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
		  offset = offset | 0
		  byteLength = byteLength | 0
		  if (!noAssert) checkOffset(offset, byteLength, this.length)
		
		  var val = this[offset]
		  var mul = 1
		  var i = 0
		  while (++i < byteLength && (mul *= 0x100)) {
		    val += this[offset + i] * mul
		  }
		  mul *= 0x80
		
		  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
		
		  return val
		}
		
		Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
		  offset = offset | 0
		  byteLength = byteLength | 0
		  if (!noAssert) checkOffset(offset, byteLength, this.length)
		
		  var i = byteLength
		  var mul = 1
		  var val = this[offset + --i]
		  while (i > 0 && (mul *= 0x100)) {
		    val += this[offset + --i] * mul
		  }
		  mul *= 0x80
		
		  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
		
		  return val
		}
		
		Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 1, this.length)
		  if (!(this[offset] & 0x80)) return (this[offset])
		  return ((0xff - this[offset] + 1) * -1)
		}
		
		Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 2, this.length)
		  var val = this[offset] | (this[offset + 1] << 8)
		  return (val & 0x8000) ? val | 0xFFFF0000 : val
		}
		
		Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 2, this.length)
		  var val = this[offset + 1] | (this[offset] << 8)
		  return (val & 0x8000) ? val | 0xFFFF0000 : val
		}
		
		Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 4, this.length)
		
		  return (this[offset]) |
		    (this[offset + 1] << 8) |
		    (this[offset + 2] << 16) |
		    (this[offset + 3] << 24)
		}
		
		Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 4, this.length)
		
		  return (this[offset] << 24) |
		    (this[offset + 1] << 16) |
		    (this[offset + 2] << 8) |
		    (this[offset + 3])
		}
		
		Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 4, this.length)
		  return ieee754.read(this, offset, true, 23, 4)
		}
		
		Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 4, this.length)
		  return ieee754.read(this, offset, false, 23, 4)
		}
		
		Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 8, this.length)
		  return ieee754.read(this, offset, true, 52, 8)
		}
		
		Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 8, this.length)
		  return ieee754.read(this, offset, false, 52, 8)
		}
		
		function checkInt (buf, value, offset, ext, max, min) {
		  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
		  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
		  if (offset + ext > buf.length) throw new RangeError('Index out of range')
		}
		
		Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
		  value = +value
		  offset = offset | 0
		  byteLength = byteLength | 0
		  if (!noAssert) {
		    var maxBytes = Math.pow(2, 8 * byteLength) - 1
		    checkInt(this, value, offset, byteLength, maxBytes, 0)
		  }
		
		  var mul = 1
		  var i = 0
		  this[offset] = value & 0xFF
		  while (++i < byteLength && (mul *= 0x100)) {
		    this[offset + i] = (value / mul) & 0xFF
		  }
		
		  return offset + byteLength
		}
		
		Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
		  value = +value
		  offset = offset | 0
		  byteLength = byteLength | 0
		  if (!noAssert) {
		    var maxBytes = Math.pow(2, 8 * byteLength) - 1
		    checkInt(this, value, offset, byteLength, maxBytes, 0)
		  }
		
		  var i = byteLength - 1
		  var mul = 1
		  this[offset + i] = value & 0xFF
		  while (--i >= 0 && (mul *= 0x100)) {
		    this[offset + i] = (value / mul) & 0xFF
		  }
		
		  return offset + byteLength
		}
		
		Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
		  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
		  this[offset] = (value & 0xff)
		  return offset + 1
		}
		
		function objectWriteUInt16 (buf, value, offset, littleEndian) {
		  if (value < 0) value = 0xffff + value + 1
		  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
		    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
		      (littleEndian ? i : 1 - i) * 8
		  }
		}
		
		Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value & 0xff)
		    this[offset + 1] = (value >>> 8)
		  } else {
		    objectWriteUInt16(this, value, offset, true)
		  }
		  return offset + 2
		}
		
		Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value >>> 8)
		    this[offset + 1] = (value & 0xff)
		  } else {
		    objectWriteUInt16(this, value, offset, false)
		  }
		  return offset + 2
		}
		
		function objectWriteUInt32 (buf, value, offset, littleEndian) {
		  if (value < 0) value = 0xffffffff + value + 1
		  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
		    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
		  }
		}
		
		Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset + 3] = (value >>> 24)
		    this[offset + 2] = (value >>> 16)
		    this[offset + 1] = (value >>> 8)
		    this[offset] = (value & 0xff)
		  } else {
		    objectWriteUInt32(this, value, offset, true)
		  }
		  return offset + 4
		}
		
		Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value >>> 24)
		    this[offset + 1] = (value >>> 16)
		    this[offset + 2] = (value >>> 8)
		    this[offset + 3] = (value & 0xff)
		  } else {
		    objectWriteUInt32(this, value, offset, false)
		  }
		  return offset + 4
		}
		
		Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) {
		    var limit = Math.pow(2, 8 * byteLength - 1)
		
		    checkInt(this, value, offset, byteLength, limit - 1, -limit)
		  }
		
		  var i = 0
		  var mul = 1
		  var sub = 0
		  this[offset] = value & 0xFF
		  while (++i < byteLength && (mul *= 0x100)) {
		    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
		      sub = 1
		    }
		    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
		  }
		
		  return offset + byteLength
		}
		
		Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) {
		    var limit = Math.pow(2, 8 * byteLength - 1)
		
		    checkInt(this, value, offset, byteLength, limit - 1, -limit)
		  }
		
		  var i = byteLength - 1
		  var mul = 1
		  var sub = 0
		  this[offset + i] = value & 0xFF
		  while (--i >= 0 && (mul *= 0x100)) {
		    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
		      sub = 1
		    }
		    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
		  }
		
		  return offset + byteLength
		}
		
		Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
		  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
		  if (value < 0) value = 0xff + value + 1
		  this[offset] = (value & 0xff)
		  return offset + 1
		}
		
		Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value & 0xff)
		    this[offset + 1] = (value >>> 8)
		  } else {
		    objectWriteUInt16(this, value, offset, true)
		  }
		  return offset + 2
		}
		
		Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value >>> 8)
		    this[offset + 1] = (value & 0xff)
		  } else {
		    objectWriteUInt16(this, value, offset, false)
		  }
		  return offset + 2
		}
		
		Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value & 0xff)
		    this[offset + 1] = (value >>> 8)
		    this[offset + 2] = (value >>> 16)
		    this[offset + 3] = (value >>> 24)
		  } else {
		    objectWriteUInt32(this, value, offset, true)
		  }
		  return offset + 4
		}
		
		Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
		  if (value < 0) value = 0xffffffff + value + 1
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value >>> 24)
		    this[offset + 1] = (value >>> 16)
		    this[offset + 2] = (value >>> 8)
		    this[offset + 3] = (value & 0xff)
		  } else {
		    objectWriteUInt32(this, value, offset, false)
		  }
		  return offset + 4
		}
		
		function checkIEEE754 (buf, value, offset, ext, max, min) {
		  if (offset + ext > buf.length) throw new RangeError('Index out of range')
		  if (offset < 0) throw new RangeError('Index out of range')
		}
		
		function writeFloat (buf, value, offset, littleEndian, noAssert) {
		  if (!noAssert) {
		    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
		  }
		  ieee754.write(buf, value, offset, littleEndian, 23, 4)
		  return offset + 4
		}
		
		Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
		  return writeFloat(this, value, offset, true, noAssert)
		}
		
		Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
		  return writeFloat(this, value, offset, false, noAssert)
		}
		
		function writeDouble (buf, value, offset, littleEndian, noAssert) {
		  if (!noAssert) {
		    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
		  }
		  ieee754.write(buf, value, offset, littleEndian, 52, 8)
		  return offset + 8
		}
		
		Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
		  return writeDouble(this, value, offset, true, noAssert)
		}
		
		Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
		  return writeDouble(this, value, offset, false, noAssert)
		}
		
		// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
		Buffer.prototype.copy = function copy (target, targetStart, start, end) {
		  if (!start) start = 0
		  if (!end && end !== 0) end = this.length
		  if (targetStart >= target.length) targetStart = target.length
		  if (!targetStart) targetStart = 0
		  if (end > 0 && end < start) end = start
		
		  // Copy 0 bytes; we're done
		  if (end === start) return 0
		  if (target.length === 0 || this.length === 0) return 0
		
		  // Fatal error conditions
		  if (targetStart < 0) {
		    throw new RangeError('targetStart out of bounds')
		  }
		  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
		  if (end < 0) throw new RangeError('sourceEnd out of bounds')
		
		  // Are we oob?
		  if (end > this.length) end = this.length
		  if (target.length - targetStart < end - start) {
		    end = target.length - targetStart + start
		  }
		
		  var len = end - start
		  var i
		
		  if (this === target && start < targetStart && targetStart < end) {
		    // descending copy from end
		    for (i = len - 1; i >= 0; --i) {
		      target[i + targetStart] = this[i + start]
		    }
		  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
		    // ascending copy from start
		    for (i = 0; i < len; ++i) {
		      target[i + targetStart] = this[i + start]
		    }
		  } else {
		    Uint8Array.prototype.set.call(
		      target,
		      this.subarray(start, start + len),
		      targetStart
		    )
		  }
		
		  return len
		}
		
		// Usage:
		//    buffer.fill(number[, offset[, end]])
		//    buffer.fill(buffer[, offset[, end]])
		//    buffer.fill(string[, offset[, end]][, encoding])
		Buffer.prototype.fill = function fill (val, start, end, encoding) {
		  // Handle string cases:
		  if (typeof val === 'string') {
		    if (typeof start === 'string') {
		      encoding = start
		      start = 0
		      end = this.length
		    } else if (typeof end === 'string') {
		      encoding = end
		      end = this.length
		    }
		    if (val.length === 1) {
		      var code = val.charCodeAt(0)
		      if (code < 256) {
		        val = code
		      }
		    }
		    if (encoding !== undefined && typeof encoding !== 'string') {
		      throw new TypeError('encoding must be a string')
		    }
		    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
		      throw new TypeError('Unknown encoding: ' + encoding)
		    }
		  } else if (typeof val === 'number') {
		    val = val & 255
		  }
		
		  // Invalid ranges are not set to a default, so can range check early.
		  if (start < 0 || this.length < start || this.length < end) {
		    throw new RangeError('Out of range index')
		  }
		
		  if (end <= start) {
		    return this
		  }
		
		  start = start >>> 0
		  end = end === undefined ? this.length : end >>> 0
		
		  if (!val) val = 0
		
		  var i
		  if (typeof val === 'number') {
		    for (i = start; i < end; ++i) {
		      this[i] = val
		    }
		  } else {
		    var bytes = Buffer.isBuffer(val)
		      ? val
		      : utf8ToBytes(new Buffer(val, encoding).toString())
		    var len = bytes.length
		    for (i = 0; i < end - start; ++i) {
		      this[i + start] = bytes[i % len]
		    }
		  }
		
		  return this
		}
		
		// HELPER FUNCTIONS
		// ================
		
		var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
		
		function base64clean (str) {
		  // Node strips out invalid characters like \n and \t from the string, base64-js does not
		  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
		  // Node converts strings with length < 2 to ''
		  if (str.length < 2) return ''
		  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
		  while (str.length % 4 !== 0) {
		    str = str + '='
		  }
		  return str
		}
		
		function stringtrim (str) {
		  if (str.trim) return str.trim()
		  return str.replace(/^\s+|\s+$/g, '')
		}
		
		function toHex (n) {
		  if (n < 16) return '0' + n.toString(16)
		  return n.toString(16)
		}
		
		function utf8ToBytes (string, units) {
		  units = units || Infinity
		  var codePoint
		  var length = string.length
		  var leadSurrogate = null
		  var bytes = []
		
		  for (var i = 0; i < length; ++i) {
		    codePoint = string.charCodeAt(i)
		
		    // is surrogate component
		    if (codePoint > 0xD7FF && codePoint < 0xE000) {
		      // last char was a lead
		      if (!leadSurrogate) {
		        // no lead yet
		        if (codePoint > 0xDBFF) {
		          // unexpected trail
		          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
		          continue
		        } else if (i + 1 === length) {
		          // unpaired lead
		          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
		          continue
		        }
		
		        // valid lead
		        leadSurrogate = codePoint
		
		        continue
		      }
		
		      // 2 leads in a row
		      if (codePoint < 0xDC00) {
		        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
		        leadSurrogate = codePoint
		        continue
		      }
		
		      // valid surrogate pair
		      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
		    } else if (leadSurrogate) {
		      // valid bmp char, but last char was a lead
		      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
		    }
		
		    leadSurrogate = null
		
		    // encode utf8
		    if (codePoint < 0x80) {
		      if ((units -= 1) < 0) break
		      bytes.push(codePoint)
		    } else if (codePoint < 0x800) {
		      if ((units -= 2) < 0) break
		      bytes.push(
		        codePoint >> 0x6 | 0xC0,
		        codePoint & 0x3F | 0x80
		      )
		    } else if (codePoint < 0x10000) {
		      if ((units -= 3) < 0) break
		      bytes.push(
		        codePoint >> 0xC | 0xE0,
		        codePoint >> 0x6 & 0x3F | 0x80,
		        codePoint & 0x3F | 0x80
		      )
		    } else if (codePoint < 0x110000) {
		      if ((units -= 4) < 0) break
		      bytes.push(
		        codePoint >> 0x12 | 0xF0,
		        codePoint >> 0xC & 0x3F | 0x80,
		        codePoint >> 0x6 & 0x3F | 0x80,
		        codePoint & 0x3F | 0x80
		      )
		    } else {
		      throw new Error('Invalid code point')
		    }
		  }
		
		  return bytes
		}
		
		function asciiToBytes (str) {
		  var byteArray = []
		  for (var i = 0; i < str.length; ++i) {
		    // Node's code seems to be doing this and not & 0x7F..
		    byteArray.push(str.charCodeAt(i) & 0xFF)
		  }
		  return byteArray
		}
		
		function utf16leToBytes (str, units) {
		  var c, hi, lo
		  var byteArray = []
		  for (var i = 0; i < str.length; ++i) {
		    if ((units -= 2) < 0) break
		
		    c = str.charCodeAt(i)
		    hi = c >> 8
		    lo = c % 256
		    byteArray.push(lo)
		    byteArray.push(hi)
		  }
		
		  return byteArray
		}
		
		function base64ToBytes (str) {
		  return base64.toByteArray(base64clean(str))
		}
		
		function blitBuffer (src, dst, offset, length) {
		  for (var i = 0; i < length; ++i) {
		    if ((i + offset >= dst.length) || (i >= src.length)) break
		    dst[i + offset] = src[i]
		  }
		  return i
		}
		
		function isnan (val) {
		  return val !== val // eslint-disable-line no-self-compare
		}
		
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ },
	/* 175 */
	/***/ function(module, exports) {
	
		'use strict'
		
		exports.byteLength = byteLength
		exports.toByteArray = toByteArray
		exports.fromByteArray = fromByteArray
		
		var lookup = []
		var revLookup = []
		var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
		
		var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
		for (var i = 0, len = code.length; i < len; ++i) {
		  lookup[i] = code[i]
		  revLookup[code.charCodeAt(i)] = i
		}
		
		revLookup['-'.charCodeAt(0)] = 62
		revLookup['_'.charCodeAt(0)] = 63
		
		function placeHoldersCount (b64) {
		  var len = b64.length
		  if (len % 4 > 0) {
		    throw new Error('Invalid string. Length must be a multiple of 4')
		  }
		
		  // the number of equal signs (place holders)
		  // if there are two placeholders, than the two characters before it
		  // represent one byte
		  // if there is only one, then the three characters before it represent 2 bytes
		  // this is just a cheap hack to not do indexOf twice
		  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
		}
		
		function byteLength (b64) {
		  // base64 is 4/3 + up to two characters of the original data
		  return b64.length * 3 / 4 - placeHoldersCount(b64)
		}
		
		function toByteArray (b64) {
		  var i, j, l, tmp, placeHolders, arr
		  var len = b64.length
		  placeHolders = placeHoldersCount(b64)
		
		  arr = new Arr(len * 3 / 4 - placeHolders)
		
		  // if there are placeholders, only get up to the last complete 4 chars
		  l = placeHolders > 0 ? len - 4 : len
		
		  var L = 0
		
		  for (i = 0, j = 0; i < l; i += 4, j += 3) {
		    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
		    arr[L++] = (tmp >> 16) & 0xFF
		    arr[L++] = (tmp >> 8) & 0xFF
		    arr[L++] = tmp & 0xFF
		  }
		
		  if (placeHolders === 2) {
		    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
		    arr[L++] = tmp & 0xFF
		  } else if (placeHolders === 1) {
		    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
		    arr[L++] = (tmp >> 8) & 0xFF
		    arr[L++] = tmp & 0xFF
		  }
		
		  return arr
		}
		
		function tripletToBase64 (num) {
		  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
		}
		
		function encodeChunk (uint8, start, end) {
		  var tmp
		  var output = []
		  for (var i = start; i < end; i += 3) {
		    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
		    output.push(tripletToBase64(tmp))
		  }
		  return output.join('')
		}
		
		function fromByteArray (uint8) {
		  var tmp
		  var len = uint8.length
		  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
		  var output = ''
		  var parts = []
		  var maxChunkLength = 16383 // must be multiple of 3
		
		  // go through the array every three bytes, we'll deal with trailing stuff later
		  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
		    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
		  }
		
		  // pad the end with zeros, but make sure to not forget the extra bytes
		  if (extraBytes === 1) {
		    tmp = uint8[len - 1]
		    output += lookup[tmp >> 2]
		    output += lookup[(tmp << 4) & 0x3F]
		    output += '=='
		  } else if (extraBytes === 2) {
		    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
		    output += lookup[tmp >> 10]
		    output += lookup[(tmp >> 4) & 0x3F]
		    output += lookup[(tmp << 2) & 0x3F]
		    output += '='
		  }
		
		  parts.push(output)
		
		  return parts.join('')
		}
	
	
	/***/ },
	/* 176 */
	/***/ function(module, exports) {
	
		exports.read = function (buffer, offset, isLE, mLen, nBytes) {
		  var e, m
		  var eLen = nBytes * 8 - mLen - 1
		  var eMax = (1 << eLen) - 1
		  var eBias = eMax >> 1
		  var nBits = -7
		  var i = isLE ? (nBytes - 1) : 0
		  var d = isLE ? -1 : 1
		  var s = buffer[offset + i]
		
		  i += d
		
		  e = s & ((1 << (-nBits)) - 1)
		  s >>= (-nBits)
		  nBits += eLen
		  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
		
		  m = e & ((1 << (-nBits)) - 1)
		  e >>= (-nBits)
		  nBits += mLen
		  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
		
		  if (e === 0) {
		    e = 1 - eBias
		  } else if (e === eMax) {
		    return m ? NaN : ((s ? -1 : 1) * Infinity)
		  } else {
		    m = m + Math.pow(2, mLen)
		    e = e - eBias
		  }
		  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
		}
		
		exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
		  var e, m, c
		  var eLen = nBytes * 8 - mLen - 1
		  var eMax = (1 << eLen) - 1
		  var eBias = eMax >> 1
		  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
		  var i = isLE ? 0 : (nBytes - 1)
		  var d = isLE ? 1 : -1
		  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
		
		  value = Math.abs(value)
		
		  if (isNaN(value) || value === Infinity) {
		    m = isNaN(value) ? 1 : 0
		    e = eMax
		  } else {
		    e = Math.floor(Math.log(value) / Math.LN2)
		    if (value * (c = Math.pow(2, -e)) < 1) {
		      e--
		      c *= 2
		    }
		    if (e + eBias >= 1) {
		      value += rt / c
		    } else {
		      value += rt * Math.pow(2, 1 - eBias)
		    }
		    if (value * c >= 2) {
		      e++
		      c /= 2
		    }
		
		    if (e + eBias >= eMax) {
		      m = 0
		      e = eMax
		    } else if (e + eBias >= 1) {
		      m = (value * c - 1) * Math.pow(2, mLen)
		      e = e + eBias
		    } else {
		      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
		      e = 0
		    }
		  }
		
		  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
		
		  e = (e << mLen) | m
		  eLen += mLen
		  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
		
		  buffer[offset + i - d] |= s * 128
		}
	
	
	/***/ },
	/* 177 */
	/***/ function(module, exports) {
	
		var toString = {}.toString;
		
		module.exports = Array.isArray || function (arr) {
		  return toString.call(arr) == '[object Array]';
		};
	
	
	/***/ },
	/* 178 */
	/***/ function(module, exports) {
	
		/* (ignored) */
	
	/***/ },
	/* 179 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* WEBPACK VAR INJECTION */(function(global) {/**
		 * marked - a markdown parser
		 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
		 * https://github.com/chjj/marked
		 */
		
		;(function() {
		
		/**
		 * Block-Level Grammar
		 */
		
		var block = {
		  newline: /^\n+/,
		  code: /^( {4}[^\n]+\n*)+/,
		  fences: noop,
		  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
		  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
		  nptable: noop,
		  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
		  blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
		  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
		  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
		  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
		  table: noop,
		  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
		  text: /^[^\n]+/
		};
		
		block.bullet = /(?:[*+-]|\d+\.)/;
		block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
		block.item = replace(block.item, 'gm')
		  (/bull/g, block.bullet)
		  ();
		
		block.list = replace(block.list)
		  (/bull/g, block.bullet)
		  ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
		  ('def', '\\n+(?=' + block.def.source + ')')
		  ();
		
		block.blockquote = replace(block.blockquote)
		  ('def', block.def)
		  ();
		
		block._tag = '(?!(?:'
		  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
		  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
		  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';
		
		block.html = replace(block.html)
		  ('comment', /<!--[\s\S]*?-->/)
		  ('closed', /<(tag)[\s\S]+?<\/\1>/)
		  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
		  (/tag/g, block._tag)
		  ();
		
		block.paragraph = replace(block.paragraph)
		  ('hr', block.hr)
		  ('heading', block.heading)
		  ('lheading', block.lheading)
		  ('blockquote', block.blockquote)
		  ('tag', '<' + block._tag)
		  ('def', block.def)
		  ();
		
		/**
		 * Normal Block Grammar
		 */
		
		block.normal = merge({}, block);
		
		/**
		 * GFM Block Grammar
		 */
		
		block.gfm = merge({}, block.normal, {
		  fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/,
		  paragraph: /^/,
		  heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
		});
		
		block.gfm.paragraph = replace(block.paragraph)
		  ('(?!', '(?!'
		    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
		    + block.list.source.replace('\\1', '\\3') + '|')
		  ();
		
		/**
		 * GFM + Tables Block Grammar
		 */
		
		block.tables = merge({}, block.gfm, {
		  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
		  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
		});
		
		/**
		 * Block Lexer
		 */
		
		function Lexer(options) {
		  this.tokens = [];
		  this.tokens.links = {};
		  this.options = options || marked.defaults;
		  this.rules = block.normal;
		
		  if (this.options.gfm) {
		    if (this.options.tables) {
		      this.rules = block.tables;
		    } else {
		      this.rules = block.gfm;
		    }
		  }
		}
		
		/**
		 * Expose Block Rules
		 */
		
		Lexer.rules = block;
		
		/**
		 * Static Lex Method
		 */
		
		Lexer.lex = function(src, options) {
		  var lexer = new Lexer(options);
		  return lexer.lex(src);
		};
		
		/**
		 * Preprocessing
		 */
		
		Lexer.prototype.lex = function(src) {
		  src = src
		    .replace(/\r\n|\r/g, '\n')
		    .replace(/\t/g, '    ')
		    .replace(/\u00a0/g, ' ')
		    .replace(/\u2424/g, '\n');
		
		  return this.token(src, true);
		};
		
		/**
		 * Lexing
		 */
		
		Lexer.prototype.token = function(src, top, bq) {
		  var src = src.replace(/^ +$/gm, '')
		    , next
		    , loose
		    , cap
		    , bull
		    , b
		    , item
		    , space
		    , i
		    , l;
		
		  while (src) {
		    // newline
		    if (cap = this.rules.newline.exec(src)) {
		      src = src.substring(cap[0].length);
		      if (cap[0].length > 1) {
		        this.tokens.push({
		          type: 'space'
		        });
		      }
		    }
		
		    // code
		    if (cap = this.rules.code.exec(src)) {
		      src = src.substring(cap[0].length);
		      cap = cap[0].replace(/^ {4}/gm, '');
		      this.tokens.push({
		        type: 'code',
		        text: !this.options.pedantic
		          ? cap.replace(/\n+$/, '')
		          : cap
		      });
		      continue;
		    }
		
		    // fences (gfm)
		    if (cap = this.rules.fences.exec(src)) {
		      src = src.substring(cap[0].length);
		      this.tokens.push({
		        type: 'code',
		        lang: cap[2],
		        text: cap[3] || ''
		      });
		      continue;
		    }
		
		    // heading
		    if (cap = this.rules.heading.exec(src)) {
		      src = src.substring(cap[0].length);
		      this.tokens.push({
		        type: 'heading',
		        depth: cap[1].length,
		        text: cap[2]
		      });
		      continue;
		    }
		
		    // table no leading pipe (gfm)
		    if (top && (cap = this.rules.nptable.exec(src))) {
		      src = src.substring(cap[0].length);
		
		      item = {
		        type: 'table',
		        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
		        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
		        cells: cap[3].replace(/\n$/, '').split('\n')
		      };
		
		      for (i = 0; i < item.align.length; i++) {
		        if (/^ *-+: *$/.test(item.align[i])) {
		          item.align[i] = 'right';
		        } else if (/^ *:-+: *$/.test(item.align[i])) {
		          item.align[i] = 'center';
		        } else if (/^ *:-+ *$/.test(item.align[i])) {
		          item.align[i] = 'left';
		        } else {
		          item.align[i] = null;
		        }
		      }
		
		      for (i = 0; i < item.cells.length; i++) {
		        item.cells[i] = item.cells[i].split(/ *\| */);
		      }
		
		      this.tokens.push(item);
		
		      continue;
		    }
		
		    // lheading
		    if (cap = this.rules.lheading.exec(src)) {
		      src = src.substring(cap[0].length);
		      this.tokens.push({
		        type: 'heading',
		        depth: cap[2] === '=' ? 1 : 2,
		        text: cap[1]
		      });
		      continue;
		    }
		
		    // hr
		    if (cap = this.rules.hr.exec(src)) {
		      src = src.substring(cap[0].length);
		      this.tokens.push({
		        type: 'hr'
		      });
		      continue;
		    }
		
		    // blockquote
		    if (cap = this.rules.blockquote.exec(src)) {
		      src = src.substring(cap[0].length);
		
		      this.tokens.push({
		        type: 'blockquote_start'
		      });
		
		      cap = cap[0].replace(/^ *> ?/gm, '');
		
		      // Pass `top` to keep the current
		      // "toplevel" state. This is exactly
		      // how markdown.pl works.
		      this.token(cap, top, true);
		
		      this.tokens.push({
		        type: 'blockquote_end'
		      });
		
		      continue;
		    }
		
		    // list
		    if (cap = this.rules.list.exec(src)) {
		      src = src.substring(cap[0].length);
		      bull = cap[2];
		
		      this.tokens.push({
		        type: 'list_start',
		        ordered: bull.length > 1
		      });
		
		      // Get each top-level item.
		      cap = cap[0].match(this.rules.item);
		
		      next = false;
		      l = cap.length;
		      i = 0;
		
		      for (; i < l; i++) {
		        item = cap[i];
		
		        // Remove the list item's bullet
		        // so it is seen as the next token.
		        space = item.length;
		        item = item.replace(/^ *([*+-]|\d+\.) +/, '');
		
		        // Outdent whatever the
		        // list item contains. Hacky.
		        if (~item.indexOf('\n ')) {
		          space -= item.length;
		          item = !this.options.pedantic
		            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
		            : item.replace(/^ {1,4}/gm, '');
		        }
		
		        // Determine whether the next list item belongs here.
		        // Backpedal if it does not belong in this list.
		        if (this.options.smartLists && i !== l - 1) {
		          b = block.bullet.exec(cap[i + 1])[0];
		          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
		            src = cap.slice(i + 1).join('\n') + src;
		            i = l - 1;
		          }
		        }
		
		        // Determine whether item is loose or not.
		        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
		        // for discount behavior.
		        loose = next || /\n\n(?!\s*$)/.test(item);
		        if (i !== l - 1) {
		          next = item.charAt(item.length - 1) === '\n';
		          if (!loose) loose = next;
		        }
		
		        this.tokens.push({
		          type: loose
		            ? 'loose_item_start'
		            : 'list_item_start'
		        });
		
		        // Recurse.
		        this.token(item, false, bq);
		
		        this.tokens.push({
		          type: 'list_item_end'
		        });
		      }
		
		      this.tokens.push({
		        type: 'list_end'
		      });
		
		      continue;
		    }
		
		    // html
		    if (cap = this.rules.html.exec(src)) {
		      src = src.substring(cap[0].length);
		      this.tokens.push({
		        type: this.options.sanitize
		          ? 'paragraph'
		          : 'html',
		        pre: !this.options.sanitizer
		          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
		        text: cap[0]
		      });
		      continue;
		    }
		
		    // def
		    if ((!bq && top) && (cap = this.rules.def.exec(src))) {
		      src = src.substring(cap[0].length);
		      this.tokens.links[cap[1].toLowerCase()] = {
		        href: cap[2],
		        title: cap[3]
		      };
		      continue;
		    }
		
		    // table (gfm)
		    if (top && (cap = this.rules.table.exec(src))) {
		      src = src.substring(cap[0].length);
		
		      item = {
		        type: 'table',
		        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
		        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
		        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
		      };
		
		      for (i = 0; i < item.align.length; i++) {
		        if (/^ *-+: *$/.test(item.align[i])) {
		          item.align[i] = 'right';
		        } else if (/^ *:-+: *$/.test(item.align[i])) {
		          item.align[i] = 'center';
		        } else if (/^ *:-+ *$/.test(item.align[i])) {
		          item.align[i] = 'left';
		        } else {
		          item.align[i] = null;
		        }
		      }
		
		      for (i = 0; i < item.cells.length; i++) {
		        item.cells[i] = item.cells[i]
		          .replace(/^ *\| *| *\| *$/g, '')
		          .split(/ *\| */);
		      }
		
		      this.tokens.push(item);
		
		      continue;
		    }
		
		    // top-level paragraph
		    if (top && (cap = this.rules.paragraph.exec(src))) {
		      src = src.substring(cap[0].length);
		      this.tokens.push({
		        type: 'paragraph',
		        text: cap[1].charAt(cap[1].length - 1) === '\n'
		          ? cap[1].slice(0, -1)
		          : cap[1]
		      });
		      continue;
		    }
		
		    // text
		    if (cap = this.rules.text.exec(src)) {
		      // Top-level should never reach here.
		      src = src.substring(cap[0].length);
		      this.tokens.push({
		        type: 'text',
		        text: cap[0]
		      });
		      continue;
		    }
		
		    if (src) {
		      throw new
		        Error('Infinite loop on byte: ' + src.charCodeAt(0));
		    }
		  }
		
		  return this.tokens;
		};
		
		/**
		 * Inline-Level Grammar
		 */
		
		var inline = {
		  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
		  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
		  url: noop,
		  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
		  link: /^!?\[(inside)\]\(href\)/,
		  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
		  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
		  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
		  em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
		  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
		  br: /^ {2,}\n(?!\s*$)/,
		  del: noop,
		  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
		};
		
		inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
		inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;
		
		inline.link = replace(inline.link)
		  ('inside', inline._inside)
		  ('href', inline._href)
		  ();
		
		inline.reflink = replace(inline.reflink)
		  ('inside', inline._inside)
		  ();
		
		/**
		 * Normal Inline Grammar
		 */
		
		inline.normal = merge({}, inline);
		
		/**
		 * Pedantic Inline Grammar
		 */
		
		inline.pedantic = merge({}, inline.normal, {
		  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
		  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
		});
		
		/**
		 * GFM Inline Grammar
		 */
		
		inline.gfm = merge({}, inline.normal, {
		  escape: replace(inline.escape)('])', '~|])')(),
		  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
		  del: /^~~(?=\S)([\s\S]*?\S)~~/,
		  text: replace(inline.text)
		    (']|', '~]|')
		    ('|', '|https?://|')
		    ()
		});
		
		/**
		 * GFM + Line Breaks Inline Grammar
		 */
		
		inline.breaks = merge({}, inline.gfm, {
		  br: replace(inline.br)('{2,}', '*')(),
		  text: replace(inline.gfm.text)('{2,}', '*')()
		});
		
		/**
		 * Inline Lexer & Compiler
		 */
		
		function InlineLexer(links, options) {
		  this.options = options || marked.defaults;
		  this.links = links;
		  this.rules = inline.normal;
		  this.renderer = this.options.renderer || new Renderer;
		  this.renderer.options = this.options;
		
		  if (!this.links) {
		    throw new
		      Error('Tokens array requires a `links` property.');
		  }
		
		  if (this.options.gfm) {
		    if (this.options.breaks) {
		      this.rules = inline.breaks;
		    } else {
		      this.rules = inline.gfm;
		    }
		  } else if (this.options.pedantic) {
		    this.rules = inline.pedantic;
		  }
		}
		
		/**
		 * Expose Inline Rules
		 */
		
		InlineLexer.rules = inline;
		
		/**
		 * Static Lexing/Compiling Method
		 */
		
		InlineLexer.output = function(src, links, options) {
		  var inline = new InlineLexer(links, options);
		  return inline.output(src);
		};
		
		/**
		 * Lexing/Compiling
		 */
		
		InlineLexer.prototype.output = function(src) {
		  var out = ''
		    , link
		    , text
		    , href
		    , cap;
		
		  while (src) {
		    // escape
		    if (cap = this.rules.escape.exec(src)) {
		      src = src.substring(cap[0].length);
		      out += cap[1];
		      continue;
		    }
		
		    // autolink
		    if (cap = this.rules.autolink.exec(src)) {
		      src = src.substring(cap[0].length);
		      if (cap[2] === '@') {
		        text = cap[1].charAt(6) === ':'
		          ? this.mangle(cap[1].substring(7))
		          : this.mangle(cap[1]);
		        href = this.mangle('mailto:') + text;
		      } else {
		        text = escape(cap[1]);
		        href = text;
		      }
		      out += this.renderer.link(href, null, text);
		      continue;
		    }
		
		    // url (gfm)
		    if (!this.inLink && (cap = this.rules.url.exec(src))) {
		      src = src.substring(cap[0].length);
		      text = escape(cap[1]);
		      href = text;
		      out += this.renderer.link(href, null, text);
		      continue;
		    }
		
		    // tag
		    if (cap = this.rules.tag.exec(src)) {
		      if (!this.inLink && /^<a /i.test(cap[0])) {
		        this.inLink = true;
		      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
		        this.inLink = false;
		      }
		      src = src.substring(cap[0].length);
		      out += this.options.sanitize
		        ? this.options.sanitizer
		          ? this.options.sanitizer(cap[0])
		          : escape(cap[0])
		        : cap[0]
		      continue;
		    }
		
		    // link
		    if (cap = this.rules.link.exec(src)) {
		      src = src.substring(cap[0].length);
		      this.inLink = true;
		      out += this.outputLink(cap, {
		        href: cap[2],
		        title: cap[3]
		      });
		      this.inLink = false;
		      continue;
		    }
		
		    // reflink, nolink
		    if ((cap = this.rules.reflink.exec(src))
		        || (cap = this.rules.nolink.exec(src))) {
		      src = src.substring(cap[0].length);
		      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
		      link = this.links[link.toLowerCase()];
		      if (!link || !link.href) {
		        out += cap[0].charAt(0);
		        src = cap[0].substring(1) + src;
		        continue;
		      }
		      this.inLink = true;
		      out += this.outputLink(cap, link);
		      this.inLink = false;
		      continue;
		    }
		
		    // strong
		    if (cap = this.rules.strong.exec(src)) {
		      src = src.substring(cap[0].length);
		      out += this.renderer.strong(this.output(cap[2] || cap[1]));
		      continue;
		    }
		
		    // em
		    if (cap = this.rules.em.exec(src)) {
		      src = src.substring(cap[0].length);
		      out += this.renderer.em(this.output(cap[2] || cap[1]));
		      continue;
		    }
		
		    // code
		    if (cap = this.rules.code.exec(src)) {
		      src = src.substring(cap[0].length);
		      out += this.renderer.codespan(escape(cap[2], true));
		      continue;
		    }
		
		    // br
		    if (cap = this.rules.br.exec(src)) {
		      src = src.substring(cap[0].length);
		      out += this.renderer.br();
		      continue;
		    }
		
		    // del (gfm)
		    if (cap = this.rules.del.exec(src)) {
		      src = src.substring(cap[0].length);
		      out += this.renderer.del(this.output(cap[1]));
		      continue;
		    }
		
		    // text
		    if (cap = this.rules.text.exec(src)) {
		      src = src.substring(cap[0].length);
		      out += this.renderer.text(escape(this.smartypants(cap[0])));
		      continue;
		    }
		
		    if (src) {
		      throw new
		        Error('Infinite loop on byte: ' + src.charCodeAt(0));
		    }
		  }
		
		  return out;
		};
		
		/**
		 * Compile Link
		 */
		
		InlineLexer.prototype.outputLink = function(cap, link) {
		  var href = escape(link.href)
		    , title = link.title ? escape(link.title) : null;
		
		  return cap[0].charAt(0) !== '!'
		    ? this.renderer.link(href, title, this.output(cap[1]))
		    : this.renderer.image(href, title, escape(cap[1]));
		};
		
		/**
		 * Smartypants Transformations
		 */
		
		InlineLexer.prototype.smartypants = function(text) {
		  if (!this.options.smartypants) return text;
		  return text
		    // em-dashes
		    .replace(/---/g, '\u2014')
		    // en-dashes
		    .replace(/--/g, '\u2013')
		    // opening singles
		    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
		    // closing singles & apostrophes
		    .replace(/'/g, '\u2019')
		    // opening doubles
		    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
		    // closing doubles
		    .replace(/"/g, '\u201d')
		    // ellipses
		    .replace(/\.{3}/g, '\u2026');
		};
		
		/**
		 * Mangle Links
		 */
		
		InlineLexer.prototype.mangle = function(text) {
		  if (!this.options.mangle) return text;
		  var out = ''
		    , l = text.length
		    , i = 0
		    , ch;
		
		  for (; i < l; i++) {
		    ch = text.charCodeAt(i);
		    if (Math.random() > 0.5) {
		      ch = 'x' + ch.toString(16);
		    }
		    out += '&#' + ch + ';';
		  }
		
		  return out;
		};
		
		/**
		 * Renderer
		 */
		
		function Renderer(options) {
		  this.options = options || {};
		}
		
		Renderer.prototype.code = function(code, lang, escaped) {
		  if (this.options.highlight) {
		    var out = this.options.highlight(code, lang);
		    if (out != null && out !== code) {
		      escaped = true;
		      code = out;
		    }
		  }
		
		  if (!lang) {
		    return '<pre><code>'
		      + (escaped ? code : escape(code, true))
		      + '\n</code></pre>';
		  }
		
		  return '<pre><code class="'
		    + this.options.langPrefix
		    + escape(lang, true)
		    + '">'
		    + (escaped ? code : escape(code, true))
		    + '\n</code></pre>\n';
		};
		
		Renderer.prototype.blockquote = function(quote) {
		  return '<blockquote>\n' + quote + '</blockquote>\n';
		};
		
		Renderer.prototype.html = function(html) {
		  return html;
		};
		
		Renderer.prototype.heading = function(text, level, raw) {
		  return '<h'
		    + level
		    + ' id="'
		    + this.options.headerPrefix
		    + raw.toLowerCase().replace(/[^\w]+/g, '-')
		    + '">'
		    + text
		    + '</h'
		    + level
		    + '>\n';
		};
		
		Renderer.prototype.hr = function() {
		  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
		};
		
		Renderer.prototype.list = function(body, ordered) {
		  var type = ordered ? 'ol' : 'ul';
		  return '<' + type + '>\n' + body + '</' + type + '>\n';
		};
		
		Renderer.prototype.listitem = function(text) {
		  return '<li>' + text + '</li>\n';
		};
		
		Renderer.prototype.paragraph = function(text) {
		  return '<p>' + text + '</p>\n';
		};
		
		Renderer.prototype.table = function(header, body) {
		  return '<table>\n'
		    + '<thead>\n'
		    + header
		    + '</thead>\n'
		    + '<tbody>\n'
		    + body
		    + '</tbody>\n'
		    + '</table>\n';
		};
		
		Renderer.prototype.tablerow = function(content) {
		  return '<tr>\n' + content + '</tr>\n';
		};
		
		Renderer.prototype.tablecell = function(content, flags) {
		  var type = flags.header ? 'th' : 'td';
		  var tag = flags.align
		    ? '<' + type + ' style="text-align:' + flags.align + '">'
		    : '<' + type + '>';
		  return tag + content + '</' + type + '>\n';
		};
		
		// span level renderer
		Renderer.prototype.strong = function(text) {
		  return '<strong>' + text + '</strong>';
		};
		
		Renderer.prototype.em = function(text) {
		  return '<em>' + text + '</em>';
		};
		
		Renderer.prototype.codespan = function(text) {
		  return '<code>' + text + '</code>';
		};
		
		Renderer.prototype.br = function() {
		  return this.options.xhtml ? '<br/>' : '<br>';
		};
		
		Renderer.prototype.del = function(text) {
		  return '<del>' + text + '</del>';
		};
		
		Renderer.prototype.link = function(href, title, text) {
		  if (this.options.sanitize) {
		    try {
		      var prot = decodeURIComponent(unescape(href))
		        .replace(/[^\w:]/g, '')
		        .toLowerCase();
		    } catch (e) {
		      return '';
		    }
		    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {
		      return '';
		    }
		  }
		  var out = '<a href="' + href + '"';
		  if (title) {
		    out += ' title="' + title + '"';
		  }
		  out += '>' + text + '</a>';
		  return out;
		};
		
		Renderer.prototype.image = function(href, title, text) {
		  var out = '<img src="' + href + '" alt="' + text + '"';
		  if (title) {
		    out += ' title="' + title + '"';
		  }
		  out += this.options.xhtml ? '/>' : '>';
		  return out;
		};
		
		Renderer.prototype.text = function(text) {
		  return text;
		};
		
		/**
		 * Parsing & Compiling
		 */
		
		function Parser(options) {
		  this.tokens = [];
		  this.token = null;
		  this.options = options || marked.defaults;
		  this.options.renderer = this.options.renderer || new Renderer;
		  this.renderer = this.options.renderer;
		  this.renderer.options = this.options;
		}
		
		/**
		 * Static Parse Method
		 */
		
		Parser.parse = function(src, options, renderer) {
		  var parser = new Parser(options, renderer);
		  return parser.parse(src);
		};
		
		/**
		 * Parse Loop
		 */
		
		Parser.prototype.parse = function(src) {
		  this.inline = new InlineLexer(src.links, this.options, this.renderer);
		  this.tokens = src.reverse();
		
		  var out = '';
		  while (this.next()) {
		    out += this.tok();
		  }
		
		  return out;
		};
		
		/**
		 * Next Token
		 */
		
		Parser.prototype.next = function() {
		  return this.token = this.tokens.pop();
		};
		
		/**
		 * Preview Next Token
		 */
		
		Parser.prototype.peek = function() {
		  return this.tokens[this.tokens.length - 1] || 0;
		};
		
		/**
		 * Parse Text Tokens
		 */
		
		Parser.prototype.parseText = function() {
		  var body = this.token.text;
		
		  while (this.peek().type === 'text') {
		    body += '\n' + this.next().text;
		  }
		
		  return this.inline.output(body);
		};
		
		/**
		 * Parse Current Token
		 */
		
		Parser.prototype.tok = function() {
		  switch (this.token.type) {
		    case 'space': {
		      return '';
		    }
		    case 'hr': {
		      return this.renderer.hr();
		    }
		    case 'heading': {
		      return this.renderer.heading(
		        this.inline.output(this.token.text),
		        this.token.depth,
		        this.token.text);
		    }
		    case 'code': {
		      return this.renderer.code(this.token.text,
		        this.token.lang,
		        this.token.escaped);
		    }
		    case 'table': {
		      var header = ''
		        , body = ''
		        , i
		        , row
		        , cell
		        , flags
		        , j;
		
		      // header
		      cell = '';
		      for (i = 0; i < this.token.header.length; i++) {
		        flags = { header: true, align: this.token.align[i] };
		        cell += this.renderer.tablecell(
		          this.inline.output(this.token.header[i]),
		          { header: true, align: this.token.align[i] }
		        );
		      }
		      header += this.renderer.tablerow(cell);
		
		      for (i = 0; i < this.token.cells.length; i++) {
		        row = this.token.cells[i];
		
		        cell = '';
		        for (j = 0; j < row.length; j++) {
		          cell += this.renderer.tablecell(
		            this.inline.output(row[j]),
		            { header: false, align: this.token.align[j] }
		          );
		        }
		
		        body += this.renderer.tablerow(cell);
		      }
		      return this.renderer.table(header, body);
		    }
		    case 'blockquote_start': {
		      var body = '';
		
		      while (this.next().type !== 'blockquote_end') {
		        body += this.tok();
		      }
		
		      return this.renderer.blockquote(body);
		    }
		    case 'list_start': {
		      var body = ''
		        , ordered = this.token.ordered;
		
		      while (this.next().type !== 'list_end') {
		        body += this.tok();
		      }
		
		      return this.renderer.list(body, ordered);
		    }
		    case 'list_item_start': {
		      var body = '';
		
		      while (this.next().type !== 'list_item_end') {
		        body += this.token.type === 'text'
		          ? this.parseText()
		          : this.tok();
		      }
		
		      return this.renderer.listitem(body);
		    }
		    case 'loose_item_start': {
		      var body = '';
		
		      while (this.next().type !== 'list_item_end') {
		        body += this.tok();
		      }
		
		      return this.renderer.listitem(body);
		    }
		    case 'html': {
		      var html = !this.token.pre && !this.options.pedantic
		        ? this.inline.output(this.token.text)
		        : this.token.text;
		      return this.renderer.html(html);
		    }
		    case 'paragraph': {
		      return this.renderer.paragraph(this.inline.output(this.token.text));
		    }
		    case 'text': {
		      return this.renderer.paragraph(this.parseText());
		    }
		  }
		};
		
		/**
		 * Helpers
		 */
		
		function escape(html, encode) {
		  return html
		    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
		    .replace(/</g, '&lt;')
		    .replace(/>/g, '&gt;')
		    .replace(/"/g, '&quot;')
		    .replace(/'/g, '&#39;');
		}
		
		function unescape(html) {
			// explicitly match decimal, hex, and named HTML entities 
		  return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/g, function(_, n) {
		    n = n.toLowerCase();
		    if (n === 'colon') return ':';
		    if (n.charAt(0) === '#') {
		      return n.charAt(1) === 'x'
		        ? String.fromCharCode(parseInt(n.substring(2), 16))
		        : String.fromCharCode(+n.substring(1));
		    }
		    return '';
		  });
		}
		
		function replace(regex, opt) {
		  regex = regex.source;
		  opt = opt || '';
		  return function self(name, val) {
		    if (!name) return new RegExp(regex, opt);
		    val = val.source || val;
		    val = val.replace(/(^|[^\[])\^/g, '$1');
		    regex = regex.replace(name, val);
		    return self;
		  };
		}
		
		function noop() {}
		noop.exec = noop;
		
		function merge(obj) {
		  var i = 1
		    , target
		    , key;
		
		  for (; i < arguments.length; i++) {
		    target = arguments[i];
		    for (key in target) {
		      if (Object.prototype.hasOwnProperty.call(target, key)) {
		        obj[key] = target[key];
		      }
		    }
		  }
		
		  return obj;
		}
		
		
		/**
		 * Marked
		 */
		
		function marked(src, opt, callback) {
		  if (callback || typeof opt === 'function') {
		    if (!callback) {
		      callback = opt;
		      opt = null;
		    }
		
		    opt = merge({}, marked.defaults, opt || {});
		
		    var highlight = opt.highlight
		      , tokens
		      , pending
		      , i = 0;
		
		    try {
		      tokens = Lexer.lex(src, opt)
		    } catch (e) {
		      return callback(e);
		    }
		
		    pending = tokens.length;
		
		    var done = function(err) {
		      if (err) {
		        opt.highlight = highlight;
		        return callback(err);
		      }
		
		      var out;
		
		      try {
		        out = Parser.parse(tokens, opt);
		      } catch (e) {
		        err = e;
		      }
		
		      opt.highlight = highlight;
		
		      return err
		        ? callback(err)
		        : callback(null, out);
		    };
		
		    if (!highlight || highlight.length < 3) {
		      return done();
		    }
		
		    delete opt.highlight;
		
		    if (!pending) return done();
		
		    for (; i < tokens.length; i++) {
		      (function(token) {
		        if (token.type !== 'code') {
		          return --pending || done();
		        }
		        return highlight(token.text, token.lang, function(err, code) {
		          if (err) return done(err);
		          if (code == null || code === token.text) {
		            return --pending || done();
		          }
		          token.text = code;
		          token.escaped = true;
		          --pending || done();
		        });
		      })(tokens[i]);
		    }
		
		    return;
		  }
		  try {
		    if (opt) opt = merge({}, marked.defaults, opt);
		    return Parser.parse(Lexer.lex(src, opt), opt);
		  } catch (e) {
		    e.message += '\nPlease report this to https://github.com/chjj/marked.';
		    if ((opt || marked.defaults).silent) {
		      return '<p>An error occured:</p><pre>'
		        + escape(e.message + '', true)
		        + '</pre>';
		    }
		    throw e;
		  }
		}
		
		/**
		 * Options
		 */
		
		marked.options =
		marked.setOptions = function(opt) {
		  merge(marked.defaults, opt);
		  return marked;
		};
		
		marked.defaults = {
		  gfm: true,
		  tables: true,
		  breaks: false,
		  pedantic: false,
		  sanitize: false,
		  sanitizer: null,
		  mangle: true,
		  smartLists: false,
		  silent: false,
		  highlight: null,
		  langPrefix: 'lang-',
		  smartypants: false,
		  headerPrefix: '',
		  renderer: new Renderer,
		  xhtml: false
		};
		
		/**
		 * Expose
		 */
		
		marked.Parser = Parser;
		marked.parser = Parser.parse;
		
		marked.Renderer = Renderer;
		
		marked.Lexer = Lexer;
		marked.lexer = Lexer.lex;
		
		marked.InlineLexer = InlineLexer;
		marked.inlineLexer = InlineLexer.output;
		
		marked.parse = marked;
		
		if (true) {
		  module.exports = marked;
		} else if (typeof define === 'function' && define.amd) {
		  define(function() { return marked; });
		} else {
		  this.marked = marked;
		}
		
		}).call(function() {
		  return this || (typeof window !== 'undefined' ? window : global);
		}());
		
		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
	
	/***/ }
	/******/ ])
	});
	;
	//# sourceMappingURL=react-simplemde-editor.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(29).Buffer))

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(30)
	var ieee754 = __webpack_require__(31)
	var isArray = __webpack_require__(32)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()
	
	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }
	
	  return that
	}
	
	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */
	
	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}
	
	Buffer.poolSize = 8192 // not used by this implementation
	
	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}
	
	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }
	
	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }
	
	  return fromObject(that, value)
	}
	
	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}
	
	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}
	
	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}
	
	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}
	
	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }
	
	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }
	
	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)
	
	  var actual = that.write(string, encoding)
	
	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual)
	  }
	
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer
	
	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }
	
	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }
	
	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }
	
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}
	
	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)
	
	    if (that.length === 0) {
	      return that
	    }
	
	    obj.copy(that, 0, 0, len)
	    return that
	  }
	
	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }
	
	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }
	
	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }
	
	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }
	
	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}
	
	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.
	
	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }
	
	  if (end === undefined || end > this.length) {
	    end = this.length
	  }
	
	  if (end <= 0) {
	    return ''
	  }
	
	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0
	
	  if (end <= start) {
	    return ''
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true
	
	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}
	
	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}
	
	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}
	
	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }
	
	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }
	
	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }
	
	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }
	
	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0
	
	  if (this === target) return 0
	
	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)
	
	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)
	
	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1
	
	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }
	
	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }
	
	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }
	
	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length
	
	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }
	
	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }
	
	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }
	
	  return -1
	}
	
	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}
	
	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }
	
	  return len
	}
	
	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }
	
	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }
	
	  if (end <= start) {
	    return this
	  }
	
	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0
	
	  if (!val) val = 0
	
	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 30 */
/***/ (function(module, exports) {

	'use strict'
	
	exports.byteLength = byteLength
	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray
	
	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
	
	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i]
	  revLookup[code.charCodeAt(i)] = i
	}
	
	// Support decoding URL-safe base64 strings, as Node.js does.
	// See: https://en.wikipedia.org/wiki/Base64#URL_applications
	revLookup['-'.charCodeAt(0)] = 62
	revLookup['_'.charCodeAt(0)] = 63
	
	function getLens (b64) {
	  var len = b64.length
	
	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }
	
	  // Trim off extra bytes after placeholder bytes are found
	  // See: https://github.com/beatgammit/base64-js/issues/42
	  var validLen = b64.indexOf('=')
	  if (validLen === -1) validLen = len
	
	  var placeHoldersLen = validLen === len
	    ? 0
	    : 4 - (validLen % 4)
	
	  return [validLen, placeHoldersLen]
	}
	
	// base64 is 4/3 + up to two characters of the original data
	function byteLength (b64) {
	  var lens = getLens(b64)
	  var validLen = lens[0]
	  var placeHoldersLen = lens[1]
	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}
	
	function _byteLength (b64, validLen, placeHoldersLen) {
	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}
	
	function toByteArray (b64) {
	  var tmp
	  var lens = getLens(b64)
	  var validLen = lens[0]
	  var placeHoldersLen = lens[1]
	
	  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))
	
	  var curByte = 0
	
	  // if there are placeholders, only get up to the last complete 4 chars
	  var len = placeHoldersLen > 0
	    ? validLen - 4
	    : validLen
	
	  var i
	  for (i = 0; i < len; i += 4) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 18) |
	      (revLookup[b64.charCodeAt(i + 1)] << 12) |
	      (revLookup[b64.charCodeAt(i + 2)] << 6) |
	      revLookup[b64.charCodeAt(i + 3)]
	    arr[curByte++] = (tmp >> 16) & 0xFF
	    arr[curByte++] = (tmp >> 8) & 0xFF
	    arr[curByte++] = tmp & 0xFF
	  }
	
	  if (placeHoldersLen === 2) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 2) |
	      (revLookup[b64.charCodeAt(i + 1)] >> 4)
	    arr[curByte++] = tmp & 0xFF
	  }
	
	  if (placeHoldersLen === 1) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 10) |
	      (revLookup[b64.charCodeAt(i + 1)] << 4) |
	      (revLookup[b64.charCodeAt(i + 2)] >> 2)
	    arr[curByte++] = (tmp >> 8) & 0xFF
	    arr[curByte++] = tmp & 0xFF
	  }
	
	  return arr
	}
	
	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] +
	    lookup[num >> 12 & 0x3F] +
	    lookup[num >> 6 & 0x3F] +
	    lookup[num & 0x3F]
	}
	
	function encodeChunk (uint8, start, end) {
	  var tmp
	  var output = []
	  for (var i = start; i < end; i += 3) {
	    tmp =
	      ((uint8[i] << 16) & 0xFF0000) +
	      ((uint8[i + 1] << 8) & 0xFF00) +
	      (uint8[i + 2] & 0xFF)
	    output.push(tripletToBase64(tmp))
	  }
	  return output.join('')
	}
	
	function fromByteArray (uint8) {
	  var tmp
	  var len = uint8.length
	  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
	  var parts = []
	  var maxChunkLength = 16383 // must be multiple of 3
	
	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(
	      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
	    ))
	  }
	
	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1]
	    parts.push(
	      lookup[tmp >> 2] +
	      lookup[(tmp << 4) & 0x3F] +
	      '=='
	    )
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
	    parts.push(
	      lookup[tmp >> 10] +
	      lookup[(tmp >> 4) & 0x3F] +
	      lookup[(tmp << 2) & 0x3F] +
	      '='
	    )
	  }
	
	  return parts.join('')
	}


/***/ }),
/* 31 */
/***/ (function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = (nBytes * 8) - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = (nBytes * 8) - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = ((value * c) - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ }),
/* 32 */
/***/ (function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var util = __webpack_require__(34);
	
	var SHORTCODE_ATTRS = /(\s+([a-z0-9\-_]+|([a-z0-9\-_]+)\s*=\s*([a-z0-9\-_]+|\d+\.\d+|'[^']*'|"[^"]*")))*/.toString().slice(1, -1);
	var SHORTCODE_SLASH = /\s*\/?\s*/.toString().slice(1, -1);
	var SHORTCODE_OPEN = /\[\s*%s/.toString().slice(1, -1);
	var SHORTCODE_RIGHT_BRACKET = '\\]';
	var SHORTCODE_CLOSE = /\[\s*\/\s*%s\s*\]/.toString().slice(1, -1);
	var SHORTCODE_CONTENT = /(.|\n|)*?/.toString().slice(1, -1);
	var SHORTCODE_SPACE = /\s*/.toString().slice(1, -1);
	
	var ShortcodeParser = function () {
	    function ShortcodeParser() {
	        _classCallCheck(this, ShortcodeParser);
	    }
	
	    _createClass(ShortcodeParser, [{
	        key: 'construct',
	        value: function construct() {
	            this.shortCodes = {};
	        }
	    }, {
	        key: 'registerShortCode',
	        value: function registerShortCode(key, callback) {
	            this.shortCodes[key] = callback;
	        }
	    }, {
	        key: 'typecast',
	        value: function typecast(val) {
	            val = val.trim().replace(/(^['"]|['"]$)/g, '');
	            if (/^\d+$/.test(val)) {
	                return parseInt(val, 10);
	            } else if (/^\d+\.\d+$/.test(val)) {
	                return parseFloat(val);
	            } else if (/^(true|false)$/.test(val)) {
	                return val === 'true';
	            } else if (/^undefined$/.test(val)) {
	                return undefined;
	            } else if (/^null$/i.test(val)) {
	                return null;
	            } else {
	                return val;
	            }
	        }
	    }, {
	        key: 'closeTagString',
	        value: function closeTagString(name) {
	            return (/^[^a-z0-9]/.test(name) ? util.format('[%s]?%s', name[0].replace('$', '\\$'), name.slice(1)) : name
	            );
	        }
	    }, {
	        key: 'parseShortcode',
	        value: function parseShortcode(name, buf, inline) {
	            var regex,
	                match,
	                data = {},
	                attr = {};
	
	            if (inline) {
	                regex = new RegExp('^' + util.format(SHORTCODE_OPEN, name) + SHORTCODE_ATTRS + SHORTCODE_SPACE + SHORTCODE_SLASH + SHORTCODE_RIGHT_BRACKET, 'i');
	            } else {
	                regex = new RegExp('^' + util.format(SHORTCODE_OPEN, name) + SHORTCODE_ATTRS + SHORTCODE_SPACE + SHORTCODE_RIGHT_BRACKET, 'i');
	            }
	
	            while ((match = buf.match(regex)) !== null) {
	                var key = match[3] || match[2];
	                var val = match[4] || match[3];
	                var pattern = match[1];
	                if (pattern) {
	                    var idx = buf.lastIndexOf(pattern);
	                    attr[key] = val !== undefined ? this.typecast(val) : true;
	                    buf = buf.slice(0, idx) + buf.slice(idx + pattern.length);
	                } else {
	                    break;
	                }
	            }
	
	            attr = Object.keys(attr).reverse().reduce(function (prev, current) {
	                prev[current] = attr[current];return prev;
	            }, {});
	
	            buf = buf.replace(regex, '').replace(new RegExp(util.format(SHORTCODE_CLOSE, this.closeTagString(name))), '');
	
	            return {
	                attr: attr,
	                content: inline ? buf : buf.replace(/(^\n|\n$)/g, '')
	            };
	        }
	    }, {
	        key: 'parse',
	        value: function parse(plainText) {
	
	            for (var name in this.shortCodes) {
	                var regex = {
	                    wrapper: new RegExp(util.format(SHORTCODE_OPEN, name) + SHORTCODE_ATTRS + SHORTCODE_RIGHT_BRACKET + SHORTCODE_CONTENT + util.format(SHORTCODE_CLOSE, this.closeTagString(name)), 'gi'),
	                    inline: new RegExp(util.format(SHORTCODE_OPEN, name) + SHORTCODE_ATTRS + SHORTCODE_SLASH + SHORTCODE_RIGHT_BRACKET, 'gi')
	                };
	
	                var matches = plainText.match(regex.wrapper);
	
	                if (matches) {
	                    for (var m, data, i = 0, len = matches.length; i < len; i++) {
	                        m = matches[i];
	                        data = this.parseShortcode(name, m);
	                        plainText = plainText.replace(m, this.shortCodes[name].call(null, data.content, data.attr));
	                    }
	                }
	
	                matches = plainText.match(regex.inline);
	                if (matches) {
	                    var _m = null;
	                    while ((_m = matches.shift()) !== undefined) {
	                        var _data = this.parseShortcode(name, _m, true);
	                        plainText = plainText.replace(_m, this.shortCodes[name].call(null, _data.content, _data.attr));
	                    }
	                }
	            }
	
	            return plainText;
	        }
	    }]);
	
	    return ShortcodeParser;
	}();
	
	ShortcodeParser.prototype.shortCodes = {};
	
	exports.default = ShortcodeParser;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }
	
	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};
	
	
	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }
	
	  if (process.noDeprecation === true) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};
	
	
	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};
	
	
	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;
	
	
	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};
	
	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};
	
	
	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];
	
	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}
	
	
	function stylizeNoColor(str, styleType) {
	  return str;
	}
	
	
	function arrayToHash(array) {
	  var hash = {};
	
	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });
	
	  return hash;
	}
	
	
	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }
	
	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }
	
	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);
	
	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }
	
	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }
	
	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }
	
	  var base = '', array = false, braces = ['{', '}'];
	
	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }
	
	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }
	
	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }
	
	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }
	
	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }
	
	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }
	
	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }
	
	  ctx.seen.push(value);
	
	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }
	
	  ctx.seen.pop();
	
	  return reduceToSingleString(output, base, braces);
	}
	
	
	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}
	
	
	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}
	
	
	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}
	
	
	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }
	
	  return name + ': ' + str;
	}
	
	
	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);
	
	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }
	
	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}
	
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = __webpack_require__(35);
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	
	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}
	
	
	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];
	
	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}
	
	
	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};
	
	
	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(36);
	
	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;
	
	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};
	
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(15)))

/***/ }),
/* 35 */
/***/ (function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ }),
/* 36 */
/***/ (function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	/*global require,module*/
	"use strict";
	var CodeMirror = __webpack_require__(38);
	__webpack_require__(39);
	__webpack_require__(40);
	__webpack_require__(41);
	__webpack_require__(42);
	__webpack_require__(45);
	__webpack_require__(46);
	__webpack_require__(47);
	__webpack_require__(48);
	__webpack_require__(43);
	var CodeMirrorSpellChecker = __webpack_require__(49);
	var marked = __webpack_require__(52);
	
	
	// Some variables
	var isMac = /Mac/.test(navigator.platform);
	
	// Mapping of actions that can be bound to keyboard shortcuts or toolbar buttons
	var bindings = {
		"toggleBold": toggleBold,
		"toggleItalic": toggleItalic,
		"drawLink": drawLink,
		"toggleHeadingSmaller": toggleHeadingSmaller,
		"toggleHeadingBigger": toggleHeadingBigger,
		"drawImage": drawImage,
		"toggleBlockquote": toggleBlockquote,
		"toggleOrderedList": toggleOrderedList,
		"toggleUnorderedList": toggleUnorderedList,
		"toggleCodeBlock": toggleCodeBlock,
		"togglePreview": togglePreview,
		"toggleStrikethrough": toggleStrikethrough,
		"toggleHeading1": toggleHeading1,
		"toggleHeading2": toggleHeading2,
		"toggleHeading3": toggleHeading3,
		"cleanBlock": cleanBlock,
		"drawTable": drawTable,
		"drawHorizontalRule": drawHorizontalRule,
		"undo": undo,
		"redo": redo,
		"toggleSideBySide": toggleSideBySide,
		"toggleFullScreen": toggleFullScreen
	};
	
	var shortcuts = {
		"toggleBold": "Cmd-B",
		"toggleItalic": "Cmd-I",
		"drawLink": "Cmd-K",
		"toggleHeadingSmaller": "Cmd-H",
		"toggleHeadingBigger": "Shift-Cmd-H",
		"cleanBlock": "Cmd-E",
		"drawImage": "Cmd-Alt-I",
		"toggleBlockquote": "Cmd-'",
		"toggleOrderedList": "Cmd-Alt-L",
		"toggleUnorderedList": "Cmd-L",
		"toggleCodeBlock": "Cmd-Alt-C",
		"togglePreview": "Cmd-P",
		"toggleSideBySide": "F9",
		"toggleFullScreen": "F11"
	};
	
	var getBindingName = function(f) {
		for(var key in bindings) {
			if(bindings[key] === f) {
				return key;
			}
		}
		return null;
	};
	
	var isMobile = function() {
		var check = false;
		(function(a) {
			if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) check = true;
		})(navigator.userAgent || navigator.vendor || window.opera);
		return check;
	};
	
	
	/**
	 * Fix shortcut. Mac use Command, others use Ctrl.
	 */
	function fixShortcut(name) {
		if(isMac) {
			name = name.replace("Ctrl", "Cmd");
		} else {
			name = name.replace("Cmd", "Ctrl");
		}
		return name;
	}
	
	
	/**
	 * Create icon element for toolbar.
	 */
	function createIcon(options, enableTooltips, shortcuts) {
		options = options || {};
		var el = document.createElement("a");
		enableTooltips = (enableTooltips == undefined) ? true : enableTooltips;
	
		if(options.title && enableTooltips) {
			el.title = createTootlip(options.title, options.action, shortcuts);
	
			if(isMac) {
				el.title = el.title.replace("Ctrl", "⌘");
				el.title = el.title.replace("Alt", "⌥");
			}
		}
	
		el.tabIndex = -1;
		el.className = options.className;
		return el;
	}
	
	function createSep() {
		var el = document.createElement("i");
		el.className = "separator";
		el.innerHTML = "|";
		return el;
	}
	
	function createTootlip(title, action, shortcuts) {
		var actionName;
		var tooltip = title;
	
		if(action) {
			actionName = getBindingName(action);
			if(shortcuts[actionName]) {
				tooltip += " (" + fixShortcut(shortcuts[actionName]) + ")";
			}
		}
	
		return tooltip;
	}
	
	/**
	 * The state of CodeMirror at the given position.
	 */
	function getState(cm, pos) {
		pos = pos || cm.getCursor("start");
		var stat = cm.getTokenAt(pos);
		if(!stat.type) return {};
	
		var types = stat.type.split(" ");
	
		var ret = {},
			data, text;
		for(var i = 0; i < types.length; i++) {
			data = types[i];
			if(data === "strong") {
				ret.bold = true;
			} else if(data === "variable-2") {
				text = cm.getLine(pos.line);
				if(/^\s*\d+\.\s/.test(text)) {
					ret["ordered-list"] = true;
				} else {
					ret["unordered-list"] = true;
				}
			} else if(data === "atom") {
				ret.quote = true;
			} else if(data === "em") {
				ret.italic = true;
			} else if(data === "quote") {
				ret.quote = true;
			} else if(data === "strikethrough") {
				ret.strikethrough = true;
			} else if(data === "comment") {
				ret.code = true;
			} else if(data === "link") {
				ret.link = true;
			} else if(data === "tag") {
				ret.image = true;
			} else if(data.match(/^header(\-[1-6])?$/)) {
				ret[data.replace("header", "heading")] = true;
			}
		}
		return ret;
	}
	
	
	// Saved overflow setting
	var saved_overflow = "";
	
	/**
	 * Toggle full screen of the editor.
	 */
	function toggleFullScreen(editor) {
		// Set fullscreen
		var cm = editor.codemirror;
		cm.setOption("fullScreen", !cm.getOption("fullScreen"));
	
	
		// Prevent scrolling on body during fullscreen active
		if(cm.getOption("fullScreen")) {
			saved_overflow = document.body.style.overflow;
			document.body.style.overflow = "hidden";
		} else {
			document.body.style.overflow = saved_overflow;
		}
	
	
		// Update toolbar class
		var wrap = cm.getWrapperElement();
	
		if(!/fullscreen/.test(wrap.previousSibling.className)) {
			wrap.previousSibling.className += " fullscreen";
		} else {
			wrap.previousSibling.className = wrap.previousSibling.className.replace(/\s*fullscreen\b/, "");
		}
	
	
		// Update toolbar button
		var toolbarButton = editor.toolbarElements.fullscreen;
	
		if(!/active/.test(toolbarButton.className)) {
			toolbarButton.className += " active";
		} else {
			toolbarButton.className = toolbarButton.className.replace(/\s*active\s*/g, "");
		}
	
	
		// Hide side by side if needed
		var sidebyside = cm.getWrapperElement().nextSibling;
		if(/editor-preview-active-side/.test(sidebyside.className))
			toggleSideBySide(editor);
	}
	
	
	/**
	 * Action for toggling bold.
	 */
	function toggleBold(editor) {
		_toggleBlock(editor, "bold", editor.options.blockStyles.bold);
	}
	
	
	/**
	 * Action for toggling italic.
	 */
	function toggleItalic(editor) {
		_toggleBlock(editor, "italic", editor.options.blockStyles.italic);
	}
	
	
	/**
	 * Action for toggling strikethrough.
	 */
	function toggleStrikethrough(editor) {
		_toggleBlock(editor, "strikethrough", "~~");
	}
	
	/**
	 * Action for toggling code block.
	 */
	function toggleCodeBlock(editor) {
		var fenceCharsToInsert = editor.options.blockStyles.code;
	
		function fencing_line(line) {
			/* return true, if this is a ``` or ~~~ line */
			if(typeof line !== "object") {
				throw "fencing_line() takes a 'line' object (not a line number, or line text).  Got: " + typeof line + ": " + line;
			}
			return line.styles && line.styles[2] && line.styles[2].indexOf("formatting-code-block") !== -1;
		}
	
		function token_state(token) {
			// base goes an extra level deep when mode backdrops are used, e.g. spellchecker on
			return token.state.base.base || token.state.base;
		}
	
		function code_type(cm, line_num, line, firstTok, lastTok) {
			/*
			 * Return "single", "indented", "fenced" or false
			 *
			 * cm and line_num are required.  Others are optional for efficiency
			 *   To check in the middle of a line, pass in firstTok yourself.
			 */
			line = line || cm.getLineHandle(line_num);
			firstTok = firstTok || cm.getTokenAt({
				line: line_num,
				ch: 1
			});
			lastTok = lastTok || (!!line.text && cm.getTokenAt({
				line: line_num,
				ch: line.text.length - 1
			}));
			var types = firstTok.type ? firstTok.type.split(" ") : [];
			if(lastTok && token_state(lastTok).indentedCode) {
				// have to check last char, since first chars of first line aren"t marked as indented
				return "indented";
			} else if(types.indexOf("comment") === -1) {
				// has to be after "indented" check, since first chars of first indented line aren"t marked as such
				return false;
			} else if(token_state(firstTok).fencedChars || token_state(lastTok).fencedChars || fencing_line(line)) {
				return "fenced";
			} else {
				return "single";
			}
		}
	
		function insertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert) {
			var start_line_sel = cur_start.line + 1,
				end_line_sel = cur_end.line + 1,
				sel_multi = cur_start.line !== cur_end.line,
				repl_start = fenceCharsToInsert + "\n",
				repl_end = "\n" + fenceCharsToInsert;
			if(sel_multi) {
				end_line_sel++;
			}
			// handle last char including \n or not
			if(sel_multi && cur_end.ch === 0) {
				repl_end = fenceCharsToInsert + "\n";
				end_line_sel--;
			}
			_replaceSelection(cm, false, [repl_start, repl_end]);
			cm.setSelection({
				line: start_line_sel,
				ch: 0
			}, {
				line: end_line_sel,
				ch: 0
			});
		}
	
		var cm = editor.codemirror,
			cur_start = cm.getCursor("start"),
			cur_end = cm.getCursor("end"),
			tok = cm.getTokenAt({
				line: cur_start.line,
				ch: cur_start.ch || 1
			}), // avoid ch 0 which is a cursor pos but not token
			line = cm.getLineHandle(cur_start.line),
			is_code = code_type(cm, cur_start.line, line, tok);
		var block_start, block_end, lineCount;
	
		if(is_code === "single") {
			// similar to some SimpleMDE _toggleBlock logic
			var start = line.text.slice(0, cur_start.ch).replace("`", ""),
				end = line.text.slice(cur_start.ch).replace("`", "");
			cm.replaceRange(start + end, {
				line: cur_start.line,
				ch: 0
			}, {
				line: cur_start.line,
				ch: 99999999999999
			});
			cur_start.ch--;
			if(cur_start !== cur_end) {
				cur_end.ch--;
			}
			cm.setSelection(cur_start, cur_end);
			cm.focus();
		} else if(is_code === "fenced") {
			if(cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {
				// use selection
	
				// find the fenced line so we know what type it is (tilde, backticks, number of them)
				for(block_start = cur_start.line; block_start >= 0; block_start--) {
					line = cm.getLineHandle(block_start);
					if(fencing_line(line)) {
						break;
					}
				}
				var fencedTok = cm.getTokenAt({
					line: block_start,
					ch: 1
				});
				var fence_chars = token_state(fencedTok).fencedChars;
				var start_text, start_line;
				var end_text, end_line;
				// check for selection going up against fenced lines, in which case we don't want to add more fencing
				if(fencing_line(cm.getLineHandle(cur_start.line))) {
					start_text = "";
					start_line = cur_start.line;
				} else if(fencing_line(cm.getLineHandle(cur_start.line - 1))) {
					start_text = "";
					start_line = cur_start.line - 1;
				} else {
					start_text = fence_chars + "\n";
					start_line = cur_start.line;
				}
				if(fencing_line(cm.getLineHandle(cur_end.line))) {
					end_text = "";
					end_line = cur_end.line;
					if(cur_end.ch === 0) {
						end_line += 1;
					}
				} else if(cur_end.ch !== 0 && fencing_line(cm.getLineHandle(cur_end.line + 1))) {
					end_text = "";
					end_line = cur_end.line + 1;
				} else {
					end_text = fence_chars + "\n";
					end_line = cur_end.line + 1;
				}
				if(cur_end.ch === 0) {
					// full last line selected, putting cursor at beginning of next
					end_line -= 1;
				}
				cm.operation(function() {
					// end line first, so that line numbers don't change
					cm.replaceRange(end_text, {
						line: end_line,
						ch: 0
					}, {
						line: end_line + (end_text ? 0 : 1),
						ch: 0
					});
					cm.replaceRange(start_text, {
						line: start_line,
						ch: 0
					}, {
						line: start_line + (start_text ? 0 : 1),
						ch: 0
					});
				});
				cm.setSelection({
					line: start_line + (start_text ? 1 : 0),
					ch: 0
				}, {
					line: end_line + (start_text ? 1 : -1),
					ch: 0
				});
				cm.focus();
			} else {
				// no selection, search for ends of this fenced block
				var search_from = cur_start.line;
				if(fencing_line(cm.getLineHandle(cur_start.line))) { // gets a little tricky if cursor is right on a fenced line
					if(code_type(cm, cur_start.line + 1) === "fenced") {
						block_start = cur_start.line;
						search_from = cur_start.line + 1; // for searching for "end"
					} else {
						block_end = cur_start.line;
						search_from = cur_start.line - 1; // for searching for "start"
					}
				}
				if(block_start === undefined) {
					for(block_start = search_from; block_start >= 0; block_start--) {
						line = cm.getLineHandle(block_start);
						if(fencing_line(line)) {
							break;
						}
					}
				}
				if(block_end === undefined) {
					lineCount = cm.lineCount();
					for(block_end = search_from; block_end < lineCount; block_end++) {
						line = cm.getLineHandle(block_end);
						if(fencing_line(line)) {
							break;
						}
					}
				}
				cm.operation(function() {
					cm.replaceRange("", {
						line: block_start,
						ch: 0
					}, {
						line: block_start + 1,
						ch: 0
					});
					cm.replaceRange("", {
						line: block_end - 1,
						ch: 0
					}, {
						line: block_end,
						ch: 0
					});
				});
				cm.focus();
			}
		} else if(is_code === "indented") {
			if(cur_start.line !== cur_end.line || cur_start.ch !== cur_end.ch) {
				// use selection
				block_start = cur_start.line;
				block_end = cur_end.line;
				if(cur_end.ch === 0) {
					block_end--;
				}
			} else {
				// no selection, search for ends of this indented block
				for(block_start = cur_start.line; block_start >= 0; block_start--) {
					line = cm.getLineHandle(block_start);
					if(line.text.match(/^\s*$/)) {
						// empty or all whitespace - keep going
						continue;
					} else {
						if(code_type(cm, block_start, line) !== "indented") {
							block_start += 1;
							break;
						}
					}
				}
				lineCount = cm.lineCount();
				for(block_end = cur_start.line; block_end < lineCount; block_end++) {
					line = cm.getLineHandle(block_end);
					if(line.text.match(/^\s*$/)) {
						// empty or all whitespace - keep going
						continue;
					} else {
						if(code_type(cm, block_end, line) !== "indented") {
							block_end -= 1;
							break;
						}
					}
				}
			}
			// if we are going to un-indent based on a selected set of lines, and the next line is indented too, we need to
			// insert a blank line so that the next line(s) continue to be indented code
			var next_line = cm.getLineHandle(block_end + 1),
				next_line_last_tok = next_line && cm.getTokenAt({
					line: block_end + 1,
					ch: next_line.text.length - 1
				}),
				next_line_indented = next_line_last_tok && token_state(next_line_last_tok).indentedCode;
			if(next_line_indented) {
				cm.replaceRange("\n", {
					line: block_end + 1,
					ch: 0
				});
			}
	
			for(var i = block_start; i <= block_end; i++) {
				cm.indentLine(i, "subtract"); // TODO: this doesn't get tracked in the history, so can't be undone :(
			}
			cm.focus();
		} else {
			// insert code formatting
			var no_sel_and_starting_of_line = (cur_start.line === cur_end.line && cur_start.ch === cur_end.ch && cur_start.ch === 0);
			var sel_multi = cur_start.line !== cur_end.line;
			if(no_sel_and_starting_of_line || sel_multi) {
				insertFencingAtSelection(cm, cur_start, cur_end, fenceCharsToInsert);
			} else {
				_replaceSelection(cm, false, ["`", "`"]);
			}
		}
	}
	
	/**
	 * Action for toggling blockquote.
	 */
	function toggleBlockquote(editor) {
		var cm = editor.codemirror;
		_toggleLine(cm, "quote");
	}
	
	/**
	 * Action for toggling heading size: normal -> h1 -> h2 -> h3 -> h4 -> h5 -> h6 -> normal
	 */
	function toggleHeadingSmaller(editor) {
		var cm = editor.codemirror;
		_toggleHeading(cm, "smaller");
	}
	
	/**
	 * Action for toggling heading size: normal -> h6 -> h5 -> h4 -> h3 -> h2 -> h1 -> normal
	 */
	function toggleHeadingBigger(editor) {
		var cm = editor.codemirror;
		_toggleHeading(cm, "bigger");
	}
	
	/**
	 * Action for toggling heading size 1
	 */
	function toggleHeading1(editor) {
		var cm = editor.codemirror;
		_toggleHeading(cm, undefined, 1);
	}
	
	/**
	 * Action for toggling heading size 2
	 */
	function toggleHeading2(editor) {
		var cm = editor.codemirror;
		_toggleHeading(cm, undefined, 2);
	}
	
	/**
	 * Action for toggling heading size 3
	 */
	function toggleHeading3(editor) {
		var cm = editor.codemirror;
		_toggleHeading(cm, undefined, 3);
	}
	
	
	/**
	 * Action for toggling ul.
	 */
	function toggleUnorderedList(editor) {
		var cm = editor.codemirror;
		_toggleLine(cm, "unordered-list");
	}
	
	
	/**
	 * Action for toggling ol.
	 */
	function toggleOrderedList(editor) {
		var cm = editor.codemirror;
		_toggleLine(cm, "ordered-list");
	}
	
	/**
	 * Action for clean block (remove headline, list, blockquote code, markers)
	 */
	function cleanBlock(editor) {
		var cm = editor.codemirror;
		_cleanBlock(cm);
	}
	
	/**
	 * Action for drawing a link.
	 */
	function drawLink(editor) {
		var cm = editor.codemirror;
		var stat = getState(cm);
		var options = editor.options;
		var url = "http://";
		if(options.promptURLs) {
			url = prompt(options.promptTexts.link);
			if(!url) {
				return false;
			}
		}
		_replaceSelection(cm, stat.link, options.insertTexts.link, url);
	}
	
	/**
	 * Action for drawing an img.
	 */
	function drawImage(editor) {
		var cm = editor.codemirror;
		var stat = getState(cm);
		var options = editor.options;
		var url = "http://";
		if(options.promptURLs) {
			url = prompt(options.promptTexts.image);
			if(!url) {
				return false;
			}
		}
		_replaceSelection(cm, stat.image, options.insertTexts.image, url);
	}
	
	/**
	 * Action for drawing a table.
	 */
	function drawTable(editor) {
		var cm = editor.codemirror;
		var stat = getState(cm);
		var options = editor.options;
		_replaceSelection(cm, stat.table, options.insertTexts.table);
	}
	
	/**
	 * Action for drawing a horizontal rule.
	 */
	function drawHorizontalRule(editor) {
		var cm = editor.codemirror;
		var stat = getState(cm);
		var options = editor.options;
		_replaceSelection(cm, stat.image, options.insertTexts.horizontalRule);
	}
	
	
	/**
	 * Undo action.
	 */
	function undo(editor) {
		var cm = editor.codemirror;
		cm.undo();
		cm.focus();
	}
	
	
	/**
	 * Redo action.
	 */
	function redo(editor) {
		var cm = editor.codemirror;
		cm.redo();
		cm.focus();
	}
	
	
	/**
	 * Toggle side by side preview
	 */
	function toggleSideBySide(editor) {
		var cm = editor.codemirror;
		var wrapper = cm.getWrapperElement();
		var preview = wrapper.nextSibling;
		var toolbarButton = editor.toolbarElements["side-by-side"];
		var useSideBySideListener = false;
		if(/editor-preview-active-side/.test(preview.className)) {
			preview.className = preview.className.replace(
				/\s*editor-preview-active-side\s*/g, ""
			);
			toolbarButton.className = toolbarButton.className.replace(/\s*active\s*/g, "");
			wrapper.className = wrapper.className.replace(/\s*CodeMirror-sided\s*/g, " ");
		} else {
			// When the preview button is clicked for the first time,
			// give some time for the transition from editor.css to fire and the view to slide from right to left,
			// instead of just appearing.
			setTimeout(function() {
				if(!cm.getOption("fullScreen"))
					toggleFullScreen(editor);
				preview.className += " editor-preview-active-side";
			}, 1);
			toolbarButton.className += " active";
			wrapper.className += " CodeMirror-sided";
			useSideBySideListener = true;
		}
	
		// Hide normal preview if active
		var previewNormal = wrapper.lastChild;
		if(/editor-preview-active/.test(previewNormal.className)) {
			previewNormal.className = previewNormal.className.replace(
				/\s*editor-preview-active\s*/g, ""
			);
			var toolbar = editor.toolbarElements.preview;
			var toolbar_div = wrapper.previousSibling;
			toolbar.className = toolbar.className.replace(/\s*active\s*/g, "");
			toolbar_div.className = toolbar_div.className.replace(/\s*disabled-for-preview*/g, "");
		}
	
		var sideBySideRenderingFunction = function() {
			preview.innerHTML = editor.options.previewRender(editor.value(), preview);
		};
	
		if(!cm.sideBySideRenderingFunction) {
			cm.sideBySideRenderingFunction = sideBySideRenderingFunction;
		}
	
		if(useSideBySideListener) {
			preview.innerHTML = editor.options.previewRender(editor.value(), preview);
			cm.on("update", cm.sideBySideRenderingFunction);
		} else {
			cm.off("update", cm.sideBySideRenderingFunction);
		}
	
		// Refresh to fix selection being off (#309)
		cm.refresh();
	}
	
	
	/**
	 * Preview action.
	 */
	function togglePreview(editor) {
		var cm = editor.codemirror;
		var wrapper = cm.getWrapperElement();
		var toolbar_div = wrapper.previousSibling;
		var toolbar = editor.options.toolbar ? editor.toolbarElements.preview : false;
		var preview = wrapper.lastChild;
		if(!preview || !/editor-preview/.test(preview.className)) {
			preview = document.createElement("div");
			preview.className = "editor-preview";
			wrapper.appendChild(preview);
		}
		if(/editor-preview-active/.test(preview.className)) {
			preview.className = preview.className.replace(
				/\s*editor-preview-active\s*/g, ""
			);
			if(toolbar) {
				toolbar.className = toolbar.className.replace(/\s*active\s*/g, "");
				toolbar_div.className = toolbar_div.className.replace(/\s*disabled-for-preview*/g, "");
			}
		} else {
			// When the preview button is clicked for the first time,
			// give some time for the transition from editor.css to fire and the view to slide from right to left,
			// instead of just appearing.
			setTimeout(function() {
				preview.className += " editor-preview-active";
			}, 1);
			if(toolbar) {
				toolbar.className += " active";
				toolbar_div.className += " disabled-for-preview";
			}
		}
		preview.innerHTML = editor.options.previewRender(editor.value(), preview);
	
		// Turn off side by side if needed
		var sidebyside = cm.getWrapperElement().nextSibling;
		if(/editor-preview-active-side/.test(sidebyside.className))
			toggleSideBySide(editor);
	}
	
	function _replaceSelection(cm, active, startEnd, url) {
		if(/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))
			return;
	
		var text;
		var start = startEnd[0];
		var end = startEnd[1];
		var startPoint = cm.getCursor("start");
		var endPoint = cm.getCursor("end");
		if(url) {
			end = end.replace("#url#", url);
		}
		if(active) {
			text = cm.getLine(startPoint.line);
			start = text.slice(0, startPoint.ch);
			end = text.slice(startPoint.ch);
			cm.replaceRange(start + end, {
				line: startPoint.line,
				ch: 0
			});
		} else {
			text = cm.getSelection();
			cm.replaceSelection(start + text + end);
	
			startPoint.ch += start.length;
			if(startPoint !== endPoint) {
				endPoint.ch += start.length;
			}
		}
		cm.setSelection(startPoint, endPoint);
		cm.focus();
	}
	
	
	function _toggleHeading(cm, direction, size) {
		if(/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))
			return;
	
		var startPoint = cm.getCursor("start");
		var endPoint = cm.getCursor("end");
		for(var i = startPoint.line; i <= endPoint.line; i++) {
			(function(i) {
				var text = cm.getLine(i);
				var currHeadingLevel = text.search(/[^#]/);
	
				if(direction !== undefined) {
					if(currHeadingLevel <= 0) {
						if(direction == "bigger") {
							text = "###### " + text;
						} else {
							text = "# " + text;
						}
					} else if(currHeadingLevel == 6 && direction == "smaller") {
						text = text.substr(7);
					} else if(currHeadingLevel == 1 && direction == "bigger") {
						text = text.substr(2);
					} else {
						if(direction == "bigger") {
							text = text.substr(1);
						} else {
							text = "#" + text;
						}
					}
				} else {
					if(size == 1) {
						if(currHeadingLevel <= 0) {
							text = "# " + text;
						} else if(currHeadingLevel == size) {
							text = text.substr(currHeadingLevel + 1);
						} else {
							text = "# " + text.substr(currHeadingLevel + 1);
						}
					} else if(size == 2) {
						if(currHeadingLevel <= 0) {
							text = "## " + text;
						} else if(currHeadingLevel == size) {
							text = text.substr(currHeadingLevel + 1);
						} else {
							text = "## " + text.substr(currHeadingLevel + 1);
						}
					} else {
						if(currHeadingLevel <= 0) {
							text = "### " + text;
						} else if(currHeadingLevel == size) {
							text = text.substr(currHeadingLevel + 1);
						} else {
							text = "### " + text.substr(currHeadingLevel + 1);
						}
					}
				}
	
				cm.replaceRange(text, {
					line: i,
					ch: 0
				}, {
					line: i,
					ch: 99999999999999
				});
			})(i);
		}
		cm.focus();
	}
	
	
	function _toggleLine(cm, name) {
		if(/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))
			return;
	
		var stat = getState(cm);
		var startPoint = cm.getCursor("start");
		var endPoint = cm.getCursor("end");
		var repl = {
			"quote": /^(\s*)\>\s+/,
			"unordered-list": /^(\s*)(\*|\-|\+)\s+/,
			"ordered-list": /^(\s*)\d+\.\s+/
		};
		var map = {
			"quote": "> ",
			"unordered-list": "* ",
			"ordered-list": "1. "
		};
		for(var i = startPoint.line; i <= endPoint.line; i++) {
			(function(i) {
				var text = cm.getLine(i);
				if(stat[name]) {
					text = text.replace(repl[name], "$1");
				} else {
					text = map[name] + text;
				}
				cm.replaceRange(text, {
					line: i,
					ch: 0
				}, {
					line: i,
					ch: 99999999999999
				});
			})(i);
		}
		cm.focus();
	}
	
	function _toggleBlock(editor, type, start_chars, end_chars) {
		if(/editor-preview-active/.test(editor.codemirror.getWrapperElement().lastChild.className))
			return;
	
		end_chars = (typeof end_chars === "undefined") ? start_chars : end_chars;
		var cm = editor.codemirror;
		var stat = getState(cm);
	
		var text;
		var start = start_chars;
		var end = end_chars;
	
		var startPoint = cm.getCursor("start");
		var endPoint = cm.getCursor("end");
	
		if(stat[type]) {
			text = cm.getLine(startPoint.line);
			start = text.slice(0, startPoint.ch);
			end = text.slice(startPoint.ch);
			if(type == "bold") {
				start = start.replace(/(\*\*|__)(?![\s\S]*(\*\*|__))/, "");
				end = end.replace(/(\*\*|__)/, "");
			} else if(type == "italic") {
				start = start.replace(/(\*|_)(?![\s\S]*(\*|_))/, "");
				end = end.replace(/(\*|_)/, "");
			} else if(type == "strikethrough") {
				start = start.replace(/(\*\*|~~)(?![\s\S]*(\*\*|~~))/, "");
				end = end.replace(/(\*\*|~~)/, "");
			}
			cm.replaceRange(start + end, {
				line: startPoint.line,
				ch: 0
			}, {
				line: startPoint.line,
				ch: 99999999999999
			});
	
			if(type == "bold" || type == "strikethrough") {
				startPoint.ch -= 2;
				if(startPoint !== endPoint) {
					endPoint.ch -= 2;
				}
			} else if(type == "italic") {
				startPoint.ch -= 1;
				if(startPoint !== endPoint) {
					endPoint.ch -= 1;
				}
			}
		} else {
			text = cm.getSelection();
			if(type == "bold") {
				text = text.split("**").join("");
				text = text.split("__").join("");
			} else if(type == "italic") {
				text = text.split("*").join("");
				text = text.split("_").join("");
			} else if(type == "strikethrough") {
				text = text.split("~~").join("");
			}
			cm.replaceSelection(start + text + end);
	
			startPoint.ch += start_chars.length;
			endPoint.ch = startPoint.ch + text.length;
		}
	
		cm.setSelection(startPoint, endPoint);
		cm.focus();
	}
	
	function _cleanBlock(cm) {
		if(/editor-preview-active/.test(cm.getWrapperElement().lastChild.className))
			return;
	
		var startPoint = cm.getCursor("start");
		var endPoint = cm.getCursor("end");
		var text;
	
		for(var line = startPoint.line; line <= endPoint.line; line++) {
			text = cm.getLine(line);
			text = text.replace(/^[ ]*([# ]+|\*|\-|[> ]+|[0-9]+(.|\)))[ ]*/, "");
	
			cm.replaceRange(text, {
				line: line,
				ch: 0
			}, {
				line: line,
				ch: 99999999999999
			});
		}
	}
	
	// Merge the properties of one object into another.
	function _mergeProperties(target, source) {
		for(var property in source) {
			if(source.hasOwnProperty(property)) {
				if(source[property] instanceof Array) {
					target[property] = source[property].concat(target[property] instanceof Array ? target[property] : []);
				} else if(
					source[property] !== null &&
					typeof source[property] === "object" &&
					source[property].constructor === Object
				) {
					target[property] = _mergeProperties(target[property] || {}, source[property]);
				} else {
					target[property] = source[property];
				}
			}
		}
	
		return target;
	}
	
	// Merge an arbitrary number of objects into one.
	function extend(target) {
		for(var i = 1; i < arguments.length; i++) {
			target = _mergeProperties(target, arguments[i]);
		}
	
		return target;
	}
	
	/* The right word count in respect for CJK. */
	function wordCount(data) {
		var pattern = /[a-zA-Z0-9_\u0392-\u03c9\u0410-\u04F9]+|[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af]+/g;
		var m = data.match(pattern);
		var count = 0;
		if(m === null) return count;
		for(var i = 0; i < m.length; i++) {
			if(m[i].charCodeAt(0) >= 0x4E00) {
				count += m[i].length;
			} else {
				count += 1;
			}
		}
		return count;
	}
	
	var toolbarBuiltInButtons = {
		"bold": {
			name: "bold",
			action: toggleBold,
			className: "fa fa-bold",
			title: "Bold",
			default: true
		},
		"italic": {
			name: "italic",
			action: toggleItalic,
			className: "fa fa-italic",
			title: "Italic",
			default: true
		},
		"strikethrough": {
			name: "strikethrough",
			action: toggleStrikethrough,
			className: "fa fa-strikethrough",
			title: "Strikethrough"
		},
		"heading": {
			name: "heading",
			action: toggleHeadingSmaller,
			className: "fa fa-header",
			title: "Heading",
			default: true
		},
		"heading-smaller": {
			name: "heading-smaller",
			action: toggleHeadingSmaller,
			className: "fa fa-header fa-header-x fa-header-smaller",
			title: "Smaller Heading"
		},
		"heading-bigger": {
			name: "heading-bigger",
			action: toggleHeadingBigger,
			className: "fa fa-header fa-header-x fa-header-bigger",
			title: "Bigger Heading"
		},
		"heading-1": {
			name: "heading-1",
			action: toggleHeading1,
			className: "fa fa-header fa-header-x fa-header-1",
			title: "Big Heading"
		},
		"heading-2": {
			name: "heading-2",
			action: toggleHeading2,
			className: "fa fa-header fa-header-x fa-header-2",
			title: "Medium Heading"
		},
		"heading-3": {
			name: "heading-3",
			action: toggleHeading3,
			className: "fa fa-header fa-header-x fa-header-3",
			title: "Small Heading"
		},
		"separator-1": {
			name: "separator-1"
		},
		"code": {
			name: "code",
			action: toggleCodeBlock,
			className: "fa fa-code",
			title: "Code"
		},
		"quote": {
			name: "quote",
			action: toggleBlockquote,
			className: "fa fa-quote-left",
			title: "Quote",
			default: true
		},
		"unordered-list": {
			name: "unordered-list",
			action: toggleUnorderedList,
			className: "fa fa-list-ul",
			title: "Generic List",
			default: true
		},
		"ordered-list": {
			name: "ordered-list",
			action: toggleOrderedList,
			className: "fa fa-list-ol",
			title: "Numbered List",
			default: true
		},
		"clean-block": {
			name: "clean-block",
			action: cleanBlock,
			className: "fa fa-eraser fa-clean-block",
			title: "Clean block"
		},
		"separator-2": {
			name: "separator-2"
		},
		"link": {
			name: "link",
			action: drawLink,
			className: "fa fa-link",
			title: "Create Link",
			default: true
		},
		"image": {
			name: "image",
			action: drawImage,
			className: "fa fa-picture-o",
			title: "Insert Image",
			default: true
		},
		"table": {
			name: "table",
			action: drawTable,
			className: "fa fa-table",
			title: "Insert Table"
		},
		"horizontal-rule": {
			name: "horizontal-rule",
			action: drawHorizontalRule,
			className: "fa fa-minus",
			title: "Insert Horizontal Line"
		},
		"separator-3": {
			name: "separator-3"
		},
		"preview": {
			name: "preview",
			action: togglePreview,
			className: "fa fa-eye no-disable",
			title: "Toggle Preview",
			default: true
		},
		"side-by-side": {
			name: "side-by-side",
			action: toggleSideBySide,
			className: "fa fa-columns no-disable no-mobile",
			title: "Toggle Side by Side",
			default: true
		},
		"fullscreen": {
			name: "fullscreen",
			action: toggleFullScreen,
			className: "fa fa-arrows-alt no-disable no-mobile",
			title: "Toggle Fullscreen",
			default: true
		},
		"separator-4": {
			name: "separator-4"
		},
		"guide": {
			name: "guide",
			action: "https://simplemde.com/markdown-guide",
			className: "fa fa-question-circle",
			title: "Markdown Guide",
			default: true
		},
		"separator-5": {
			name: "separator-5"
		},
		"undo": {
			name: "undo",
			action: undo,
			className: "fa fa-undo no-disable",
			title: "Undo"
		},
		"redo": {
			name: "redo",
			action: redo,
			className: "fa fa-repeat no-disable",
			title: "Redo"
		}
	};
	
	var insertTexts = {
		link: ["[", "](#url#)"],
		image: ["![](", "#url#)"],
		table: ["", "\n\n| Column 1 | Column 2 | Column 3 |\n| -------- | -------- | -------- |\n| Text     | Text     | Text     |\n\n"],
		horizontalRule: ["", "\n\n-----\n\n"]
	};
	
	var promptTexts = {
		link: "URL for the link:",
		image: "URL of the image:"
	};
	
	var blockStyles = {
		"bold": "**",
		"code": "```",
		"italic": "*"
	};
	
	/**
	 * Interface of SimpleMDE.
	 */
	function SimpleMDE(options) {
		// Handle options parameter
		options = options || {};
	
	
		// Used later to refer to it"s parent
		options.parent = this;
	
	
		// Check if Font Awesome needs to be auto downloaded
		var autoDownloadFA = true;
	
		if(options.autoDownloadFontAwesome === false) {
			autoDownloadFA = false;
		}
	
		if(options.autoDownloadFontAwesome !== true) {
			var styleSheets = document.styleSheets;
			for(var i = 0; i < styleSheets.length; i++) {
				if(!styleSheets[i].href)
					continue;
	
				if(styleSheets[i].href.indexOf("//maxcdn.bootstrapcdn.com/font-awesome/") > -1) {
					autoDownloadFA = false;
				}
			}
		}
	
		if(autoDownloadFA) {
			var link = document.createElement("link");
			link.rel = "stylesheet";
			link.href = "https://maxcdn.bootstrapcdn.com/font-awesome/latest/css/font-awesome.min.css";
			document.getElementsByTagName("head")[0].appendChild(link);
		}
	
	
		// Find the textarea to use
		if(options.element) {
			this.element = options.element;
		} else if(options.element === null) {
			// This means that the element option was specified, but no element was found
			console.log("SimpleMDE: Error. No element was found.");
			return;
		}
	
	
		// Handle toolbar
		if(options.toolbar === undefined) {
			// Initialize
			options.toolbar = [];
	
	
			// Loop over the built in buttons, to get the preferred order
			for(var key in toolbarBuiltInButtons) {
				if(toolbarBuiltInButtons.hasOwnProperty(key)) {
					if(key.indexOf("separator-") != -1) {
						options.toolbar.push("|");
					}
	
					if(toolbarBuiltInButtons[key].default === true || (options.showIcons && options.showIcons.constructor === Array && options.showIcons.indexOf(key) != -1)) {
						options.toolbar.push(key);
					}
				}
			}
		}
	
	
		// Handle status bar
		if(!options.hasOwnProperty("status")) {
			options.status = ["autosave", "lines", "words", "cursor"];
		}
	
	
		// Add default preview rendering function
		if(!options.previewRender) {
			options.previewRender = function(plainText) {
				// Note: "this" refers to the options object
				return this.parent.markdown(plainText);
			};
		}
	
	
		// Set default options for parsing config
		options.parsingConfig = extend({
			highlightFormatting: true // needed for toggleCodeBlock to detect types of code
		}, options.parsingConfig || {});
	
	
		// Merging the insertTexts, with the given options
		options.insertTexts = extend({}, insertTexts, options.insertTexts || {});
	
	
		// Merging the promptTexts, with the given options
		options.promptTexts = promptTexts;
	
	
		// Merging the blockStyles, with the given options
		options.blockStyles = extend({}, blockStyles, options.blockStyles || {});
	
	
		// Merging the shortcuts, with the given options
		options.shortcuts = extend({}, shortcuts, options.shortcuts || {});
	
	
		// Change unique_id to uniqueId for backwards compatibility
		if(options.autosave != undefined && options.autosave.unique_id != undefined && options.autosave.unique_id != "")
			options.autosave.uniqueId = options.autosave.unique_id;
	
	
		// Update this options
		this.options = options;
	
	
		// Auto render
		this.render();
	
	
		// The codemirror component is only available after rendering
		// so, the setter for the initialValue can only run after
		// the element has been rendered
		if(options.initialValue && (!this.options.autosave || this.options.autosave.foundSavedValue !== true)) {
			this.value(options.initialValue);
		}
	}
	
	/**
	 * Default markdown render.
	 */
	SimpleMDE.prototype.markdown = function(text) {
		if(marked) {
			// Initialize
			var markedOptions = {};
	
	
			// Update options
			if(this.options && this.options.renderingConfig && this.options.renderingConfig.singleLineBreaks === false) {
				markedOptions.breaks = false;
			} else {
				markedOptions.breaks = true;
			}
	
			if(this.options && this.options.renderingConfig && this.options.renderingConfig.codeSyntaxHighlighting === true && window.hljs) {
				markedOptions.highlight = function(code) {
					return window.hljs.highlightAuto(code).value;
				};
			}
	
	
			// Set options
			marked.setOptions(markedOptions);
	
	
			// Return
			return marked(text);
		}
	};
	
	/**
	 * Render editor to the given element.
	 */
	SimpleMDE.prototype.render = function(el) {
		if(!el) {
			el = this.element || document.getElementsByTagName("textarea")[0];
		}
	
		if(this._rendered && this._rendered === el) {
			// Already rendered.
			return;
		}
	
		this.element = el;
		var options = this.options;
	
		var self = this;
		var keyMaps = {};
	
		for(var key in options.shortcuts) {
			// null stands for "do not bind this command"
			if(options.shortcuts[key] !== null && bindings[key] !== null) {
				(function(key) {
					keyMaps[fixShortcut(options.shortcuts[key])] = function() {
						bindings[key](self);
					};
				})(key);
			}
		}
	
		keyMaps["Enter"] = "newlineAndIndentContinueMarkdownList";
		keyMaps["Tab"] = "tabAndIndentMarkdownList";
		keyMaps["Shift-Tab"] = "shiftTabAndUnindentMarkdownList";
		keyMaps["Esc"] = function(cm) {
			if(cm.getOption("fullScreen")) toggleFullScreen(self);
		};
	
		document.addEventListener("keydown", function(e) {
			e = e || window.event;
	
			if(e.keyCode == 27) {
				if(self.codemirror.getOption("fullScreen")) toggleFullScreen(self);
			}
		}, false);
	
		var mode, backdrop;
		if(options.spellChecker !== false) {
			mode = "spell-checker";
			backdrop = options.parsingConfig;
			backdrop.name = "gfm";
			backdrop.gitHubSpice = false;
	
			CodeMirrorSpellChecker({
				codeMirrorInstance: CodeMirror
			});
		} else {
			mode = options.parsingConfig;
			mode.name = "gfm";
			mode.gitHubSpice = false;
		}
	
		this.codemirror = CodeMirror.fromTextArea(el, {
			mode: mode,
			backdrop: backdrop,
			theme: "paper",
			tabSize: (options.tabSize != undefined) ? options.tabSize : 2,
			indentUnit: (options.tabSize != undefined) ? options.tabSize : 2,
			indentWithTabs: (options.indentWithTabs === false) ? false : true,
			lineNumbers: false,
			autofocus: (options.autofocus === true) ? true : false,
			extraKeys: keyMaps,
			lineWrapping: (options.lineWrapping === false) ? false : true,
			allowDropFileTypes: ["text/plain"],
			placeholder: options.placeholder || el.getAttribute("placeholder") || "",
			styleSelectedText: (options.styleSelectedText != undefined) ? options.styleSelectedText : true
		});
	
		if(options.forceSync === true) {
			var cm = this.codemirror;
			cm.on("change", function() {
				cm.save();
			});
		}
	
		this.gui = {};
	
		if(options.toolbar !== false) {
			this.gui.toolbar = this.createToolbar();
		}
		if(options.status !== false) {
			this.gui.statusbar = this.createStatusbar();
		}
		if(options.autosave != undefined && options.autosave.enabled === true) {
			this.autosave();
		}
	
		this.gui.sideBySide = this.createSideBySide();
	
		this._rendered = this.element;
	
	
		// Fixes CodeMirror bug (#344)
		var temp_cm = this.codemirror;
		setTimeout(function() {
			temp_cm.refresh();
		}.bind(temp_cm), 0);
	};
	
	// Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem throw QuotaExceededError. We're going to detect this and set a variable accordingly.
	function isLocalStorageAvailable() {
		if(typeof localStorage === "object") {
			try {
				localStorage.setItem("smde_localStorage", 1);
				localStorage.removeItem("smde_localStorage");
			} catch(e) {
				return false;
			}
		} else {
			return false;
		}
	
		return true;
	}
	
	SimpleMDE.prototype.autosave = function() {
		if(isLocalStorageAvailable()) {
			var simplemde = this;
	
			if(this.options.autosave.uniqueId == undefined || this.options.autosave.uniqueId == "") {
				console.log("SimpleMDE: You must set a uniqueId to use the autosave feature");
				return;
			}
	
			if(simplemde.element.form != null && simplemde.element.form != undefined) {
				simplemde.element.form.addEventListener("submit", function() {
					localStorage.removeItem("smde_" + simplemde.options.autosave.uniqueId);
				});
			}
	
			if(this.options.autosave.loaded !== true) {
				if(typeof localStorage.getItem("smde_" + this.options.autosave.uniqueId) == "string" && localStorage.getItem("smde_" + this.options.autosave.uniqueId) != "") {
					this.codemirror.setValue(localStorage.getItem("smde_" + this.options.autosave.uniqueId));
					this.options.autosave.foundSavedValue = true;
				}
	
				this.options.autosave.loaded = true;
			}
	
			localStorage.setItem("smde_" + this.options.autosave.uniqueId, simplemde.value());
	
			var el = document.getElementById("autosaved");
			if(el != null && el != undefined && el != "") {
				var d = new Date();
				var hh = d.getHours();
				var m = d.getMinutes();
				var dd = "am";
				var h = hh;
				if(h >= 12) {
					h = hh - 12;
					dd = "pm";
				}
				if(h == 0) {
					h = 12;
				}
				m = m < 10 ? "0" + m : m;
	
				el.innerHTML = "Autosaved: " + h + ":" + m + " " + dd;
			}
	
			this.autosaveTimeoutId = setTimeout(function() {
				simplemde.autosave();
			}, this.options.autosave.delay || 10000);
		} else {
			console.log("SimpleMDE: localStorage not available, cannot autosave");
		}
	};
	
	SimpleMDE.prototype.clearAutosavedValue = function() {
		if(isLocalStorageAvailable()) {
			if(this.options.autosave == undefined || this.options.autosave.uniqueId == undefined || this.options.autosave.uniqueId == "") {
				console.log("SimpleMDE: You must set a uniqueId to clear the autosave value");
				return;
			}
	
			localStorage.removeItem("smde_" + this.options.autosave.uniqueId);
		} else {
			console.log("SimpleMDE: localStorage not available, cannot autosave");
		}
	};
	
	SimpleMDE.prototype.createSideBySide = function() {
		var cm = this.codemirror;
		var wrapper = cm.getWrapperElement();
		var preview = wrapper.nextSibling;
	
		if(!preview || !/editor-preview-side/.test(preview.className)) {
			preview = document.createElement("div");
			preview.className = "editor-preview-side";
			wrapper.parentNode.insertBefore(preview, wrapper.nextSibling);
		}
	
		// Syncs scroll  editor -> preview
		var cScroll = false;
		var pScroll = false;
		cm.on("scroll", function(v) {
			if(cScroll) {
				cScroll = false;
				return;
			}
			pScroll = true;
			var height = v.getScrollInfo().height - v.getScrollInfo().clientHeight;
			var ratio = parseFloat(v.getScrollInfo().top) / height;
			var move = (preview.scrollHeight - preview.clientHeight) * ratio;
			preview.scrollTop = move;
		});
	
		// Syncs scroll  preview -> editor
		preview.onscroll = function() {
			if(pScroll) {
				pScroll = false;
				return;
			}
			cScroll = true;
			var height = preview.scrollHeight - preview.clientHeight;
			var ratio = parseFloat(preview.scrollTop) / height;
			var move = (cm.getScrollInfo().height - cm.getScrollInfo().clientHeight) * ratio;
			cm.scrollTo(0, move);
		};
		return preview;
	};
	
	SimpleMDE.prototype.createToolbar = function(items) {
		items = items || this.options.toolbar;
	
		if(!items || items.length === 0) {
			return;
		}
		var i;
		for(i = 0; i < items.length; i++) {
			if(toolbarBuiltInButtons[items[i]] != undefined) {
				items[i] = toolbarBuiltInButtons[items[i]];
			}
		}
	
		var bar = document.createElement("div");
		bar.className = "editor-toolbar";
	
		var self = this;
	
		var toolbarData = {};
		self.toolbar = items;
	
		for(i = 0; i < items.length; i++) {
			if(items[i].name == "guide" && self.options.toolbarGuideIcon === false)
				continue;
	
			if(self.options.hideIcons && self.options.hideIcons.indexOf(items[i].name) != -1)
				continue;
	
			// Fullscreen does not work well on mobile devices (even tablets)
			// In the future, hopefully this can be resolved
			if((items[i].name == "fullscreen" || items[i].name == "side-by-side") && isMobile())
				continue;
	
	
			// Don't include trailing separators
			if(items[i] === "|") {
				var nonSeparatorIconsFollow = false;
	
				for(var x = (i + 1); x < items.length; x++) {
					if(items[x] !== "|" && (!self.options.hideIcons || self.options.hideIcons.indexOf(items[x].name) == -1)) {
						nonSeparatorIconsFollow = true;
					}
				}
	
				if(!nonSeparatorIconsFollow)
					continue;
			}
	
	
			// Create the icon and append to the toolbar
			(function(item) {
				var el;
				if(item === "|") {
					el = createSep();
				} else {
					el = createIcon(item, self.options.toolbarTips, self.options.shortcuts);
				}
	
				// bind events, special for info
				if(item.action) {
					if(typeof item.action === "function") {
						el.onclick = function(e) {
							e.preventDefault();
							item.action(self);
						};
					} else if(typeof item.action === "string") {
						el.href = item.action;
						el.target = "_blank";
					}
				}
	
				toolbarData[item.name || item] = el;
				bar.appendChild(el);
			})(items[i]);
		}
	
		self.toolbarElements = toolbarData;
	
		var cm = this.codemirror;
		cm.on("cursorActivity", function() {
			var stat = getState(cm);
	
			for(var key in toolbarData) {
				(function(key) {
					var el = toolbarData[key];
					if(stat[key]) {
						el.className += " active";
					} else if(key != "fullscreen" && key != "side-by-side") {
						el.className = el.className.replace(/\s*active\s*/g, "");
					}
				})(key);
			}
		});
	
		var cmWrapper = cm.getWrapperElement();
		cmWrapper.parentNode.insertBefore(bar, cmWrapper);
		return bar;
	};
	
	SimpleMDE.prototype.createStatusbar = function(status) {
		// Initialize
		status = status || this.options.status;
		var options = this.options;
		var cm = this.codemirror;
	
	
		// Make sure the status variable is valid
		if(!status || status.length === 0)
			return;
	
	
		// Set up the built-in items
		var items = [];
		var i, onUpdate, defaultValue;
	
		for(i = 0; i < status.length; i++) {
			// Reset some values
			onUpdate = undefined;
			defaultValue = undefined;
	
	
			// Handle if custom or not
			if(typeof status[i] === "object") {
				items.push({
					className: status[i].className,
					defaultValue: status[i].defaultValue,
					onUpdate: status[i].onUpdate
				});
			} else {
				var name = status[i];
	
				if(name === "words") {
					defaultValue = function(el) {
						el.innerHTML = wordCount(cm.getValue());
					};
					onUpdate = function(el) {
						el.innerHTML = wordCount(cm.getValue());
					};
				} else if(name === "lines") {
					defaultValue = function(el) {
						el.innerHTML = cm.lineCount();
					};
					onUpdate = function(el) {
						el.innerHTML = cm.lineCount();
					};
				} else if(name === "cursor") {
					defaultValue = function(el) {
						el.innerHTML = "0:0";
					};
					onUpdate = function(el) {
						var pos = cm.getCursor();
						el.innerHTML = pos.line + ":" + pos.ch;
					};
				} else if(name === "autosave") {
					defaultValue = function(el) {
						if(options.autosave != undefined && options.autosave.enabled === true) {
							el.setAttribute("id", "autosaved");
						}
					};
				}
	
				items.push({
					className: name,
					defaultValue: defaultValue,
					onUpdate: onUpdate
				});
			}
		}
	
	
		// Create element for the status bar
		var bar = document.createElement("div");
		bar.className = "editor-statusbar";
	
	
		// Create a new span for each item
		for(i = 0; i < items.length; i++) {
			// Store in temporary variable
			var item = items[i];
	
	
			// Create span element
			var el = document.createElement("span");
			el.className = item.className;
	
	
			// Ensure the defaultValue is a function
			if(typeof item.defaultValue === "function") {
				item.defaultValue(el);
			}
	
	
			// Ensure the onUpdate is a function
			if(typeof item.onUpdate === "function") {
				// Create a closure around the span of the current action, then execute the onUpdate handler
				this.codemirror.on("update", (function(el, item) {
					return function() {
						item.onUpdate(el);
					};
				}(el, item)));
			}
	
	
			// Append the item to the status bar
			bar.appendChild(el);
		}
	
	
		// Insert the status bar into the DOM
		var cmWrapper = this.codemirror.getWrapperElement();
		cmWrapper.parentNode.insertBefore(bar, cmWrapper.nextSibling);
		return bar;
	};
	
	/**
	 * Get or set the text content.
	 */
	SimpleMDE.prototype.value = function(val) {
		if(val === undefined) {
			return this.codemirror.getValue();
		} else {
			this.codemirror.getDoc().setValue(val);
			return this;
		}
	};
	
	
	/**
	 * Bind static methods for exports.
	 */
	SimpleMDE.toggleBold = toggleBold;
	SimpleMDE.toggleItalic = toggleItalic;
	SimpleMDE.toggleStrikethrough = toggleStrikethrough;
	SimpleMDE.toggleBlockquote = toggleBlockquote;
	SimpleMDE.toggleHeadingSmaller = toggleHeadingSmaller;
	SimpleMDE.toggleHeadingBigger = toggleHeadingBigger;
	SimpleMDE.toggleHeading1 = toggleHeading1;
	SimpleMDE.toggleHeading2 = toggleHeading2;
	SimpleMDE.toggleHeading3 = toggleHeading3;
	SimpleMDE.toggleCodeBlock = toggleCodeBlock;
	SimpleMDE.toggleUnorderedList = toggleUnorderedList;
	SimpleMDE.toggleOrderedList = toggleOrderedList;
	SimpleMDE.cleanBlock = cleanBlock;
	SimpleMDE.drawLink = drawLink;
	SimpleMDE.drawImage = drawImage;
	SimpleMDE.drawTable = drawTable;
	SimpleMDE.drawHorizontalRule = drawHorizontalRule;
	SimpleMDE.undo = undo;
	SimpleMDE.redo = redo;
	SimpleMDE.togglePreview = togglePreview;
	SimpleMDE.toggleSideBySide = toggleSideBySide;
	SimpleMDE.toggleFullScreen = toggleFullScreen;
	
	/**
	 * Bind instance methods for exports.
	 */
	SimpleMDE.prototype.toggleBold = function() {
		toggleBold(this);
	};
	SimpleMDE.prototype.toggleItalic = function() {
		toggleItalic(this);
	};
	SimpleMDE.prototype.toggleStrikethrough = function() {
		toggleStrikethrough(this);
	};
	SimpleMDE.prototype.toggleBlockquote = function() {
		toggleBlockquote(this);
	};
	SimpleMDE.prototype.toggleHeadingSmaller = function() {
		toggleHeadingSmaller(this);
	};
	SimpleMDE.prototype.toggleHeadingBigger = function() {
		toggleHeadingBigger(this);
	};
	SimpleMDE.prototype.toggleHeading1 = function() {
		toggleHeading1(this);
	};
	SimpleMDE.prototype.toggleHeading2 = function() {
		toggleHeading2(this);
	};
	SimpleMDE.prototype.toggleHeading3 = function() {
		toggleHeading3(this);
	};
	SimpleMDE.prototype.toggleCodeBlock = function() {
		toggleCodeBlock(this);
	};
	SimpleMDE.prototype.toggleUnorderedList = function() {
		toggleUnorderedList(this);
	};
	SimpleMDE.prototype.toggleOrderedList = function() {
		toggleOrderedList(this);
	};
	SimpleMDE.prototype.cleanBlock = function() {
		cleanBlock(this);
	};
	SimpleMDE.prototype.drawLink = function() {
		drawLink(this);
	};
	SimpleMDE.prototype.drawImage = function() {
		drawImage(this);
	};
	SimpleMDE.prototype.drawTable = function() {
		drawTable(this);
	};
	SimpleMDE.prototype.drawHorizontalRule = function() {
		drawHorizontalRule(this);
	};
	SimpleMDE.prototype.undo = function() {
		undo(this);
	};
	SimpleMDE.prototype.redo = function() {
		redo(this);
	};
	SimpleMDE.prototype.togglePreview = function() {
		togglePreview(this);
	};
	SimpleMDE.prototype.toggleSideBySide = function() {
		toggleSideBySide(this);
	};
	SimpleMDE.prototype.toggleFullScreen = function() {
		toggleFullScreen(this);
	};
	
	SimpleMDE.prototype.isPreviewActive = function() {
		var cm = this.codemirror;
		var wrapper = cm.getWrapperElement();
		var preview = wrapper.lastChild;
	
		return /editor-preview-active/.test(preview.className);
	};
	
	SimpleMDE.prototype.isSideBySideActive = function() {
		var cm = this.codemirror;
		var wrapper = cm.getWrapperElement();
		var preview = wrapper.nextSibling;
	
		return /editor-preview-active-side/.test(preview.className);
	};
	
	SimpleMDE.prototype.isFullscreenActive = function() {
		var cm = this.codemirror;
	
		return cm.getOption("fullScreen");
	};
	
	SimpleMDE.prototype.getState = function() {
		var cm = this.codemirror;
	
		return getState(cm);
	};
	
	SimpleMDE.prototype.toTextArea = function() {
		var cm = this.codemirror;
		var wrapper = cm.getWrapperElement();
	
		if(wrapper.parentNode) {
			if(this.gui.toolbar) {
				wrapper.parentNode.removeChild(this.gui.toolbar);
			}
			if(this.gui.statusbar) {
				wrapper.parentNode.removeChild(this.gui.statusbar);
			}
			if(this.gui.sideBySide) {
				wrapper.parentNode.removeChild(this.gui.sideBySide);
			}
		}
	
		cm.toTextArea();
	
		if(this.autosaveTimeoutId) {
			clearTimeout(this.autosaveTimeoutId);
			this.autosaveTimeoutId = undefined;
			this.clearAutosavedValue();
		}
	};
	
	module.exports = SimpleMDE;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: https://codemirror.net/LICENSE
	
	// This is CodeMirror (https://codemirror.net), a code editor
	// implemented in JavaScript on top of the browser's DOM.
	//
	// You can find some technical background for some of the code below
	// at http://marijnhaverbeke.nl/blog/#cm-internals .
	
	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  (global = global || self, global.CodeMirror = factory());
	}(this, (function () { 'use strict';
	
	  // Kludges for bugs and behavior differences that can't be feature
	  // detected are enabled based on userAgent etc sniffing.
	  var userAgent = navigator.userAgent;
	  var platform = navigator.platform;
	
	  var gecko = /gecko\/\d/i.test(userAgent);
	  var ie_upto10 = /MSIE \d/.test(userAgent);
	  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
	  var edge = /Edge\/(\d+)/.exec(userAgent);
	  var ie = ie_upto10 || ie_11up || edge;
	  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
	  var webkit = !edge && /WebKit\//.test(userAgent);
	  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
	  var chrome = !edge && /Chrome\//.test(userAgent);
	  var presto = /Opera\//.test(userAgent);
	  var safari = /Apple Computer/.test(navigator.vendor);
	  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
	  var phantom = /PhantomJS/.test(userAgent);
	
	  var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
	  var android = /Android/.test(userAgent);
	  // This is woefully incomplete. Suggestions for alternative methods welcome.
	  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
	  var mac = ios || /Mac/.test(platform);
	  var chromeOS = /\bCrOS\b/.test(userAgent);
	  var windows = /win/i.test(platform);
	
	  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
	  if (presto_version) { presto_version = Number(presto_version[1]); }
	  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
	  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
	  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
	  var captureRightClick = gecko || (ie && ie_version >= 9);
	
	  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }
	
	  var rmClass = function(node, cls) {
	    var current = node.className;
	    var match = classTest(cls).exec(current);
	    if (match) {
	      var after = current.slice(match.index + match[0].length);
	      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
	    }
	  };
	
	  function removeChildren(e) {
	    for (var count = e.childNodes.length; count > 0; --count)
	      { e.removeChild(e.firstChild); }
	    return e
	  }
	
	  function removeChildrenAndAdd(parent, e) {
	    return removeChildren(parent).appendChild(e)
	  }
	
	  function elt(tag, content, className, style) {
	    var e = document.createElement(tag);
	    if (className) { e.className = className; }
	    if (style) { e.style.cssText = style; }
	    if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }
	    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }
	    return e
	  }
	  // wrapper for elt, which removes the elt from the accessibility tree
	  function eltP(tag, content, className, style) {
	    var e = elt(tag, content, className, style);
	    e.setAttribute("role", "presentation");
	    return e
	  }
	
	  var range;
	  if (document.createRange) { range = function(node, start, end, endNode) {
	    var r = document.createRange();
	    r.setEnd(endNode || node, end);
	    r.setStart(node, start);
	    return r
	  }; }
	  else { range = function(node, start, end) {
	    var r = document.body.createTextRange();
	    try { r.moveToElementText(node.parentNode); }
	    catch(e) { return r }
	    r.collapse(true);
	    r.moveEnd("character", end);
	    r.moveStart("character", start);
	    return r
	  }; }
	
	  function contains(parent, child) {
	    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
	      { child = child.parentNode; }
	    if (parent.contains)
	      { return parent.contains(child) }
	    do {
	      if (child.nodeType == 11) { child = child.host; }
	      if (child == parent) { return true }
	    } while (child = child.parentNode)
	  }
	
	  function activeElt() {
	    // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
	    // IE < 10 will throw when accessed while the page is loading or in an iframe.
	    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
	    var activeElement;
	    try {
	      activeElement = document.activeElement;
	    } catch(e) {
	      activeElement = document.body || null;
	    }
	    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
	      { activeElement = activeElement.shadowRoot.activeElement; }
	    return activeElement
	  }
	
	  function addClass(node, cls) {
	    var current = node.className;
	    if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }
	  }
	  function joinClasses(a, b) {
	    var as = a.split(" ");
	    for (var i = 0; i < as.length; i++)
	      { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }
	    return b
	  }
	
	  var selectInput = function(node) { node.select(); };
	  if (ios) // Mobile Safari apparently has a bug where select() is broken.
	    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }
	  else if (ie) // Suppress mysterious IE10 errors
	    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }
	
	  function bind(f) {
	    var args = Array.prototype.slice.call(arguments, 1);
	    return function(){return f.apply(null, args)}
	  }
	
	  function copyObj(obj, target, overwrite) {
	    if (!target) { target = {}; }
	    for (var prop in obj)
	      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
	        { target[prop] = obj[prop]; } }
	    return target
	  }
	
	  // Counts the column offset in a string, taking tabs into account.
	  // Used mostly to find indentation.
	  function countColumn(string, end, tabSize, startIndex, startValue) {
	    if (end == null) {
	      end = string.search(/[^\s\u00a0]/);
	      if (end == -1) { end = string.length; }
	    }
	    for (var i = startIndex || 0, n = startValue || 0;;) {
	      var nextTab = string.indexOf("\t", i);
	      if (nextTab < 0 || nextTab >= end)
	        { return n + (end - i) }
	      n += nextTab - i;
	      n += tabSize - (n % tabSize);
	      i = nextTab + 1;
	    }
	  }
	
	  var Delayed = function() {
	    this.id = null;
	    this.f = null;
	    this.time = 0;
	    this.handler = bind(this.onTimeout, this);
	  };
	  Delayed.prototype.onTimeout = function (self) {
	    self.id = 0;
	    if (self.time <= +new Date) {
	      self.f();
	    } else {
	      setTimeout(self.handler, self.time - +new Date);
	    }
	  };
	  Delayed.prototype.set = function (ms, f) {
	    this.f = f;
	    var time = +new Date + ms;
	    if (!this.id || time < this.time) {
	      clearTimeout(this.id);
	      this.id = setTimeout(this.handler, ms);
	      this.time = time;
	    }
	  };
	
	  function indexOf(array, elt) {
	    for (var i = 0; i < array.length; ++i)
	      { if (array[i] == elt) { return i } }
	    return -1
	  }
	
	  // Number of pixels added to scroller and sizer to hide scrollbar
	  var scrollerGap = 30;
	
	  // Returned or thrown by various protocols to signal 'I'm not
	  // handling this'.
	  var Pass = {toString: function(){return "CodeMirror.Pass"}};
	
	  // Reused option objects for setSelection & friends
	  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};
	
	  // The inverse of countColumn -- find the offset that corresponds to
	  // a particular column.
	  function findColumn(string, goal, tabSize) {
	    for (var pos = 0, col = 0;;) {
	      var nextTab = string.indexOf("\t", pos);
	      if (nextTab == -1) { nextTab = string.length; }
	      var skipped = nextTab - pos;
	      if (nextTab == string.length || col + skipped >= goal)
	        { return pos + Math.min(skipped, goal - col) }
	      col += nextTab - pos;
	      col += tabSize - (col % tabSize);
	      pos = nextTab + 1;
	      if (col >= goal) { return pos }
	    }
	  }
	
	  var spaceStrs = [""];
	  function spaceStr(n) {
	    while (spaceStrs.length <= n)
	      { spaceStrs.push(lst(spaceStrs) + " "); }
	    return spaceStrs[n]
	  }
	
	  function lst(arr) { return arr[arr.length-1] }
	
	  function map(array, f) {
	    var out = [];
	    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }
	    return out
	  }
	
	  function insertSorted(array, value, score) {
	    var pos = 0, priority = score(value);
	    while (pos < array.length && score(array[pos]) <= priority) { pos++; }
	    array.splice(pos, 0, value);
	  }
	
	  function nothing() {}
	
	  function createObj(base, props) {
	    var inst;
	    if (Object.create) {
	      inst = Object.create(base);
	    } else {
	      nothing.prototype = base;
	      inst = new nothing();
	    }
	    if (props) { copyObj(props, inst); }
	    return inst
	  }
	
	  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
	  function isWordCharBasic(ch) {
	    return /\w/.test(ch) || ch > "\x80" &&
	      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
	  }
	  function isWordChar(ch, helper) {
	    if (!helper) { return isWordCharBasic(ch) }
	    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
	    return helper.test(ch)
	  }
	
	  function isEmpty(obj) {
	    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
	    return true
	  }
	
	  // Extending unicode characters. A series of a non-extending char +
	  // any number of extending chars is treated as a single unit as far
	  // as editing and measuring is concerned. This is not fully correct,
	  // since some scripts/fonts/browsers also treat other configurations
	  // of code points as a group.
	  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
	  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }
	
	  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
	  function skipExtendingChars(str, pos, dir) {
	    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }
	    return pos
	  }
	
	  // Returns the value from the range [`from`; `to`] that satisfies
	  // `pred` and is closest to `from`. Assumes that at least `to`
	  // satisfies `pred`. Supports `from` being greater than `to`.
	  function findFirst(pred, from, to) {
	    // At any point we are certain `to` satisfies `pred`, don't know
	    // whether `from` does.
	    var dir = from > to ? -1 : 1;
	    for (;;) {
	      if (from == to) { return from }
	      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
	      if (mid == from) { return pred(mid) ? from : to }
	      if (pred(mid)) { to = mid; }
	      else { from = mid + dir; }
	    }
	  }
	
	  // BIDI HELPERS
	
	  function iterateBidiSections(order, from, to, f) {
	    if (!order) { return f(from, to, "ltr", 0) }
	    var found = false;
	    for (var i = 0; i < order.length; ++i) {
	      var part = order[i];
	      if (part.from < to && part.to > from || from == to && part.to == from) {
	        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
	        found = true;
	      }
	    }
	    if (!found) { f(from, to, "ltr"); }
	  }
	
	  var bidiOther = null;
	  function getBidiPartAt(order, ch, sticky) {
	    var found;
	    bidiOther = null;
	    for (var i = 0; i < order.length; ++i) {
	      var cur = order[i];
	      if (cur.from < ch && cur.to > ch) { return i }
	      if (cur.to == ch) {
	        if (cur.from != cur.to && sticky == "before") { found = i; }
	        else { bidiOther = i; }
	      }
	      if (cur.from == ch) {
	        if (cur.from != cur.to && sticky != "before") { found = i; }
	        else { bidiOther = i; }
	      }
	    }
	    return found != null ? found : bidiOther
	  }
	
	  // Bidirectional ordering algorithm
	  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
	  // that this (partially) implements.
	
	  // One-char codes used for character types:
	  // L (L):   Left-to-Right
	  // R (R):   Right-to-Left
	  // r (AL):  Right-to-Left Arabic
	  // 1 (EN):  European Number
	  // + (ES):  European Number Separator
	  // % (ET):  European Number Terminator
	  // n (AN):  Arabic Number
	  // , (CS):  Common Number Separator
	  // m (NSM): Non-Spacing Mark
	  // b (BN):  Boundary Neutral
	  // s (B):   Paragraph Separator
	  // t (S):   Segment Separator
	  // w (WS):  Whitespace
	  // N (ON):  Other Neutrals
	
	  // Returns null if characters are ordered as they appear
	  // (left-to-right), or an array of sections ({from, to, level}
	  // objects) in the order in which they occur visually.
	  var bidiOrdering = (function() {
	    // Character types for codepoints 0 to 0xff
	    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
	    // Character types for codepoints 0x600 to 0x6f9
	    var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
	    function charType(code) {
	      if (code <= 0xf7) { return lowTypes.charAt(code) }
	      else if (0x590 <= code && code <= 0x5f4) { return "R" }
	      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
	      else if (0x6ee <= code && code <= 0x8ac) { return "r" }
	      else if (0x2000 <= code && code <= 0x200b) { return "w" }
	      else if (code == 0x200c) { return "b" }
	      else { return "L" }
	    }
	
	    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
	    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
	
	    function BidiSpan(level, from, to) {
	      this.level = level;
	      this.from = from; this.to = to;
	    }
	
	    return function(str, direction) {
	      var outerType = direction == "ltr" ? "L" : "R";
	
	      if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
	      var len = str.length, types = [];
	      for (var i = 0; i < len; ++i)
	        { types.push(charType(str.charCodeAt(i))); }
	
	      // W1. Examine each non-spacing mark (NSM) in the level run, and
	      // change the type of the NSM to the type of the previous
	      // character. If the NSM is at the start of the level run, it will
	      // get the type of sor.
	      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
	        var type = types[i$1];
	        if (type == "m") { types[i$1] = prev; }
	        else { prev = type; }
	      }
	
	      // W2. Search backwards from each instance of a European number
	      // until the first strong type (R, L, AL, or sor) is found. If an
	      // AL is found, change the type of the European number to Arabic
	      // number.
	      // W3. Change all ALs to R.
	      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
	        var type$1 = types[i$2];
	        if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }
	        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }
	      }
	
	      // W4. A single European separator between two European numbers
	      // changes to a European number. A single common separator between
	      // two numbers of the same type changes to that type.
	      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
	        var type$2 = types[i$3];
	        if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1"; }
	        else if (type$2 == "," && prev$1 == types[i$3+1] &&
	                 (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }
	        prev$1 = type$2;
	      }
	
	      // W5. A sequence of European terminators adjacent to European
	      // numbers changes to all European numbers.
	      // W6. Otherwise, separators and terminators change to Other
	      // Neutral.
	      for (var i$4 = 0; i$4 < len; ++i$4) {
	        var type$3 = types[i$4];
	        if (type$3 == ",") { types[i$4] = "N"; }
	        else if (type$3 == "%") {
	          var end = (void 0);
	          for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
	          var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
	          for (var j = i$4; j < end; ++j) { types[j] = replace; }
	          i$4 = end - 1;
	        }
	      }
	
	      // W7. Search backwards from each instance of a European number
	      // until the first strong type (R, L, or sor) is found. If an L is
	      // found, then change the type of the European number to L.
	      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
	        var type$4 = types[i$5];
	        if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }
	        else if (isStrong.test(type$4)) { cur$1 = type$4; }
	      }
	
	      // N1. A sequence of neutrals takes the direction of the
	      // surrounding strong text if the text on both sides has the same
	      // direction. European and Arabic numbers act as if they were R in
	      // terms of their influence on neutrals. Start-of-level-run (sor)
	      // and end-of-level-run (eor) are used at level run boundaries.
	      // N2. Any remaining neutrals take the embedding direction.
	      for (var i$6 = 0; i$6 < len; ++i$6) {
	        if (isNeutral.test(types[i$6])) {
	          var end$1 = (void 0);
	          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
	          var before = (i$6 ? types[i$6-1] : outerType) == "L";
	          var after = (end$1 < len ? types[end$1] : outerType) == "L";
	          var replace$1 = before == after ? (before ? "L" : "R") : outerType;
	          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }
	          i$6 = end$1 - 1;
	        }
	      }
	
	      // Here we depart from the documented algorithm, in order to avoid
	      // building up an actual levels array. Since there are only three
	      // levels (0, 1, 2) in an implementation that doesn't take
	      // explicit embedding into account, we can build up the order on
	      // the fly, without following the level-based algorithm.
	      var order = [], m;
	      for (var i$7 = 0; i$7 < len;) {
	        if (countsAsLeft.test(types[i$7])) {
	          var start = i$7;
	          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
	          order.push(new BidiSpan(0, start, i$7));
	        } else {
	          var pos = i$7, at = order.length, isRTL = direction == "rtl" ? 1 : 0;
	          for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
	          for (var j$2 = pos; j$2 < i$7;) {
	            if (countsAsNum.test(types[j$2])) {
	              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); at += isRTL; }
	              var nstart = j$2;
	              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
	              order.splice(at, 0, new BidiSpan(2, nstart, j$2));
	              at += isRTL;
	              pos = j$2;
	            } else { ++j$2; }
	          }
	          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }
	        }
	      }
	      if (direction == "ltr") {
	        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
	          order[0].from = m[0].length;
	          order.unshift(new BidiSpan(0, 0, m[0].length));
	        }
	        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
	          lst(order).to -= m[0].length;
	          order.push(new BidiSpan(0, len - m[0].length, len));
	        }
	      }
	
	      return direction == "rtl" ? order.reverse() : order
	    }
	  })();
	
	  // Get the bidi ordering for the given line (and cache it). Returns
	  // false for lines that are fully left-to-right, and an array of
	  // BidiSpan objects otherwise.
	  function getOrder(line, direction) {
	    var order = line.order;
	    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }
	    return order
	  }
	
	  // EVENT HANDLING
	
	  // Lightweight event framework. on/off also work on DOM nodes,
	  // registering native DOM handlers.
	
	  var noHandlers = [];
	
	  var on = function(emitter, type, f) {
	    if (emitter.addEventListener) {
	      emitter.addEventListener(type, f, false);
	    } else if (emitter.attachEvent) {
	      emitter.attachEvent("on" + type, f);
	    } else {
	      var map = emitter._handlers || (emitter._handlers = {});
	      map[type] = (map[type] || noHandlers).concat(f);
	    }
	  };
	
	  function getHandlers(emitter, type) {
	    return emitter._handlers && emitter._handlers[type] || noHandlers
	  }
	
	  function off(emitter, type, f) {
	    if (emitter.removeEventListener) {
	      emitter.removeEventListener(type, f, false);
	    } else if (emitter.detachEvent) {
	      emitter.detachEvent("on" + type, f);
	    } else {
	      var map = emitter._handlers, arr = map && map[type];
	      if (arr) {
	        var index = indexOf(arr, f);
	        if (index > -1)
	          { map[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }
	      }
	    }
	  }
	
	  function signal(emitter, type /*, values...*/) {
	    var handlers = getHandlers(emitter, type);
	    if (!handlers.length) { return }
	    var args = Array.prototype.slice.call(arguments, 2);
	    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }
	  }
	
	  // The DOM events that CodeMirror handles can be overridden by
	  // registering a (non-DOM) handler on the editor for the event name,
	  // and preventDefault-ing the event in that handler.
	  function signalDOMEvent(cm, e, override) {
	    if (typeof e == "string")
	      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }
	    signal(cm, override || e.type, cm, e);
	    return e_defaultPrevented(e) || e.codemirrorIgnore
	  }
	
	  function signalCursorActivity(cm) {
	    var arr = cm._handlers && cm._handlers.cursorActivity;
	    if (!arr) { return }
	    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
	    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
	      { set.push(arr[i]); } }
	  }
	
	  function hasHandler(emitter, type) {
	    return getHandlers(emitter, type).length > 0
	  }
	
	  // Add on and off methods to a constructor's prototype, to make
	  // registering events on such objects more convenient.
	  function eventMixin(ctor) {
	    ctor.prototype.on = function(type, f) {on(this, type, f);};
	    ctor.prototype.off = function(type, f) {off(this, type, f);};
	  }
	
	  // Due to the fact that we still support jurassic IE versions, some
	  // compatibility wrappers are needed.
	
	  function e_preventDefault(e) {
	    if (e.preventDefault) { e.preventDefault(); }
	    else { e.returnValue = false; }
	  }
	  function e_stopPropagation(e) {
	    if (e.stopPropagation) { e.stopPropagation(); }
	    else { e.cancelBubble = true; }
	  }
	  function e_defaultPrevented(e) {
	    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
	  }
	  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}
	
	  function e_target(e) {return e.target || e.srcElement}
	  function e_button(e) {
	    var b = e.which;
	    if (b == null) {
	      if (e.button & 1) { b = 1; }
	      else if (e.button & 2) { b = 3; }
	      else if (e.button & 4) { b = 2; }
	    }
	    if (mac && e.ctrlKey && b == 1) { b = 3; }
	    return b
	  }
	
	  // Detect drag-and-drop
	  var dragAndDrop = function() {
	    // There is *some* kind of drag-and-drop support in IE6-8, but I
	    // couldn't get it to work yet.
	    if (ie && ie_version < 9) { return false }
	    var div = elt('div');
	    return "draggable" in div || "dragDrop" in div
	  }();
	
	  var zwspSupported;
	  function zeroWidthElement(measure) {
	    if (zwspSupported == null) {
	      var test = elt("span", "\u200b");
	      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
	      if (measure.firstChild.offsetHeight != 0)
	        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }
	    }
	    var node = zwspSupported ? elt("span", "\u200b") :
	      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
	    node.setAttribute("cm-text", "");
	    return node
	  }
	
	  // Feature-detect IE's crummy client rect reporting for bidi text
	  var badBidiRects;
	  function hasBadBidiRects(measure) {
	    if (badBidiRects != null) { return badBidiRects }
	    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
	    var r0 = range(txt, 0, 1).getBoundingClientRect();
	    var r1 = range(txt, 1, 2).getBoundingClientRect();
	    removeChildren(measure);
	    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
	    return badBidiRects = (r1.right - r0.right < 3)
	  }
	
	  // See if "".split is the broken IE version, if so, provide an
	  // alternative way to split lines.
	  var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
	    var pos = 0, result = [], l = string.length;
	    while (pos <= l) {
	      var nl = string.indexOf("\n", pos);
	      if (nl == -1) { nl = string.length; }
	      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
	      var rt = line.indexOf("\r");
	      if (rt != -1) {
	        result.push(line.slice(0, rt));
	        pos += rt + 1;
	      } else {
	        result.push(line);
	        pos = nl + 1;
	      }
	    }
	    return result
	  } : function (string) { return string.split(/\r\n?|\n/); };
	
	  var hasSelection = window.getSelection ? function (te) {
	    try { return te.selectionStart != te.selectionEnd }
	    catch(e) { return false }
	  } : function (te) {
	    var range;
	    try {range = te.ownerDocument.selection.createRange();}
	    catch(e) {}
	    if (!range || range.parentElement() != te) { return false }
	    return range.compareEndPoints("StartToEnd", range) != 0
	  };
	
	  var hasCopyEvent = (function () {
	    var e = elt("div");
	    if ("oncopy" in e) { return true }
	    e.setAttribute("oncopy", "return;");
	    return typeof e.oncopy == "function"
	  })();
	
	  var badZoomedRects = null;
	  function hasBadZoomedRects(measure) {
	    if (badZoomedRects != null) { return badZoomedRects }
	    var node = removeChildrenAndAdd(measure, elt("span", "x"));
	    var normal = node.getBoundingClientRect();
	    var fromRange = range(node, 0, 1).getBoundingClientRect();
	    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
	  }
	
	  // Known modes, by name and by MIME
	  var modes = {}, mimeModes = {};
	
	  // Extra arguments are stored as the mode's dependencies, which is
	  // used by (legacy) mechanisms like loadmode.js to automatically
	  // load a mode. (Preferred mechanism is the require/define calls.)
	  function defineMode(name, mode) {
	    if (arguments.length > 2)
	      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
	    modes[name] = mode;
	  }
	
	  function defineMIME(mime, spec) {
	    mimeModes[mime] = spec;
	  }
	
	  // Given a MIME type, a {name, ...options} config object, or a name
	  // string, return a mode config object.
	  function resolveMode(spec) {
	    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
	      spec = mimeModes[spec];
	    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
	      var found = mimeModes[spec.name];
	      if (typeof found == "string") { found = {name: found}; }
	      spec = createObj(found, spec);
	      spec.name = found.name;
	    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
	      return resolveMode("application/xml")
	    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
	      return resolveMode("application/json")
	    }
	    if (typeof spec == "string") { return {name: spec} }
	    else { return spec || {name: "null"} }
	  }
	
	  // Given a mode spec (anything that resolveMode accepts), find and
	  // initialize an actual mode object.
	  function getMode(options, spec) {
	    spec = resolveMode(spec);
	    var mfactory = modes[spec.name];
	    if (!mfactory) { return getMode(options, "text/plain") }
	    var modeObj = mfactory(options, spec);
	    if (modeExtensions.hasOwnProperty(spec.name)) {
	      var exts = modeExtensions[spec.name];
	      for (var prop in exts) {
	        if (!exts.hasOwnProperty(prop)) { continue }
	        if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
	        modeObj[prop] = exts[prop];
	      }
	    }
	    modeObj.name = spec.name;
	    if (spec.helperType) { modeObj.helperType = spec.helperType; }
	    if (spec.modeProps) { for (var prop$1 in spec.modeProps)
	      { modeObj[prop$1] = spec.modeProps[prop$1]; } }
	
	    return modeObj
	  }
	
	  // This can be used to attach properties to mode objects from
	  // outside the actual mode definition.
	  var modeExtensions = {};
	  function extendMode(mode, properties) {
	    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
	    copyObj(properties, exts);
	  }
	
	  function copyState(mode, state) {
	    if (state === true) { return state }
	    if (mode.copyState) { return mode.copyState(state) }
	    var nstate = {};
	    for (var n in state) {
	      var val = state[n];
	      if (val instanceof Array) { val = val.concat([]); }
	      nstate[n] = val;
	    }
	    return nstate
	  }
	
	  // Given a mode and a state (for that mode), find the inner mode and
	  // state at the position that the state refers to.
	  function innerMode(mode, state) {
	    var info;
	    while (mode.innerMode) {
	      info = mode.innerMode(state);
	      if (!info || info.mode == mode) { break }
	      state = info.state;
	      mode = info.mode;
	    }
	    return info || {mode: mode, state: state}
	  }
	
	  function startState(mode, a1, a2) {
	    return mode.startState ? mode.startState(a1, a2) : true
	  }
	
	  // STRING STREAM
	
	  // Fed to the mode parsers, provides helper functions to make
	  // parsers more succinct.
	
	  var StringStream = function(string, tabSize, lineOracle) {
	    this.pos = this.start = 0;
	    this.string = string;
	    this.tabSize = tabSize || 8;
	    this.lastColumnPos = this.lastColumnValue = 0;
	    this.lineStart = 0;
	    this.lineOracle = lineOracle;
	  };
	
	  StringStream.prototype.eol = function () {return this.pos >= this.string.length};
	  StringStream.prototype.sol = function () {return this.pos == this.lineStart};
	  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
	  StringStream.prototype.next = function () {
	    if (this.pos < this.string.length)
	      { return this.string.charAt(this.pos++) }
	  };
	  StringStream.prototype.eat = function (match) {
	    var ch = this.string.charAt(this.pos);
	    var ok;
	    if (typeof match == "string") { ok = ch == match; }
	    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
	    if (ok) {++this.pos; return ch}
	  };
	  StringStream.prototype.eatWhile = function (match) {
	    var start = this.pos;
	    while (this.eat(match)){}
	    return this.pos > start
	  };
	  StringStream.prototype.eatSpace = function () {
	    var start = this.pos;
	    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this.pos; }
	    return this.pos > start
	  };
	  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
	  StringStream.prototype.skipTo = function (ch) {
	    var found = this.string.indexOf(ch, this.pos);
	    if (found > -1) {this.pos = found; return true}
	  };
	  StringStream.prototype.backUp = function (n) {this.pos -= n;};
	  StringStream.prototype.column = function () {
	    if (this.lastColumnPos < this.start) {
	      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
	      this.lastColumnPos = this.start;
	    }
	    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
	  };
	  StringStream.prototype.indentation = function () {
	    return countColumn(this.string, null, this.tabSize) -
	      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
	  };
	  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
	    if (typeof pattern == "string") {
	      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
	      var substr = this.string.substr(this.pos, pattern.length);
	      if (cased(substr) == cased(pattern)) {
	        if (consume !== false) { this.pos += pattern.length; }
	        return true
	      }
	    } else {
	      var match = this.string.slice(this.pos).match(pattern);
	      if (match && match.index > 0) { return null }
	      if (match && consume !== false) { this.pos += match[0].length; }
	      return match
	    }
	  };
	  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
	  StringStream.prototype.hideFirstChars = function (n, inner) {
	    this.lineStart += n;
	    try { return inner() }
	    finally { this.lineStart -= n; }
	  };
	  StringStream.prototype.lookAhead = function (n) {
	    var oracle = this.lineOracle;
	    return oracle && oracle.lookAhead(n)
	  };
	  StringStream.prototype.baseToken = function () {
	    var oracle = this.lineOracle;
	    return oracle && oracle.baseToken(this.pos)
	  };
	
	  // Find the line object corresponding to the given line number.
	  function getLine(doc, n) {
	    n -= doc.first;
	    if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
	    var chunk = doc;
	    while (!chunk.lines) {
	      for (var i = 0;; ++i) {
	        var child = chunk.children[i], sz = child.chunkSize();
	        if (n < sz) { chunk = child; break }
	        n -= sz;
	      }
	    }
	    return chunk.lines[n]
	  }
	
	  // Get the part of a document between two positions, as an array of
	  // strings.
	  function getBetween(doc, start, end) {
	    var out = [], n = start.line;
	    doc.iter(start.line, end.line + 1, function (line) {
	      var text = line.text;
	      if (n == end.line) { text = text.slice(0, end.ch); }
	      if (n == start.line) { text = text.slice(start.ch); }
	      out.push(text);
	      ++n;
	    });
	    return out
	  }
	  // Get the lines between from and to, as array of strings.
	  function getLines(doc, from, to) {
	    var out = [];
	    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value
	    return out
	  }
	
	  // Update the height of a line, propagating the height change
	  // upwards to parent nodes.
	  function updateLineHeight(line, height) {
	    var diff = height - line.height;
	    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }
	  }
	
	  // Given a line object, find its line number by walking up through
	  // its parent links.
	  function lineNo(line) {
	    if (line.parent == null) { return null }
	    var cur = line.parent, no = indexOf(cur.lines, line);
	    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
	      for (var i = 0;; ++i) {
	        if (chunk.children[i] == cur) { break }
	        no += chunk.children[i].chunkSize();
	      }
	    }
	    return no + cur.first
	  }
	
	  // Find the line at the given vertical position, using the height
	  // information in the document tree.
	  function lineAtHeight(chunk, h) {
	    var n = chunk.first;
	    outer: do {
	      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
	        var child = chunk.children[i$1], ch = child.height;
	        if (h < ch) { chunk = child; continue outer }
	        h -= ch;
	        n += child.chunkSize();
	      }
	      return n
	    } while (!chunk.lines)
	    var i = 0;
	    for (; i < chunk.lines.length; ++i) {
	      var line = chunk.lines[i], lh = line.height;
	      if (h < lh) { break }
	      h -= lh;
	    }
	    return n + i
	  }
	
	  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}
	
	  function lineNumberFor(options, i) {
	    return String(options.lineNumberFormatter(i + options.firstLineNumber))
	  }
	
	  // A Pos instance represents a position within the text.
	  function Pos(line, ch, sticky) {
	    if ( sticky === void 0 ) sticky = null;
	
	    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
	    this.line = line;
	    this.ch = ch;
	    this.sticky = sticky;
	  }
	
	  // Compare two positions, return 0 if they are the same, a negative
	  // number when a is less, and a positive number otherwise.
	  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }
	
	  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }
	
	  function copyPos(x) {return Pos(x.line, x.ch)}
	  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
	  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }
	
	  // Most of the external API clips given positions to make sure they
	  // actually exist within the document.
	  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
	  function clipPos(doc, pos) {
	    if (pos.line < doc.first) { return Pos(doc.first, 0) }
	    var last = doc.first + doc.size - 1;
	    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
	    return clipToLen(pos, getLine(doc, pos.line).text.length)
	  }
	  function clipToLen(pos, linelen) {
	    var ch = pos.ch;
	    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
	    else if (ch < 0) { return Pos(pos.line, 0) }
	    else { return pos }
	  }
	  function clipPosArray(doc, array) {
	    var out = [];
	    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }
	    return out
	  }
	
	  var SavedContext = function(state, lookAhead) {
	    this.state = state;
	    this.lookAhead = lookAhead;
	  };
	
	  var Context = function(doc, state, line, lookAhead) {
	    this.state = state;
	    this.doc = doc;
	    this.line = line;
	    this.maxLookAhead = lookAhead || 0;
	    this.baseTokens = null;
	    this.baseTokenPos = 1;
	  };
	
	  Context.prototype.lookAhead = function (n) {
	    var line = this.doc.getLine(this.line + n);
	    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }
	    return line
	  };
	
	  Context.prototype.baseToken = function (n) {
	    if (!this.baseTokens) { return null }
	    while (this.baseTokens[this.baseTokenPos] <= n)
	      { this.baseTokenPos += 2; }
	    var type = this.baseTokens[this.baseTokenPos + 1];
	    return {type: type && type.replace(/( |^)overlay .*/, ""),
	            size: this.baseTokens[this.baseTokenPos] - n}
	  };
	
	  Context.prototype.nextLine = function () {
	    this.line++;
	    if (this.maxLookAhead > 0) { this.maxLookAhead--; }
	  };
	
	  Context.fromSaved = function (doc, saved, line) {
	    if (saved instanceof SavedContext)
	      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }
	    else
	      { return new Context(doc, copyState(doc.mode, saved), line) }
	  };
	
	  Context.prototype.save = function (copy) {
	    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
	    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
	  };
	
	
	  // Compute a style array (an array starting with a mode generation
	  // -- for invalidation -- followed by pairs of end positions and
	  // style strings), which is used to highlight the tokens on the
	  // line.
	  function highlightLine(cm, line, context, forceToEnd) {
	    // A styles array always starts with a number identifying the
	    // mode/overlays that it is based on (for easy invalidation).
	    var st = [cm.state.modeGen], lineClasses = {};
	    // Compute the base array of styles
	    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },
	            lineClasses, forceToEnd);
	    var state = context.state;
	
	    // Run overlays, adjust style array.
	    var loop = function ( o ) {
	      context.baseTokens = st;
	      var overlay = cm.state.overlays[o], i = 1, at = 0;
	      context.state = true;
	      runMode(cm, line.text, overlay.mode, context, function (end, style) {
	        var start = i;
	        // Ensure there's a token end at the current position, and that i points at it
	        while (at < end) {
	          var i_end = st[i];
	          if (i_end > end)
	            { st.splice(i, 1, end, st[i+1], i_end); }
	          i += 2;
	          at = Math.min(end, i_end);
	        }
	        if (!style) { return }
	        if (overlay.opaque) {
	          st.splice(start, i - start, end, "overlay " + style);
	          i = start + 2;
	        } else {
	          for (; start < i; start += 2) {
	            var cur = st[start+1];
	            st[start+1] = (cur ? cur + " " : "") + "overlay " + style;
	          }
	        }
	      }, lineClasses);
	      context.state = state;
	      context.baseTokens = null;
	      context.baseTokenPos = 1;
	    };
	
	    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );
	
	    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
	  }
	
	  function getLineStyles(cm, line, updateFrontier) {
	    if (!line.styles || line.styles[0] != cm.state.modeGen) {
	      var context = getContextBefore(cm, lineNo(line));
	      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
	      var result = highlightLine(cm, line, context);
	      if (resetState) { context.state = resetState; }
	      line.stateAfter = context.save(!resetState);
	      line.styles = result.styles;
	      if (result.classes) { line.styleClasses = result.classes; }
	      else if (line.styleClasses) { line.styleClasses = null; }
	      if (updateFrontier === cm.doc.highlightFrontier)
	        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }
	    }
	    return line.styles
	  }
	
	  function getContextBefore(cm, n, precise) {
	    var doc = cm.doc, display = cm.display;
	    if (!doc.mode.startState) { return new Context(doc, true, n) }
	    var start = findStartLine(cm, n, precise);
	    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
	    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);
	
	    doc.iter(start, n, function (line) {
	      processLine(cm, line.text, context);
	      var pos = context.line;
	      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
	      context.nextLine();
	    });
	    if (precise) { doc.modeFrontier = context.line; }
	    return context
	  }
	
	  // Lightweight form of highlight -- proceed over this line and
	  // update state, but don't save a style array. Used for lines that
	  // aren't currently visible.
	  function processLine(cm, text, context, startAt) {
	    var mode = cm.doc.mode;
	    var stream = new StringStream(text, cm.options.tabSize, context);
	    stream.start = stream.pos = startAt || 0;
	    if (text == "") { callBlankLine(mode, context.state); }
	    while (!stream.eol()) {
	      readToken(mode, stream, context.state);
	      stream.start = stream.pos;
	    }
	  }
	
	  function callBlankLine(mode, state) {
	    if (mode.blankLine) { return mode.blankLine(state) }
	    if (!mode.innerMode) { return }
	    var inner = innerMode(mode, state);
	    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
	  }
	
	  function readToken(mode, stream, state, inner) {
	    for (var i = 0; i < 10; i++) {
	      if (inner) { inner[0] = innerMode(mode, state).mode; }
	      var style = mode.token(stream, state);
	      if (stream.pos > stream.start) { return style }
	    }
	    throw new Error("Mode " + mode.name + " failed to advance stream.")
	  }
	
	  var Token = function(stream, type, state) {
	    this.start = stream.start; this.end = stream.pos;
	    this.string = stream.current();
	    this.type = type || null;
	    this.state = state;
	  };
	
	  // Utility for getTokenAt and getLineTokens
	  function takeToken(cm, pos, precise, asArray) {
	    var doc = cm.doc, mode = doc.mode, style;
	    pos = clipPos(doc, pos);
	    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
	    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
	    if (asArray) { tokens = []; }
	    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
	      stream.start = stream.pos;
	      style = readToken(mode, stream, context.state);
	      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }
	    }
	    return asArray ? tokens : new Token(stream, style, context.state)
	  }
	
	  function extractLineClasses(type, output) {
	    if (type) { for (;;) {
	      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
	      if (!lineClass) { break }
	      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
	      var prop = lineClass[1] ? "bgClass" : "textClass";
	      if (output[prop] == null)
	        { output[prop] = lineClass[2]; }
	      else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
	        { output[prop] += " " + lineClass[2]; }
	    } }
	    return type
	  }
	
	  // Run the given mode's parser over a line, calling f for each token.
	  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
	    var flattenSpans = mode.flattenSpans;
	    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }
	    var curStart = 0, curStyle = null;
	    var stream = new StringStream(text, cm.options.tabSize, context), style;
	    var inner = cm.options.addModeClass && [null];
	    if (text == "") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }
	    while (!stream.eol()) {
	      if (stream.pos > cm.options.maxHighlightLength) {
	        flattenSpans = false;
	        if (forceToEnd) { processLine(cm, text, context, stream.pos); }
	        stream.pos = text.length;
	        style = null;
	      } else {
	        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
	      }
	      if (inner) {
	        var mName = inner[0].name;
	        if (mName) { style = "m-" + (style ? mName + " " + style : mName); }
	      }
	      if (!flattenSpans || curStyle != style) {
	        while (curStart < stream.start) {
	          curStart = Math.min(stream.start, curStart + 5000);
	          f(curStart, curStyle);
	        }
	        curStyle = style;
	      }
	      stream.start = stream.pos;
	    }
	    while (curStart < stream.pos) {
	      // Webkit seems to refuse to render text nodes longer than 57444
	      // characters, and returns inaccurate measurements in nodes
	      // starting around 5000 chars.
	      var pos = Math.min(stream.pos, curStart + 5000);
	      f(pos, curStyle);
	      curStart = pos;
	    }
	  }
	
	  // Finds the line to start with when starting a parse. Tries to
	  // find a line with a stateAfter, so that it can start with a
	  // valid state. If that fails, it returns the line with the
	  // smallest indentation, which tends to need the least context to
	  // parse correctly.
	  function findStartLine(cm, n, precise) {
	    var minindent, minline, doc = cm.doc;
	    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
	    for (var search = n; search > lim; --search) {
	      if (search <= doc.first) { return doc.first }
	      var line = getLine(doc, search - 1), after = line.stateAfter;
	      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
	        { return search }
	      var indented = countColumn(line.text, null, cm.options.tabSize);
	      if (minline == null || minindent > indented) {
	        minline = search - 1;
	        minindent = indented;
	      }
	    }
	    return minline
	  }
	
	  function retreatFrontier(doc, n) {
	    doc.modeFrontier = Math.min(doc.modeFrontier, n);
	    if (doc.highlightFrontier < n - 10) { return }
	    var start = doc.first;
	    for (var line = n - 1; line > start; line--) {
	      var saved = getLine(doc, line).stateAfter;
	      // change is on 3
	      // state on line 1 looked ahead 2 -- so saw 3
	      // test 1 + 2 < 3 should cover this
	      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
	        start = line + 1;
	        break
	      }
	    }
	    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
	  }
	
	  // Optimize some code when these features are not used.
	  var sawReadOnlySpans = false, sawCollapsedSpans = false;
	
	  function seeReadOnlySpans() {
	    sawReadOnlySpans = true;
	  }
	
	  function seeCollapsedSpans() {
	    sawCollapsedSpans = true;
	  }
	
	  // TEXTMARKER SPANS
	
	  function MarkedSpan(marker, from, to) {
	    this.marker = marker;
	    this.from = from; this.to = to;
	  }
	
	  // Search an array of spans for a span matching the given marker.
	  function getMarkedSpanFor(spans, marker) {
	    if (spans) { for (var i = 0; i < spans.length; ++i) {
	      var span = spans[i];
	      if (span.marker == marker) { return span }
	    } }
	  }
	  // Remove a span from an array, returning undefined if no spans are
	  // left (we don't store arrays for lines without spans).
	  function removeMarkedSpan(spans, span) {
	    var r;
	    for (var i = 0; i < spans.length; ++i)
	      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }
	    return r
	  }
	  // Add a span to a line.
	  function addMarkedSpan(line, span) {
	    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
	    span.marker.attachLine(line);
	  }
	
	  // Used for the algorithm that adjusts markers for a change in the
	  // document. These functions cut an array of spans at a given
	  // character position, returning an array of remaining chunks (or
	  // undefined if nothing remains).
	  function markedSpansBefore(old, startCh, isInsert) {
	    var nw;
	    if (old) { for (var i = 0; i < old.length; ++i) {
	      var span = old[i], marker = span.marker;
	      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
	      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
	        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)
	        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
	      }
	    } }
	    return nw
	  }
	  function markedSpansAfter(old, endCh, isInsert) {
	    var nw;
	    if (old) { for (var i = 0; i < old.length; ++i) {
	      var span = old[i], marker = span.marker;
	      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
	      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
	        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)
	        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
	                                              span.to == null ? null : span.to - endCh));
	      }
	    } }
	    return nw
	  }
	
	  // Given a change object, compute the new set of marker spans that
	  // cover the line in which the change took place. Removes spans
	  // entirely within the change, reconnects spans belonging to the
	  // same marker that appear on both sides of the change, and cuts off
	  // spans partially within the change. Returns an array of span
	  // arrays with one element for each line in (after) the change.
	  function stretchSpansOverChange(doc, change) {
	    if (change.full) { return null }
	    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
	    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
	    if (!oldFirst && !oldLast) { return null }
	
	    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
	    // Get the spans that 'stick out' on both sides
	    var first = markedSpansBefore(oldFirst, startCh, isInsert);
	    var last = markedSpansAfter(oldLast, endCh, isInsert);
	
	    // Next, merge those two ends
	    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
	    if (first) {
	      // Fix up .to properties of first
	      for (var i = 0; i < first.length; ++i) {
	        var span = first[i];
	        if (span.to == null) {
	          var found = getMarkedSpanFor(last, span.marker);
	          if (!found) { span.to = startCh; }
	          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }
	        }
	      }
	    }
	    if (last) {
	      // Fix up .from in last (or move them into first in case of sameLine)
	      for (var i$1 = 0; i$1 < last.length; ++i$1) {
	        var span$1 = last[i$1];
	        if (span$1.to != null) { span$1.to += offset; }
	        if (span$1.from == null) {
	          var found$1 = getMarkedSpanFor(first, span$1.marker);
	          if (!found$1) {
	            span$1.from = offset;
	            if (sameLine) { (first || (first = [])).push(span$1); }
	          }
	        } else {
	          span$1.from += offset;
	          if (sameLine) { (first || (first = [])).push(span$1); }
	        }
	      }
	    }
	    // Make sure we didn't create any zero-length spans
	    if (first) { first = clearEmptySpans(first); }
	    if (last && last != first) { last = clearEmptySpans(last); }
	
	    var newMarkers = [first];
	    if (!sameLine) {
	      // Fill gap with whole-line-spans
	      var gap = change.text.length - 2, gapMarkers;
	      if (gap > 0 && first)
	        { for (var i$2 = 0; i$2 < first.length; ++i$2)
	          { if (first[i$2].to == null)
	            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }
	      for (var i$3 = 0; i$3 < gap; ++i$3)
	        { newMarkers.push(gapMarkers); }
	      newMarkers.push(last);
	    }
	    return newMarkers
	  }
	
	  // Remove spans that are empty and don't have a clearWhenEmpty
	  // option of false.
	  function clearEmptySpans(spans) {
	    for (var i = 0; i < spans.length; ++i) {
	      var span = spans[i];
	      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
	        { spans.splice(i--, 1); }
	    }
	    if (!spans.length) { return null }
	    return spans
	  }
	
	  // Used to 'clip' out readOnly ranges when making a change.
	  function removeReadOnlyRanges(doc, from, to) {
	    var markers = null;
	    doc.iter(from.line, to.line + 1, function (line) {
	      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
	        var mark = line.markedSpans[i].marker;
	        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
	          { (markers || (markers = [])).push(mark); }
	      } }
	    });
	    if (!markers) { return null }
	    var parts = [{from: from, to: to}];
	    for (var i = 0; i < markers.length; ++i) {
	      var mk = markers[i], m = mk.find(0);
	      for (var j = 0; j < parts.length; ++j) {
	        var p = parts[j];
	        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
	        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
	        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
	          { newParts.push({from: p.from, to: m.from}); }
	        if (dto > 0 || !mk.inclusiveRight && !dto)
	          { newParts.push({from: m.to, to: p.to}); }
	        parts.splice.apply(parts, newParts);
	        j += newParts.length - 3;
	      }
	    }
	    return parts
	  }
	
	  // Connect or disconnect spans from a line.
	  function detachMarkedSpans(line) {
	    var spans = line.markedSpans;
	    if (!spans) { return }
	    for (var i = 0; i < spans.length; ++i)
	      { spans[i].marker.detachLine(line); }
	    line.markedSpans = null;
	  }
	  function attachMarkedSpans(line, spans) {
	    if (!spans) { return }
	    for (var i = 0; i < spans.length; ++i)
	      { spans[i].marker.attachLine(line); }
	    line.markedSpans = spans;
	  }
	
	  // Helpers used when computing which overlapping collapsed span
	  // counts as the larger one.
	  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
	  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }
	
	  // Returns a number indicating which of two overlapping collapsed
	  // spans is larger (and thus includes the other). Falls back to
	  // comparing ids when the spans cover exactly the same range.
	  function compareCollapsedMarkers(a, b) {
	    var lenDiff = a.lines.length - b.lines.length;
	    if (lenDiff != 0) { return lenDiff }
	    var aPos = a.find(), bPos = b.find();
	    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
	    if (fromCmp) { return -fromCmp }
	    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
	    if (toCmp) { return toCmp }
	    return b.id - a.id
	  }
	
	  // Find out whether a line ends or starts in a collapsed span. If
	  // so, return the marker for that span.
	  function collapsedSpanAtSide(line, start) {
	    var sps = sawCollapsedSpans && line.markedSpans, found;
	    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
	      sp = sps[i];
	      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
	          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
	        { found = sp.marker; }
	    } }
	    return found
	  }
	  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
	  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }
	
	  function collapsedSpanAround(line, ch) {
	    var sps = sawCollapsedSpans && line.markedSpans, found;
	    if (sps) { for (var i = 0; i < sps.length; ++i) {
	      var sp = sps[i];
	      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&
	          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }
	    } }
	    return found
	  }
	
	  // Test whether there exists a collapsed span that partially
	  // overlaps (covers the start or end, but not both) of a new span.
	  // Such overlap is not allowed.
	  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
	    var line = getLine(doc, lineNo);
	    var sps = sawCollapsedSpans && line.markedSpans;
	    if (sps) { for (var i = 0; i < sps.length; ++i) {
	      var sp = sps[i];
	      if (!sp.marker.collapsed) { continue }
	      var found = sp.marker.find(0);
	      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
	      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
	      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
	      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
	          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
	        { return true }
	    } }
	  }
	
	  // A visual line is a line as drawn on the screen. Folding, for
	  // example, can cause multiple logical lines to appear on the same
	  // visual line. This finds the start of the visual line that the
	  // given line is part of (usually that is the line itself).
	  function visualLine(line) {
	    var merged;
	    while (merged = collapsedSpanAtStart(line))
	      { line = merged.find(-1, true).line; }
	    return line
	  }
	
	  function visualLineEnd(line) {
	    var merged;
	    while (merged = collapsedSpanAtEnd(line))
	      { line = merged.find(1, true).line; }
	    return line
	  }
	
	  // Returns an array of logical lines that continue the visual line
	  // started by the argument, or undefined if there are no such lines.
	  function visualLineContinued(line) {
	    var merged, lines;
	    while (merged = collapsedSpanAtEnd(line)) {
	      line = merged.find(1, true).line
	      ;(lines || (lines = [])).push(line);
	    }
	    return lines
	  }
	
	  // Get the line number of the start of the visual line that the
	  // given line number is part of.
	  function visualLineNo(doc, lineN) {
	    var line = getLine(doc, lineN), vis = visualLine(line);
	    if (line == vis) { return lineN }
	    return lineNo(vis)
	  }
	
	  // Get the line number of the start of the next visual line after
	  // the given line.
	  function visualLineEndNo(doc, lineN) {
	    if (lineN > doc.lastLine()) { return lineN }
	    var line = getLine(doc, lineN), merged;
	    if (!lineIsHidden(doc, line)) { return lineN }
	    while (merged = collapsedSpanAtEnd(line))
	      { line = merged.find(1, true).line; }
	    return lineNo(line) + 1
	  }
	
	  // Compute whether a line is hidden. Lines count as hidden when they
	  // are part of a visual line that starts with another line, or when
	  // they are entirely covered by collapsed, non-widget span.
	  function lineIsHidden(doc, line) {
	    var sps = sawCollapsedSpans && line.markedSpans;
	    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
	      sp = sps[i];
	      if (!sp.marker.collapsed) { continue }
	      if (sp.from == null) { return true }
	      if (sp.marker.widgetNode) { continue }
	      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
	        { return true }
	    } }
	  }
	  function lineIsHiddenInner(doc, line, span) {
	    if (span.to == null) {
	      var end = span.marker.find(1, true);
	      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
	    }
	    if (span.marker.inclusiveRight && span.to == line.text.length)
	      { return true }
	    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
	      sp = line.markedSpans[i];
	      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
	          (sp.to == null || sp.to != span.from) &&
	          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
	          lineIsHiddenInner(doc, line, sp)) { return true }
	    }
	  }
	
	  // Find the height above the given line.
	  function heightAtLine(lineObj) {
	    lineObj = visualLine(lineObj);
	
	    var h = 0, chunk = lineObj.parent;
	    for (var i = 0; i < chunk.lines.length; ++i) {
	      var line = chunk.lines[i];
	      if (line == lineObj) { break }
	      else { h += line.height; }
	    }
	    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
	      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
	        var cur = p.children[i$1];
	        if (cur == chunk) { break }
	        else { h += cur.height; }
	      }
	    }
	    return h
	  }
	
	  // Compute the character length of a line, taking into account
	  // collapsed ranges (see markText) that might hide parts, and join
	  // other lines onto it.
	  function lineLength(line) {
	    if (line.height == 0) { return 0 }
	    var len = line.text.length, merged, cur = line;
	    while (merged = collapsedSpanAtStart(cur)) {
	      var found = merged.find(0, true);
	      cur = found.from.line;
	      len += found.from.ch - found.to.ch;
	    }
	    cur = line;
	    while (merged = collapsedSpanAtEnd(cur)) {
	      var found$1 = merged.find(0, true);
	      len -= cur.text.length - found$1.from.ch;
	      cur = found$1.to.line;
	      len += cur.text.length - found$1.to.ch;
	    }
	    return len
	  }
	
	  // Find the longest line in the document.
	  function findMaxLine(cm) {
	    var d = cm.display, doc = cm.doc;
	    d.maxLine = getLine(doc, doc.first);
	    d.maxLineLength = lineLength(d.maxLine);
	    d.maxLineChanged = true;
	    doc.iter(function (line) {
	      var len = lineLength(line);
	      if (len > d.maxLineLength) {
	        d.maxLineLength = len;
	        d.maxLine = line;
	      }
	    });
	  }
	
	  // LINE DATA STRUCTURE
	
	  // Line objects. These hold state related to a line, including
	  // highlighting info (the styles array).
	  var Line = function(text, markedSpans, estimateHeight) {
	    this.text = text;
	    attachMarkedSpans(this, markedSpans);
	    this.height = estimateHeight ? estimateHeight(this) : 1;
	  };
	
	  Line.prototype.lineNo = function () { return lineNo(this) };
	  eventMixin(Line);
	
	  // Change the content (text, markers) of a line. Automatically
	  // invalidates cached information and tries to re-estimate the
	  // line's height.
	  function updateLine(line, text, markedSpans, estimateHeight) {
	    line.text = text;
	    if (line.stateAfter) { line.stateAfter = null; }
	    if (line.styles) { line.styles = null; }
	    if (line.order != null) { line.order = null; }
	    detachMarkedSpans(line);
	    attachMarkedSpans(line, markedSpans);
	    var estHeight = estimateHeight ? estimateHeight(line) : 1;
	    if (estHeight != line.height) { updateLineHeight(line, estHeight); }
	  }
	
	  // Detach a line from the document tree and its markers.
	  function cleanUpLine(line) {
	    line.parent = null;
	    detachMarkedSpans(line);
	  }
	
	  // Convert a style as returned by a mode (either null, or a string
	  // containing one or more styles) to a CSS style. This is cached,
	  // and also looks for line-wide styles.
	  var styleToClassCache = {}, styleToClassCacheWithMode = {};
	  function interpretTokenStyle(style, options) {
	    if (!style || /^\s*$/.test(style)) { return null }
	    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
	    return cache[style] ||
	      (cache[style] = style.replace(/\S+/g, "cm-$&"))
	  }
	
	  // Render the DOM representation of the text of a line. Also builds
	  // up a 'line map', which points at the DOM nodes that represent
	  // specific stretches of text, and is used by the measuring code.
	  // The returned object contains the DOM node, this map, and
	  // information about line-wide styles that were set by the mode.
	  function buildLineContent(cm, lineView) {
	    // The padding-right forces the element to have a 'border', which
	    // is needed on Webkit to be able to get line-level bounding
	    // rectangles for it (in measureChar).
	    var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
	    var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,
	                   col: 0, pos: 0, cm: cm,
	                   trailingSpace: false,
	                   splitSpaces: cm.getOption("lineWrapping")};
	    lineView.measure = {};
	
	    // Iterate over the logical lines that make up this visual line.
	    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
	      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);
	      builder.pos = 0;
	      builder.addToken = buildToken;
	      // Optionally wire in some hacks into the token-rendering
	      // algorithm, to deal with browser quirks.
	      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))
	        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }
	      builder.map = [];
	      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
	      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
	      if (line.styleClasses) {
	        if (line.styleClasses.bgClass)
	          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }
	        if (line.styleClasses.textClass)
	          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }
	      }
	
	      // Ensure at least a single node is present, for measuring.
	      if (builder.map.length == 0)
	        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }
	
	      // Store the map and a cache object for the current logical line
	      if (i == 0) {
	        lineView.measure.map = builder.map;
	        lineView.measure.cache = {};
	      } else {
	  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
	        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});
	      }
	    }
	
	    // See issue #2901
	    if (webkit) {
	      var last = builder.content.lastChild;
	      if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
	        { builder.content.className = "cm-tab-wrap-hack"; }
	    }
	
	    signal(cm, "renderLine", cm, lineView.line, builder.pre);
	    if (builder.pre.className)
	      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }
	
	    return builder
	  }
	
	  function defaultSpecialCharPlaceholder(ch) {
	    var token = elt("span", "\u2022", "cm-invalidchar");
	    token.title = "\\u" + ch.charCodeAt(0).toString(16);
	    token.setAttribute("aria-label", token.title);
	    return token
	  }
	
	  // Build up the DOM representation for a single token, and add it to
	  // the line map. Takes care to render special characters separately.
	  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
	    if (!text) { return }
	    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
	    var special = builder.cm.state.specialChars, mustWrap = false;
	    var content;
	    if (!special.test(text)) {
	      builder.col += text.length;
	      content = document.createTextNode(displayText);
	      builder.map.push(builder.pos, builder.pos + text.length, content);
	      if (ie && ie_version < 9) { mustWrap = true; }
	      builder.pos += text.length;
	    } else {
	      content = document.createDocumentFragment();
	      var pos = 0;
	      while (true) {
	        special.lastIndex = pos;
	        var m = special.exec(text);
	        var skipped = m ? m.index - pos : text.length - pos;
	        if (skipped) {
	          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
	          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }
	          else { content.appendChild(txt); }
	          builder.map.push(builder.pos, builder.pos + skipped, txt);
	          builder.col += skipped;
	          builder.pos += skipped;
	        }
	        if (!m) { break }
	        pos += skipped + 1;
	        var txt$1 = (void 0);
	        if (m[0] == "\t") {
	          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
	          txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
	          txt$1.setAttribute("role", "presentation");
	          txt$1.setAttribute("cm-text", "\t");
	          builder.col += tabWidth;
	        } else if (m[0] == "\r" || m[0] == "\n") {
	          txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
	          txt$1.setAttribute("cm-text", m[0]);
	          builder.col += 1;
	        } else {
	          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
	          txt$1.setAttribute("cm-text", m[0]);
	          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }
	          else { content.appendChild(txt$1); }
	          builder.col += 1;
	        }
	        builder.map.push(builder.pos, builder.pos + 1, txt$1);
	        builder.pos++;
	      }
	    }
	    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
	    if (style || startStyle || endStyle || mustWrap || css) {
	      var fullStyle = style || "";
	      if (startStyle) { fullStyle += startStyle; }
	      if (endStyle) { fullStyle += endStyle; }
	      var token = elt("span", [content], fullStyle, css);
	      if (attributes) {
	        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class")
	          { token.setAttribute(attr, attributes[attr]); } }
	      }
	      return builder.content.appendChild(token)
	    }
	    builder.content.appendChild(content);
	  }
	
	  // Change some spaces to NBSP to prevent the browser from collapsing
	  // trailing spaces at the end of a line when rendering text (issue #1362).
	  function splitSpaces(text, trailingBefore) {
	    if (text.length > 1 && !/  /.test(text)) { return text }
	    var spaceBefore = trailingBefore, result = "";
	    for (var i = 0; i < text.length; i++) {
	      var ch = text.charAt(i);
	      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
	        { ch = "\u00a0"; }
	      result += ch;
	      spaceBefore = ch == " ";
	    }
	    return result
	  }
	
	  // Work around nonsense dimensions being reported for stretches of
	  // right-to-left text.
	  function buildTokenBadBidi(inner, order) {
	    return function (builder, text, style, startStyle, endStyle, css, attributes) {
	      style = style ? style + " cm-force-border" : "cm-force-border";
	      var start = builder.pos, end = start + text.length;
	      for (;;) {
	        // Find the part that overlaps with the start of this text
	        var part = (void 0);
	        for (var i = 0; i < order.length; i++) {
	          part = order[i];
	          if (part.to > start && part.from <= start) { break }
	        }
	        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }
	        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
	        startStyle = null;
	        text = text.slice(part.to - start);
	        start = part.to;
	      }
	    }
	  }
	
	  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
	    var widget = !ignoreWidget && marker.widgetNode;
	    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }
	    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
	      if (!widget)
	        { widget = builder.content.appendChild(document.createElement("span")); }
	      widget.setAttribute("cm-marker", marker.id);
	    }
	    if (widget) {
	      builder.cm.display.input.setUneditable(widget);
	      builder.content.appendChild(widget);
	    }
	    builder.pos += size;
	    builder.trailingSpace = false;
	  }
	
	  // Outputs a number of spans to make up a line, taking highlighting
	  // and marked text into account.
	  function insertLineContent(line, builder, styles) {
	    var spans = line.markedSpans, allText = line.text, at = 0;
	    if (!spans) {
	      for (var i$1 = 1; i$1 < styles.length; i$1+=2)
	        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }
	      return
	    }
	
	    var len = allText.length, pos = 0, i = 1, text = "", style, css;
	    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
	    for (;;) {
	      if (nextChange == pos) { // Update current marker set
	        spanStyle = spanEndStyle = spanStartStyle = css = "";
	        attributes = null;
	        collapsed = null; nextChange = Infinity;
	        var foundBookmarks = [], endStyles = (void 0);
	        for (var j = 0; j < spans.length; ++j) {
	          var sp = spans[j], m = sp.marker;
	          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
	            foundBookmarks.push(m);
	          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
	            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
	              nextChange = sp.to;
	              spanEndStyle = "";
	            }
	            if (m.className) { spanStyle += " " + m.className; }
	            if (m.css) { css = (css ? css + ";" : "") + m.css; }
	            if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }
	            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }
	            // support for the old title property
	            // https://github.com/codemirror/CodeMirror/pull/5673
	            if (m.title) { (attributes || (attributes = {})).title = m.title; }
	            if (m.attributes) {
	              for (var attr in m.attributes)
	                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }
	            }
	            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
	              { collapsed = sp; }
	          } else if (sp.from > pos && nextChange > sp.from) {
	            nextChange = sp.from;
	          }
	        }
	        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
	          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } } }
	
	        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
	          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }
	        if (collapsed && (collapsed.from || 0) == pos) {
	          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
	                             collapsed.marker, collapsed.from == null);
	          if (collapsed.to == null) { return }
	          if (collapsed.to == pos) { collapsed = false; }
	        }
	      }
	      if (pos >= len) { break }
	
	      var upto = Math.min(len, nextChange);
	      while (true) {
	        if (text) {
	          var end = pos + text.length;
	          if (!collapsed) {
	            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
	            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
	                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
	          }
	          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
	          pos = end;
	          spanStartStyle = "";
	        }
	        text = allText.slice(at, at = styles[i++]);
	        style = interpretTokenStyle(styles[i++], builder.cm.options);
	      }
	    }
	  }
	
	
	  // These objects are used to represent the visible (currently drawn)
	  // part of the document. A LineView may correspond to multiple
	  // logical lines, if those are connected by collapsed ranges.
	  function LineView(doc, line, lineN) {
	    // The starting line
	    this.line = line;
	    // Continuing lines, if any
	    this.rest = visualLineContinued(line);
	    // Number of logical lines in this visual line
	    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
	    this.node = this.text = null;
	    this.hidden = lineIsHidden(doc, line);
	  }
	
	  // Create a range of LineView objects for the given lines.
	  function buildViewArray(cm, from, to) {
	    var array = [], nextPos;
	    for (var pos = from; pos < to; pos = nextPos) {
	      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
	      nextPos = pos + view.size;
	      array.push(view);
	    }
	    return array
	  }
	
	  var operationGroup = null;
	
	  function pushOperation(op) {
	    if (operationGroup) {
	      operationGroup.ops.push(op);
	    } else {
	      op.ownsGroup = operationGroup = {
	        ops: [op],
	        delayedCallbacks: []
	      };
	    }
	  }
	
	  function fireCallbacksForOps(group) {
	    // Calls delayed callbacks and cursorActivity handlers until no
	    // new ones appear
	    var callbacks = group.delayedCallbacks, i = 0;
	    do {
	      for (; i < callbacks.length; i++)
	        { callbacks[i].call(null); }
	      for (var j = 0; j < group.ops.length; j++) {
	        var op = group.ops[j];
	        if (op.cursorActivityHandlers)
	          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
	            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }
	      }
	    } while (i < callbacks.length)
	  }
	
	  function finishOperation(op, endCb) {
	    var group = op.ownsGroup;
	    if (!group) { return }
	
	    try { fireCallbacksForOps(group); }
	    finally {
	      operationGroup = null;
	      endCb(group);
	    }
	  }
	
	  var orphanDelayedCallbacks = null;
	
	  // Often, we want to signal events at a point where we are in the
	  // middle of some work, but don't want the handler to start calling
	  // other methods on the editor, which might be in an inconsistent
	  // state or simply not expect any other events to happen.
	  // signalLater looks whether there are any handlers, and schedules
	  // them to be executed when the last operation ends, or, if no
	  // operation is active, when a timeout fires.
	  function signalLater(emitter, type /*, values...*/) {
	    var arr = getHandlers(emitter, type);
	    if (!arr.length) { return }
	    var args = Array.prototype.slice.call(arguments, 2), list;
	    if (operationGroup) {
	      list = operationGroup.delayedCallbacks;
	    } else if (orphanDelayedCallbacks) {
	      list = orphanDelayedCallbacks;
	    } else {
	      list = orphanDelayedCallbacks = [];
	      setTimeout(fireOrphanDelayed, 0);
	    }
	    var loop = function ( i ) {
	      list.push(function () { return arr[i].apply(null, args); });
	    };
	
	    for (var i = 0; i < arr.length; ++i)
	      loop( i );
	  }
	
	  function fireOrphanDelayed() {
	    var delayed = orphanDelayedCallbacks;
	    orphanDelayedCallbacks = null;
	    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }
	  }
	
	  // When an aspect of a line changes, a string is added to
	  // lineView.changes. This updates the relevant part of the line's
	  // DOM structure.
	  function updateLineForChanges(cm, lineView, lineN, dims) {
	    for (var j = 0; j < lineView.changes.length; j++) {
	      var type = lineView.changes[j];
	      if (type == "text") { updateLineText(cm, lineView); }
	      else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }
	      else if (type == "class") { updateLineClasses(cm, lineView); }
	      else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }
	    }
	    lineView.changes = null;
	  }
	
	  // Lines with gutter elements, widgets or a background class need to
	  // be wrapped, and have the extra elements added to the wrapper div
	  function ensureLineWrapped(lineView) {
	    if (lineView.node == lineView.text) {
	      lineView.node = elt("div", null, null, "position: relative");
	      if (lineView.text.parentNode)
	        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }
	      lineView.node.appendChild(lineView.text);
	      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }
	    }
	    return lineView.node
	  }
	
	  function updateLineBackground(cm, lineView) {
	    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
	    if (cls) { cls += " CodeMirror-linebackground"; }
	    if (lineView.background) {
	      if (cls) { lineView.background.className = cls; }
	      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
	    } else if (cls) {
	      var wrap = ensureLineWrapped(lineView);
	      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
	      cm.display.input.setUneditable(lineView.background);
	    }
	  }
	
	  // Wrapper around buildLineContent which will reuse the structure
	  // in display.externalMeasured when possible.
	  function getLineContent(cm, lineView) {
	    var ext = cm.display.externalMeasured;
	    if (ext && ext.line == lineView.line) {
	      cm.display.externalMeasured = null;
	      lineView.measure = ext.measure;
	      return ext.built
	    }
	    return buildLineContent(cm, lineView)
	  }
	
	  // Redraw the line's text. Interacts with the background and text
	  // classes because the mode may output tokens that influence these
	  // classes.
	  function updateLineText(cm, lineView) {
	    var cls = lineView.text.className;
	    var built = getLineContent(cm, lineView);
	    if (lineView.text == lineView.node) { lineView.node = built.pre; }
	    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
	    lineView.text = built.pre;
	    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
	      lineView.bgClass = built.bgClass;
	      lineView.textClass = built.textClass;
	      updateLineClasses(cm, lineView);
	    } else if (cls) {
	      lineView.text.className = cls;
	    }
	  }
	
	  function updateLineClasses(cm, lineView) {
	    updateLineBackground(cm, lineView);
	    if (lineView.line.wrapClass)
	      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }
	    else if (lineView.node != lineView.text)
	      { lineView.node.className = ""; }
	    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
	    lineView.text.className = textClass || "";
	  }
	
	  function updateLineGutter(cm, lineView, lineN, dims) {
	    if (lineView.gutter) {
	      lineView.node.removeChild(lineView.gutter);
	      lineView.gutter = null;
	    }
	    if (lineView.gutterBackground) {
	      lineView.node.removeChild(lineView.gutterBackground);
	      lineView.gutterBackground = null;
	    }
	    if (lineView.line.gutterClass) {
	      var wrap = ensureLineWrapped(lineView);
	      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
	                                      ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));
	      cm.display.input.setUneditable(lineView.gutterBackground);
	      wrap.insertBefore(lineView.gutterBackground, lineView.text);
	    }
	    var markers = lineView.line.gutterMarkers;
	    if (cm.options.lineNumbers || markers) {
	      var wrap$1 = ensureLineWrapped(lineView);
	      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));
	      cm.display.input.setUneditable(gutterWrap);
	      wrap$1.insertBefore(gutterWrap, lineView.text);
	      if (lineView.line.gutterClass)
	        { gutterWrap.className += " " + lineView.line.gutterClass; }
	      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
	        { lineView.lineNumber = gutterWrap.appendChild(
	          elt("div", lineNumberFor(cm.options, lineN),
	              "CodeMirror-linenumber CodeMirror-gutter-elt",
	              ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))); }
	      if (markers) { for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
	        var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
	        if (found)
	          { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
	                                     ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))); }
	      } }
	    }
	  }
	
	  function updateLineWidgets(cm, lineView, dims) {
	    if (lineView.alignable) { lineView.alignable = null; }
	    var isWidget = classTest("CodeMirror-linewidget");
	    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
	      next = node.nextSibling;
	      if (isWidget.test(node.className)) { lineView.node.removeChild(node); }
	    }
	    insertLineWidgets(cm, lineView, dims);
	  }
	
	  // Build a line's DOM representation from scratch
	  function buildLineElement(cm, lineView, lineN, dims) {
	    var built = getLineContent(cm, lineView);
	    lineView.text = lineView.node = built.pre;
	    if (built.bgClass) { lineView.bgClass = built.bgClass; }
	    if (built.textClass) { lineView.textClass = built.textClass; }
	
	    updateLineClasses(cm, lineView);
	    updateLineGutter(cm, lineView, lineN, dims);
	    insertLineWidgets(cm, lineView, dims);
	    return lineView.node
	  }
	
	  // A lineView may contain multiple logical lines (when merged by
	  // collapsed spans). The widgets for all of them need to be drawn.
	  function insertLineWidgets(cm, lineView, dims) {
	    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
	    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
	      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }
	  }
	
	  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
	    if (!line.widgets) { return }
	    var wrap = ensureLineWrapped(lineView);
	    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
	      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
	      if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }
	      positionLineWidget(widget, node, lineView, dims);
	      cm.display.input.setUneditable(node);
	      if (allowAbove && widget.above)
	        { wrap.insertBefore(node, lineView.gutter || lineView.text); }
	      else
	        { wrap.appendChild(node); }
	      signalLater(widget, "redraw");
	    }
	  }
	
	  function positionLineWidget(widget, node, lineView, dims) {
	    if (widget.noHScroll) {
	  (lineView.alignable || (lineView.alignable = [])).push(node);
	      var width = dims.wrapperWidth;
	      node.style.left = dims.fixedPos + "px";
	      if (!widget.coverGutter) {
	        width -= dims.gutterTotalWidth;
	        node.style.paddingLeft = dims.gutterTotalWidth + "px";
	      }
	      node.style.width = width + "px";
	    }
	    if (widget.coverGutter) {
	      node.style.zIndex = 5;
	      node.style.position = "relative";
	      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }
	    }
	  }
	
	  function widgetHeight(widget) {
	    if (widget.height != null) { return widget.height }
	    var cm = widget.doc.cm;
	    if (!cm) { return 0 }
	    if (!contains(document.body, widget.node)) {
	      var parentStyle = "position: relative;";
	      if (widget.coverGutter)
	        { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }
	      if (widget.noHScroll)
	        { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }
	      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
	    }
	    return widget.height = widget.node.parentNode.offsetHeight
	  }
	
	  // Return true when the given mouse event happened in a widget
	  function eventInWidget(display, e) {
	    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
	      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
	          (n.parentNode == display.sizer && n != display.mover))
	        { return true }
	    }
	  }
	
	  // POSITION MEASUREMENT
	
	  function paddingTop(display) {return display.lineSpace.offsetTop}
	  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
	  function paddingH(display) {
	    if (display.cachedPaddingH) { return display.cachedPaddingH }
	    var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
	    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
	    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
	    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }
	    return data
	  }
	
	  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
	  function displayWidth(cm) {
	    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
	  }
	  function displayHeight(cm) {
	    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
	  }
	
	  // Ensure the lineView.wrapping.heights array is populated. This is
	  // an array of bottom offsets for the lines that make up a drawn
	  // line. When lineWrapping is on, there might be more than one
	  // height.
	  function ensureLineHeights(cm, lineView, rect) {
	    var wrapping = cm.options.lineWrapping;
	    var curWidth = wrapping && displayWidth(cm);
	    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
	      var heights = lineView.measure.heights = [];
	      if (wrapping) {
	        lineView.measure.width = curWidth;
	        var rects = lineView.text.firstChild.getClientRects();
	        for (var i = 0; i < rects.length - 1; i++) {
	          var cur = rects[i], next = rects[i + 1];
	          if (Math.abs(cur.bottom - next.bottom) > 2)
	            { heights.push((cur.bottom + next.top) / 2 - rect.top); }
	        }
	      }
	      heights.push(rect.bottom - rect.top);
	    }
	  }
	
	  // Find a line map (mapping character offsets to text nodes) and a
	  // measurement cache for the given line number. (A line view might
	  // contain multiple lines when collapsed ranges are present.)
	  function mapFromLineView(lineView, line, lineN) {
	    if (lineView.line == line)
	      { return {map: lineView.measure.map, cache: lineView.measure.cache} }
	    for (var i = 0; i < lineView.rest.length; i++)
	      { if (lineView.rest[i] == line)
	        { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
	    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
	      { if (lineNo(lineView.rest[i$1]) > lineN)
	        { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
	  }
	
	  // Render a line into the hidden node display.externalMeasured. Used
	  // when measurement is needed for a line that's not in the viewport.
	  function updateExternalMeasurement(cm, line) {
	    line = visualLine(line);
	    var lineN = lineNo(line);
	    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
	    view.lineN = lineN;
	    var built = view.built = buildLineContent(cm, view);
	    view.text = built.pre;
	    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
	    return view
	  }
	
	  // Get a {top, bottom, left, right} box (in line-local coordinates)
	  // for a given character.
	  function measureChar(cm, line, ch, bias) {
	    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
	  }
	
	  // Find a line view that corresponds to the given line number.
	  function findViewForLine(cm, lineN) {
	    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
	      { return cm.display.view[findViewIndex(cm, lineN)] }
	    var ext = cm.display.externalMeasured;
	    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
	      { return ext }
	  }
	
	  // Measurement can be split in two steps, the set-up work that
	  // applies to the whole line, and the measurement of the actual
	  // character. Functions like coordsChar, that need to do a lot of
	  // measurements in a row, can thus ensure that the set-up work is
	  // only done once.
	  function prepareMeasureForLine(cm, line) {
	    var lineN = lineNo(line);
	    var view = findViewForLine(cm, lineN);
	    if (view && !view.text) {
	      view = null;
	    } else if (view && view.changes) {
	      updateLineForChanges(cm, view, lineN, getDimensions(cm));
	      cm.curOp.forceUpdate = true;
	    }
	    if (!view)
	      { view = updateExternalMeasurement(cm, line); }
	
	    var info = mapFromLineView(view, line, lineN);
	    return {
	      line: line, view: view, rect: null,
	      map: info.map, cache: info.cache, before: info.before,
	      hasHeights: false
	    }
	  }
	
	  // Given a prepared measurement object, measures the position of an
	  // actual character (or fetches it from the cache).
	  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
	    if (prepared.before) { ch = -1; }
	    var key = ch + (bias || ""), found;
	    if (prepared.cache.hasOwnProperty(key)) {
	      found = prepared.cache[key];
	    } else {
	      if (!prepared.rect)
	        { prepared.rect = prepared.view.text.getBoundingClientRect(); }
	      if (!prepared.hasHeights) {
	        ensureLineHeights(cm, prepared.view, prepared.rect);
	        prepared.hasHeights = true;
	      }
	      found = measureCharInner(cm, prepared, ch, bias);
	      if (!found.bogus) { prepared.cache[key] = found; }
	    }
	    return {left: found.left, right: found.right,
	            top: varHeight ? found.rtop : found.top,
	            bottom: varHeight ? found.rbottom : found.bottom}
	  }
	
	  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};
	
	  function nodeAndOffsetInLineMap(map, ch, bias) {
	    var node, start, end, collapse, mStart, mEnd;
	    // First, search the line map for the text node corresponding to,
	    // or closest to, the target character.
	    for (var i = 0; i < map.length; i += 3) {
	      mStart = map[i];
	      mEnd = map[i + 1];
	      if (ch < mStart) {
	        start = 0; end = 1;
	        collapse = "left";
	      } else if (ch < mEnd) {
	        start = ch - mStart;
	        end = start + 1;
	      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
	        end = mEnd - mStart;
	        start = end - 1;
	        if (ch >= mEnd) { collapse = "right"; }
	      }
	      if (start != null) {
	        node = map[i + 2];
	        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
	          { collapse = bias; }
	        if (bias == "left" && start == 0)
	          { while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
	            node = map[(i -= 3) + 2];
	            collapse = "left";
	          } }
	        if (bias == "right" && start == mEnd - mStart)
	          { while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
	            node = map[(i += 3) + 2];
	            collapse = "right";
	          } }
	        break
	      }
	    }
	    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
	  }
	
	  function getUsefulRect(rects, bias) {
	    var rect = nullRect;
	    if (bias == "left") { for (var i = 0; i < rects.length; i++) {
	      if ((rect = rects[i]).left != rect.right) { break }
	    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
	      if ((rect = rects[i$1]).left != rect.right) { break }
	    } }
	    return rect
	  }
	
	  function measureCharInner(cm, prepared, ch, bias) {
	    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
	    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;
	
	    var rect;
	    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
	      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
	        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }
	        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }
	        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
	          { rect = node.parentNode.getBoundingClientRect(); }
	        else
	          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }
	        if (rect.left || rect.right || start == 0) { break }
	        end = start;
	        start = start - 1;
	        collapse = "right";
	      }
	      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }
	    } else { // If it is a widget, simply get the box for the whole widget.
	      if (start > 0) { collapse = bias = "right"; }
	      var rects;
	      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
	        { rect = rects[bias == "right" ? rects.length - 1 : 0]; }
	      else
	        { rect = node.getBoundingClientRect(); }
	    }
	    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
	      var rSpan = node.parentNode.getClientRects()[0];
	      if (rSpan)
	        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }
	      else
	        { rect = nullRect; }
	    }
	
	    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
	    var mid = (rtop + rbot) / 2;
	    var heights = prepared.view.measure.heights;
	    var i = 0;
	    for (; i < heights.length - 1; i++)
	      { if (mid < heights[i]) { break } }
	    var top = i ? heights[i - 1] : 0, bot = heights[i];
	    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
	                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
	                  top: top, bottom: bot};
	    if (!rect.left && !rect.right) { result.bogus = true; }
	    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }
	
	    return result
	  }
	
	  // Work around problem with bounding client rects on ranges being
	  // returned incorrectly when zoomed on IE10 and below.
	  function maybeUpdateRectForZooming(measure, rect) {
	    if (!window.screen || screen.logicalXDPI == null ||
	        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
	      { return rect }
	    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
	    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
	    return {left: rect.left * scaleX, right: rect.right * scaleX,
	            top: rect.top * scaleY, bottom: rect.bottom * scaleY}
	  }
	
	  function clearLineMeasurementCacheFor(lineView) {
	    if (lineView.measure) {
	      lineView.measure.cache = {};
	      lineView.measure.heights = null;
	      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
	        { lineView.measure.caches[i] = {}; } }
	    }
	  }
	
	  function clearLineMeasurementCache(cm) {
	    cm.display.externalMeasure = null;
	    removeChildren(cm.display.lineMeasure);
	    for (var i = 0; i < cm.display.view.length; i++)
	      { clearLineMeasurementCacheFor(cm.display.view[i]); }
	  }
	
	  function clearCaches(cm) {
	    clearLineMeasurementCache(cm);
	    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
	    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }
	    cm.display.lineNumChars = null;
	  }
	
	  function pageScrollX() {
	    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
	    // which causes page_Offset and bounding client rects to use
	    // different reference viewports and invalidate our calculations.
	    if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }
	    return window.pageXOffset || (document.documentElement || document.body).scrollLeft
	  }
	  function pageScrollY() {
	    if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }
	    return window.pageYOffset || (document.documentElement || document.body).scrollTop
	  }
	
	  function widgetTopHeight(lineObj) {
	    var height = 0;
	    if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)
	      { height += widgetHeight(lineObj.widgets[i]); } } }
	    return height
	  }
	
	  // Converts a {top, bottom, left, right} box from line-local
	  // coordinates into another coordinate system. Context may be one of
	  // "line", "div" (display.lineDiv), "local"./null (editor), "window",
	  // or "page".
	  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
	    if (!includeWidgets) {
	      var height = widgetTopHeight(lineObj);
	      rect.top += height; rect.bottom += height;
	    }
	    if (context == "line") { return rect }
	    if (!context) { context = "local"; }
	    var yOff = heightAtLine(lineObj);
	    if (context == "local") { yOff += paddingTop(cm.display); }
	    else { yOff -= cm.display.viewOffset; }
	    if (context == "page" || context == "window") {
	      var lOff = cm.display.lineSpace.getBoundingClientRect();
	      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
	      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
	      rect.left += xOff; rect.right += xOff;
	    }
	    rect.top += yOff; rect.bottom += yOff;
	    return rect
	  }
	
	  // Coverts a box from "div" coords to another coordinate system.
	  // Context may be "window", "page", "div", or "local"./null.
	  function fromCoordSystem(cm, coords, context) {
	    if (context == "div") { return coords }
	    var left = coords.left, top = coords.top;
	    // First move into "page" coordinate system
	    if (context == "page") {
	      left -= pageScrollX();
	      top -= pageScrollY();
	    } else if (context == "local" || !context) {
	      var localBox = cm.display.sizer.getBoundingClientRect();
	      left += localBox.left;
	      top += localBox.top;
	    }
	
	    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
	    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
	  }
	
	  function charCoords(cm, pos, context, lineObj, bias) {
	    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }
	    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
	  }
	
	  // Returns a box for a given cursor position, which may have an
	  // 'other' property containing the position of the secondary cursor
	  // on a bidi boundary.
	  // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
	  // and after `char - 1` in writing order of `char - 1`
	  // A cursor Pos(line, char, "after") is on the same visual line as `char`
	  // and before `char` in writing order of `char`
	  // Examples (upper-case letters are RTL, lower-case are LTR):
	  //     Pos(0, 1, ...)
	  //     before   after
	  // ab     a|b     a|b
	  // aB     a|B     aB|
	  // Ab     |Ab     A|b
	  // AB     B|A     B|A
	  // Every position after the last character on a line is considered to stick
	  // to the last character on the line.
	  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
	    lineObj = lineObj || getLine(cm.doc, pos.line);
	    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
	    function get(ch, right) {
	      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
	      if (right) { m.left = m.right; } else { m.right = m.left; }
	      return intoCoordSystem(cm, lineObj, m, context)
	    }
	    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
	    if (ch >= lineObj.text.length) {
	      ch = lineObj.text.length;
	      sticky = "before";
	    } else if (ch <= 0) {
	      ch = 0;
	      sticky = "after";
	    }
	    if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }
	
	    function getBidi(ch, partPos, invert) {
	      var part = order[partPos], right = part.level == 1;
	      return get(invert ? ch - 1 : ch, right != invert)
	    }
	    var partPos = getBidiPartAt(order, ch, sticky);
	    var other = bidiOther;
	    var val = getBidi(ch, partPos, sticky == "before");
	    if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }
	    return val
	  }
	
	  // Used to cheaply estimate the coordinates for a position. Used for
	  // intermediate scroll updates.
	  function estimateCoords(cm, pos) {
	    var left = 0;
	    pos = clipPos(cm.doc, pos);
	    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }
	    var lineObj = getLine(cm.doc, pos.line);
	    var top = heightAtLine(lineObj) + paddingTop(cm.display);
	    return {left: left, right: left, top: top, bottom: top + lineObj.height}
	  }
	
	  // Positions returned by coordsChar contain some extra information.
	  // xRel is the relative x position of the input coordinates compared
	  // to the found position (so xRel > 0 means the coordinates are to
	  // the right of the character position, for example). When outside
	  // is true, that means the coordinates lie outside the line's
	  // vertical range.
	  function PosWithInfo(line, ch, sticky, outside, xRel) {
	    var pos = Pos(line, ch, sticky);
	    pos.xRel = xRel;
	    if (outside) { pos.outside = outside; }
	    return pos
	  }
	
	  // Compute the character position closest to the given coordinates.
	  // Input must be lineSpace-local ("div" coordinate system).
	  function coordsChar(cm, x, y) {
	    var doc = cm.doc;
	    y += cm.display.viewOffset;
	    if (y < 0) { return PosWithInfo(doc.first, 0, null, -1, -1) }
	    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
	    if (lineN > last)
	      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1) }
	    if (x < 0) { x = 0; }
	
	    var lineObj = getLine(doc, lineN);
	    for (;;) {
	      var found = coordsCharInner(cm, lineObj, lineN, x, y);
	      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
	      if (!collapsed) { return found }
	      var rangeEnd = collapsed.find(1);
	      if (rangeEnd.line == lineN) { return rangeEnd }
	      lineObj = getLine(doc, lineN = rangeEnd.line);
	    }
	  }
	
	  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
	    y -= widgetTopHeight(lineObj);
	    var end = lineObj.text.length;
	    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);
	    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);
	    return {begin: begin, end: end}
	  }
	
	  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
	    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
	    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
	    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
	  }
	
	  // Returns true if the given side of a box is after the given
	  // coordinates, in top-to-bottom, left-to-right order.
	  function boxIsAfter(box, x, y, left) {
	    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x
	  }
	
	  function coordsCharInner(cm, lineObj, lineNo, x, y) {
	    // Move y into line-local coordinate space
	    y -= heightAtLine(lineObj);
	    var preparedMeasure = prepareMeasureForLine(cm, lineObj);
	    // When directly calling `measureCharPrepared`, we have to adjust
	    // for the widgets at this line.
	    var widgetHeight = widgetTopHeight(lineObj);
	    var begin = 0, end = lineObj.text.length, ltr = true;
	
	    var order = getOrder(lineObj, cm.doc.direction);
	    // If the line isn't plain left-to-right text, first figure out
	    // which bidi section the coordinates fall into.
	    if (order) {
	      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)
	                   (cm, lineObj, lineNo, preparedMeasure, order, x, y);
	      ltr = part.level != 1;
	      // The awkward -1 offsets are needed because findFirst (called
	      // on these below) will treat its first bound as inclusive,
	      // second as exclusive, but we want to actually address the
	      // characters in the part's range
	      begin = ltr ? part.from : part.to - 1;
	      end = ltr ? part.to : part.from - 1;
	    }
	
	    // A binary search to find the first character whose bounding box
	    // starts after the coordinates. If we run across any whose box wrap
	    // the coordinates, store that.
	    var chAround = null, boxAround = null;
	    var ch = findFirst(function (ch) {
	      var box = measureCharPrepared(cm, preparedMeasure, ch);
	      box.top += widgetHeight; box.bottom += widgetHeight;
	      if (!boxIsAfter(box, x, y, false)) { return false }
	      if (box.top <= y && box.left <= x) {
	        chAround = ch;
	        boxAround = box;
	      }
	      return true
	    }, begin, end);
	
	    var baseX, sticky, outside = false;
	    // If a box around the coordinates was found, use that
	    if (boxAround) {
	      // Distinguish coordinates nearer to the left or right side of the box
	      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
	      ch = chAround + (atStart ? 0 : 1);
	      sticky = atStart ? "after" : "before";
	      baseX = atLeft ? boxAround.left : boxAround.right;
	    } else {
	      // (Adjust for extended bound, if necessary.)
	      if (!ltr && (ch == end || ch == begin)) { ch++; }
	      // To determine which side to associate with, get the box to the
	      // left of the character and compare it's vertical position to the
	      // coordinates
	      sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" :
	        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y) == ltr ?
	        "after" : "before";
	      // Now get accurate coordinates for this place, in order to get a
	      // base X position
	      var coords = cursorCoords(cm, Pos(lineNo, ch, sticky), "line", lineObj, preparedMeasure);
	      baseX = coords.left;
	      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
	    }
	
	    ch = skipExtendingChars(lineObj.text, ch, 1);
	    return PosWithInfo(lineNo, ch, sticky, outside, x - baseX)
	  }
	
	  function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {
	    // Bidi parts are sorted left-to-right, and in a non-line-wrapping
	    // situation, we can take this ordering to correspond to the visual
	    // ordering. This finds the first part whose end is after the given
	    // coordinates.
	    var index = findFirst(function (i) {
	      var part = order[i], ltr = part.level != 1;
	      return boxIsAfter(cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? "before" : "after"),
	                                     "line", lineObj, preparedMeasure), x, y, true)
	    }, 0, order.length - 1);
	    var part = order[index];
	    // If this isn't the first part, the part's start is also after
	    // the coordinates, and the coordinates aren't on the same line as
	    // that start, move one part back.
	    if (index > 0) {
	      var ltr = part.level != 1;
	      var start = cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? "after" : "before"),
	                               "line", lineObj, preparedMeasure);
	      if (boxIsAfter(start, x, y, true) && start.top > y)
	        { part = order[index - 1]; }
	    }
	    return part
	  }
	
	  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
	    // In a wrapped line, rtl text on wrapping boundaries can do things
	    // that don't correspond to the ordering in our `order` array at
	    // all, so a binary search doesn't work, and we want to return a
	    // part that only spans one line so that the binary search in
	    // coordsCharInner is safe. As such, we first find the extent of the
	    // wrapped line, and then do a flat search in which we discard any
	    // spans that aren't on the line.
	    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
	    var begin = ref.begin;
	    var end = ref.end;
	    if (/\s/.test(lineObj.text.charAt(end - 1))) { end--; }
	    var part = null, closestDist = null;
	    for (var i = 0; i < order.length; i++) {
	      var p = order[i];
	      if (p.from >= end || p.to <= begin) { continue }
	      var ltr = p.level != 1;
	      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
	      // Weigh against spans ending before this, so that they are only
	      // picked if nothing ends after
	      var dist = endX < x ? x - endX + 1e9 : endX - x;
	      if (!part || closestDist > dist) {
	        part = p;
	        closestDist = dist;
	      }
	    }
	    if (!part) { part = order[order.length - 1]; }
	    // Clip the part to the wrapped line.
	    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }
	    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }
	    return part
	  }
	
	  var measureText;
	  // Compute the default text height.
	  function textHeight(display) {
	    if (display.cachedTextHeight != null) { return display.cachedTextHeight }
	    if (measureText == null) {
	      measureText = elt("pre", null, "CodeMirror-line-like");
	      // Measure a bunch of lines, for browsers that compute
	      // fractional heights.
	      for (var i = 0; i < 49; ++i) {
	        measureText.appendChild(document.createTextNode("x"));
	        measureText.appendChild(elt("br"));
	      }
	      measureText.appendChild(document.createTextNode("x"));
	    }
	    removeChildrenAndAdd(display.measure, measureText);
	    var height = measureText.offsetHeight / 50;
	    if (height > 3) { display.cachedTextHeight = height; }
	    removeChildren(display.measure);
	    return height || 1
	  }
	
	  // Compute the default character width.
	  function charWidth(display) {
	    if (display.cachedCharWidth != null) { return display.cachedCharWidth }
	    var anchor = elt("span", "xxxxxxxxxx");
	    var pre = elt("pre", [anchor], "CodeMirror-line-like");
	    removeChildrenAndAdd(display.measure, pre);
	    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
	    if (width > 2) { display.cachedCharWidth = width; }
	    return width || 10
	  }
	
	  // Do a bulk-read of the DOM positions and sizes needed to draw the
	  // view, so that we don't interleave reading and writing to the DOM.
	  function getDimensions(cm) {
	    var d = cm.display, left = {}, width = {};
	    var gutterLeft = d.gutters.clientLeft;
	    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
	      var id = cm.display.gutterSpecs[i].className;
	      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
	      width[id] = n.clientWidth;
	    }
	    return {fixedPos: compensateForHScroll(d),
	            gutterTotalWidth: d.gutters.offsetWidth,
	            gutterLeft: left,
	            gutterWidth: width,
	            wrapperWidth: d.wrapper.clientWidth}
	  }
	
	  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
	  // but using getBoundingClientRect to get a sub-pixel-accurate
	  // result.
	  function compensateForHScroll(display) {
	    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
	  }
	
	  // Returns a function that estimates the height of a line, to use as
	  // first approximation until the line becomes visible (and is thus
	  // properly measurable).
	  function estimateHeight(cm) {
	    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
	    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
	    return function (line) {
	      if (lineIsHidden(cm.doc, line)) { return 0 }
	
	      var widgetsHeight = 0;
	      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
	        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }
	      } }
	
	      if (wrapping)
	        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
	      else
	        { return widgetsHeight + th }
	    }
	  }
	
	  function estimateLineHeights(cm) {
	    var doc = cm.doc, est = estimateHeight(cm);
	    doc.iter(function (line) {
	      var estHeight = est(line);
	      if (estHeight != line.height) { updateLineHeight(line, estHeight); }
	    });
	  }
	
	  // Given a mouse event, find the corresponding position. If liberal
	  // is false, it checks whether a gutter or scrollbar was clicked,
	  // and returns null if it was. forRect is used by rectangular
	  // selections, and tries to estimate a character position even for
	  // coordinates beyond the right of the text.
	  function posFromMouse(cm, e, liberal, forRect) {
	    var display = cm.display;
	    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }
	
	    var x, y, space = display.lineSpace.getBoundingClientRect();
	    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
	    try { x = e.clientX - space.left; y = e.clientY - space.top; }
	    catch (e) { return null }
	    var coords = coordsChar(cm, x, y), line;
	    if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
	      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
	      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
	    }
	    return coords
	  }
	
	  // Find the view element corresponding to a given line. Return null
	  // when the line isn't visible.
	  function findViewIndex(cm, n) {
	    if (n >= cm.display.viewTo) { return null }
	    n -= cm.display.viewFrom;
	    if (n < 0) { return null }
	    var view = cm.display.view;
	    for (var i = 0; i < view.length; i++) {
	      n -= view[i].size;
	      if (n < 0) { return i }
	    }
	  }
	
	  // Updates the display.view data structure for a given change to the
	  // document. From and to are in pre-change coordinates. Lendiff is
	  // the amount of lines added or subtracted by the change. This is
	  // used for changes that span multiple lines, or change the way
	  // lines are divided into visual lines. regLineChange (below)
	  // registers single-line changes.
	  function regChange(cm, from, to, lendiff) {
	    if (from == null) { from = cm.doc.first; }
	    if (to == null) { to = cm.doc.first + cm.doc.size; }
	    if (!lendiff) { lendiff = 0; }
	
	    var display = cm.display;
	    if (lendiff && to < display.viewTo &&
	        (display.updateLineNumbers == null || display.updateLineNumbers > from))
	      { display.updateLineNumbers = from; }
	
	    cm.curOp.viewChanged = true;
	
	    if (from >= display.viewTo) { // Change after
	      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
	        { resetView(cm); }
	    } else if (to <= display.viewFrom) { // Change before
	      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
	        resetView(cm);
	      } else {
	        display.viewFrom += lendiff;
	        display.viewTo += lendiff;
	      }
	    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
	      resetView(cm);
	    } else if (from <= display.viewFrom) { // Top overlap
	      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
	      if (cut) {
	        display.view = display.view.slice(cut.index);
	        display.viewFrom = cut.lineN;
	        display.viewTo += lendiff;
	      } else {
	        resetView(cm);
	      }
	    } else if (to >= display.viewTo) { // Bottom overlap
	      var cut$1 = viewCuttingPoint(cm, from, from, -1);
	      if (cut$1) {
	        display.view = display.view.slice(0, cut$1.index);
	        display.viewTo = cut$1.lineN;
	      } else {
	        resetView(cm);
	      }
	    } else { // Gap in the middle
	      var cutTop = viewCuttingPoint(cm, from, from, -1);
	      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
	      if (cutTop && cutBot) {
	        display.view = display.view.slice(0, cutTop.index)
	          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
	          .concat(display.view.slice(cutBot.index));
	        display.viewTo += lendiff;
	      } else {
	        resetView(cm);
	      }
	    }
	
	    var ext = display.externalMeasured;
	    if (ext) {
	      if (to < ext.lineN)
	        { ext.lineN += lendiff; }
	      else if (from < ext.lineN + ext.size)
	        { display.externalMeasured = null; }
	    }
	  }
	
	  // Register a change to a single line. Type must be one of "text",
	  // "gutter", "class", "widget"
	  function regLineChange(cm, line, type) {
	    cm.curOp.viewChanged = true;
	    var display = cm.display, ext = cm.display.externalMeasured;
	    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
	      { display.externalMeasured = null; }
	
	    if (line < display.viewFrom || line >= display.viewTo) { return }
	    var lineView = display.view[findViewIndex(cm, line)];
	    if (lineView.node == null) { return }
	    var arr = lineView.changes || (lineView.changes = []);
	    if (indexOf(arr, type) == -1) { arr.push(type); }
	  }
	
	  // Clear the view.
	  function resetView(cm) {
	    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
	    cm.display.view = [];
	    cm.display.viewOffset = 0;
	  }
	
	  function viewCuttingPoint(cm, oldN, newN, dir) {
	    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
	    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
	      { return {index: index, lineN: newN} }
	    var n = cm.display.viewFrom;
	    for (var i = 0; i < index; i++)
	      { n += view[i].size; }
	    if (n != oldN) {
	      if (dir > 0) {
	        if (index == view.length - 1) { return null }
	        diff = (n + view[index].size) - oldN;
	        index++;
	      } else {
	        diff = n - oldN;
	      }
	      oldN += diff; newN += diff;
	    }
	    while (visualLineNo(cm.doc, newN) != newN) {
	      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
	      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
	      index += dir;
	    }
	    return {index: index, lineN: newN}
	  }
	
	  // Force the view to cover a given range, adding empty view element
	  // or clipping off existing ones as needed.
	  function adjustView(cm, from, to) {
	    var display = cm.display, view = display.view;
	    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
	      display.view = buildViewArray(cm, from, to);
	      display.viewFrom = from;
	    } else {
	      if (display.viewFrom > from)
	        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }
	      else if (display.viewFrom < from)
	        { display.view = display.view.slice(findViewIndex(cm, from)); }
	      display.viewFrom = from;
	      if (display.viewTo < to)
	        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }
	      else if (display.viewTo > to)
	        { display.view = display.view.slice(0, findViewIndex(cm, to)); }
	    }
	    display.viewTo = to;
	  }
	
	  // Count the number of lines in the view whose DOM representation is
	  // out of date (or nonexistent).
	  function countDirtyView(cm) {
	    var view = cm.display.view, dirty = 0;
	    for (var i = 0; i < view.length; i++) {
	      var lineView = view[i];
	      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }
	    }
	    return dirty
	  }
	
	  function updateSelection(cm) {
	    cm.display.input.showSelection(cm.display.input.prepareSelection());
	  }
	
	  function prepareSelection(cm, primary) {
	    if ( primary === void 0 ) primary = true;
	
	    var doc = cm.doc, result = {};
	    var curFragment = result.cursors = document.createDocumentFragment();
	    var selFragment = result.selection = document.createDocumentFragment();
	
	    for (var i = 0; i < doc.sel.ranges.length; i++) {
	      if (!primary && i == doc.sel.primIndex) { continue }
	      var range = doc.sel.ranges[i];
	      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) { continue }
	      var collapsed = range.empty();
	      if (collapsed || cm.options.showCursorWhenSelecting)
	        { drawSelectionCursor(cm, range.head, curFragment); }
	      if (!collapsed)
	        { drawSelectionRange(cm, range, selFragment); }
	    }
	    return result
	  }
	
	  // Draws a cursor for the given range
	  function drawSelectionCursor(cm, head, output) {
	    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
	
	    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
	    cursor.style.left = pos.left + "px";
	    cursor.style.top = pos.top + "px";
	    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
	
	    if (pos.other) {
	      // Secondary cursor, shown when on a 'jump' in bi-directional text
	      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
	      otherCursor.style.display = "";
	      otherCursor.style.left = pos.other.left + "px";
	      otherCursor.style.top = pos.other.top + "px";
	      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
	    }
	  }
	
	  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }
	
	  // Draws the given range as a highlighted selection
	  function drawSelectionRange(cm, range, output) {
	    var display = cm.display, doc = cm.doc;
	    var fragment = document.createDocumentFragment();
	    var padding = paddingH(cm.display), leftSide = padding.left;
	    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
	    var docLTR = doc.direction == "ltr";
	
	    function add(left, top, width, bottom) {
	      if (top < 0) { top = 0; }
	      top = Math.round(top);
	      bottom = Math.round(bottom);
	      fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")));
	    }
	
	    function drawForLine(line, fromArg, toArg) {
	      var lineObj = getLine(doc, line);
	      var lineLen = lineObj.text.length;
	      var start, end;
	      function coords(ch, bias) {
	        return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
	      }
	
	      function wrapX(pos, dir, side) {
	        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
	        var prop = (dir == "ltr") == (side == "after") ? "left" : "right";
	        var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
	        return coords(ch, prop)[prop]
	      }
	
	      var order = getOrder(lineObj, doc.direction);
	      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
	        var ltr = dir == "ltr";
	        var fromPos = coords(from, ltr ? "left" : "right");
	        var toPos = coords(to - 1, ltr ? "right" : "left");
	
	        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
	        var first = i == 0, last = !order || i == order.length - 1;
	        if (toPos.top - fromPos.top <= 3) { // Single line
	          var openLeft = (docLTR ? openStart : openEnd) && first;
	          var openRight = (docLTR ? openEnd : openStart) && last;
	          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
	          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
	          add(left, fromPos.top, right - left, fromPos.bottom);
	        } else { // Multiple lines
	          var topLeft, topRight, botLeft, botRight;
	          if (ltr) {
	            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
	            topRight = docLTR ? rightSide : wrapX(from, dir, "before");
	            botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
	            botRight = docLTR && openEnd && last ? rightSide : toPos.right;
	          } else {
	            topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
	            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
	            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
	            botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
	          }
	          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
	          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }
	          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
	        }
	
	        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }
	        if (cmpCoords(toPos, start) < 0) { start = toPos; }
	        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }
	        if (cmpCoords(toPos, end) < 0) { end = toPos; }
	      });
	      return {start: start, end: end}
	    }
	
	    var sFrom = range.from(), sTo = range.to();
	    if (sFrom.line == sTo.line) {
	      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
	    } else {
	      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
	      var singleVLine = visualLine(fromLine) == visualLine(toLine);
	      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
	      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
	      if (singleVLine) {
	        if (leftEnd.top < rightStart.top - 2) {
	          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
	          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
	        } else {
	          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
	        }
	      }
	      if (leftEnd.bottom < rightStart.top)
	        { add(leftSide, leftEnd.bottom, null, rightStart.top); }
	    }
	
	    output.appendChild(fragment);
	  }
	
	  // Cursor-blinking
	  function restartBlink(cm) {
	    if (!cm.state.focused) { return }
	    var display = cm.display;
	    clearInterval(display.blinker);
	    var on = true;
	    display.cursorDiv.style.visibility = "";
	    if (cm.options.cursorBlinkRate > 0)
	      { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden"; },
	        cm.options.cursorBlinkRate); }
	    else if (cm.options.cursorBlinkRate < 0)
	      { display.cursorDiv.style.visibility = "hidden"; }
	  }
	
	  function ensureFocus(cm) {
	    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }
	  }
	
	  function delayBlurEvent(cm) {
	    cm.state.delayingBlurEvent = true;
	    setTimeout(function () { if (cm.state.delayingBlurEvent) {
	      cm.state.delayingBlurEvent = false;
	      onBlur(cm);
	    } }, 100);
	  }
	
	  function onFocus(cm, e) {
	    if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }
	
	    if (cm.options.readOnly == "nocursor") { return }
	    if (!cm.state.focused) {
	      signal(cm, "focus", cm, e);
	      cm.state.focused = true;
	      addClass(cm.display.wrapper, "CodeMirror-focused");
	      // This test prevents this from firing when a context
	      // menu is closed (since the input reset would kill the
	      // select-all detection hack)
	      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
	        cm.display.input.reset();
	        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730
	      }
	      cm.display.input.receivedFocus();
	    }
	    restartBlink(cm);
	  }
	  function onBlur(cm, e) {
	    if (cm.state.delayingBlurEvent) { return }
	
	    if (cm.state.focused) {
	      signal(cm, "blur", cm, e);
	      cm.state.focused = false;
	      rmClass(cm.display.wrapper, "CodeMirror-focused");
	    }
	    clearInterval(cm.display.blinker);
	    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);
	  }
	
	  // Read the actual heights of the rendered lines, and update their
	  // stored heights to match.
	  function updateHeightsInViewport(cm) {
	    var display = cm.display;
	    var prevBottom = display.lineDiv.offsetTop;
	    for (var i = 0; i < display.view.length; i++) {
	      var cur = display.view[i], wrapping = cm.options.lineWrapping;
	      var height = (void 0), width = 0;
	      if (cur.hidden) { continue }
	      if (ie && ie_version < 8) {
	        var bot = cur.node.offsetTop + cur.node.offsetHeight;
	        height = bot - prevBottom;
	        prevBottom = bot;
	      } else {
	        var box = cur.node.getBoundingClientRect();
	        height = box.bottom - box.top;
	        // Check that lines don't extend past the right of the current
	        // editor width
	        if (!wrapping && cur.text.firstChild)
	          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }
	      }
	      var diff = cur.line.height - height;
	      if (diff > .005 || diff < -.005) {
	        updateLineHeight(cur.line, height);
	        updateWidgetHeight(cur.line);
	        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
	          { updateWidgetHeight(cur.rest[j]); } }
	      }
	      if (width > cm.display.sizerWidth) {
	        var chWidth = Math.ceil(width / charWidth(cm.display));
	        if (chWidth > cm.display.maxLineLength) {
	          cm.display.maxLineLength = chWidth;
	          cm.display.maxLine = cur.line;
	          cm.display.maxLineChanged = true;
	        }
	      }
	    }
	  }
	
	  // Read and store the height of line widgets associated with the
	  // given line.
	  function updateWidgetHeight(line) {
	    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {
	      var w = line.widgets[i], parent = w.node.parentNode;
	      if (parent) { w.height = parent.offsetHeight; }
	    } }
	  }
	
	  // Compute the lines that are visible in a given viewport (defaults
	  // the the current scroll position). viewport may contain top,
	  // height, and ensure (see op.scrollToPos) properties.
	  function visibleLines(display, doc, viewport) {
	    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
	    top = Math.floor(top - paddingTop(display));
	    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
	
	    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
	    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
	    // forces those lines into the viewport (if possible).
	    if (viewport && viewport.ensure) {
	      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
	      if (ensureFrom < from) {
	        from = ensureFrom;
	        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
	      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
	        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
	        to = ensureTo;
	      }
	    }
	    return {from: from, to: Math.max(to, from + 1)}
	  }
	
	  // SCROLLING THINGS INTO VIEW
	
	  // If an editor sits on the top or bottom of the window, partially
	  // scrolled out of view, this ensures that the cursor is visible.
	  function maybeScrollWindow(cm, rect) {
	    if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }
	
	    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
	    if (rect.top + box.top < 0) { doScroll = true; }
	    else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }
	    if (doScroll != null && !phantom) {
	      var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));
	      cm.display.lineSpace.appendChild(scrollNode);
	      scrollNode.scrollIntoView(doScroll);
	      cm.display.lineSpace.removeChild(scrollNode);
	    }
	  }
	
	  // Scroll a given position into view (immediately), verifying that
	  // it actually became visible (as line heights are accurately
	  // measured, the position of something may 'drift' during drawing).
	  function scrollPosIntoView(cm, pos, end, margin) {
	    if (margin == null) { margin = 0; }
	    var rect;
	    if (!cm.options.lineWrapping && pos == end) {
	      // Set pos and end to the cursor positions around the character pos sticks to
	      // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
	      // If pos == Pos(_, 0, "before"), pos and end are unchanged
	      pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
	      end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
	    }
	    for (var limit = 0; limit < 5; limit++) {
	      var changed = false;
	      var coords = cursorCoords(cm, pos);
	      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
	      rect = {left: Math.min(coords.left, endCoords.left),
	              top: Math.min(coords.top, endCoords.top) - margin,
	              right: Math.max(coords.left, endCoords.left),
	              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};
	      var scrollPos = calculateScrollPos(cm, rect);
	      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
	      if (scrollPos.scrollTop != null) {
	        updateScrollTop(cm, scrollPos.scrollTop);
	        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }
	      }
	      if (scrollPos.scrollLeft != null) {
	        setScrollLeft(cm, scrollPos.scrollLeft);
	        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }
	      }
	      if (!changed) { break }
	    }
	    return rect
	  }
	
	  // Scroll a given set of coordinates into view (immediately).
	  function scrollIntoView(cm, rect) {
	    var scrollPos = calculateScrollPos(cm, rect);
	    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }
	    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }
	  }
	
	  // Calculate a new scroll position needed to scroll the given
	  // rectangle into view. Returns an object with scrollTop and
	  // scrollLeft properties. When these are undefined, the
	  // vertical/horizontal position does not need to be adjusted.
	  function calculateScrollPos(cm, rect) {
	    var display = cm.display, snapMargin = textHeight(cm.display);
	    if (rect.top < 0) { rect.top = 0; }
	    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
	    var screen = displayHeight(cm), result = {};
	    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }
	    var docBottom = cm.doc.height + paddingVert(display);
	    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
	    if (rect.top < screentop) {
	      result.scrollTop = atTop ? 0 : rect.top;
	    } else if (rect.bottom > screentop + screen) {
	      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
	      if (newTop != screentop) { result.scrollTop = newTop; }
	    }
	
	    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
	    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
	    var tooWide = rect.right - rect.left > screenw;
	    if (tooWide) { rect.right = rect.left + screenw; }
	    if (rect.left < 10)
	      { result.scrollLeft = 0; }
	    else if (rect.left < screenleft)
	      { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }
	    else if (rect.right > screenw + screenleft - 3)
	      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }
	    return result
	  }
	
	  // Store a relative adjustment to the scroll position in the current
	  // operation (to be applied when the operation finishes).
	  function addToScrollTop(cm, top) {
	    if (top == null) { return }
	    resolveScrollToPos(cm);
	    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
	  }
	
	  // Make sure that at the end of the operation the current cursor is
	  // shown.
	  function ensureCursorVisible(cm) {
	    resolveScrollToPos(cm);
	    var cur = cm.getCursor();
	    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};
	  }
	
	  function scrollToCoords(cm, x, y) {
	    if (x != null || y != null) { resolveScrollToPos(cm); }
	    if (x != null) { cm.curOp.scrollLeft = x; }
	    if (y != null) { cm.curOp.scrollTop = y; }
	  }
	
	  function scrollToRange(cm, range) {
	    resolveScrollToPos(cm);
	    cm.curOp.scrollToPos = range;
	  }
	
	  // When an operation has its scrollToPos property set, and another
	  // scroll action is applied before the end of the operation, this
	  // 'simulates' scrolling that position into view in a cheap way, so
	  // that the effect of intermediate scroll commands is not ignored.
	  function resolveScrollToPos(cm) {
	    var range = cm.curOp.scrollToPos;
	    if (range) {
	      cm.curOp.scrollToPos = null;
	      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
	      scrollToCoordsRange(cm, from, to, range.margin);
	    }
	  }
	
	  function scrollToCoordsRange(cm, from, to, margin) {
	    var sPos = calculateScrollPos(cm, {
	      left: Math.min(from.left, to.left),
	      top: Math.min(from.top, to.top) - margin,
	      right: Math.max(from.right, to.right),
	      bottom: Math.max(from.bottom, to.bottom) + margin
	    });
	    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
	  }
	
	  // Sync the scrollable area and scrollbars, ensure the viewport
	  // covers the visible area.
	  function updateScrollTop(cm, val) {
	    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
	    if (!gecko) { updateDisplaySimple(cm, {top: val}); }
	    setScrollTop(cm, val, true);
	    if (gecko) { updateDisplaySimple(cm); }
	    startWorker(cm, 100);
	  }
	
	  function setScrollTop(cm, val, forceScroll) {
	    val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
	    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }
	    cm.doc.scrollTop = val;
	    cm.display.scrollbars.setScrollTop(val);
	    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }
	  }
	
	  // Sync scroller and scrollbar, ensure the gutter elements are
	  // aligned.
	  function setScrollLeft(cm, val, isScroller, forceScroll) {
	    val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
	    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }
	    cm.doc.scrollLeft = val;
	    alignHorizontally(cm);
	    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }
	    cm.display.scrollbars.setScrollLeft(val);
	  }
	
	  // SCROLLBARS
	
	  // Prepare DOM reads needed to update the scrollbars. Done in one
	  // shot to minimize update/measure roundtrips.
	  function measureForScrollbars(cm) {
	    var d = cm.display, gutterW = d.gutters.offsetWidth;
	    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
	    return {
	      clientHeight: d.scroller.clientHeight,
	      viewHeight: d.wrapper.clientHeight,
	      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
	      viewWidth: d.wrapper.clientWidth,
	      barLeft: cm.options.fixedGutter ? gutterW : 0,
	      docHeight: docH,
	      scrollHeight: docH + scrollGap(cm) + d.barHeight,
	      nativeBarWidth: d.nativeBarWidth,
	      gutterWidth: gutterW
	    }
	  }
	
	  var NativeScrollbars = function(place, scroll, cm) {
	    this.cm = cm;
	    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
	    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
	    vert.tabIndex = horiz.tabIndex = -1;
	    place(vert); place(horiz);
	
	    on(vert, "scroll", function () {
	      if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }
	    });
	    on(horiz, "scroll", function () {
	      if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }
	    });
	
	    this.checkedZeroWidth = false;
	    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
	    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }
	  };
	
	  NativeScrollbars.prototype.update = function (measure) {
	    var needsH = measure.scrollWidth > measure.clientWidth + 1;
	    var needsV = measure.scrollHeight > measure.clientHeight + 1;
	    var sWidth = measure.nativeBarWidth;
	
	    if (needsV) {
	      this.vert.style.display = "block";
	      this.vert.style.bottom = needsH ? sWidth + "px" : "0";
	      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
	      // A bug in IE8 can cause this value to be negative, so guard it.
	      this.vert.firstChild.style.height =
	        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
	    } else {
	      this.vert.style.display = "";
	      this.vert.firstChild.style.height = "0";
	    }
	
	    if (needsH) {
	      this.horiz.style.display = "block";
	      this.horiz.style.right = needsV ? sWidth + "px" : "0";
	      this.horiz.style.left = measure.barLeft + "px";
	      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
	      this.horiz.firstChild.style.width =
	        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
	    } else {
	      this.horiz.style.display = "";
	      this.horiz.firstChild.style.width = "0";
	    }
	
	    if (!this.checkedZeroWidth && measure.clientHeight > 0) {
	      if (sWidth == 0) { this.zeroWidthHack(); }
	      this.checkedZeroWidth = true;
	    }
	
	    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
	  };
	
	  NativeScrollbars.prototype.setScrollLeft = function (pos) {
	    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }
	    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz"); }
	  };
	
	  NativeScrollbars.prototype.setScrollTop = function (pos) {
	    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }
	    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, "vert"); }
	  };
	
	  NativeScrollbars.prototype.zeroWidthHack = function () {
	    var w = mac && !mac_geMountainLion ? "12px" : "18px";
	    this.horiz.style.height = this.vert.style.width = w;
	    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
	    this.disableHoriz = new Delayed;
	    this.disableVert = new Delayed;
	  };
	
	  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
	    bar.style.pointerEvents = "auto";
	    function maybeDisable() {
	      // To find out whether the scrollbar is still visible, we
	      // check whether the element under the pixel in the bottom
	      // right corner of the scrollbar box is the scrollbar box
	      // itself (when the bar is still visible) or its filler child
	      // (when the bar is hidden). If it is still visible, we keep
	      // it enabled, if it's hidden, we disable pointer events.
	      var box = bar.getBoundingClientRect();
	      var elt = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)
	          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
	      if (elt != bar) { bar.style.pointerEvents = "none"; }
	      else { delay.set(1000, maybeDisable); }
	    }
	    delay.set(1000, maybeDisable);
	  };
	
	  NativeScrollbars.prototype.clear = function () {
	    var parent = this.horiz.parentNode;
	    parent.removeChild(this.horiz);
	    parent.removeChild(this.vert);
	  };
	
	  var NullScrollbars = function () {};
	
	  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
	  NullScrollbars.prototype.setScrollLeft = function () {};
	  NullScrollbars.prototype.setScrollTop = function () {};
	  NullScrollbars.prototype.clear = function () {};
	
	  function updateScrollbars(cm, measure) {
	    if (!measure) { measure = measureForScrollbars(cm); }
	    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
	    updateScrollbarsInner(cm, measure);
	    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
	      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
	        { updateHeightsInViewport(cm); }
	      updateScrollbarsInner(cm, measureForScrollbars(cm));
	      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
	    }
	  }
	
	  // Re-synchronize the fake scrollbars with the actual size of the
	  // content.
	  function updateScrollbarsInner(cm, measure) {
	    var d = cm.display;
	    var sizes = d.scrollbars.update(measure);
	
	    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
	    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
	    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
	
	    if (sizes.right && sizes.bottom) {
	      d.scrollbarFiller.style.display = "block";
	      d.scrollbarFiller.style.height = sizes.bottom + "px";
	      d.scrollbarFiller.style.width = sizes.right + "px";
	    } else { d.scrollbarFiller.style.display = ""; }
	    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
	      d.gutterFiller.style.display = "block";
	      d.gutterFiller.style.height = sizes.bottom + "px";
	      d.gutterFiller.style.width = measure.gutterWidth + "px";
	    } else { d.gutterFiller.style.display = ""; }
	  }
	
	  var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};
	
	  function initScrollbars(cm) {
	    if (cm.display.scrollbars) {
	      cm.display.scrollbars.clear();
	      if (cm.display.scrollbars.addClass)
	        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
	    }
	
	    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
	      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
	      // Prevent clicks in the scrollbars from killing focus
	      on(node, "mousedown", function () {
	        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }
	      });
	      node.setAttribute("cm-not-content", "true");
	    }, function (pos, axis) {
	      if (axis == "horizontal") { setScrollLeft(cm, pos); }
	      else { updateScrollTop(cm, pos); }
	    }, cm);
	    if (cm.display.scrollbars.addClass)
	      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
	  }
	
	  // Operations are used to wrap a series of changes to the editor
	  // state in such a way that each change won't have to update the
	  // cursor and display (which would be awkward, slow, and
	  // error-prone). Instead, display updates are batched and then all
	  // combined and executed at once.
	
	  var nextOpId = 0;
	  // Start a new operation.
	  function startOperation(cm) {
	    cm.curOp = {
	      cm: cm,
	      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
	      startHeight: cm.doc.height, // Used to detect need to update scrollbar
	      forceUpdate: false,      // Used to force a redraw
	      updateInput: 0,       // Whether to reset the input textarea
	      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
	      changeObjs: null,        // Accumulated changes, for firing change events
	      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
	      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
	      selectionChanged: false, // Whether the selection needs to be redrawn
	      updateMaxLine: false,    // Set when the widest line needs to be determined anew
	      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
	      scrollToPos: null,       // Used to scroll to a specific position
	      focus: false,
	      id: ++nextOpId           // Unique ID
	    };
	    pushOperation(cm.curOp);
	  }
	
	  // Finish an operation, updating the display and signalling delayed events
	  function endOperation(cm) {
	    var op = cm.curOp;
	    if (op) { finishOperation(op, function (group) {
	      for (var i = 0; i < group.ops.length; i++)
	        { group.ops[i].cm.curOp = null; }
	      endOperations(group);
	    }); }
	  }
	
	  // The DOM updates done when an operation finishes are batched so
	  // that the minimum number of relayouts are required.
	  function endOperations(group) {
	    var ops = group.ops;
	    for (var i = 0; i < ops.length; i++) // Read DOM
	      { endOperation_R1(ops[i]); }
	    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
	      { endOperation_W1(ops[i$1]); }
	    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
	      { endOperation_R2(ops[i$2]); }
	    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
	      { endOperation_W2(ops[i$3]); }
	    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
	      { endOperation_finish(ops[i$4]); }
	  }
	
	  function endOperation_R1(op) {
	    var cm = op.cm, display = cm.display;
	    maybeClipScrollbars(cm);
	    if (op.updateMaxLine) { findMaxLine(cm); }
	
	    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
	      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
	                         op.scrollToPos.to.line >= display.viewTo) ||
	      display.maxLineChanged && cm.options.lineWrapping;
	    op.update = op.mustUpdate &&
	      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
	  }
	
	  function endOperation_W1(op) {
	    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
	  }
	
	  function endOperation_R2(op) {
	    var cm = op.cm, display = cm.display;
	    if (op.updatedDisplay) { updateHeightsInViewport(cm); }
	
	    op.barMeasure = measureForScrollbars(cm);
	
	    // If the max line changed since it was last measured, measure it,
	    // and ensure the document's width matches it.
	    // updateDisplay_W2 will use these properties to do the actual resizing
	    if (display.maxLineChanged && !cm.options.lineWrapping) {
	      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
	      cm.display.sizerWidth = op.adjustWidthTo;
	      op.barMeasure.scrollWidth =
	        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
	      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
	    }
	
	    if (op.updatedDisplay || op.selectionChanged)
	      { op.preparedSelection = display.input.prepareSelection(); }
	  }
	
	  function endOperation_W2(op) {
	    var cm = op.cm;
	
	    if (op.adjustWidthTo != null) {
	      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
	      if (op.maxScrollLeft < cm.doc.scrollLeft)
	        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }
	      cm.display.maxLineChanged = false;
	    }
	
	    var takeFocus = op.focus && op.focus == activeElt();
	    if (op.preparedSelection)
	      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }
	    if (op.updatedDisplay || op.startHeight != cm.doc.height)
	      { updateScrollbars(cm, op.barMeasure); }
	    if (op.updatedDisplay)
	      { setDocumentHeight(cm, op.barMeasure); }
	
	    if (op.selectionChanged) { restartBlink(cm); }
	
	    if (cm.state.focused && op.updateInput)
	      { cm.display.input.reset(op.typing); }
	    if (takeFocus) { ensureFocus(op.cm); }
	  }
	
	  function endOperation_finish(op) {
	    var cm = op.cm, display = cm.display, doc = cm.doc;
	
	    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }
	
	    // Abort mouse wheel delta measurement, when scrolling explicitly
	    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
	      { display.wheelStartX = display.wheelStartY = null; }
	
	    // Propagate the scroll position to the actual DOM scroller
	    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }
	
	    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }
	    // If we need to scroll a specific position into view, do so.
	    if (op.scrollToPos) {
	      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
	                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
	      maybeScrollWindow(cm, rect);
	    }
	
	    // Fire events for markers that are hidden/unidden by editing or
	    // undoing
	    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
	    if (hidden) { for (var i = 0; i < hidden.length; ++i)
	      { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } } }
	    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
	      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } } }
	
	    if (display.wrapper.offsetHeight)
	      { doc.scrollTop = cm.display.scroller.scrollTop; }
	
	    // Fire change events, and delayed event handlers
	    if (op.changeObjs)
	      { signal(cm, "changes", cm, op.changeObjs); }
	    if (op.update)
	      { op.update.finish(); }
	  }
	
	  // Run the given function in an operation
	  function runInOp(cm, f) {
	    if (cm.curOp) { return f() }
	    startOperation(cm);
	    try { return f() }
	    finally { endOperation(cm); }
	  }
	  // Wraps a function in an operation. Returns the wrapped function.
	  function operation(cm, f) {
	    return function() {
	      if (cm.curOp) { return f.apply(cm, arguments) }
	      startOperation(cm);
	      try { return f.apply(cm, arguments) }
	      finally { endOperation(cm); }
	    }
	  }
	  // Used to add methods to editor and doc instances, wrapping them in
	  // operations.
	  function methodOp(f) {
	    return function() {
	      if (this.curOp) { return f.apply(this, arguments) }
	      startOperation(this);
	      try { return f.apply(this, arguments) }
	      finally { endOperation(this); }
	    }
	  }
	  function docMethodOp(f) {
	    return function() {
	      var cm = this.cm;
	      if (!cm || cm.curOp) { return f.apply(this, arguments) }
	      startOperation(cm);
	      try { return f.apply(this, arguments) }
	      finally { endOperation(cm); }
	    }
	  }
	
	  // HIGHLIGHT WORKER
	
	  function startWorker(cm, time) {
	    if (cm.doc.highlightFrontier < cm.display.viewTo)
	      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }
	  }
	
	  function highlightWorker(cm) {
	    var doc = cm.doc;
	    if (doc.highlightFrontier >= cm.display.viewTo) { return }
	    var end = +new Date + cm.options.workTime;
	    var context = getContextBefore(cm, doc.highlightFrontier);
	    var changedLines = [];
	
	    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
	      if (context.line >= cm.display.viewFrom) { // Visible
	        var oldStyles = line.styles;
	        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
	        var highlighted = highlightLine(cm, line, context, true);
	        if (resetState) { context.state = resetState; }
	        line.styles = highlighted.styles;
	        var oldCls = line.styleClasses, newCls = highlighted.classes;
	        if (newCls) { line.styleClasses = newCls; }
	        else if (oldCls) { line.styleClasses = null; }
	        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
	          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
	        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }
	        if (ischange) { changedLines.push(context.line); }
	        line.stateAfter = context.save();
	        context.nextLine();
	      } else {
	        if (line.text.length <= cm.options.maxHighlightLength)
	          { processLine(cm, line.text, context); }
	        line.stateAfter = context.line % 5 == 0 ? context.save() : null;
	        context.nextLine();
	      }
	      if (+new Date > end) {
	        startWorker(cm, cm.options.workDelay);
	        return true
	      }
	    });
	    doc.highlightFrontier = context.line;
	    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
	    if (changedLines.length) { runInOp(cm, function () {
	      for (var i = 0; i < changedLines.length; i++)
	        { regLineChange(cm, changedLines[i], "text"); }
	    }); }
	  }
	
	  // DISPLAY DRAWING
	
	  var DisplayUpdate = function(cm, viewport, force) {
	    var display = cm.display;
	
	    this.viewport = viewport;
	    // Store some values that we'll need later (but don't want to force a relayout for)
	    this.visible = visibleLines(display, cm.doc, viewport);
	    this.editorIsHidden = !display.wrapper.offsetWidth;
	    this.wrapperHeight = display.wrapper.clientHeight;
	    this.wrapperWidth = display.wrapper.clientWidth;
	    this.oldDisplayWidth = displayWidth(cm);
	    this.force = force;
	    this.dims = getDimensions(cm);
	    this.events = [];
	  };
	
	  DisplayUpdate.prototype.signal = function (emitter, type) {
	    if (hasHandler(emitter, type))
	      { this.events.push(arguments); }
	  };
	  DisplayUpdate.prototype.finish = function () {
	    for (var i = 0; i < this.events.length; i++)
	      { signal.apply(null, this.events[i]); }
	  };
	
	  function maybeClipScrollbars(cm) {
	    var display = cm.display;
	    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
	      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
	      display.heightForcer.style.height = scrollGap(cm) + "px";
	      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
	      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
	      display.scrollbarsClipped = true;
	    }
	  }
	
	  function selectionSnapshot(cm) {
	    if (cm.hasFocus()) { return null }
	    var active = activeElt();
	    if (!active || !contains(cm.display.lineDiv, active)) { return null }
	    var result = {activeElt: active};
	    if (window.getSelection) {
	      var sel = window.getSelection();
	      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
	        result.anchorNode = sel.anchorNode;
	        result.anchorOffset = sel.anchorOffset;
	        result.focusNode = sel.focusNode;
	        result.focusOffset = sel.focusOffset;
	      }
	    }
	    return result
	  }
	
	  function restoreSelection(snapshot) {
	    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }
	    snapshot.activeElt.focus();
	    if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
	      var sel = window.getSelection(), range = document.createRange();
	      range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
	      range.collapse(false);
	      sel.removeAllRanges();
	      sel.addRange(range);
	      sel.extend(snapshot.focusNode, snapshot.focusOffset);
	    }
	  }
	
	  // Does the actual updating of the line display. Bails out
	  // (returning false) when there is nothing to be done and forced is
	  // false.
	  function updateDisplayIfNeeded(cm, update) {
	    var display = cm.display, doc = cm.doc;
	
	    if (update.editorIsHidden) {
	      resetView(cm);
	      return false
	    }
	
	    // Bail out if the visible area is already rendered and nothing changed.
	    if (!update.force &&
	        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
	        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
	        display.renderedView == display.view && countDirtyView(cm) == 0)
	      { return false }
	
	    if (maybeUpdateLineNumberWidth(cm)) {
	      resetView(cm);
	      update.dims = getDimensions(cm);
	    }
	
	    // Compute a suitable new viewport (from & to)
	    var end = doc.first + doc.size;
	    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
	    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
	    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }
	    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }
	    if (sawCollapsedSpans) {
	      from = visualLineNo(cm.doc, from);
	      to = visualLineEndNo(cm.doc, to);
	    }
	
	    var different = from != display.viewFrom || to != display.viewTo ||
	      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
	    adjustView(cm, from, to);
	
	    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
	    // Position the mover div to align with the current scroll position
	    cm.display.mover.style.top = display.viewOffset + "px";
	
	    var toUpdate = countDirtyView(cm);
	    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
	        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
	      { return false }
	
	    // For big changes, we hide the enclosing element during the
	    // update, since that speeds up the operations on most browsers.
	    var selSnapshot = selectionSnapshot(cm);
	    if (toUpdate > 4) { display.lineDiv.style.display = "none"; }
	    patchDisplay(cm, display.updateLineNumbers, update.dims);
	    if (toUpdate > 4) { display.lineDiv.style.display = ""; }
	    display.renderedView = display.view;
	    // There might have been a widget with a focused element that got
	    // hidden or updated, if so re-focus it.
	    restoreSelection(selSnapshot);
	
	    // Prevent selection and cursors from interfering with the scroll
	    // width and height.
	    removeChildren(display.cursorDiv);
	    removeChildren(display.selectionDiv);
	    display.gutters.style.height = display.sizer.style.minHeight = 0;
	
	    if (different) {
	      display.lastWrapHeight = update.wrapperHeight;
	      display.lastWrapWidth = update.wrapperWidth;
	      startWorker(cm, 400);
	    }
	
	    display.updateLineNumbers = null;
	
	    return true
	  }
	
	  function postUpdateDisplay(cm, update) {
	    var viewport = update.viewport;
	
	    for (var first = true;; first = false) {
	      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
	        // Clip forced viewport to actual scrollable area.
	        if (viewport && viewport.top != null)
	          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }
	        // Updated line heights might result in the drawn area not
	        // actually covering the viewport. Keep looping until it does.
	        update.visible = visibleLines(cm.display, cm.doc, viewport);
	        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
	          { break }
	      } else if (first) {
	        update.visible = visibleLines(cm.display, cm.doc, viewport);
	      }
	      if (!updateDisplayIfNeeded(cm, update)) { break }
	      updateHeightsInViewport(cm);
	      var barMeasure = measureForScrollbars(cm);
	      updateSelection(cm);
	      updateScrollbars(cm, barMeasure);
	      setDocumentHeight(cm, barMeasure);
	      update.force = false;
	    }
	
	    update.signal(cm, "update", cm);
	    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
	      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
	      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
	    }
	  }
	
	  function updateDisplaySimple(cm, viewport) {
	    var update = new DisplayUpdate(cm, viewport);
	    if (updateDisplayIfNeeded(cm, update)) {
	      updateHeightsInViewport(cm);
	      postUpdateDisplay(cm, update);
	      var barMeasure = measureForScrollbars(cm);
	      updateSelection(cm);
	      updateScrollbars(cm, barMeasure);
	      setDocumentHeight(cm, barMeasure);
	      update.finish();
	    }
	  }
	
	  // Sync the actual display DOM structure with display.view, removing
	  // nodes for lines that are no longer in view, and creating the ones
	  // that are not there yet, and updating the ones that are out of
	  // date.
	  function patchDisplay(cm, updateNumbersFrom, dims) {
	    var display = cm.display, lineNumbers = cm.options.lineNumbers;
	    var container = display.lineDiv, cur = container.firstChild;
	
	    function rm(node) {
	      var next = node.nextSibling;
	      // Works around a throw-scroll bug in OS X Webkit
	      if (webkit && mac && cm.display.currentWheelTarget == node)
	        { node.style.display = "none"; }
	      else
	        { node.parentNode.removeChild(node); }
	      return next
	    }
	
	    var view = display.view, lineN = display.viewFrom;
	    // Loop over the elements in the view, syncing cur (the DOM nodes
	    // in display.lineDiv) with the view as we go.
	    for (var i = 0; i < view.length; i++) {
	      var lineView = view[i];
	      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
	        var node = buildLineElement(cm, lineView, lineN, dims);
	        container.insertBefore(node, cur);
	      } else { // Already drawn
	        while (cur != lineView.node) { cur = rm(cur); }
	        var updateNumber = lineNumbers && updateNumbersFrom != null &&
	          updateNumbersFrom <= lineN && lineView.lineNumber;
	        if (lineView.changes) {
	          if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }
	          updateLineForChanges(cm, lineView, lineN, dims);
	        }
	        if (updateNumber) {
	          removeChildren(lineView.lineNumber);
	          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
	        }
	        cur = lineView.node.nextSibling;
	      }
	      lineN += lineView.size;
	    }
	    while (cur) { cur = rm(cur); }
	  }
	
	  function updateGutterSpace(display) {
	    var width = display.gutters.offsetWidth;
	    display.sizer.style.marginLeft = width + "px";
	  }
	
	  function setDocumentHeight(cm, measure) {
	    cm.display.sizer.style.minHeight = measure.docHeight + "px";
	    cm.display.heightForcer.style.top = measure.docHeight + "px";
	    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
	  }
	
	  // Re-align line numbers and gutter marks to compensate for
	  // horizontal scrolling.
	  function alignHorizontally(cm) {
	    var display = cm.display, view = display.view;
	    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
	    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
	    var gutterW = display.gutters.offsetWidth, left = comp + "px";
	    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
	      if (cm.options.fixedGutter) {
	        if (view[i].gutter)
	          { view[i].gutter.style.left = left; }
	        if (view[i].gutterBackground)
	          { view[i].gutterBackground.style.left = left; }
	      }
	      var align = view[i].alignable;
	      if (align) { for (var j = 0; j < align.length; j++)
	        { align[j].style.left = left; } }
	    } }
	    if (cm.options.fixedGutter)
	      { display.gutters.style.left = (comp + gutterW) + "px"; }
	  }
	
	  // Used to ensure that the line number gutter is still the right
	  // size for the current document size. Returns true when an update
	  // is needed.
	  function maybeUpdateLineNumberWidth(cm) {
	    if (!cm.options.lineNumbers) { return false }
	    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
	    if (last.length != display.lineNumChars) {
	      var test = display.measure.appendChild(elt("div", [elt("div", last)],
	                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
	      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
	      display.lineGutter.style.width = "";
	      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
	      display.lineNumWidth = display.lineNumInnerWidth + padding;
	      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
	      display.lineGutter.style.width = display.lineNumWidth + "px";
	      updateGutterSpace(cm.display);
	      return true
	    }
	    return false
	  }
	
	  function getGutters(gutters, lineNumbers) {
	    var result = [], sawLineNumbers = false;
	    for (var i = 0; i < gutters.length; i++) {
	      var name = gutters[i], style = null;
	      if (typeof name != "string") { style = name.style; name = name.className; }
	      if (name == "CodeMirror-linenumbers") {
	        if (!lineNumbers) { continue }
	        else { sawLineNumbers = true; }
	      }
	      result.push({className: name, style: style});
	    }
	    if (lineNumbers && !sawLineNumbers) { result.push({className: "CodeMirror-linenumbers", style: null}); }
	    return result
	  }
	
	  // Rebuild the gutter elements, ensure the margin to the left of the
	  // code matches their width.
	  function renderGutters(display) {
	    var gutters = display.gutters, specs = display.gutterSpecs;
	    removeChildren(gutters);
	    display.lineGutter = null;
	    for (var i = 0; i < specs.length; ++i) {
	      var ref = specs[i];
	      var className = ref.className;
	      var style = ref.style;
	      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
	      if (style) { gElt.style.cssText = style; }
	      if (className == "CodeMirror-linenumbers") {
	        display.lineGutter = gElt;
	        gElt.style.width = (display.lineNumWidth || 1) + "px";
	      }
	    }
	    gutters.style.display = specs.length ? "" : "none";
	    updateGutterSpace(display);
	  }
	
	  function updateGutters(cm) {
	    renderGutters(cm.display);
	    regChange(cm);
	    alignHorizontally(cm);
	  }
	
	  // The display handles the DOM integration, both for input reading
	  // and content drawing. It holds references to DOM nodes and
	  // display-related state.
	
	  function Display(place, doc, input, options) {
	    var d = this;
	    this.input = input;
	
	    // Covers bottom-right square when both scrollbars are present.
	    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
	    d.scrollbarFiller.setAttribute("cm-not-content", "true");
	    // Covers bottom of gutter when coverGutterNextToScrollbar is on
	    // and h scrollbar is present.
	    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
	    d.gutterFiller.setAttribute("cm-not-content", "true");
	    // Will contain the actual code, positioned to cover the viewport.
	    d.lineDiv = eltP("div", null, "CodeMirror-code");
	    // Elements are added to these to represent selection and cursors.
	    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
	    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
	    // A visibility: hidden element used to find the size of things.
	    d.measure = elt("div", null, "CodeMirror-measure");
	    // When lines outside of the viewport are measured, they are drawn in this.
	    d.lineMeasure = elt("div", null, "CodeMirror-measure");
	    // Wraps everything that needs to exist inside the vertically-padded coordinate system
	    d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
	                      null, "position: relative; outline: none");
	    var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
	    // Moved around its parent to cover visible view.
	    d.mover = elt("div", [lines], null, "position: relative");
	    // Set to the height of the document, allowing scrolling.
	    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
	    d.sizerWidth = null;
	    // Behavior of elts with overflow: auto and padding is
	    // inconsistent across browsers. This is used to ensure the
	    // scrollable area is big enough.
	    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
	    // Will contain the gutters, if any.
	    d.gutters = elt("div", null, "CodeMirror-gutters");
	    d.lineGutter = null;
	    // Actual scrollable element.
	    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
	    d.scroller.setAttribute("tabIndex", "-1");
	    // The element in which the editor lives.
	    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
	
	    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
	    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
	    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }
	
	    if (place) {
	      if (place.appendChild) { place.appendChild(d.wrapper); }
	      else { place(d.wrapper); }
	    }
	
	    // Current rendered range (may be bigger than the view window).
	    d.viewFrom = d.viewTo = doc.first;
	    d.reportedViewFrom = d.reportedViewTo = doc.first;
	    // Information about the rendered lines.
	    d.view = [];
	    d.renderedView = null;
	    // Holds info about a single rendered line when it was rendered
	    // for measurement, while not in view.
	    d.externalMeasured = null;
	    // Empty space (in pixels) above the view
	    d.viewOffset = 0;
	    d.lastWrapHeight = d.lastWrapWidth = 0;
	    d.updateLineNumbers = null;
	
	    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
	    d.scrollbarsClipped = false;
	
	    // Used to only resize the line number gutter when necessary (when
	    // the amount of lines crosses a boundary that makes its width change)
	    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
	    // Set to true when a non-horizontal-scrolling line widget is
	    // added. As an optimization, line widget aligning is skipped when
	    // this is false.
	    d.alignWidgets = false;
	
	    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
	
	    // Tracks the maximum line length so that the horizontal scrollbar
	    // can be kept static when scrolling.
	    d.maxLine = null;
	    d.maxLineLength = 0;
	    d.maxLineChanged = false;
	
	    // Used for measuring wheel scrolling granularity
	    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
	
	    // True when shift is held down.
	    d.shift = false;
	
	    // Used to track whether anything happened since the context menu
	    // was opened.
	    d.selForContextMenu = null;
	
	    d.activeTouch = null;
	
	    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
	    renderGutters(d);
	
	    input.init(d);
	  }
	
	  // Since the delta values reported on mouse wheel events are
	  // unstandardized between browsers and even browser versions, and
	  // generally horribly unpredictable, this code starts by measuring
	  // the scroll effect that the first few mouse wheel events have,
	  // and, from that, detects the way it can convert deltas to pixel
	  // offsets afterwards.
	  //
	  // The reason we want to know the amount a wheel event will scroll
	  // is that it gives us a chance to update the display before the
	  // actual scrolling happens, reducing flickering.
	
	  var wheelSamples = 0, wheelPixelsPerUnit = null;
	  // Fill in a browser-detected starting value on browsers where we
	  // know one. These don't have to be accurate -- the result of them
	  // being wrong would just be a slight flicker on the first wheel
	  // scroll (if it is large enough).
	  if (ie) { wheelPixelsPerUnit = -.53; }
	  else if (gecko) { wheelPixelsPerUnit = 15; }
	  else if (chrome) { wheelPixelsPerUnit = -.7; }
	  else if (safari) { wheelPixelsPerUnit = -1/3; }
	
	  function wheelEventDelta(e) {
	    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
	    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }
	    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }
	    else if (dy == null) { dy = e.wheelDelta; }
	    return {x: dx, y: dy}
	  }
	  function wheelEventPixels(e) {
	    var delta = wheelEventDelta(e);
	    delta.x *= wheelPixelsPerUnit;
	    delta.y *= wheelPixelsPerUnit;
	    return delta
	  }
	
	  function onScrollWheel(cm, e) {
	    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;
	
	    var display = cm.display, scroll = display.scroller;
	    // Quit if there's nothing to scroll here
	    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
	    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
	    if (!(dx && canScrollX || dy && canScrollY)) { return }
	
	    // Webkit browsers on OS X abort momentum scrolls when the target
	    // of the scroll event is removed from the scrollable element.
	    // This hack (see related code in patchDisplay) makes sure the
	    // element is kept around.
	    if (dy && mac && webkit) {
	      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
	        for (var i = 0; i < view.length; i++) {
	          if (view[i].node == cur) {
	            cm.display.currentWheelTarget = cur;
	            break outer
	          }
	        }
	      }
	    }
	
	    // On some browsers, horizontal scrolling will cause redraws to
	    // happen before the gutter has been realigned, causing it to
	    // wriggle around in a most unseemly way. When we have an
	    // estimated pixels/delta value, we just handle horizontal
	    // scrolling entirely here. It'll be slightly off from native, but
	    // better than glitching out.
	    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
	      if (dy && canScrollY)
	        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }
	      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
	      // Only prevent default scrolling if vertical scrolling is
	      // actually possible. Otherwise, it causes vertical scroll
	      // jitter on OSX trackpads when deltaX is small and deltaY
	      // is large (issue #3579)
	      if (!dy || (dy && canScrollY))
	        { e_preventDefault(e); }
	      display.wheelStartX = null; // Abort measurement, if in progress
	      return
	    }
	
	    // 'Project' the visible viewport to cover the area that is being
	    // scrolled into view (if we know enough to estimate it).
	    if (dy && wheelPixelsPerUnit != null) {
	      var pixels = dy * wheelPixelsPerUnit;
	      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
	      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }
	      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }
	      updateDisplaySimple(cm, {top: top, bottom: bot});
	    }
	
	    if (wheelSamples < 20) {
	      if (display.wheelStartX == null) {
	        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
	        display.wheelDX = dx; display.wheelDY = dy;
	        setTimeout(function () {
	          if (display.wheelStartX == null) { return }
	          var movedX = scroll.scrollLeft - display.wheelStartX;
	          var movedY = scroll.scrollTop - display.wheelStartY;
	          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
	            (movedX && display.wheelDX && movedX / display.wheelDX);
	          display.wheelStartX = display.wheelStartY = null;
	          if (!sample) { return }
	          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
	          ++wheelSamples;
	        }, 200);
	      } else {
	        display.wheelDX += dx; display.wheelDY += dy;
	      }
	    }
	  }
	
	  // Selection objects are immutable. A new one is created every time
	  // the selection changes. A selection is one or more non-overlapping
	  // (and non-touching) ranges, sorted, and an integer that indicates
	  // which one is the primary selection (the one that's scrolled into
	  // view, that getCursor returns, etc).
	  var Selection = function(ranges, primIndex) {
	    this.ranges = ranges;
	    this.primIndex = primIndex;
	  };
	
	  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };
	
	  Selection.prototype.equals = function (other) {
	    if (other == this) { return true }
	    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
	    for (var i = 0; i < this.ranges.length; i++) {
	      var here = this.ranges[i], there = other.ranges[i];
	      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
	    }
	    return true
	  };
	
	  Selection.prototype.deepCopy = function () {
	    var out = [];
	    for (var i = 0; i < this.ranges.length; i++)
	      { out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head)); }
	    return new Selection(out, this.primIndex)
	  };
	
	  Selection.prototype.somethingSelected = function () {
	    for (var i = 0; i < this.ranges.length; i++)
	      { if (!this.ranges[i].empty()) { return true } }
	    return false
	  };
	
	  Selection.prototype.contains = function (pos, end) {
	    if (!end) { end = pos; }
	    for (var i = 0; i < this.ranges.length; i++) {
	      var range = this.ranges[i];
	      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
	        { return i }
	    }
	    return -1
	  };
	
	  var Range = function(anchor, head) {
	    this.anchor = anchor; this.head = head;
	  };
	
	  Range.prototype.from = function () { return minPos(this.anchor, this.head) };
	  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
	  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };
	
	  // Take an unsorted, potentially overlapping set of ranges, and
	  // build a selection out of it. 'Consumes' ranges array (modifying
	  // it).
	  function normalizeSelection(cm, ranges, primIndex) {
	    var mayTouch = cm && cm.options.selectionsMayTouch;
	    var prim = ranges[primIndex];
	    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });
	    primIndex = indexOf(ranges, prim);
	    for (var i = 1; i < ranges.length; i++) {
	      var cur = ranges[i], prev = ranges[i - 1];
	      var diff = cmp(prev.to(), cur.from());
	      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
	        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
	        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
	        if (i <= primIndex) { --primIndex; }
	        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
	      }
	    }
	    return new Selection(ranges, primIndex)
	  }
	
	  function simpleSelection(anchor, head) {
	    return new Selection([new Range(anchor, head || anchor)], 0)
	  }
	
	  // Compute the position of the end of a change (its 'to' property
	  // refers to the pre-change end).
	  function changeEnd(change) {
	    if (!change.text) { return change.to }
	    return Pos(change.from.line + change.text.length - 1,
	               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
	  }
	
	  // Adjust a position to refer to the post-change position of the
	  // same text, or the end of the change if the change covers it.
	  function adjustForChange(pos, change) {
	    if (cmp(pos, change.from) < 0) { return pos }
	    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }
	
	    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
	    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }
	    return Pos(line, ch)
	  }
	
	  function computeSelAfterChange(doc, change) {
	    var out = [];
	    for (var i = 0; i < doc.sel.ranges.length; i++) {
	      var range = doc.sel.ranges[i];
	      out.push(new Range(adjustForChange(range.anchor, change),
	                         adjustForChange(range.head, change)));
	    }
	    return normalizeSelection(doc.cm, out, doc.sel.primIndex)
	  }
	
	  function offsetPos(pos, old, nw) {
	    if (pos.line == old.line)
	      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
	    else
	      { return Pos(nw.line + (pos.line - old.line), pos.ch) }
	  }
	
	  // Used by replaceSelections to allow moving the selection to the
	  // start or around the replaced test. Hint may be "start" or "around".
	  function computeReplacedSel(doc, changes, hint) {
	    var out = [];
	    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
	    for (var i = 0; i < changes.length; i++) {
	      var change = changes[i];
	      var from = offsetPos(change.from, oldPrev, newPrev);
	      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
	      oldPrev = change.to;
	      newPrev = to;
	      if (hint == "around") {
	        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
	        out[i] = new Range(inv ? to : from, inv ? from : to);
	      } else {
	        out[i] = new Range(from, from);
	      }
	    }
	    return new Selection(out, doc.sel.primIndex)
	  }
	
	  // Used to get the editor into a consistent state again when options change.
	
	  function loadMode(cm) {
	    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
	    resetModeState(cm);
	  }
	
	  function resetModeState(cm) {
	    cm.doc.iter(function (line) {
	      if (line.stateAfter) { line.stateAfter = null; }
	      if (line.styles) { line.styles = null; }
	    });
	    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
	    startWorker(cm, 100);
	    cm.state.modeGen++;
	    if (cm.curOp) { regChange(cm); }
	  }
	
	  // DOCUMENT DATA STRUCTURE
	
	  // By default, updates that start and end at the beginning of a line
	  // are treated specially, in order to make the association of line
	  // widgets and marker elements with the text behave more intuitive.
	  function isWholeLineUpdate(doc, change) {
	    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
	      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
	  }
	
	  // Perform a change on the document data structure.
	  function updateDoc(doc, change, markedSpans, estimateHeight) {
	    function spansFor(n) {return markedSpans ? markedSpans[n] : null}
	    function update(line, text, spans) {
	      updateLine(line, text, spans, estimateHeight);
	      signalLater(line, "change", line, change);
	    }
	    function linesFor(start, end) {
	      var result = [];
	      for (var i = start; i < end; ++i)
	        { result.push(new Line(text[i], spansFor(i), estimateHeight)); }
	      return result
	    }
	
	    var from = change.from, to = change.to, text = change.text;
	    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
	    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
	
	    // Adjust the line structure
	    if (change.full) {
	      doc.insert(0, linesFor(0, text.length));
	      doc.remove(text.length, doc.size - text.length);
	    } else if (isWholeLineUpdate(doc, change)) {
	      // This is a whole-line replace. Treated specially to make
	      // sure line objects move the way they are supposed to.
	      var added = linesFor(0, text.length - 1);
	      update(lastLine, lastLine.text, lastSpans);
	      if (nlines) { doc.remove(from.line, nlines); }
	      if (added.length) { doc.insert(from.line, added); }
	    } else if (firstLine == lastLine) {
	      if (text.length == 1) {
	        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
	      } else {
	        var added$1 = linesFor(1, text.length - 1);
	        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
	        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
	        doc.insert(from.line + 1, added$1);
	      }
	    } else if (text.length == 1) {
	      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
	      doc.remove(from.line + 1, nlines);
	    } else {
	      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
	      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
	      var added$2 = linesFor(1, text.length - 1);
	      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }
	      doc.insert(from.line + 1, added$2);
	    }
	
	    signalLater(doc, "change", doc, change);
	  }
	
	  // Call f for all linked documents.
	  function linkedDocs(doc, f, sharedHistOnly) {
	    function propagate(doc, skip, sharedHist) {
	      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
	        var rel = doc.linked[i];
	        if (rel.doc == skip) { continue }
	        var shared = sharedHist && rel.sharedHist;
	        if (sharedHistOnly && !shared) { continue }
	        f(rel.doc, shared);
	        propagate(rel.doc, doc, shared);
	      } }
	    }
	    propagate(doc, null, true);
	  }
	
	  // Attach a document to an editor.
	  function attachDoc(cm, doc) {
	    if (doc.cm) { throw new Error("This document is already in use.") }
	    cm.doc = doc;
	    doc.cm = cm;
	    estimateLineHeights(cm);
	    loadMode(cm);
	    setDirectionClass(cm);
	    if (!cm.options.lineWrapping) { findMaxLine(cm); }
	    cm.options.mode = doc.modeOption;
	    regChange(cm);
	  }
	
	  function setDirectionClass(cm) {
	  (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
	  }
	
	  function directionChanged(cm) {
	    runInOp(cm, function () {
	      setDirectionClass(cm);
	      regChange(cm);
	    });
	  }
	
	  function History(startGen) {
	    // Arrays of change events and selections. Doing something adds an
	    // event to done and clears undo. Undoing moves events from done
	    // to undone, redoing moves them in the other direction.
	    this.done = []; this.undone = [];
	    this.undoDepth = Infinity;
	    // Used to track when changes can be merged into a single undo
	    // event
	    this.lastModTime = this.lastSelTime = 0;
	    this.lastOp = this.lastSelOp = null;
	    this.lastOrigin = this.lastSelOrigin = null;
	    // Used by the isClean() method
	    this.generation = this.maxGeneration = startGen || 1;
	  }
	
	  // Create a history change event from an updateDoc-style change
	  // object.
	  function historyChangeFromChange(doc, change) {
	    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
	    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
	    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);
	    return histChange
	  }
	
	  // Pop all selection events off the end of a history array. Stop at
	  // a change event.
	  function clearSelectionEvents(array) {
	    while (array.length) {
	      var last = lst(array);
	      if (last.ranges) { array.pop(); }
	      else { break }
	    }
	  }
	
	  // Find the top change event in the history. Pop off selection
	  // events that are in the way.
	  function lastChangeEvent(hist, force) {
	    if (force) {
	      clearSelectionEvents(hist.done);
	      return lst(hist.done)
	    } else if (hist.done.length && !lst(hist.done).ranges) {
	      return lst(hist.done)
	    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
	      hist.done.pop();
	      return lst(hist.done)
	    }
	  }
	
	  // Register a change in the history. Merges changes that are within
	  // a single operation, or are close together with an origin that
	  // allows merging (starting with "+") into a single event.
	  function addChangeToHistory(doc, change, selAfter, opId) {
	    var hist = doc.history;
	    hist.undone.length = 0;
	    var time = +new Date, cur;
	    var last;
	
	    if ((hist.lastOp == opId ||
	         hist.lastOrigin == change.origin && change.origin &&
	         ((change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||
	          change.origin.charAt(0) == "*")) &&
	        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
	      // Merge this change into the last event
	      last = lst(cur.changes);
	      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
	        // Optimized case for simple insertion -- don't want to add
	        // new changesets for every character typed
	        last.to = changeEnd(change);
	      } else {
	        // Add new sub-event
	        cur.changes.push(historyChangeFromChange(doc, change));
	      }
	    } else {
	      // Can not be merged, start a new event.
	      var before = lst(hist.done);
	      if (!before || !before.ranges)
	        { pushSelectionToHistory(doc.sel, hist.done); }
	      cur = {changes: [historyChangeFromChange(doc, change)],
	             generation: hist.generation};
	      hist.done.push(cur);
	      while (hist.done.length > hist.undoDepth) {
	        hist.done.shift();
	        if (!hist.done[0].ranges) { hist.done.shift(); }
	      }
	    }
	    hist.done.push(selAfter);
	    hist.generation = ++hist.maxGeneration;
	    hist.lastModTime = hist.lastSelTime = time;
	    hist.lastOp = hist.lastSelOp = opId;
	    hist.lastOrigin = hist.lastSelOrigin = change.origin;
	
	    if (!last) { signal(doc, "historyAdded"); }
	  }
	
	  function selectionEventCanBeMerged(doc, origin, prev, sel) {
	    var ch = origin.charAt(0);
	    return ch == "*" ||
	      ch == "+" &&
	      prev.ranges.length == sel.ranges.length &&
	      prev.somethingSelected() == sel.somethingSelected() &&
	      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
	  }
	
	  // Called whenever the selection changes, sets the new selection as
	  // the pending selection in the history, and pushes the old pending
	  // selection into the 'done' array when it was significantly
	  // different (in number of selected ranges, emptiness, or time).
	  function addSelectionToHistory(doc, sel, opId, options) {
	    var hist = doc.history, origin = options && options.origin;
	
	    // A new event is started when the previous origin does not match
	    // the current, or the origins don't allow matching. Origins
	    // starting with * are always merged, those starting with + are
	    // merged when similar and close together in time.
	    if (opId == hist.lastSelOp ||
	        (origin && hist.lastSelOrigin == origin &&
	         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
	          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
	      { hist.done[hist.done.length - 1] = sel; }
	    else
	      { pushSelectionToHistory(sel, hist.done); }
	
	    hist.lastSelTime = +new Date;
	    hist.lastSelOrigin = origin;
	    hist.lastSelOp = opId;
	    if (options && options.clearRedo !== false)
	      { clearSelectionEvents(hist.undone); }
	  }
	
	  function pushSelectionToHistory(sel, dest) {
	    var top = lst(dest);
	    if (!(top && top.ranges && top.equals(sel)))
	      { dest.push(sel); }
	  }
	
	  // Used to store marked span information in the history.
	  function attachLocalSpans(doc, change, from, to) {
	    var existing = change["spans_" + doc.id], n = 0;
	    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
	      if (line.markedSpans)
	        { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }
	      ++n;
	    });
	  }
	
	  // When un/re-doing restores text containing marked spans, those
	  // that have been explicitly cleared should not be restored.
	  function removeClearedSpans(spans) {
	    if (!spans) { return null }
	    var out;
	    for (var i = 0; i < spans.length; ++i) {
	      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }
	      else if (out) { out.push(spans[i]); }
	    }
	    return !out ? spans : out.length ? out : null
	  }
	
	  // Retrieve and filter the old marked spans stored in a change event.
	  function getOldSpans(doc, change) {
	    var found = change["spans_" + doc.id];
	    if (!found) { return null }
	    var nw = [];
	    for (var i = 0; i < change.text.length; ++i)
	      { nw.push(removeClearedSpans(found[i])); }
	    return nw
	  }
	
	  // Used for un/re-doing changes from the history. Combines the
	  // result of computing the existing spans with the set of spans that
	  // existed in the history (so that deleting around a span and then
	  // undoing brings back the span).
	  function mergeOldSpans(doc, change) {
	    var old = getOldSpans(doc, change);
	    var stretched = stretchSpansOverChange(doc, change);
	    if (!old) { return stretched }
	    if (!stretched) { return old }
	
	    for (var i = 0; i < old.length; ++i) {
	      var oldCur = old[i], stretchCur = stretched[i];
	      if (oldCur && stretchCur) {
	        spans: for (var j = 0; j < stretchCur.length; ++j) {
	          var span = stretchCur[j];
	          for (var k = 0; k < oldCur.length; ++k)
	            { if (oldCur[k].marker == span.marker) { continue spans } }
	          oldCur.push(span);
	        }
	      } else if (stretchCur) {
	        old[i] = stretchCur;
	      }
	    }
	    return old
	  }
	
	  // Used both to provide a JSON-safe object in .getHistory, and, when
	  // detaching a document, to split the history in two
	  function copyHistoryArray(events, newGroup, instantiateSel) {
	    var copy = [];
	    for (var i = 0; i < events.length; ++i) {
	      var event = events[i];
	      if (event.ranges) {
	        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
	        continue
	      }
	      var changes = event.changes, newChanges = [];
	      copy.push({changes: newChanges});
	      for (var j = 0; j < changes.length; ++j) {
	        var change = changes[j], m = (void 0);
	        newChanges.push({from: change.from, to: change.to, text: change.text});
	        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
	          if (indexOf(newGroup, Number(m[1])) > -1) {
	            lst(newChanges)[prop] = change[prop];
	            delete change[prop];
	          }
	        } } }
	      }
	    }
	    return copy
	  }
	
	  // The 'scroll' parameter given to many of these indicated whether
	  // the new cursor position should be scrolled into view after
	  // modifying the selection.
	
	  // If shift is held or the extend flag is set, extends a range to
	  // include a given position (and optionally a second position).
	  // Otherwise, simply returns the range between the given positions.
	  // Used for cursor motion and such.
	  function extendRange(range, head, other, extend) {
	    if (extend) {
	      var anchor = range.anchor;
	      if (other) {
	        var posBefore = cmp(head, anchor) < 0;
	        if (posBefore != (cmp(other, anchor) < 0)) {
	          anchor = head;
	          head = other;
	        } else if (posBefore != (cmp(head, other) < 0)) {
	          head = other;
	        }
	      }
	      return new Range(anchor, head)
	    } else {
	      return new Range(other || head, head)
	    }
	  }
	
	  // Extend the primary selection range, discard the rest.
	  function extendSelection(doc, head, other, options, extend) {
	    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }
	    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
	  }
	
	  // Extend all selections (pos is an array of selections with length
	  // equal the number of selections)
	  function extendSelections(doc, heads, options) {
	    var out = [];
	    var extend = doc.cm && (doc.cm.display.shift || doc.extend);
	    for (var i = 0; i < doc.sel.ranges.length; i++)
	      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }
	    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
	    setSelection(doc, newSel, options);
	  }
	
	  // Updates a single range in the selection.
	  function replaceOneSelection(doc, i, range, options) {
	    var ranges = doc.sel.ranges.slice(0);
	    ranges[i] = range;
	    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
	  }
	
	  // Reset the selection to a single range.
	  function setSimpleSelection(doc, anchor, head, options) {
	    setSelection(doc, simpleSelection(anchor, head), options);
	  }
	
	  // Give beforeSelectionChange handlers a change to influence a
	  // selection update.
	  function filterSelectionChange(doc, sel, options) {
	    var obj = {
	      ranges: sel.ranges,
	      update: function(ranges) {
	        this.ranges = [];
	        for (var i = 0; i < ranges.length; i++)
	          { this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
	                                     clipPos(doc, ranges[i].head)); }
	      },
	      origin: options && options.origin
	    };
	    signal(doc, "beforeSelectionChange", doc, obj);
	    if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }
	    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }
	    else { return sel }
	  }
	
	  function setSelectionReplaceHistory(doc, sel, options) {
	    var done = doc.history.done, last = lst(done);
	    if (last && last.ranges) {
	      done[done.length - 1] = sel;
	      setSelectionNoUndo(doc, sel, options);
	    } else {
	      setSelection(doc, sel, options);
	    }
	  }
	
	  // Set a new selection.
	  function setSelection(doc, sel, options) {
	    setSelectionNoUndo(doc, sel, options);
	    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
	  }
	
	  function setSelectionNoUndo(doc, sel, options) {
	    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
	      { sel = filterSelectionChange(doc, sel, options); }
	
	    var bias = options && options.bias ||
	      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
	    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));
	
	    if (!(options && options.scroll === false) && doc.cm)
	      { ensureCursorVisible(doc.cm); }
	  }
	
	  function setSelectionInner(doc, sel) {
	    if (sel.equals(doc.sel)) { return }
	
	    doc.sel = sel;
	
	    if (doc.cm) {
	      doc.cm.curOp.updateInput = 1;
	      doc.cm.curOp.selectionChanged = true;
	      signalCursorActivity(doc.cm);
	    }
	    signalLater(doc, "cursorActivity", doc);
	  }
	
	  // Verify that the selection does not partially select any atomic
	  // marked ranges.
	  function reCheckSelection(doc) {
	    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
	  }
	
	  // Return a selection that does not partially select any atomic
	  // ranges.
	  function skipAtomicInSelection(doc, sel, bias, mayClear) {
	    var out;
	    for (var i = 0; i < sel.ranges.length; i++) {
	      var range = sel.ranges[i];
	      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
	      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
	      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
	      if (out || newAnchor != range.anchor || newHead != range.head) {
	        if (!out) { out = sel.ranges.slice(0, i); }
	        out[i] = new Range(newAnchor, newHead);
	      }
	    }
	    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel
	  }
	
	  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
	    var line = getLine(doc, pos.line);
	    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
	      var sp = line.markedSpans[i], m = sp.marker;
	
	      // Determine if we should prevent the cursor being placed to the left/right of an atomic marker
	      // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it
	      // is with selectLeft/Right
	      var preventCursorLeft = ("selectLeft" in m) ? !m.selectLeft : m.inclusiveLeft;
	      var preventCursorRight = ("selectRight" in m) ? !m.selectRight : m.inclusiveRight;
	
	      if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
	          (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
	        if (mayClear) {
	          signal(m, "beforeCursorEnter");
	          if (m.explicitlyCleared) {
	            if (!line.markedSpans) { break }
	            else {--i; continue}
	          }
	        }
	        if (!m.atomic) { continue }
	
	        if (oldPos) {
	          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);
	          if (dir < 0 ? preventCursorRight : preventCursorLeft)
	            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }
	          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
	            { return skipAtomicInner(doc, near, pos, dir, mayClear) }
	        }
	
	        var far = m.find(dir < 0 ? -1 : 1);
	        if (dir < 0 ? preventCursorLeft : preventCursorRight)
	          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }
	        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
	      }
	    } }
	    return pos
	  }
	
	  // Ensure a given position is not inside an atomic range.
	  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
	    var dir = bias || 1;
	    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
	        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
	        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
	        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
	    if (!found) {
	      doc.cantEdit = true;
	      return Pos(doc.first, 0)
	    }
	    return found
	  }
	
	  function movePos(doc, pos, dir, line) {
	    if (dir < 0 && pos.ch == 0) {
	      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
	      else { return null }
	    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
	      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
	      else { return null }
	    } else {
	      return new Pos(pos.line, pos.ch + dir)
	    }
	  }
	
	  function selectAll(cm) {
	    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
	  }
	
	  // UPDATING
	
	  // Allow "beforeChange" event handlers to influence a change
	  function filterChange(doc, change, update) {
	    var obj = {
	      canceled: false,
	      from: change.from,
	      to: change.to,
	      text: change.text,
	      origin: change.origin,
	      cancel: function () { return obj.canceled = true; }
	    };
	    if (update) { obj.update = function (from, to, text, origin) {
	      if (from) { obj.from = clipPos(doc, from); }
	      if (to) { obj.to = clipPos(doc, to); }
	      if (text) { obj.text = text; }
	      if (origin !== undefined) { obj.origin = origin; }
	    }; }
	    signal(doc, "beforeChange", doc, obj);
	    if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }
	
	    if (obj.canceled) {
	      if (doc.cm) { doc.cm.curOp.updateInput = 2; }
	      return null
	    }
	    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
	  }
	
	  // Apply a change to a document, and add it to the document's
	  // history, and propagating it to all linked documents.
	  function makeChange(doc, change, ignoreReadOnly) {
	    if (doc.cm) {
	      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
	      if (doc.cm.state.suppressEdits) { return }
	    }
	
	    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
	      change = filterChange(doc, change, true);
	      if (!change) { return }
	    }
	
	    // Possibly split or suppress the update based on the presence
	    // of read-only spans in its range.
	    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
	    if (split) {
	      for (var i = split.length - 1; i >= 0; --i)
	        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin}); }
	    } else {
	      makeChangeInner(doc, change);
	    }
	  }
	
	  function makeChangeInner(doc, change) {
	    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
	    var selAfter = computeSelAfterChange(doc, change);
	    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
	
	    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
	    var rebased = [];
	
	    linkedDocs(doc, function (doc, sharedHist) {
	      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
	        rebaseHist(doc.history, change);
	        rebased.push(doc.history);
	      }
	      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
	    });
	  }
	
	  // Revert a change stored in a document's history.
	  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
	    var suppress = doc.cm && doc.cm.state.suppressEdits;
	    if (suppress && !allowSelectionOnly) { return }
	
	    var hist = doc.history, event, selAfter = doc.sel;
	    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;
	
	    // Verify that there is a useable event (so that ctrl-z won't
	    // needlessly clear selection events)
	    var i = 0;
	    for (; i < source.length; i++) {
	      event = source[i];
	      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
	        { break }
	    }
	    if (i == source.length) { return }
	    hist.lastOrigin = hist.lastSelOrigin = null;
	
	    for (;;) {
	      event = source.pop();
	      if (event.ranges) {
	        pushSelectionToHistory(event, dest);
	        if (allowSelectionOnly && !event.equals(doc.sel)) {
	          setSelection(doc, event, {clearRedo: false});
	          return
	        }
	        selAfter = event;
	      } else if (suppress) {
	        source.push(event);
	        return
	      } else { break }
	    }
	
	    // Build up a reverse change object to add to the opposite history
	    // stack (redo when undoing, and vice versa).
	    var antiChanges = [];
	    pushSelectionToHistory(selAfter, dest);
	    dest.push({changes: antiChanges, generation: hist.generation});
	    hist.generation = event.generation || ++hist.maxGeneration;
	
	    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");
	
	    var loop = function ( i ) {
	      var change = event.changes[i];
	      change.origin = type;
	      if (filter && !filterChange(doc, change, false)) {
	        source.length = 0;
	        return {}
	      }
	
	      antiChanges.push(historyChangeFromChange(doc, change));
	
	      var after = i ? computeSelAfterChange(doc, change) : lst(source);
	      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
	      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }
	      var rebased = [];
	
	      // Propagate to the linked documents
	      linkedDocs(doc, function (doc, sharedHist) {
	        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
	          rebaseHist(doc.history, change);
	          rebased.push(doc.history);
	        }
	        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
	      });
	    };
	
	    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
	      var returned = loop( i$1 );
	
	      if ( returned ) return returned.v;
	    }
	  }
	
	  // Sub-views need their line numbers shifted when text is added
	  // above or below them in the parent document.
	  function shiftDoc(doc, distance) {
	    if (distance == 0) { return }
	    doc.first += distance;
	    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
	      Pos(range.anchor.line + distance, range.anchor.ch),
	      Pos(range.head.line + distance, range.head.ch)
	    ); }), doc.sel.primIndex);
	    if (doc.cm) {
	      regChange(doc.cm, doc.first, doc.first - distance, distance);
	      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
	        { regLineChange(doc.cm, l, "gutter"); }
	    }
	  }
	
	  // More lower-level change function, handling only a single document
	  // (not linked ones).
	  function makeChangeSingleDoc(doc, change, selAfter, spans) {
	    if (doc.cm && !doc.cm.curOp)
	      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }
	
	    if (change.to.line < doc.first) {
	      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
	      return
	    }
	    if (change.from.line > doc.lastLine()) { return }
	
	    // Clip the change to the size of this doc
	    if (change.from.line < doc.first) {
	      var shift = change.text.length - 1 - (doc.first - change.from.line);
	      shiftDoc(doc, shift);
	      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
	                text: [lst(change.text)], origin: change.origin};
	    }
	    var last = doc.lastLine();
	    if (change.to.line > last) {
	      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
	                text: [change.text[0]], origin: change.origin};
	    }
	
	    change.removed = getBetween(doc, change.from, change.to);
	
	    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }
	    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }
	    else { updateDoc(doc, change, spans); }
	    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
	
	    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0)))
	      { doc.cantEdit = false; }
	  }
	
	  // Handle the interaction of a change to a document with the editor
	  // that this document is part of.
	  function makeChangeSingleDocInEditor(cm, change, spans) {
	    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;
	
	    var recomputeMaxLength = false, checkWidthStart = from.line;
	    if (!cm.options.lineWrapping) {
	      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
	      doc.iter(checkWidthStart, to.line + 1, function (line) {
	        if (line == display.maxLine) {
	          recomputeMaxLength = true;
	          return true
	        }
	      });
	    }
	
	    if (doc.sel.contains(change.from, change.to) > -1)
	      { signalCursorActivity(cm); }
	
	    updateDoc(doc, change, spans, estimateHeight(cm));
	
	    if (!cm.options.lineWrapping) {
	      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
	        var len = lineLength(line);
	        if (len > display.maxLineLength) {
	          display.maxLine = line;
	          display.maxLineLength = len;
	          display.maxLineChanged = true;
	          recomputeMaxLength = false;
	        }
	      });
	      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }
	    }
	
	    retreatFrontier(doc, from.line);
	    startWorker(cm, 400);
	
	    var lendiff = change.text.length - (to.line - from.line) - 1;
	    // Remember that these lines changed, for updating the display
	    if (change.full)
	      { regChange(cm); }
	    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
	      { regLineChange(cm, from.line, "text"); }
	    else
	      { regChange(cm, from.line, to.line + 1, lendiff); }
	
	    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
	    if (changeHandler || changesHandler) {
	      var obj = {
	        from: from, to: to,
	        text: change.text,
	        removed: change.removed,
	        origin: change.origin
	      };
	      if (changeHandler) { signalLater(cm, "change", cm, obj); }
	      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }
	    }
	    cm.display.selForContextMenu = null;
	  }
	
	  function replaceRange(doc, code, from, to, origin) {
	    var assign;
	
	    if (!to) { to = from; }
	    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }
	    if (typeof code == "string") { code = doc.splitLines(code); }
	    makeChange(doc, {from: from, to: to, text: code, origin: origin});
	  }
	
	  // Rebasing/resetting history to deal with externally-sourced changes
	
	  function rebaseHistSelSingle(pos, from, to, diff) {
	    if (to < pos.line) {
	      pos.line += diff;
	    } else if (from < pos.line) {
	      pos.line = from;
	      pos.ch = 0;
	    }
	  }
	
	  // Tries to rebase an array of history events given a change in the
	  // document. If the change touches the same lines as the event, the
	  // event, and everything 'behind' it, is discarded. If the change is
	  // before the event, the event's positions are updated. Uses a
	  // copy-on-write scheme for the positions, to avoid having to
	  // reallocate them all on every rebase, but also avoid problems with
	  // shared position objects being unsafely updated.
	  function rebaseHistArray(array, from, to, diff) {
	    for (var i = 0; i < array.length; ++i) {
	      var sub = array[i], ok = true;
	      if (sub.ranges) {
	        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
	        for (var j = 0; j < sub.ranges.length; j++) {
	          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
	          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
	        }
	        continue
	      }
	      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
	        var cur = sub.changes[j$1];
	        if (to < cur.from.line) {
	          cur.from = Pos(cur.from.line + diff, cur.from.ch);
	          cur.to = Pos(cur.to.line + diff, cur.to.ch);
	        } else if (from <= cur.to.line) {
	          ok = false;
	          break
	        }
	      }
	      if (!ok) {
	        array.splice(0, i + 1);
	        i = 0;
	      }
	    }
	  }
	
	  function rebaseHist(hist, change) {
	    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
	    rebaseHistArray(hist.done, from, to, diff);
	    rebaseHistArray(hist.undone, from, to, diff);
	  }
	
	  // Utility for applying a change to a line by handle or number,
	  // returning the number and optionally registering the line as
	  // changed.
	  function changeLine(doc, handle, changeType, op) {
	    var no = handle, line = handle;
	    if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }
	    else { no = lineNo(handle); }
	    if (no == null) { return null }
	    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }
	    return line
	  }
	
	  // The document is represented as a BTree consisting of leaves, with
	  // chunk of lines in them, and branches, with up to ten leaves or
	  // other branch nodes below them. The top node is always a branch
	  // node, and is the document object itself (meaning it has
	  // additional methods and properties).
	  //
	  // All nodes have parent links. The tree is used both to go from
	  // line numbers to line objects, and to go from objects to numbers.
	  // It also indexes by height, and is used to convert between height
	  // and line object, and to find the total height of the document.
	  //
	  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html
	
	  function LeafChunk(lines) {
	    this.lines = lines;
	    this.parent = null;
	    var height = 0;
	    for (var i = 0; i < lines.length; ++i) {
	      lines[i].parent = this;
	      height += lines[i].height;
	    }
	    this.height = height;
	  }
	
	  LeafChunk.prototype = {
	    chunkSize: function() { return this.lines.length },
	
	    // Remove the n lines at offset 'at'.
	    removeInner: function(at, n) {
	      for (var i = at, e = at + n; i < e; ++i) {
	        var line = this.lines[i];
	        this.height -= line.height;
	        cleanUpLine(line);
	        signalLater(line, "delete");
	      }
	      this.lines.splice(at, n);
	    },
	
	    // Helper used to collapse a small branch into a single leaf.
	    collapse: function(lines) {
	      lines.push.apply(lines, this.lines);
	    },
	
	    // Insert the given array of lines at offset 'at', count them as
	    // having the given height.
	    insertInner: function(at, lines, height) {
	      this.height += height;
	      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
	      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this; }
	    },
	
	    // Used to iterate over a part of the tree.
	    iterN: function(at, n, op) {
	      for (var e = at + n; at < e; ++at)
	        { if (op(this.lines[at])) { return true } }
	    }
	  };
	
	  function BranchChunk(children) {
	    this.children = children;
	    var size = 0, height = 0;
	    for (var i = 0; i < children.length; ++i) {
	      var ch = children[i];
	      size += ch.chunkSize(); height += ch.height;
	      ch.parent = this;
	    }
	    this.size = size;
	    this.height = height;
	    this.parent = null;
	  }
	
	  BranchChunk.prototype = {
	    chunkSize: function() { return this.size },
	
	    removeInner: function(at, n) {
	      this.size -= n;
	      for (var i = 0; i < this.children.length; ++i) {
	        var child = this.children[i], sz = child.chunkSize();
	        if (at < sz) {
	          var rm = Math.min(n, sz - at), oldHeight = child.height;
	          child.removeInner(at, rm);
	          this.height -= oldHeight - child.height;
	          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
	          if ((n -= rm) == 0) { break }
	          at = 0;
	        } else { at -= sz; }
	      }
	      // If the result is smaller than 25 lines, ensure that it is a
	      // single leaf node.
	      if (this.size - n < 25 &&
	          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
	        var lines = [];
	        this.collapse(lines);
	        this.children = [new LeafChunk(lines)];
	        this.children[0].parent = this;
	      }
	    },
	
	    collapse: function(lines) {
	      for (var i = 0; i < this.children.length; ++i) { this.children[i].collapse(lines); }
	    },
	
	    insertInner: function(at, lines, height) {
	      this.size += lines.length;
	      this.height += height;
	      for (var i = 0; i < this.children.length; ++i) {
	        var child = this.children[i], sz = child.chunkSize();
	        if (at <= sz) {
	          child.insertInner(at, lines, height);
	          if (child.lines && child.lines.length > 50) {
	            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
	            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
	            var remaining = child.lines.length % 25 + 25;
	            for (var pos = remaining; pos < child.lines.length;) {
	              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
	              child.height -= leaf.height;
	              this.children.splice(++i, 0, leaf);
	              leaf.parent = this;
	            }
	            child.lines = child.lines.slice(0, remaining);
	            this.maybeSpill();
	          }
	          break
	        }
	        at -= sz;
	      }
	    },
	
	    // When a node has grown, check whether it should be split.
	    maybeSpill: function() {
	      if (this.children.length <= 10) { return }
	      var me = this;
	      do {
	        var spilled = me.children.splice(me.children.length - 5, 5);
	        var sibling = new BranchChunk(spilled);
	        if (!me.parent) { // Become the parent node
	          var copy = new BranchChunk(me.children);
	          copy.parent = me;
	          me.children = [copy, sibling];
	          me = copy;
	       } else {
	          me.size -= sibling.size;
	          me.height -= sibling.height;
	          var myIndex = indexOf(me.parent.children, me);
	          me.parent.children.splice(myIndex + 1, 0, sibling);
	        }
	        sibling.parent = me.parent;
	      } while (me.children.length > 10)
	      me.parent.maybeSpill();
	    },
	
	    iterN: function(at, n, op) {
	      for (var i = 0; i < this.children.length; ++i) {
	        var child = this.children[i], sz = child.chunkSize();
	        if (at < sz) {
	          var used = Math.min(n, sz - at);
	          if (child.iterN(at, used, op)) { return true }
	          if ((n -= used) == 0) { break }
	          at = 0;
	        } else { at -= sz; }
	      }
	    }
	  };
	
	  // Line widgets are block elements displayed above or below a line.
	
	  var LineWidget = function(doc, node, options) {
	    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
	      { this[opt] = options[opt]; } } }
	    this.doc = doc;
	    this.node = node;
	  };
	
	  LineWidget.prototype.clear = function () {
	    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
	    if (no == null || !ws) { return }
	    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this) { ws.splice(i--, 1); } }
	    if (!ws.length) { line.widgets = null; }
	    var height = widgetHeight(this);
	    updateLineHeight(line, Math.max(0, line.height - height));
	    if (cm) {
	      runInOp(cm, function () {
	        adjustScrollWhenAboveVisible(cm, line, -height);
	        regLineChange(cm, no, "widget");
	      });
	      signalLater(cm, "lineWidgetCleared", cm, this, no);
	    }
	  };
	
	  LineWidget.prototype.changed = function () {
	      var this$1 = this;
	
	    var oldH = this.height, cm = this.doc.cm, line = this.line;
	    this.height = null;
	    var diff = widgetHeight(this) - oldH;
	    if (!diff) { return }
	    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }
	    if (cm) {
	      runInOp(cm, function () {
	        cm.curOp.forceUpdate = true;
	        adjustScrollWhenAboveVisible(cm, line, diff);
	        signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
	      });
	    }
	  };
	  eventMixin(LineWidget);
	
	  function adjustScrollWhenAboveVisible(cm, line, diff) {
	    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
	      { addToScrollTop(cm, diff); }
	  }
	
	  function addLineWidget(doc, handle, node, options) {
	    var widget = new LineWidget(doc, node, options);
	    var cm = doc.cm;
	    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }
	    changeLine(doc, handle, "widget", function (line) {
	      var widgets = line.widgets || (line.widgets = []);
	      if (widget.insertAt == null) { widgets.push(widget); }
	      else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }
	      widget.line = line;
	      if (cm && !lineIsHidden(doc, line)) {
	        var aboveVisible = heightAtLine(line) < doc.scrollTop;
	        updateLineHeight(line, line.height + widgetHeight(widget));
	        if (aboveVisible) { addToScrollTop(cm, widget.height); }
	        cm.curOp.forceUpdate = true;
	      }
	      return true
	    });
	    if (cm) { signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle)); }
	    return widget
	  }
	
	  // TEXTMARKERS
	
	  // Created with markText and setBookmark methods. A TextMarker is a
	  // handle that can be used to clear or find a marked position in the
	  // document. Line objects hold arrays (markedSpans) containing
	  // {from, to, marker} object pointing to such marker objects, and
	  // indicating that such a marker is present on that line. Multiple
	  // lines may point to the same marker when it spans across lines.
	  // The spans will have null for their from/to properties when the
	  // marker continues beyond the start/end of the line. Markers have
	  // links back to the lines they currently touch.
	
	  // Collapsed markers have unique ids, in order to be able to order
	  // them, which is needed for uniquely determining an outer marker
	  // when they overlap (they may nest, but not partially overlap).
	  var nextMarkerId = 0;
	
	  var TextMarker = function(doc, type) {
	    this.lines = [];
	    this.type = type;
	    this.doc = doc;
	    this.id = ++nextMarkerId;
	  };
	
	  // Clear the marker.
	  TextMarker.prototype.clear = function () {
	    if (this.explicitlyCleared) { return }
	    var cm = this.doc.cm, withOp = cm && !cm.curOp;
	    if (withOp) { startOperation(cm); }
	    if (hasHandler(this, "clear")) {
	      var found = this.find();
	      if (found) { signalLater(this, "clear", found.from, found.to); }
	    }
	    var min = null, max = null;
	    for (var i = 0; i < this.lines.length; ++i) {
	      var line = this.lines[i];
	      var span = getMarkedSpanFor(line.markedSpans, this);
	      if (cm && !this.collapsed) { regLineChange(cm, lineNo(line), "text"); }
	      else if (cm) {
	        if (span.to != null) { max = lineNo(line); }
	        if (span.from != null) { min = lineNo(line); }
	      }
	      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
	      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
	        { updateLineHeight(line, textHeight(cm.display)); }
	    }
	    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
	      var visual = visualLine(this.lines[i$1]), len = lineLength(visual);
	      if (len > cm.display.maxLineLength) {
	        cm.display.maxLine = visual;
	        cm.display.maxLineLength = len;
	        cm.display.maxLineChanged = true;
	      }
	    } }
	
	    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }
	    this.lines.length = 0;
	    this.explicitlyCleared = true;
	    if (this.atomic && this.doc.cantEdit) {
	      this.doc.cantEdit = false;
	      if (cm) { reCheckSelection(cm.doc); }
	    }
	    if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }
	    if (withOp) { endOperation(cm); }
	    if (this.parent) { this.parent.clear(); }
	  };
	
	  // Find the position of the marker in the document. Returns a {from,
	  // to} object by default. Side can be passed to get a specific side
	  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
	  // Pos objects returned contain a line object, rather than a line
	  // number (used to prevent looking up the same line twice).
	  TextMarker.prototype.find = function (side, lineObj) {
	    if (side == null && this.type == "bookmark") { side = 1; }
	    var from, to;
	    for (var i = 0; i < this.lines.length; ++i) {
	      var line = this.lines[i];
	      var span = getMarkedSpanFor(line.markedSpans, this);
	      if (span.from != null) {
	        from = Pos(lineObj ? line : lineNo(line), span.from);
	        if (side == -1) { return from }
	      }
	      if (span.to != null) {
	        to = Pos(lineObj ? line : lineNo(line), span.to);
	        if (side == 1) { return to }
	      }
	    }
	    return from && {from: from, to: to}
	  };
	
	  // Signals that the marker's widget changed, and surrounding layout
	  // should be recomputed.
	  TextMarker.prototype.changed = function () {
	      var this$1 = this;
	
	    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
	    if (!pos || !cm) { return }
	    runInOp(cm, function () {
	      var line = pos.line, lineN = lineNo(pos.line);
	      var view = findViewForLine(cm, lineN);
	      if (view) {
	        clearLineMeasurementCacheFor(view);
	        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
	      }
	      cm.curOp.updateMaxLine = true;
	      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
	        var oldHeight = widget.height;
	        widget.height = null;
	        var dHeight = widgetHeight(widget) - oldHeight;
	        if (dHeight)
	          { updateLineHeight(line, line.height + dHeight); }
	      }
	      signalLater(cm, "markerChanged", cm, this$1);
	    });
	  };
	
	  TextMarker.prototype.attachLine = function (line) {
	    if (!this.lines.length && this.doc.cm) {
	      var op = this.doc.cm.curOp;
	      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
	        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }
	    }
	    this.lines.push(line);
	  };
	
	  TextMarker.prototype.detachLine = function (line) {
	    this.lines.splice(indexOf(this.lines, line), 1);
	    if (!this.lines.length && this.doc.cm) {
	      var op = this.doc.cm.curOp
	      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
	    }
	  };
	  eventMixin(TextMarker);
	
	  // Create a marker, wire it up to the right lines, and
	  function markText(doc, from, to, options, type) {
	    // Shared markers (across linked documents) are handled separately
	    // (markTextShared will call out to this again, once per
	    // document).
	    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
	    // Ensure we are in an operation.
	    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }
	
	    var marker = new TextMarker(doc, type), diff = cmp(from, to);
	    if (options) { copyObj(options, marker, false); }
	    // Don't connect empty markers unless clearWhenEmpty is false
	    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
	      { return marker }
	    if (marker.replacedWith) {
	      // Showing up as a widget implies collapsed (widget replaces text)
	      marker.collapsed = true;
	      marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
	      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }
	      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }
	    }
	    if (marker.collapsed) {
	      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
	          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
	        { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
	      seeCollapsedSpans();
	    }
	
	    if (marker.addToHistory)
	      { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN); }
	
	    var curLine = from.line, cm = doc.cm, updateMaxLine;
	    doc.iter(curLine, to.line + 1, function (line) {
	      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
	        { updateMaxLine = true; }
	      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }
	      addMarkedSpan(line, new MarkedSpan(marker,
	                                         curLine == from.line ? from.ch : null,
	                                         curLine == to.line ? to.ch : null));
	      ++curLine;
	    });
	    // lineIsHidden depends on the presence of the spans, so needs a second pass
	    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
	      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }
	    }); }
	
	    if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }
	
	    if (marker.readOnly) {
	      seeReadOnlySpans();
	      if (doc.history.done.length || doc.history.undone.length)
	        { doc.clearHistory(); }
	    }
	    if (marker.collapsed) {
	      marker.id = ++nextMarkerId;
	      marker.atomic = true;
	    }
	    if (cm) {
	      // Sync editor state
	      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }
	      if (marker.collapsed)
	        { regChange(cm, from.line, to.line + 1); }
	      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||
	               marker.attributes || marker.title)
	        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }
	      if (marker.atomic) { reCheckSelection(cm.doc); }
	      signalLater(cm, "markerAdded", cm, marker);
	    }
	    return marker
	  }
	
	  // SHARED TEXTMARKERS
	
	  // A shared marker spans multiple linked documents. It is
	  // implemented as a meta-marker-object controlling multiple normal
	  // markers.
	  var SharedTextMarker = function(markers, primary) {
	    this.markers = markers;
	    this.primary = primary;
	    for (var i = 0; i < markers.length; ++i)
	      { markers[i].parent = this; }
	  };
	
	  SharedTextMarker.prototype.clear = function () {
	    if (this.explicitlyCleared) { return }
	    this.explicitlyCleared = true;
	    for (var i = 0; i < this.markers.length; ++i)
	      { this.markers[i].clear(); }
	    signalLater(this, "clear");
	  };
	
	  SharedTextMarker.prototype.find = function (side, lineObj) {
	    return this.primary.find(side, lineObj)
	  };
	  eventMixin(SharedTextMarker);
	
	  function markTextShared(doc, from, to, options, type) {
	    options = copyObj(options);
	    options.shared = false;
	    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
	    var widget = options.widgetNode;
	    linkedDocs(doc, function (doc) {
	      if (widget) { options.widgetNode = widget.cloneNode(true); }
	      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
	      for (var i = 0; i < doc.linked.length; ++i)
	        { if (doc.linked[i].isParent) { return } }
	      primary = lst(markers);
	    });
	    return new SharedTextMarker(markers, primary)
	  }
	
	  function findSharedMarkers(doc) {
	    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
	  }
	
	  function copySharedMarkers(doc, markers) {
	    for (var i = 0; i < markers.length; i++) {
	      var marker = markers[i], pos = marker.find();
	      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
	      if (cmp(mFrom, mTo)) {
	        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
	        marker.markers.push(subMark);
	        subMark.parent = marker;
	      }
	    }
	  }
	
	  function detachSharedMarkers(markers) {
	    var loop = function ( i ) {
	      var marker = markers[i], linked = [marker.primary.doc];
	      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });
	      for (var j = 0; j < marker.markers.length; j++) {
	        var subMarker = marker.markers[j];
	        if (indexOf(linked, subMarker.doc) == -1) {
	          subMarker.parent = null;
	          marker.markers.splice(j--, 1);
	        }
	      }
	    };
	
	    for (var i = 0; i < markers.length; i++) loop( i );
	  }
	
	  var nextDocId = 0;
	  var Doc = function(text, mode, firstLine, lineSep, direction) {
	    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
	    if (firstLine == null) { firstLine = 0; }
	
	    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
	    this.first = firstLine;
	    this.scrollTop = this.scrollLeft = 0;
	    this.cantEdit = false;
	    this.cleanGeneration = 1;
	    this.modeFrontier = this.highlightFrontier = firstLine;
	    var start = Pos(firstLine, 0);
	    this.sel = simpleSelection(start);
	    this.history = new History(null);
	    this.id = ++nextDocId;
	    this.modeOption = mode;
	    this.lineSep = lineSep;
	    this.direction = (direction == "rtl") ? "rtl" : "ltr";
	    this.extend = false;
	
	    if (typeof text == "string") { text = this.splitLines(text); }
	    updateDoc(this, {from: start, to: start, text: text});
	    setSelection(this, simpleSelection(start), sel_dontScroll);
	  };
	
	  Doc.prototype = createObj(BranchChunk.prototype, {
	    constructor: Doc,
	    // Iterate over the document. Supports two forms -- with only one
	    // argument, it calls that for each line in the document. With
	    // three, it iterates over the range given by the first two (with
	    // the second being non-inclusive).
	    iter: function(from, to, op) {
	      if (op) { this.iterN(from - this.first, to - from, op); }
	      else { this.iterN(this.first, this.first + this.size, from); }
	    },
	
	    // Non-public interface for adding and removing lines.
	    insert: function(at, lines) {
	      var height = 0;
	      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }
	      this.insertInner(at - this.first, lines, height);
	    },
	    remove: function(at, n) { this.removeInner(at - this.first, n); },
	
	    // From here, the methods are part of the public interface. Most
	    // are also available from CodeMirror (editor) instances.
	
	    getValue: function(lineSep) {
	      var lines = getLines(this, this.first, this.first + this.size);
	      if (lineSep === false) { return lines }
	      return lines.join(lineSep || this.lineSeparator())
	    },
	    setValue: docMethodOp(function(code) {
	      var top = Pos(this.first, 0), last = this.first + this.size - 1;
	      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
	                        text: this.splitLines(code), origin: "setValue", full: true}, true);
	      if (this.cm) { scrollToCoords(this.cm, 0, 0); }
	      setSelection(this, simpleSelection(top), sel_dontScroll);
	    }),
	    replaceRange: function(code, from, to, origin) {
	      from = clipPos(this, from);
	      to = to ? clipPos(this, to) : from;
	      replaceRange(this, code, from, to, origin);
	    },
	    getRange: function(from, to, lineSep) {
	      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
	      if (lineSep === false) { return lines }
	      return lines.join(lineSep || this.lineSeparator())
	    },
	
	    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},
	
	    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
	    getLineNumber: function(line) {return lineNo(line)},
	
	    getLineHandleVisualStart: function(line) {
	      if (typeof line == "number") { line = getLine(this, line); }
	      return visualLine(line)
	    },
	
	    lineCount: function() {return this.size},
	    firstLine: function() {return this.first},
	    lastLine: function() {return this.first + this.size - 1},
	
	    clipPos: function(pos) {return clipPos(this, pos)},
	
	    getCursor: function(start) {
	      var range = this.sel.primary(), pos;
	      if (start == null || start == "head") { pos = range.head; }
	      else if (start == "anchor") { pos = range.anchor; }
	      else if (start == "end" || start == "to" || start === false) { pos = range.to(); }
	      else { pos = range.from(); }
	      return pos
	    },
	    listSelections: function() { return this.sel.ranges },
	    somethingSelected: function() {return this.sel.somethingSelected()},
	
	    setCursor: docMethodOp(function(line, ch, options) {
	      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
	    }),
	    setSelection: docMethodOp(function(anchor, head, options) {
	      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
	    }),
	    extendSelection: docMethodOp(function(head, other, options) {
	      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
	    }),
	    extendSelections: docMethodOp(function(heads, options) {
	      extendSelections(this, clipPosArray(this, heads), options);
	    }),
	    extendSelectionsBy: docMethodOp(function(f, options) {
	      var heads = map(this.sel.ranges, f);
	      extendSelections(this, clipPosArray(this, heads), options);
	    }),
	    setSelections: docMethodOp(function(ranges, primary, options) {
	      if (!ranges.length) { return }
	      var out = [];
	      for (var i = 0; i < ranges.length; i++)
	        { out[i] = new Range(clipPos(this, ranges[i].anchor),
	                           clipPos(this, ranges[i].head)); }
	      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }
	      setSelection(this, normalizeSelection(this.cm, out, primary), options);
	    }),
	    addSelection: docMethodOp(function(anchor, head, options) {
	      var ranges = this.sel.ranges.slice(0);
	      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
	      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
	    }),
	
	    getSelection: function(lineSep) {
	      var ranges = this.sel.ranges, lines;
	      for (var i = 0; i < ranges.length; i++) {
	        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
	        lines = lines ? lines.concat(sel) : sel;
	      }
	      if (lineSep === false) { return lines }
	      else { return lines.join(lineSep || this.lineSeparator()) }
	    },
	    getSelections: function(lineSep) {
	      var parts = [], ranges = this.sel.ranges;
	      for (var i = 0; i < ranges.length; i++) {
	        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
	        if (lineSep !== false) { sel = sel.join(lineSep || this.lineSeparator()); }
	        parts[i] = sel;
	      }
	      return parts
	    },
	    replaceSelection: function(code, collapse, origin) {
	      var dup = [];
	      for (var i = 0; i < this.sel.ranges.length; i++)
	        { dup[i] = code; }
	      this.replaceSelections(dup, collapse, origin || "+input");
	    },
	    replaceSelections: docMethodOp(function(code, collapse, origin) {
	      var changes = [], sel = this.sel;
	      for (var i = 0; i < sel.ranges.length; i++) {
	        var range = sel.ranges[i];
	        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};
	      }
	      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
	      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
	        { makeChange(this, changes[i$1]); }
	      if (newSel) { setSelectionReplaceHistory(this, newSel); }
	      else if (this.cm) { ensureCursorVisible(this.cm); }
	    }),
	    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
	    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
	    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
	    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),
	
	    setExtending: function(val) {this.extend = val;},
	    getExtending: function() {return this.extend},
	
	    historySize: function() {
	      var hist = this.history, done = 0, undone = 0;
	      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }
	      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }
	      return {undo: done, redo: undone}
	    },
	    clearHistory: function() {
	      var this$1 = this;
	
	      this.history = new History(this.history.maxGeneration);
	      linkedDocs(this, function (doc) { return doc.history = this$1.history; }, true);
	    },
	
	    markClean: function() {
	      this.cleanGeneration = this.changeGeneration(true);
	    },
	    changeGeneration: function(forceSplit) {
	      if (forceSplit)
	        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }
	      return this.history.generation
	    },
	    isClean: function (gen) {
	      return this.history.generation == (gen || this.cleanGeneration)
	    },
	
	    getHistory: function() {
	      return {done: copyHistoryArray(this.history.done),
	              undone: copyHistoryArray(this.history.undone)}
	    },
	    setHistory: function(histData) {
	      var hist = this.history = new History(this.history.maxGeneration);
	      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
	      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
	    },
	
	    setGutterMarker: docMethodOp(function(line, gutterID, value) {
	      return changeLine(this, line, "gutter", function (line) {
	        var markers = line.gutterMarkers || (line.gutterMarkers = {});
	        markers[gutterID] = value;
	        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }
	        return true
	      })
	    }),
	
	    clearGutter: docMethodOp(function(gutterID) {
	      var this$1 = this;
	
	      this.iter(function (line) {
	        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
	          changeLine(this$1, line, "gutter", function () {
	            line.gutterMarkers[gutterID] = null;
	            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }
	            return true
	          });
	        }
	      });
	    }),
	
	    lineInfo: function(line) {
	      var n;
	      if (typeof line == "number") {
	        if (!isLine(this, line)) { return null }
	        n = line;
	        line = getLine(this, line);
	        if (!line) { return null }
	      } else {
	        n = lineNo(line);
	        if (n == null) { return null }
	      }
	      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
	              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
	              widgets: line.widgets}
	    },
	
	    addLineClass: docMethodOp(function(handle, where, cls) {
	      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
	        var prop = where == "text" ? "textClass"
	                 : where == "background" ? "bgClass"
	                 : where == "gutter" ? "gutterClass" : "wrapClass";
	        if (!line[prop]) { line[prop] = cls; }
	        else if (classTest(cls).test(line[prop])) { return false }
	        else { line[prop] += " " + cls; }
	        return true
	      })
	    }),
	    removeLineClass: docMethodOp(function(handle, where, cls) {
	      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
	        var prop = where == "text" ? "textClass"
	                 : where == "background" ? "bgClass"
	                 : where == "gutter" ? "gutterClass" : "wrapClass";
	        var cur = line[prop];
	        if (!cur) { return false }
	        else if (cls == null) { line[prop] = null; }
	        else {
	          var found = cur.match(classTest(cls));
	          if (!found) { return false }
	          var end = found.index + found[0].length;
	          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
	        }
	        return true
	      })
	    }),
	
	    addLineWidget: docMethodOp(function(handle, node, options) {
	      return addLineWidget(this, handle, node, options)
	    }),
	    removeLineWidget: function(widget) { widget.clear(); },
	
	    markText: function(from, to, options) {
	      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
	    },
	    setBookmark: function(pos, options) {
	      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
	                      insertLeft: options && options.insertLeft,
	                      clearWhenEmpty: false, shared: options && options.shared,
	                      handleMouseEvents: options && options.handleMouseEvents};
	      pos = clipPos(this, pos);
	      return markText(this, pos, pos, realOpts, "bookmark")
	    },
	    findMarksAt: function(pos) {
	      pos = clipPos(this, pos);
	      var markers = [], spans = getLine(this, pos.line).markedSpans;
	      if (spans) { for (var i = 0; i < spans.length; ++i) {
	        var span = spans[i];
	        if ((span.from == null || span.from <= pos.ch) &&
	            (span.to == null || span.to >= pos.ch))
	          { markers.push(span.marker.parent || span.marker); }
	      } }
	      return markers
	    },
	    findMarks: function(from, to, filter) {
	      from = clipPos(this, from); to = clipPos(this, to);
	      var found = [], lineNo = from.line;
	      this.iter(from.line, to.line + 1, function (line) {
	        var spans = line.markedSpans;
	        if (spans) { for (var i = 0; i < spans.length; i++) {
	          var span = spans[i];
	          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||
	                span.from == null && lineNo != from.line ||
	                span.from != null && lineNo == to.line && span.from >= to.ch) &&
	              (!filter || filter(span.marker)))
	            { found.push(span.marker.parent || span.marker); }
	        } }
	        ++lineNo;
	      });
	      return found
	    },
	    getAllMarks: function() {
	      var markers = [];
	      this.iter(function (line) {
	        var sps = line.markedSpans;
	        if (sps) { for (var i = 0; i < sps.length; ++i)
	          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }
	      });
	      return markers
	    },
	
	    posFromIndex: function(off) {
	      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;
	      this.iter(function (line) {
	        var sz = line.text.length + sepSize;
	        if (sz > off) { ch = off; return true }
	        off -= sz;
	        ++lineNo;
	      });
	      return clipPos(this, Pos(lineNo, ch))
	    },
	    indexFromPos: function (coords) {
	      coords = clipPos(this, coords);
	      var index = coords.ch;
	      if (coords.line < this.first || coords.ch < 0) { return 0 }
	      var sepSize = this.lineSeparator().length;
	      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
	        index += line.text.length + sepSize;
	      });
	      return index
	    },
	
	    copy: function(copyHistory) {
	      var doc = new Doc(getLines(this, this.first, this.first + this.size),
	                        this.modeOption, this.first, this.lineSep, this.direction);
	      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
	      doc.sel = this.sel;
	      doc.extend = false;
	      if (copyHistory) {
	        doc.history.undoDepth = this.history.undoDepth;
	        doc.setHistory(this.getHistory());
	      }
	      return doc
	    },
	
	    linkedDoc: function(options) {
	      if (!options) { options = {}; }
	      var from = this.first, to = this.first + this.size;
	      if (options.from != null && options.from > from) { from = options.from; }
	      if (options.to != null && options.to < to) { to = options.to; }
	      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
	      if (options.sharedHist) { copy.history = this.history
	      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
	      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
	      copySharedMarkers(copy, findSharedMarkers(this));
	      return copy
	    },
	    unlinkDoc: function(other) {
	      if (other instanceof CodeMirror) { other = other.doc; }
	      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
	        var link = this.linked[i];
	        if (link.doc != other) { continue }
	        this.linked.splice(i, 1);
	        other.unlinkDoc(this);
	        detachSharedMarkers(findSharedMarkers(this));
	        break
	      } }
	      // If the histories were shared, split them again
	      if (other.history == this.history) {
	        var splitIds = [other.id];
	        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);
	        other.history = new History(null);
	        other.history.done = copyHistoryArray(this.history.done, splitIds);
	        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
	      }
	    },
	    iterLinkedDocs: function(f) {linkedDocs(this, f);},
	
	    getMode: function() {return this.mode},
	    getEditor: function() {return this.cm},
	
	    splitLines: function(str) {
	      if (this.lineSep) { return str.split(this.lineSep) }
	      return splitLinesAuto(str)
	    },
	    lineSeparator: function() { return this.lineSep || "\n" },
	
	    setDirection: docMethodOp(function (dir) {
	      if (dir != "rtl") { dir = "ltr"; }
	      if (dir == this.direction) { return }
	      this.direction = dir;
	      this.iter(function (line) { return line.order = null; });
	      if (this.cm) { directionChanged(this.cm); }
	    })
	  });
	
	  // Public alias.
	  Doc.prototype.eachLine = Doc.prototype.iter;
	
	  // Kludge to work around strange IE behavior where it'll sometimes
	  // re-fire a series of drag-related events right after the drop (#1551)
	  var lastDrop = 0;
	
	  function onDrop(e) {
	    var cm = this;
	    clearDragCursor(cm);
	    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
	      { return }
	    e_preventDefault(e);
	    if (ie) { lastDrop = +new Date; }
	    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
	    if (!pos || cm.isReadOnly()) { return }
	    // Might be a file drop, in which case we simply extract the text
	    // and insert it.
	    if (files && files.length && window.FileReader && window.File) {
	      var n = files.length, text = Array(n), read = 0;
	      var markAsReadAndPasteIfAllFilesAreRead = function () {
	        if (++read == n) {
	          operation(cm, function () {
	            pos = clipPos(cm.doc, pos);
	            var change = {from: pos, to: pos,
	                          text: cm.doc.splitLines(
	                              text.filter(function (t) { return t != null; }).join(cm.doc.lineSeparator())),
	                          origin: "paste"};
	            makeChange(cm.doc, change);
	            setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
	          })();
	        }
	      };
	      var readTextFromFile = function (file, i) {
	        if (cm.options.allowDropFileTypes &&
	            indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
	          markAsReadAndPasteIfAllFilesAreRead();
	          return
	        }
	        var reader = new FileReader;
	        reader.onerror = function () { return markAsReadAndPasteIfAllFilesAreRead(); };
	        reader.onload = function () {
	          var content = reader.result;
	          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
	            markAsReadAndPasteIfAllFilesAreRead();
	            return
	          }
	          text[i] = content;
	          markAsReadAndPasteIfAllFilesAreRead();
	        };
	        reader.readAsText(file);
	      };
	      for (var i = 0; i < files.length; i++) { readTextFromFile(files[i], i); }
	    } else { // Normal drop
	      // Don't do a replace if the drop happened inside of the selected text.
	      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
	        cm.state.draggingText(e);
	        // Ensure the editor is re-focused
	        setTimeout(function () { return cm.display.input.focus(); }, 20);
	        return
	      }
	      try {
	        var text$1 = e.dataTransfer.getData("Text");
	        if (text$1) {
	          var selected;
	          if (cm.state.draggingText && !cm.state.draggingText.copy)
	            { selected = cm.listSelections(); }
	          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
	          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
	            { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); } }
	          cm.replaceSelection(text$1, "around", "paste");
	          cm.display.input.focus();
	        }
	      }
	      catch(e){}
	    }
	  }
	
	  function onDragStart(cm, e) {
	    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
	    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }
	
	    e.dataTransfer.setData("Text", cm.getSelection());
	    e.dataTransfer.effectAllowed = "copyMove";
	
	    // Use dummy image instead of default browsers image.
	    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
	    if (e.dataTransfer.setDragImage && !safari) {
	      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
	      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
	      if (presto) {
	        img.width = img.height = 1;
	        cm.display.wrapper.appendChild(img);
	        // Force a relayout, or Opera won't use our image for some obscure reason
	        img._top = img.offsetTop;
	      }
	      e.dataTransfer.setDragImage(img, 0, 0);
	      if (presto) { img.parentNode.removeChild(img); }
	    }
	  }
	
	  function onDragOver(cm, e) {
	    var pos = posFromMouse(cm, e);
	    if (!pos) { return }
	    var frag = document.createDocumentFragment();
	    drawSelectionCursor(cm, pos, frag);
	    if (!cm.display.dragCursor) {
	      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
	      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
	    }
	    removeChildrenAndAdd(cm.display.dragCursor, frag);
	  }
	
	  function clearDragCursor(cm) {
	    if (cm.display.dragCursor) {
	      cm.display.lineSpace.removeChild(cm.display.dragCursor);
	      cm.display.dragCursor = null;
	    }
	  }
	
	  // These must be handled carefully, because naively registering a
	  // handler for each editor will cause the editors to never be
	  // garbage collected.
	
	  function forEachCodeMirror(f) {
	    if (!document.getElementsByClassName) { return }
	    var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
	    for (var i = 0; i < byClass.length; i++) {
	      var cm = byClass[i].CodeMirror;
	      if (cm) { editors.push(cm); }
	    }
	    if (editors.length) { editors[0].operation(function () {
	      for (var i = 0; i < editors.length; i++) { f(editors[i]); }
	    }); }
	  }
	
	  var globalsRegistered = false;
	  function ensureGlobalHandlers() {
	    if (globalsRegistered) { return }
	    registerGlobalHandlers();
	    globalsRegistered = true;
	  }
	  function registerGlobalHandlers() {
	    // When the window resizes, we need to refresh active editors.
	    var resizeTimer;
	    on(window, "resize", function () {
	      if (resizeTimer == null) { resizeTimer = setTimeout(function () {
	        resizeTimer = null;
	        forEachCodeMirror(onResize);
	      }, 100); }
	    });
	    // When the window loses focus, we want to show the editor as blurred
	    on(window, "blur", function () { return forEachCodeMirror(onBlur); });
	  }
	  // Called when the window resizes
	  function onResize(cm) {
	    var d = cm.display;
	    // Might be a text scaling operation, clear size caches.
	    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
	    d.scrollbarsClipped = false;
	    cm.setSize();
	  }
	
	  var keyNames = {
	    3: "Pause", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
	    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
	    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
	    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
	    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 145: "ScrollLock",
	    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
	    221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
	    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
	  };
	
	  // Number keys
	  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }
	  // Alphabetic keys
	  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }
	  // Function keys
	  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }
	
	  var keyMap = {};
	
	  keyMap.basic = {
	    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
	    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
	    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
	    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
	    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
	    "Esc": "singleSelection"
	  };
	  // Note that the save and find-related commands aren't defined by
	  // default. User code or addons can define them. Unknown commands
	  // are simply ignored.
	  keyMap.pcDefault = {
	    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
	    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
	    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
	    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
	    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
	    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
	    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
	    "fallthrough": "basic"
	  };
	  // Very basic readline/emacs-style bindings, which are standard on Mac.
	  keyMap.emacsy = {
	    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
	    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
	    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
	    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
	    "Ctrl-O": "openLine"
	  };
	  keyMap.macDefault = {
	    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
	    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
	    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
	    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
	    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
	    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
	    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
	    "fallthrough": ["basic", "emacsy"]
	  };
	  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
	
	  // KEYMAP DISPATCH
	
	  function normalizeKeyName(name) {
	    var parts = name.split(/-(?!$)/);
	    name = parts[parts.length - 1];
	    var alt, ctrl, shift, cmd;
	    for (var i = 0; i < parts.length - 1; i++) {
	      var mod = parts[i];
	      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }
	      else if (/^a(lt)?$/i.test(mod)) { alt = true; }
	      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
	      else if (/^s(hift)?$/i.test(mod)) { shift = true; }
	      else { throw new Error("Unrecognized modifier name: " + mod) }
	    }
	    if (alt) { name = "Alt-" + name; }
	    if (ctrl) { name = "Ctrl-" + name; }
	    if (cmd) { name = "Cmd-" + name; }
	    if (shift) { name = "Shift-" + name; }
	    return name
	  }
	
	  // This is a kludge to keep keymaps mostly working as raw objects
	  // (backwards compatibility) while at the same time support features
	  // like normalization and multi-stroke key bindings. It compiles a
	  // new normalized keymap, and then updates the old object to reflect
	  // this.
	  function normalizeKeyMap(keymap) {
	    var copy = {};
	    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
	      var value = keymap[keyname];
	      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
	      if (value == "...") { delete keymap[keyname]; continue }
	
	      var keys = map(keyname.split(" "), normalizeKeyName);
	      for (var i = 0; i < keys.length; i++) {
	        var val = (void 0), name = (void 0);
	        if (i == keys.length - 1) {
	          name = keys.join(" ");
	          val = value;
	        } else {
	          name = keys.slice(0, i + 1).join(" ");
	          val = "...";
	        }
	        var prev = copy[name];
	        if (!prev) { copy[name] = val; }
	        else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
	      }
	      delete keymap[keyname];
	    } }
	    for (var prop in copy) { keymap[prop] = copy[prop]; }
	    return keymap
	  }
	
	  function lookupKey(key, map, handle, context) {
	    map = getKeyMap(map);
	    var found = map.call ? map.call(key, context) : map[key];
	    if (found === false) { return "nothing" }
	    if (found === "...") { return "multi" }
	    if (found != null && handle(found)) { return "handled" }
	
	    if (map.fallthrough) {
	      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
	        { return lookupKey(key, map.fallthrough, handle, context) }
	      for (var i = 0; i < map.fallthrough.length; i++) {
	        var result = lookupKey(key, map.fallthrough[i], handle, context);
	        if (result) { return result }
	      }
	    }
	  }
	
	  // Modifier key presses don't count as 'real' key presses for the
	  // purpose of keymap fallthrough.
	  function isModifierKey(value) {
	    var name = typeof value == "string" ? value : keyNames[value.keyCode];
	    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
	  }
	
	  function addModifierNames(name, event, noShift) {
	    var base = name;
	    if (event.altKey && base != "Alt") { name = "Alt-" + name; }
	    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }
	    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") { name = "Cmd-" + name; }
	    if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }
	    return name
	  }
	
	  // Look up the name of a key as indicated by an event object.
	  function keyName(event, noShift) {
	    if (presto && event.keyCode == 34 && event["char"]) { return false }
	    var name = keyNames[event.keyCode];
	    if (name == null || event.altGraphKey) { return false }
	    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
	    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
	    if (event.keyCode == 3 && event.code) { name = event.code; }
	    return addModifierNames(name, event, noShift)
	  }
	
	  function getKeyMap(val) {
	    return typeof val == "string" ? keyMap[val] : val
	  }
	
	  // Helper for deleting text near the selection(s), used to implement
	  // backspace, delete, and similar functionality.
	  function deleteNearSelection(cm, compute) {
	    var ranges = cm.doc.sel.ranges, kill = [];
	    // Build up a set of ranges to kill first, merging overlapping
	    // ranges.
	    for (var i = 0; i < ranges.length; i++) {
	      var toKill = compute(ranges[i]);
	      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
	        var replaced = kill.pop();
	        if (cmp(replaced.from, toKill.from) < 0) {
	          toKill.from = replaced.from;
	          break
	        }
	      }
	      kill.push(toKill);
	    }
	    // Next, remove those actual ranges.
	    runInOp(cm, function () {
	      for (var i = kill.length - 1; i >= 0; i--)
	        { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }
	      ensureCursorVisible(cm);
	    });
	  }
	
	  function moveCharLogically(line, ch, dir) {
	    var target = skipExtendingChars(line.text, ch + dir, dir);
	    return target < 0 || target > line.text.length ? null : target
	  }
	
	  function moveLogically(line, start, dir) {
	    var ch = moveCharLogically(line, start.ch, dir);
	    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
	  }
	
	  function endOfLine(visually, cm, lineObj, lineNo, dir) {
	    if (visually) {
	      if (cm.doc.direction == "rtl") { dir = -dir; }
	      var order = getOrder(lineObj, cm.doc.direction);
	      if (order) {
	        var part = dir < 0 ? lst(order) : order[0];
	        var moveInStorageOrder = (dir < 0) == (part.level == 1);
	        var sticky = moveInStorageOrder ? "after" : "before";
	        var ch;
	        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
	        // it could be that the last bidi part is not on the last visual line,
	        // since visual lines contain content order-consecutive chunks.
	        // Thus, in rtl, we are looking for the first (content-order) character
	        // in the rtl chunk that is on the last line (that is, the same line
	        // as the last (content-order) character).
	        if (part.level > 0 || cm.doc.direction == "rtl") {
	          var prep = prepareMeasureForLine(cm, lineObj);
	          ch = dir < 0 ? lineObj.text.length - 1 : 0;
	          var targetTop = measureCharPrepared(cm, prep, ch).top;
	          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);
	          if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1); }
	        } else { ch = dir < 0 ? part.to : part.from; }
	        return new Pos(lineNo, ch, sticky)
	      }
	    }
	    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
	  }
	
	  function moveVisually(cm, line, start, dir) {
	    var bidi = getOrder(line, cm.doc.direction);
	    if (!bidi) { return moveLogically(line, start, dir) }
	    if (start.ch >= line.text.length) {
	      start.ch = line.text.length;
	      start.sticky = "before";
	    } else if (start.ch <= 0) {
	      start.ch = 0;
	      start.sticky = "after";
	    }
	    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
	    if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
	      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
	      // nothing interesting happens.
	      return moveLogically(line, start, dir)
	    }
	
	    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };
	    var prep;
	    var getWrappedLineExtent = function (ch) {
	      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
	      prep = prep || prepareMeasureForLine(cm, line);
	      return wrappedLineExtentChar(cm, line, prep, ch)
	    };
	    var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);
	
	    if (cm.doc.direction == "rtl" || part.level == 1) {
	      var moveInStorageOrder = (part.level == 1) == (dir < 0);
	      var ch = mv(start, moveInStorageOrder ? 1 : -1);
	      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
	        // Case 2: We move within an rtl part or in an rtl editor on the same visual line
	        var sticky = moveInStorageOrder ? "before" : "after";
	        return new Pos(start.line, ch, sticky)
	      }
	    }
	
	    // Case 3: Could not move within this bidi part in this visual line, so leave
	    // the current bidi part
	
	    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
	      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
	        ? new Pos(start.line, mv(ch, 1), "before")
	        : new Pos(start.line, ch, "after"); };
	
	      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
	        var part = bidi[partPos];
	        var moveInStorageOrder = (dir > 0) == (part.level != 1);
	        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
	        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
	        ch = moveInStorageOrder ? part.from : mv(part.to, -1);
	        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
	      }
	    };
	
	    // Case 3a: Look for other bidi parts on the same visual line
	    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
	    if (res) { return res }
	
	    // Case 3b: Look for other bidi parts on the next visual line
	    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
	    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
	      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
	      if (res) { return res }
	    }
	
	    // Case 4: Nowhere to move
	    return null
	  }
	
	  // Commands are parameter-less actions that can be performed on an
	  // editor, mostly used for keybindings.
	  var commands = {
	    selectAll: selectAll,
	    singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
	    killLine: function (cm) { return deleteNearSelection(cm, function (range) {
	      if (range.empty()) {
	        var len = getLine(cm.doc, range.head.line).text.length;
	        if (range.head.ch == len && range.head.line < cm.lastLine())
	          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
	        else
	          { return {from: range.head, to: Pos(range.head.line, len)} }
	      } else {
	        return {from: range.from(), to: range.to()}
	      }
	    }); },
	    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
	      from: Pos(range.from().line, 0),
	      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
	    }); }); },
	    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
	      from: Pos(range.from().line, 0), to: range.from()
	    }); }); },
	    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
	      var top = cm.charCoords(range.head, "div").top + 5;
	      var leftPos = cm.coordsChar({left: 0, top: top}, "div");
	      return {from: leftPos, to: range.from()}
	    }); },
	    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
	      var top = cm.charCoords(range.head, "div").top + 5;
	      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
	      return {from: range.from(), to: rightPos }
	    }); },
	    undo: function (cm) { return cm.undo(); },
	    redo: function (cm) { return cm.redo(); },
	    undoSelection: function (cm) { return cm.undoSelection(); },
	    redoSelection: function (cm) { return cm.redoSelection(); },
	    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
	    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
	    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
	      {origin: "+move", bias: 1}
	    ); },
	    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
	      {origin: "+move", bias: 1}
	    ); },
	    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
	      {origin: "+move", bias: -1}
	    ); },
	    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
	      var top = cm.cursorCoords(range.head, "div").top + 5;
	      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
	    }, sel_move); },
	    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
	      var top = cm.cursorCoords(range.head, "div").top + 5;
	      return cm.coordsChar({left: 0, top: top}, "div")
	    }, sel_move); },
	    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
	      var top = cm.cursorCoords(range.head, "div").top + 5;
	      var pos = cm.coordsChar({left: 0, top: top}, "div");
	      if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
	      return pos
	    }, sel_move); },
	    goLineUp: function (cm) { return cm.moveV(-1, "line"); },
	    goLineDown: function (cm) { return cm.moveV(1, "line"); },
	    goPageUp: function (cm) { return cm.moveV(-1, "page"); },
	    goPageDown: function (cm) { return cm.moveV(1, "page"); },
	    goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
	    goCharRight: function (cm) { return cm.moveH(1, "char"); },
	    goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
	    goColumnRight: function (cm) { return cm.moveH(1, "column"); },
	    goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
	    goGroupRight: function (cm) { return cm.moveH(1, "group"); },
	    goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
	    goWordRight: function (cm) { return cm.moveH(1, "word"); },
	    delCharBefore: function (cm) { return cm.deleteH(-1, "char"); },
	    delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
	    delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
	    delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
	    delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
	    delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
	    indentAuto: function (cm) { return cm.indentSelection("smart"); },
	    indentMore: function (cm) { return cm.indentSelection("add"); },
	    indentLess: function (cm) { return cm.indentSelection("subtract"); },
	    insertTab: function (cm) { return cm.replaceSelection("\t"); },
	    insertSoftTab: function (cm) {
	      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
	      for (var i = 0; i < ranges.length; i++) {
	        var pos = ranges[i].from();
	        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
	        spaces.push(spaceStr(tabSize - col % tabSize));
	      }
	      cm.replaceSelections(spaces);
	    },
	    defaultTab: function (cm) {
	      if (cm.somethingSelected()) { cm.indentSelection("add"); }
	      else { cm.execCommand("insertTab"); }
	    },
	    // Swap the two chars left and right of each selection's head.
	    // Move cursor behind the two swapped characters afterwards.
	    //
	    // Doesn't consider line feeds a character.
	    // Doesn't scan more than one line above to find a character.
	    // Doesn't do anything on an empty line.
	    // Doesn't do anything with non-empty selections.
	    transposeChars: function (cm) { return runInOp(cm, function () {
	      var ranges = cm.listSelections(), newSel = [];
	      for (var i = 0; i < ranges.length; i++) {
	        if (!ranges[i].empty()) { continue }
	        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
	        if (line) {
	          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }
	          if (cur.ch > 0) {
	            cur = new Pos(cur.line, cur.ch + 1);
	            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
	                            Pos(cur.line, cur.ch - 2), cur, "+transpose");
	          } else if (cur.line > cm.doc.first) {
	            var prev = getLine(cm.doc, cur.line - 1).text;
	            if (prev) {
	              cur = new Pos(cur.line, 1);
	              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
	                              prev.charAt(prev.length - 1),
	                              Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
	            }
	          }
	        }
	        newSel.push(new Range(cur, cur));
	      }
	      cm.setSelections(newSel);
	    }); },
	    newlineAndIndent: function (cm) { return runInOp(cm, function () {
	      var sels = cm.listSelections();
	      for (var i = sels.length - 1; i >= 0; i--)
	        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }
	      sels = cm.listSelections();
	      for (var i$1 = 0; i$1 < sels.length; i$1++)
	        { cm.indentLine(sels[i$1].from().line, null, true); }
	      ensureCursorVisible(cm);
	    }); },
	    openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
	    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
	  };
	
	
	  function lineStart(cm, lineN) {
	    var line = getLine(cm.doc, lineN);
	    var visual = visualLine(line);
	    if (visual != line) { lineN = lineNo(visual); }
	    return endOfLine(true, cm, visual, lineN, 1)
	  }
	  function lineEnd(cm, lineN) {
	    var line = getLine(cm.doc, lineN);
	    var visual = visualLineEnd(line);
	    if (visual != line) { lineN = lineNo(visual); }
	    return endOfLine(true, cm, line, lineN, -1)
	  }
	  function lineStartSmart(cm, pos) {
	    var start = lineStart(cm, pos.line);
	    var line = getLine(cm.doc, start.line);
	    var order = getOrder(line, cm.doc.direction);
	    if (!order || order[0].level == 0) {
	      var firstNonWS = Math.max(start.ch, line.text.search(/\S/));
	      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
	      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
	    }
	    return start
	  }
	
	  // Run a handler that was bound to a key.
	  function doHandleBinding(cm, bound, dropShift) {
	    if (typeof bound == "string") {
	      bound = commands[bound];
	      if (!bound) { return false }
	    }
	    // Ensure previous input has been read, so that the handler sees a
	    // consistent view of the document
	    cm.display.input.ensurePolled();
	    var prevShift = cm.display.shift, done = false;
	    try {
	      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
	      if (dropShift) { cm.display.shift = false; }
	      done = bound(cm) != Pass;
	    } finally {
	      cm.display.shift = prevShift;
	      cm.state.suppressEdits = false;
	    }
	    return done
	  }
	
	  function lookupKeyForEditor(cm, name, handle) {
	    for (var i = 0; i < cm.state.keyMaps.length; i++) {
	      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
	      if (result) { return result }
	    }
	    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
	      || lookupKey(name, cm.options.keyMap, handle, cm)
	  }
	
	  // Note that, despite the name, this function is also used to check
	  // for bound mouse clicks.
	
	  var stopSeq = new Delayed;
	
	  function dispatchKey(cm, name, e, handle) {
	    var seq = cm.state.keySeq;
	    if (seq) {
	      if (isModifierKey(name)) { return "handled" }
	      if (/\'$/.test(name))
	        { cm.state.keySeq = null; }
	      else
	        { stopSeq.set(50, function () {
	          if (cm.state.keySeq == seq) {
	            cm.state.keySeq = null;
	            cm.display.input.reset();
	          }
	        }); }
	      if (dispatchKeyInner(cm, seq + " " + name, e, handle)) { return true }
	    }
	    return dispatchKeyInner(cm, name, e, handle)
	  }
	
	  function dispatchKeyInner(cm, name, e, handle) {
	    var result = lookupKeyForEditor(cm, name, handle);
	
	    if (result == "multi")
	      { cm.state.keySeq = name; }
	    if (result == "handled")
	      { signalLater(cm, "keyHandled", cm, name, e); }
	
	    if (result == "handled" || result == "multi") {
	      e_preventDefault(e);
	      restartBlink(cm);
	    }
	
	    return !!result
	  }
	
	  // Handle a key from the keydown event.
	  function handleKeyBinding(cm, e) {
	    var name = keyName(e, true);
	    if (!name) { return false }
	
	    if (e.shiftKey && !cm.state.keySeq) {
	      // First try to resolve full name (including 'Shift-'). Failing
	      // that, see if there is a cursor-motion command (starting with
	      // 'go') bound to the keyname without 'Shift-'.
	      return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
	          || dispatchKey(cm, name, e, function (b) {
	               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
	                 { return doHandleBinding(cm, b) }
	             })
	    } else {
	      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
	    }
	  }
	
	  // Handle a key from the keypress event
	  function handleCharBinding(cm, e, ch) {
	    return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
	  }
	
	  var lastStoppedKey = null;
	  function onKeyDown(e) {
	    var cm = this;
	    cm.curOp.focus = activeElt();
	    if (signalDOMEvent(cm, e)) { return }
	    // IE does strange things with escape.
	    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }
	    var code = e.keyCode;
	    cm.display.shift = code == 16 || e.shiftKey;
	    var handled = handleKeyBinding(cm, e);
	    if (presto) {
	      lastStoppedKey = handled ? code : null;
	      // Opera has no cut event... we try to at least catch the key combo
	      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
	        { cm.replaceSelection("", null, "cut"); }
	    }
	    if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand)
	      { document.execCommand("cut"); }
	
	    // Turn mouse into crosshair when Alt is held on Mac.
	    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
	      { showCrossHair(cm); }
	  }
	
	  function showCrossHair(cm) {
	    var lineDiv = cm.display.lineDiv;
	    addClass(lineDiv, "CodeMirror-crosshair");
	
	    function up(e) {
	      if (e.keyCode == 18 || !e.altKey) {
	        rmClass(lineDiv, "CodeMirror-crosshair");
	        off(document, "keyup", up);
	        off(document, "mouseover", up);
	      }
	    }
	    on(document, "keyup", up);
	    on(document, "mouseover", up);
	  }
	
	  function onKeyUp(e) {
	    if (e.keyCode == 16) { this.doc.sel.shift = false; }
	    signalDOMEvent(this, e);
	  }
	
	  function onKeyPress(e) {
	    var cm = this;
	    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
	    var keyCode = e.keyCode, charCode = e.charCode;
	    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
	    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
	    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
	    // Some browsers fire keypress events for backspace
	    if (ch == "\x08") { return }
	    if (handleCharBinding(cm, e, ch)) { return }
	    cm.display.input.onKeyPress(e);
	  }
	
	  var DOUBLECLICK_DELAY = 400;
	
	  var PastClick = function(time, pos, button) {
	    this.time = time;
	    this.pos = pos;
	    this.button = button;
	  };
	
	  PastClick.prototype.compare = function (time, pos, button) {
	    return this.time + DOUBLECLICK_DELAY > time &&
	      cmp(pos, this.pos) == 0 && button == this.button
	  };
	
	  var lastClick, lastDoubleClick;
	  function clickRepeat(pos, button) {
	    var now = +new Date;
	    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
	      lastClick = lastDoubleClick = null;
	      return "triple"
	    } else if (lastClick && lastClick.compare(now, pos, button)) {
	      lastDoubleClick = new PastClick(now, pos, button);
	      lastClick = null;
	      return "double"
	    } else {
	      lastClick = new PastClick(now, pos, button);
	      lastDoubleClick = null;
	      return "single"
	    }
	  }
	
	  // A mouse down can be a single click, double click, triple click,
	  // start of selection drag, start of text drag, new cursor
	  // (ctrl-click), rectangle drag (alt-drag), or xwin
	  // middle-click-paste. Or it might be a click on something we should
	  // not interfere with, such as a scrollbar or widget.
	  function onMouseDown(e) {
	    var cm = this, display = cm.display;
	    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
	    display.input.ensurePolled();
	    display.shift = e.shiftKey;
	
	    if (eventInWidget(display, e)) {
	      if (!webkit) {
	        // Briefly turn off draggability, to allow widgets to do
	        // normal dragging things.
	        display.scroller.draggable = false;
	        setTimeout(function () { return display.scroller.draggable = true; }, 100);
	      }
	      return
	    }
	    if (clickInGutter(cm, e)) { return }
	    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
	    window.focus();
	
	    // #3261: make sure, that we're not starting a second selection
	    if (button == 1 && cm.state.selectingText)
	      { cm.state.selectingText(e); }
	
	    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }
	
	    if (button == 1) {
	      if (pos) { leftButtonDown(cm, pos, repeat, e); }
	      else if (e_target(e) == display.scroller) { e_preventDefault(e); }
	    } else if (button == 2) {
	      if (pos) { extendSelection(cm.doc, pos); }
	      setTimeout(function () { return display.input.focus(); }, 20);
	    } else if (button == 3) {
	      if (captureRightClick) { cm.display.input.onContextMenu(e); }
	      else { delayBlurEvent(cm); }
	    }
	  }
	
	  function handleMappedButton(cm, button, pos, repeat, event) {
	    var name = "Click";
	    if (repeat == "double") { name = "Double" + name; }
	    else if (repeat == "triple") { name = "Triple" + name; }
	    name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;
	
	    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {
	      if (typeof bound == "string") { bound = commands[bound]; }
	      if (!bound) { return false }
	      var done = false;
	      try {
	        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
	        done = bound(cm, pos) != Pass;
	      } finally {
	        cm.state.suppressEdits = false;
	      }
	      return done
	    })
	  }
	
	  function configureMouse(cm, repeat, event) {
	    var option = cm.getOption("configureMouse");
	    var value = option ? option(cm, repeat, event) : {};
	    if (value.unit == null) {
	      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
	      value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
	    }
	    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }
	    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }
	    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }
	    return value
	  }
	
	  function leftButtonDown(cm, pos, repeat, event) {
	    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }
	    else { cm.curOp.focus = activeElt(); }
	
	    var behavior = configureMouse(cm, repeat, event);
	
	    var sel = cm.doc.sel, contained;
	    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
	        repeat == "single" && (contained = sel.contains(pos)) > -1 &&
	        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&
	        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))
	      { leftButtonStartDrag(cm, event, pos, behavior); }
	    else
	      { leftButtonSelect(cm, event, pos, behavior); }
	  }
	
	  // Start a text drag. When it ends, see if any dragging actually
	  // happen, and treat as a click if it didn't.
	  function leftButtonStartDrag(cm, event, pos, behavior) {
	    var display = cm.display, moved = false;
	    var dragEnd = operation(cm, function (e) {
	      if (webkit) { display.scroller.draggable = false; }
	      cm.state.draggingText = false;
	      off(display.wrapper.ownerDocument, "mouseup", dragEnd);
	      off(display.wrapper.ownerDocument, "mousemove", mouseMove);
	      off(display.scroller, "dragstart", dragStart);
	      off(display.scroller, "drop", dragEnd);
	      if (!moved) {
	        e_preventDefault(e);
	        if (!behavior.addNew)
	          { extendSelection(cm.doc, pos, null, null, behavior.extend); }
	        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
	        if (webkit || ie && ie_version == 9)
	          { setTimeout(function () {display.wrapper.ownerDocument.body.focus(); display.input.focus();}, 20); }
	        else
	          { display.input.focus(); }
	      }
	    });
	    var mouseMove = function(e2) {
	      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
	    };
	    var dragStart = function () { return moved = true; };
	    // Let the drag handler handle this.
	    if (webkit) { display.scroller.draggable = true; }
	    cm.state.draggingText = dragEnd;
	    dragEnd.copy = !behavior.moveOnDrag;
	    // IE's approach to draggable
	    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }
	    on(display.wrapper.ownerDocument, "mouseup", dragEnd);
	    on(display.wrapper.ownerDocument, "mousemove", mouseMove);
	    on(display.scroller, "dragstart", dragStart);
	    on(display.scroller, "drop", dragEnd);
	
	    delayBlurEvent(cm);
	    setTimeout(function () { return display.input.focus(); }, 20);
	  }
	
	  function rangeForUnit(cm, pos, unit) {
	    if (unit == "char") { return new Range(pos, pos) }
	    if (unit == "word") { return cm.findWordAt(pos) }
	    if (unit == "line") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
	    var result = unit(cm, pos);
	    return new Range(result.from, result.to)
	  }
	
	  // Normal selection, as opposed to text dragging.
	  function leftButtonSelect(cm, event, start, behavior) {
	    var display = cm.display, doc = cm.doc;
	    e_preventDefault(event);
	
	    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
	    if (behavior.addNew && !behavior.extend) {
	      ourIndex = doc.sel.contains(start);
	      if (ourIndex > -1)
	        { ourRange = ranges[ourIndex]; }
	      else
	        { ourRange = new Range(start, start); }
	    } else {
	      ourRange = doc.sel.primary();
	      ourIndex = doc.sel.primIndex;
	    }
	
	    if (behavior.unit == "rectangle") {
	      if (!behavior.addNew) { ourRange = new Range(start, start); }
	      start = posFromMouse(cm, event, true, true);
	      ourIndex = -1;
	    } else {
	      var range = rangeForUnit(cm, start, behavior.unit);
	      if (behavior.extend)
	        { ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend); }
	      else
	        { ourRange = range; }
	    }
	
	    if (!behavior.addNew) {
	      ourIndex = 0;
	      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
	      startSel = doc.sel;
	    } else if (ourIndex == -1) {
	      ourIndex = ranges.length;
	      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),
	                   {scroll: false, origin: "*mouse"});
	    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
	      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
	                   {scroll: false, origin: "*mouse"});
	      startSel = doc.sel;
	    } else {
	      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
	    }
	
	    var lastPos = start;
	    function extendTo(pos) {
	      if (cmp(lastPos, pos) == 0) { return }
	      lastPos = pos;
	
	      if (behavior.unit == "rectangle") {
	        var ranges = [], tabSize = cm.options.tabSize;
	        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
	        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
	        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
	        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
	             line <= end; line++) {
	          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
	          if (left == right)
	            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }
	          else if (text.length > leftPos)
	            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }
	        }
	        if (!ranges.length) { ranges.push(new Range(start, start)); }
	        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
	                     {origin: "*mouse", scroll: false});
	        cm.scrollIntoView(pos);
	      } else {
	        var oldRange = ourRange;
	        var range = rangeForUnit(cm, pos, behavior.unit);
	        var anchor = oldRange.anchor, head;
	        if (cmp(range.anchor, anchor) > 0) {
	          head = range.head;
	          anchor = minPos(oldRange.from(), range.anchor);
	        } else {
	          head = range.anchor;
	          anchor = maxPos(oldRange.to(), range.head);
	        }
	        var ranges$1 = startSel.ranges.slice(0);
	        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
	        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
	      }
	    }
	
	    var editorSize = display.wrapper.getBoundingClientRect();
	    // Used to ensure timeout re-tries don't fire when another extend
	    // happened in the meantime (clearTimeout isn't reliable -- at
	    // least on Chrome, the timeouts still happen even when cleared,
	    // if the clear happens after their scheduled firing time).
	    var counter = 0;
	
	    function extend(e) {
	      var curCount = ++counter;
	      var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
	      if (!cur) { return }
	      if (cmp(cur, lastPos) != 0) {
	        cm.curOp.focus = activeElt();
	        extendTo(cur);
	        var visible = visibleLines(display, doc);
	        if (cur.line >= visible.to || cur.line < visible.from)
	          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }
	      } else {
	        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
	        if (outside) { setTimeout(operation(cm, function () {
	          if (counter != curCount) { return }
	          display.scroller.scrollTop += outside;
	          extend(e);
	        }), 50); }
	      }
	    }
	
	    function done(e) {
	      cm.state.selectingText = false;
	      counter = Infinity;
	      // If e is null or undefined we interpret this as someone trying
	      // to explicitly cancel the selection rather than the user
	      // letting go of the mouse button.
	      if (e) {
	        e_preventDefault(e);
	        display.input.focus();
	      }
	      off(display.wrapper.ownerDocument, "mousemove", move);
	      off(display.wrapper.ownerDocument, "mouseup", up);
	      doc.history.lastSelOrigin = null;
	    }
	
	    var move = operation(cm, function (e) {
	      if (e.buttons === 0 || !e_button(e)) { done(e); }
	      else { extend(e); }
	    });
	    var up = operation(cm, done);
	    cm.state.selectingText = up;
	    on(display.wrapper.ownerDocument, "mousemove", move);
	    on(display.wrapper.ownerDocument, "mouseup", up);
	  }
	
	  // Used when mouse-selecting to adjust the anchor to the proper side
	  // of a bidi jump depending on the visual position of the head.
	  function bidiSimplify(cm, range) {
	    var anchor = range.anchor;
	    var head = range.head;
	    var anchorLine = getLine(cm.doc, anchor.line);
	    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range }
	    var order = getOrder(anchorLine);
	    if (!order) { return range }
	    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
	    if (part.from != anchor.ch && part.to != anchor.ch) { return range }
	    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);
	    if (boundary == 0 || boundary == order.length) { return range }
	
	    // Compute the relative visual position of the head compared to the
	    // anchor (<0 is to the left, >0 to the right)
	    var leftSide;
	    if (head.line != anchor.line) {
	      leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
	    } else {
	      var headIndex = getBidiPartAt(order, head.ch, head.sticky);
	      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
	      if (headIndex == boundary - 1 || headIndex == boundary)
	        { leftSide = dir < 0; }
	      else
	        { leftSide = dir > 0; }
	    }
	
	    var usePart = order[boundary + (leftSide ? -1 : 0)];
	    var from = leftSide == (usePart.level == 1);
	    var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
	    return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head)
	  }
	
	
	  // Determines whether an event happened in the gutter, and fires the
	  // handlers for the corresponding event.
	  function gutterEvent(cm, e, type, prevent) {
	    var mX, mY;
	    if (e.touches) {
	      mX = e.touches[0].clientX;
	      mY = e.touches[0].clientY;
	    } else {
	      try { mX = e.clientX; mY = e.clientY; }
	      catch(e) { return false }
	    }
	    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
	    if (prevent) { e_preventDefault(e); }
	
	    var display = cm.display;
	    var lineBox = display.lineDiv.getBoundingClientRect();
	
	    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
	    mY -= lineBox.top - display.viewOffset;
	
	    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {
	      var g = display.gutters.childNodes[i];
	      if (g && g.getBoundingClientRect().right >= mX) {
	        var line = lineAtHeight(cm.doc, mY);
	        var gutter = cm.display.gutterSpecs[i];
	        signal(cm, type, cm, line, gutter.className, e);
	        return e_defaultPrevented(e)
	      }
	    }
	  }
	
	  function clickInGutter(cm, e) {
	    return gutterEvent(cm, e, "gutterClick", true)
	  }
	
	  // CONTEXT MENU HANDLING
	
	  // To make the context menu work, we need to briefly unhide the
	  // textarea (making it as unobtrusive as possible) to let the
	  // right-click take effect on it.
	  function onContextMenu(cm, e) {
	    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
	    if (signalDOMEvent(cm, e, "contextmenu")) { return }
	    if (!captureRightClick) { cm.display.input.onContextMenu(e); }
	  }
	
	  function contextMenuInGutter(cm, e) {
	    if (!hasHandler(cm, "gutterContextMenu")) { return false }
	    return gutterEvent(cm, e, "gutterContextMenu", false)
	  }
	
	  function themeChanged(cm) {
	    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
	      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
	    clearCaches(cm);
	  }
	
	  var Init = {toString: function(){return "CodeMirror.Init"}};
	
	  var defaults = {};
	  var optionHandlers = {};
	
	  function defineOptions(CodeMirror) {
	    var optionHandlers = CodeMirror.optionHandlers;
	
	    function option(name, deflt, handle, notOnInit) {
	      CodeMirror.defaults[name] = deflt;
	      if (handle) { optionHandlers[name] =
	        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }
	    }
	
	    CodeMirror.defineOption = option;
	
	    // Passed to option handlers when there is no old value.
	    CodeMirror.Init = Init;
	
	    // These two are, on init, called from the constructor because they
	    // have to be initialized before the editor can start at all.
	    option("value", "", function (cm, val) { return cm.setValue(val); }, true);
	    option("mode", null, function (cm, val) {
	      cm.doc.modeOption = val;
	      loadMode(cm);
	    }, true);
	
	    option("indentUnit", 2, loadMode, true);
	    option("indentWithTabs", false);
	    option("smartIndent", true);
	    option("tabSize", 4, function (cm) {
	      resetModeState(cm);
	      clearCaches(cm);
	      regChange(cm);
	    }, true);
	
	    option("lineSeparator", null, function (cm, val) {
	      cm.doc.lineSep = val;
	      if (!val) { return }
	      var newBreaks = [], lineNo = cm.doc.first;
	      cm.doc.iter(function (line) {
	        for (var pos = 0;;) {
	          var found = line.text.indexOf(val, pos);
	          if (found == -1) { break }
	          pos = found + val.length;
	          newBreaks.push(Pos(lineNo, found));
	        }
	        lineNo++;
	      });
	      for (var i = newBreaks.length - 1; i >= 0; i--)
	        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }
	    });
	    option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function (cm, val, old) {
	      cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
	      if (old != Init) { cm.refresh(); }
	    });
	    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);
	    option("electricChars", true);
	    option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
	      throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
	    }, true);
	    option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);
	    option("autocorrect", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);
	    option("autocapitalize", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);
	    option("rtlMoveVisually", !windows);
	    option("wholeLineUpdateBefore", true);
	
	    option("theme", "default", function (cm) {
	      themeChanged(cm);
	      updateGutters(cm);
	    }, true);
	    option("keyMap", "default", function (cm, val, old) {
	      var next = getKeyMap(val);
	      var prev = old != Init && getKeyMap(old);
	      if (prev && prev.detach) { prev.detach(cm, next); }
	      if (next.attach) { next.attach(cm, prev || null); }
	    });
	    option("extraKeys", null);
	    option("configureMouse", null);
	
	    option("lineWrapping", false, wrappingChanged, true);
	    option("gutters", [], function (cm, val) {
	      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
	      updateGutters(cm);
	    }, true);
	    option("fixedGutter", true, function (cm, val) {
	      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
	      cm.refresh();
	    }, true);
	    option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);
	    option("scrollbarStyle", "native", function (cm) {
	      initScrollbars(cm);
	      updateScrollbars(cm);
	      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
	      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
	    }, true);
	    option("lineNumbers", false, function (cm, val) {
	      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
	      updateGutters(cm);
	    }, true);
	    option("firstLineNumber", 1, updateGutters, true);
	    option("lineNumberFormatter", function (integer) { return integer; }, updateGutters, true);
	    option("showCursorWhenSelecting", false, updateSelection, true);
	
	    option("resetSelectionOnContextMenu", true);
	    option("lineWiseCopyCut", true);
	    option("pasteLinesPerSelection", true);
	    option("selectionsMayTouch", false);
	
	    option("readOnly", false, function (cm, val) {
	      if (val == "nocursor") {
	        onBlur(cm);
	        cm.display.input.blur();
	      }
	      cm.display.input.readOnlyChanged(val);
	    });
	    option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);
	    option("dragDrop", true, dragDropChanged);
	    option("allowDropFileTypes", null);
	
	    option("cursorBlinkRate", 530);
	    option("cursorScrollMargin", 0);
	    option("cursorHeight", 1, updateSelection, true);
	    option("singleCursorHeightPerLine", true, updateSelection, true);
	    option("workTime", 100);
	    option("workDelay", 100);
	    option("flattenSpans", true, resetModeState, true);
	    option("addModeClass", false, resetModeState, true);
	    option("pollInterval", 100);
	    option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });
	    option("historyEventDelay", 1250);
	    option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);
	    option("maxHighlightLength", 10000, resetModeState, true);
	    option("moveInputWithCursor", true, function (cm, val) {
	      if (!val) { cm.display.input.resetPosition(); }
	    });
	
	    option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });
	    option("autofocus", null);
	    option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);
	    option("phrases", null);
	  }
	
	  function dragDropChanged(cm, value, old) {
	    var wasOn = old && old != Init;
	    if (!value != !wasOn) {
	      var funcs = cm.display.dragFunctions;
	      var toggle = value ? on : off;
	      toggle(cm.display.scroller, "dragstart", funcs.start);
	      toggle(cm.display.scroller, "dragenter", funcs.enter);
	      toggle(cm.display.scroller, "dragover", funcs.over);
	      toggle(cm.display.scroller, "dragleave", funcs.leave);
	      toggle(cm.display.scroller, "drop", funcs.drop);
	    }
	  }
	
	  function wrappingChanged(cm) {
	    if (cm.options.lineWrapping) {
	      addClass(cm.display.wrapper, "CodeMirror-wrap");
	      cm.display.sizer.style.minWidth = "";
	      cm.display.sizerWidth = null;
	    } else {
	      rmClass(cm.display.wrapper, "CodeMirror-wrap");
	      findMaxLine(cm);
	    }
	    estimateLineHeights(cm);
	    regChange(cm);
	    clearCaches(cm);
	    setTimeout(function () { return updateScrollbars(cm); }, 100);
	  }
	
	  // A CodeMirror instance represents an editor. This is the object
	  // that user code is usually dealing with.
	
	  function CodeMirror(place, options) {
	    var this$1 = this;
	
	    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }
	
	    this.options = options = options ? copyObj(options) : {};
	    // Determine effective options based on given values and defaults.
	    copyObj(defaults, options, false);
	
	    var doc = options.value;
	    if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }
	    else if (options.mode) { doc.modeOption = options.mode; }
	    this.doc = doc;
	
	    var input = new CodeMirror.inputStyles[options.inputStyle](this);
	    var display = this.display = new Display(place, doc, input, options);
	    display.wrapper.CodeMirror = this;
	    themeChanged(this);
	    if (options.lineWrapping)
	      { this.display.wrapper.className += " CodeMirror-wrap"; }
	    initScrollbars(this);
	
	    this.state = {
	      keyMaps: [],  // stores maps added by addKeyMap
	      overlays: [], // highlighting overlays, as added by addOverlay
	      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
	      overwrite: false,
	      delayingBlurEvent: false,
	      focused: false,
	      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
	      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll
	      selectingText: false,
	      draggingText: false,
	      highlight: new Delayed(), // stores highlight worker timeout
	      keySeq: null,  // Unfinished key sequence
	      specialChars: null
	    };
	
	    if (options.autofocus && !mobile) { display.input.focus(); }
	
	    // Override magic textarea content restore that IE sometimes does
	    // on our hidden textarea on reload
	    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }
	
	    registerEventHandlers(this);
	    ensureGlobalHandlers();
	
	    startOperation(this);
	    this.curOp.forceUpdate = true;
	    attachDoc(this, doc);
	
	    if ((options.autofocus && !mobile) || this.hasFocus())
	      { setTimeout(bind(onFocus, this), 20); }
	    else
	      { onBlur(this); }
	
	    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
	      { optionHandlers[opt](this, options[opt], Init); } }
	    maybeUpdateLineNumberWidth(this);
	    if (options.finishInit) { options.finishInit(this); }
	    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this); }
	    endOperation(this);
	    // Suppress optimizelegibility in Webkit, since it breaks text
	    // measuring on line wrapping boundaries.
	    if (webkit && options.lineWrapping &&
	        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
	      { display.lineDiv.style.textRendering = "auto"; }
	  }
	
	  // The default configuration options.
	  CodeMirror.defaults = defaults;
	  // Functions to run when options are changed.
	  CodeMirror.optionHandlers = optionHandlers;
	
	  // Attach the necessary event handlers when initializing the editor
	  function registerEventHandlers(cm) {
	    var d = cm.display;
	    on(d.scroller, "mousedown", operation(cm, onMouseDown));
	    // Older IE's will not fire a second mousedown for a double click
	    if (ie && ie_version < 11)
	      { on(d.scroller, "dblclick", operation(cm, function (e) {
	        if (signalDOMEvent(cm, e)) { return }
	        var pos = posFromMouse(cm, e);
	        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
	        e_preventDefault(e);
	        var word = cm.findWordAt(pos);
	        extendSelection(cm.doc, word.anchor, word.head);
	      })); }
	    else
	      { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }
	    // Some browsers fire contextmenu *after* opening the menu, at
	    // which point we can't mess with it anymore. Context menu is
	    // handled in onMouseDown for these browsers.
	    on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); });
	    on(d.input.getField(), "contextmenu", function (e) {
	      if (!d.scroller.contains(e.target)) { onContextMenu(cm, e); }
	    });
	
	    // Used to suppress mouse event handling when a touch happens
	    var touchFinished, prevTouch = {end: 0};
	    function finishTouch() {
	      if (d.activeTouch) {
	        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);
	        prevTouch = d.activeTouch;
	        prevTouch.end = +new Date;
	      }
	    }
	    function isMouseLikeTouchEvent(e) {
	      if (e.touches.length != 1) { return false }
	      var touch = e.touches[0];
	      return touch.radiusX <= 1 && touch.radiusY <= 1
	    }
	    function farAway(touch, other) {
	      if (other.left == null) { return true }
	      var dx = other.left - touch.left, dy = other.top - touch.top;
	      return dx * dx + dy * dy > 20 * 20
	    }
	    on(d.scroller, "touchstart", function (e) {
	      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
	        d.input.ensurePolled();
	        clearTimeout(touchFinished);
	        var now = +new Date;
	        d.activeTouch = {start: now, moved: false,
	                         prev: now - prevTouch.end <= 300 ? prevTouch : null};
	        if (e.touches.length == 1) {
	          d.activeTouch.left = e.touches[0].pageX;
	          d.activeTouch.top = e.touches[0].pageY;
	        }
	      }
	    });
	    on(d.scroller, "touchmove", function () {
	      if (d.activeTouch) { d.activeTouch.moved = true; }
	    });
	    on(d.scroller, "touchend", function (e) {
	      var touch = d.activeTouch;
	      if (touch && !eventInWidget(d, e) && touch.left != null &&
	          !touch.moved && new Date - touch.start < 300) {
	        var pos = cm.coordsChar(d.activeTouch, "page"), range;
	        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
	          { range = new Range(pos, pos); }
	        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
	          { range = cm.findWordAt(pos); }
	        else // Triple tap
	          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }
	        cm.setSelection(range.anchor, range.head);
	        cm.focus();
	        e_preventDefault(e);
	      }
	      finishTouch();
	    });
	    on(d.scroller, "touchcancel", finishTouch);
	
	    // Sync scrolling between fake scrollbars and real scrollable
	    // area, ensure viewport is updated when scrolling.
	    on(d.scroller, "scroll", function () {
	      if (d.scroller.clientHeight) {
	        updateScrollTop(cm, d.scroller.scrollTop);
	        setScrollLeft(cm, d.scroller.scrollLeft, true);
	        signal(cm, "scroll", cm);
	      }
	    });
	
	    // Listen to wheel events in order to try and update the viewport on time.
	    on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });
	    on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });
	
	    // Prevent wrapper from ever scrolling
	    on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });
	
	    d.dragFunctions = {
	      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},
	      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
	      start: function (e) { return onDragStart(cm, e); },
	      drop: operation(cm, onDrop),
	      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
	    };
	
	    var inp = d.input.getField();
	    on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });
	    on(inp, "keydown", operation(cm, onKeyDown));
	    on(inp, "keypress", operation(cm, onKeyPress));
	    on(inp, "focus", function (e) { return onFocus(cm, e); });
	    on(inp, "blur", function (e) { return onBlur(cm, e); });
	  }
	
	  var initHooks = [];
	  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };
	
	  // Indent the given line. The how parameter can be "smart",
	  // "add"/null, "subtract", or "prev". When aggressive is false
	  // (typically set to true for forced single-line indents), empty
	  // lines are not indented, and places where the mode returns Pass
	  // are left alone.
	  function indentLine(cm, n, how, aggressive) {
	    var doc = cm.doc, state;
	    if (how == null) { how = "add"; }
	    if (how == "smart") {
	      // Fall back to "prev" when the mode doesn't have an indentation
	      // method.
	      if (!doc.mode.indent) { how = "prev"; }
	      else { state = getContextBefore(cm, n).state; }
	    }
	
	    var tabSize = cm.options.tabSize;
	    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
	    if (line.stateAfter) { line.stateAfter = null; }
	    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
	    if (!aggressive && !/\S/.test(line.text)) {
	      indentation = 0;
	      how = "not";
	    } else if (how == "smart") {
	      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
	      if (indentation == Pass || indentation > 150) {
	        if (!aggressive) { return }
	        how = "prev";
	      }
	    }
	    if (how == "prev") {
	      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }
	      else { indentation = 0; }
	    } else if (how == "add") {
	      indentation = curSpace + cm.options.indentUnit;
	    } else if (how == "subtract") {
	      indentation = curSpace - cm.options.indentUnit;
	    } else if (typeof how == "number") {
	      indentation = curSpace + how;
	    }
	    indentation = Math.max(0, indentation);
	
	    var indentString = "", pos = 0;
	    if (cm.options.indentWithTabs)
	      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";} }
	    if (pos < indentation) { indentString += spaceStr(indentation - pos); }
	
	    if (indentString != curSpaceString) {
	      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
	      line.stateAfter = null;
	      return true
	    } else {
	      // Ensure that, if the cursor was in the whitespace at the start
	      // of the line, it is moved to the end of that space.
	      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
	        var range = doc.sel.ranges[i$1];
	        if (range.head.line == n && range.head.ch < curSpaceString.length) {
	          var pos$1 = Pos(n, curSpaceString.length);
	          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
	          break
	        }
	      }
	    }
	  }
	
	  // This will be set to a {lineWise: bool, text: [string]} object, so
	  // that, when pasting, we know what kind of selections the copied
	  // text was made out of.
	  var lastCopied = null;
	
	  function setLastCopied(newLastCopied) {
	    lastCopied = newLastCopied;
	  }
	
	  function applyTextInput(cm, inserted, deleted, sel, origin) {
	    var doc = cm.doc;
	    cm.display.shift = false;
	    if (!sel) { sel = doc.sel; }
	
	    var recent = +new Date - 200;
	    var paste = origin == "paste" || cm.state.pasteIncoming > recent;
	    var textLines = splitLinesAuto(inserted), multiPaste = null;
	    // When pasting N lines into N selections, insert one line per selection
	    if (paste && sel.ranges.length > 1) {
	      if (lastCopied && lastCopied.text.join("\n") == inserted) {
	        if (sel.ranges.length % lastCopied.text.length == 0) {
	          multiPaste = [];
	          for (var i = 0; i < lastCopied.text.length; i++)
	            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }
	        }
	      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
	        multiPaste = map(textLines, function (l) { return [l]; });
	      }
	    }
	
	    var updateInput = cm.curOp.updateInput;
	    // Normal behavior is to insert the new text into every selection
	    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
	      var range = sel.ranges[i$1];
	      var from = range.from(), to = range.to();
	      if (range.empty()) {
	        if (deleted && deleted > 0) // Handle deletion
	          { from = Pos(from.line, from.ch - deleted); }
	        else if (cm.state.overwrite && !paste) // Handle overwrite
	          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }
	        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted)
	          { from = to = Pos(from.line, 0); }
	      }
	      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
	                         origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")};
	      makeChange(cm.doc, changeEvent);
	      signalLater(cm, "inputRead", cm, changeEvent);
	    }
	    if (inserted && !paste)
	      { triggerElectric(cm, inserted); }
	
	    ensureCursorVisible(cm);
	    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }
	    cm.curOp.typing = true;
	    cm.state.pasteIncoming = cm.state.cutIncoming = -1;
	  }
	
	  function handlePaste(e, cm) {
	    var pasted = e.clipboardData && e.clipboardData.getData("Text");
	    if (pasted) {
	      e.preventDefault();
	      if (!cm.isReadOnly() && !cm.options.disableInput)
	        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }
	      return true
	    }
	  }
	
	  function triggerElectric(cm, inserted) {
	    // When an 'electric' character is inserted, immediately trigger a reindent
	    if (!cm.options.electricChars || !cm.options.smartIndent) { return }
	    var sel = cm.doc.sel;
	
	    for (var i = sel.ranges.length - 1; i >= 0; i--) {
	      var range = sel.ranges[i];
	      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) { continue }
	      var mode = cm.getModeAt(range.head);
	      var indented = false;
	      if (mode.electricChars) {
	        for (var j = 0; j < mode.electricChars.length; j++)
	          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
	            indented = indentLine(cm, range.head.line, "smart");
	            break
	          } }
	      } else if (mode.electricInput) {
	        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))
	          { indented = indentLine(cm, range.head.line, "smart"); }
	      }
	      if (indented) { signalLater(cm, "electricInput", cm, range.head.line); }
	    }
	  }
	
	  function copyableRanges(cm) {
	    var text = [], ranges = [];
	    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
	      var line = cm.doc.sel.ranges[i].head.line;
	      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
	      ranges.push(lineRange);
	      text.push(cm.getRange(lineRange.anchor, lineRange.head));
	    }
	    return {text: text, ranges: ranges}
	  }
	
	  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
	    field.setAttribute("autocorrect", autocorrect ? "" : "off");
	    field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
	    field.setAttribute("spellcheck", !!spellcheck);
	  }
	
	  function hiddenTextarea() {
	    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
	    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
	    // The textarea is kept positioned near the cursor to prevent the
	    // fact that it'll be scrolled into view on input from scrolling
	    // our fake cursor out of view. On webkit, when wrap=off, paste is
	    // very slow. So make the area wide instead.
	    if (webkit) { te.style.width = "1000px"; }
	    else { te.setAttribute("wrap", "off"); }
	    // If border: 0; -- iOS fails to open keyboard (issue #1287)
	    if (ios) { te.style.border = "1px solid black"; }
	    disableBrowserMagic(te);
	    return div
	  }
	
	  // The publicly visible API. Note that methodOp(f) means
	  // 'wrap f in an operation, performed on its `this` parameter'.
	
	  // This is not the complete set of editor methods. Most of the
	  // methods defined on the Doc type are also injected into
	  // CodeMirror.prototype, for backwards compatibility and
	  // convenience.
	
	  function addEditorMethods(CodeMirror) {
	    var optionHandlers = CodeMirror.optionHandlers;
	
	    var helpers = CodeMirror.helpers = {};
	
	    CodeMirror.prototype = {
	      constructor: CodeMirror,
	      focus: function(){window.focus(); this.display.input.focus();},
	
	      setOption: function(option, value) {
	        var options = this.options, old = options[option];
	        if (options[option] == value && option != "mode") { return }
	        options[option] = value;
	        if (optionHandlers.hasOwnProperty(option))
	          { operation(this, optionHandlers[option])(this, value, old); }
	        signal(this, "optionChange", this, option);
	      },
	
	      getOption: function(option) {return this.options[option]},
	      getDoc: function() {return this.doc},
	
	      addKeyMap: function(map, bottom) {
	        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
	      },
	      removeKeyMap: function(map) {
	        var maps = this.state.keyMaps;
	        for (var i = 0; i < maps.length; ++i)
	          { if (maps[i] == map || maps[i].name == map) {
	            maps.splice(i, 1);
	            return true
	          } }
	      },
	
	      addOverlay: methodOp(function(spec, options) {
	        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
	        if (mode.startState) { throw new Error("Overlays may not be stateful.") }
	        insertSorted(this.state.overlays,
	                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,
	                      priority: (options && options.priority) || 0},
	                     function (overlay) { return overlay.priority; });
	        this.state.modeGen++;
	        regChange(this);
	      }),
	      removeOverlay: methodOp(function(spec) {
	        var overlays = this.state.overlays;
	        for (var i = 0; i < overlays.length; ++i) {
	          var cur = overlays[i].modeSpec;
	          if (cur == spec || typeof spec == "string" && cur.name == spec) {
	            overlays.splice(i, 1);
	            this.state.modeGen++;
	            regChange(this);
	            return
	          }
	        }
	      }),
	
	      indentLine: methodOp(function(n, dir, aggressive) {
	        if (typeof dir != "string" && typeof dir != "number") {
	          if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }
	          else { dir = dir ? "add" : "subtract"; }
	        }
	        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }
	      }),
	      indentSelection: methodOp(function(how) {
	        var ranges = this.doc.sel.ranges, end = -1;
	        for (var i = 0; i < ranges.length; i++) {
	          var range = ranges[i];
	          if (!range.empty()) {
	            var from = range.from(), to = range.to();
	            var start = Math.max(end, from.line);
	            end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
	            for (var j = start; j < end; ++j)
	              { indentLine(this, j, how); }
	            var newRanges = this.doc.sel.ranges;
	            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
	              { replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }
	          } else if (range.head.line > end) {
	            indentLine(this, range.head.line, how, true);
	            end = range.head.line;
	            if (i == this.doc.sel.primIndex) { ensureCursorVisible(this); }
	          }
	        }
	      }),
	
	      // Fetch the parser token for a given character. Useful for hacks
	      // that want to inspect the mode state (say, for completion).
	      getTokenAt: function(pos, precise) {
	        return takeToken(this, pos, precise)
	      },
	
	      getLineTokens: function(line, precise) {
	        return takeToken(this, Pos(line), precise, true)
	      },
	
	      getTokenTypeAt: function(pos) {
	        pos = clipPos(this.doc, pos);
	        var styles = getLineStyles(this, getLine(this.doc, pos.line));
	        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
	        var type;
	        if (ch == 0) { type = styles[2]; }
	        else { for (;;) {
	          var mid = (before + after) >> 1;
	          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }
	          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }
	          else { type = styles[mid * 2 + 2]; break }
	        } }
	        var cut = type ? type.indexOf("overlay ") : -1;
	        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
	      },
	
	      getModeAt: function(pos) {
	        var mode = this.doc.mode;
	        if (!mode.innerMode) { return mode }
	        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
	      },
	
	      getHelper: function(pos, type) {
	        return this.getHelpers(pos, type)[0]
	      },
	
	      getHelpers: function(pos, type) {
	        var found = [];
	        if (!helpers.hasOwnProperty(type)) { return found }
	        var help = helpers[type], mode = this.getModeAt(pos);
	        if (typeof mode[type] == "string") {
	          if (help[mode[type]]) { found.push(help[mode[type]]); }
	        } else if (mode[type]) {
	          for (var i = 0; i < mode[type].length; i++) {
	            var val = help[mode[type][i]];
	            if (val) { found.push(val); }
	          }
	        } else if (mode.helperType && help[mode.helperType]) {
	          found.push(help[mode.helperType]);
	        } else if (help[mode.name]) {
	          found.push(help[mode.name]);
	        }
	        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
	          var cur = help._global[i$1];
	          if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
	            { found.push(cur.val); }
	        }
	        return found
	      },
	
	      getStateAfter: function(line, precise) {
	        var doc = this.doc;
	        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
	        return getContextBefore(this, line + 1, precise).state
	      },
	
	      cursorCoords: function(start, mode) {
	        var pos, range = this.doc.sel.primary();
	        if (start == null) { pos = range.head; }
	        else if (typeof start == "object") { pos = clipPos(this.doc, start); }
	        else { pos = start ? range.from() : range.to(); }
	        return cursorCoords(this, pos, mode || "page")
	      },
	
	      charCoords: function(pos, mode) {
	        return charCoords(this, clipPos(this.doc, pos), mode || "page")
	      },
	
	      coordsChar: function(coords, mode) {
	        coords = fromCoordSystem(this, coords, mode || "page");
	        return coordsChar(this, coords.left, coords.top)
	      },
	
	      lineAtHeight: function(height, mode) {
	        height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
	        return lineAtHeight(this.doc, height + this.display.viewOffset)
	      },
	      heightAtLine: function(line, mode, includeWidgets) {
	        var end = false, lineObj;
	        if (typeof line == "number") {
	          var last = this.doc.first + this.doc.size - 1;
	          if (line < this.doc.first) { line = this.doc.first; }
	          else if (line > last) { line = last; end = true; }
	          lineObj = getLine(this.doc, line);
	        } else {
	          lineObj = line;
	        }
	        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +
	          (end ? this.doc.height - heightAtLine(lineObj) : 0)
	      },
	
	      defaultTextHeight: function() { return textHeight(this.display) },
	      defaultCharWidth: function() { return charWidth(this.display) },
	
	      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},
	
	      addWidget: function(pos, node, scroll, vert, horiz) {
	        var display = this.display;
	        pos = cursorCoords(this, clipPos(this.doc, pos));
	        var top = pos.bottom, left = pos.left;
	        node.style.position = "absolute";
	        node.setAttribute("cm-ignore-events", "true");
	        this.display.input.setUneditable(node);
	        display.sizer.appendChild(node);
	        if (vert == "over") {
	          top = pos.top;
	        } else if (vert == "above" || vert == "near") {
	          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
	          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
	          // Default to positioning above (if specified and possible); otherwise default to positioning below
	          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
	            { top = pos.top - node.offsetHeight; }
	          else if (pos.bottom + node.offsetHeight <= vspace)
	            { top = pos.bottom; }
	          if (left + node.offsetWidth > hspace)
	            { left = hspace - node.offsetWidth; }
	        }
	        node.style.top = top + "px";
	        node.style.left = node.style.right = "";
	        if (horiz == "right") {
	          left = display.sizer.clientWidth - node.offsetWidth;
	          node.style.right = "0px";
	        } else {
	          if (horiz == "left") { left = 0; }
	          else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }
	          node.style.left = left + "px";
	        }
	        if (scroll)
	          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }
	      },
	
	      triggerOnKeyDown: methodOp(onKeyDown),
	      triggerOnKeyPress: methodOp(onKeyPress),
	      triggerOnKeyUp: onKeyUp,
	      triggerOnMouseDown: methodOp(onMouseDown),
	
	      execCommand: function(cmd) {
	        if (commands.hasOwnProperty(cmd))
	          { return commands[cmd].call(null, this) }
	      },
	
	      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),
	
	      findPosH: function(from, amount, unit, visually) {
	        var dir = 1;
	        if (amount < 0) { dir = -1; amount = -amount; }
	        var cur = clipPos(this.doc, from);
	        for (var i = 0; i < amount; ++i) {
	          cur = findPosH(this.doc, cur, dir, unit, visually);
	          if (cur.hitSide) { break }
	        }
	        return cur
	      },
	
	      moveH: methodOp(function(dir, unit) {
	        var this$1 = this;
	
	        this.extendSelectionsBy(function (range) {
	          if (this$1.display.shift || this$1.doc.extend || range.empty())
	            { return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) }
	          else
	            { return dir < 0 ? range.from() : range.to() }
	        }, sel_move);
	      }),
	
	      deleteH: methodOp(function(dir, unit) {
	        var sel = this.doc.sel, doc = this.doc;
	        if (sel.somethingSelected())
	          { doc.replaceSelection("", null, "+delete"); }
	        else
	          { deleteNearSelection(this, function (range) {
	            var other = findPosH(doc, range.head, dir, unit, false);
	            return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other}
	          }); }
	      }),
	
	      findPosV: function(from, amount, unit, goalColumn) {
	        var dir = 1, x = goalColumn;
	        if (amount < 0) { dir = -1; amount = -amount; }
	        var cur = clipPos(this.doc, from);
	        for (var i = 0; i < amount; ++i) {
	          var coords = cursorCoords(this, cur, "div");
	          if (x == null) { x = coords.left; }
	          else { coords.left = x; }
	          cur = findPosV(this, coords, dir, unit);
	          if (cur.hitSide) { break }
	        }
	        return cur
	      },
	
	      moveV: methodOp(function(dir, unit) {
	        var this$1 = this;
	
	        var doc = this.doc, goals = [];
	        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
	        doc.extendSelectionsBy(function (range) {
	          if (collapse)
	            { return dir < 0 ? range.from() : range.to() }
	          var headPos = cursorCoords(this$1, range.head, "div");
	          if (range.goalColumn != null) { headPos.left = range.goalColumn; }
	          goals.push(headPos.left);
	          var pos = findPosV(this$1, headPos, dir, unit);
	          if (unit == "page" && range == doc.sel.primary())
	            { addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top); }
	          return pos
	        }, sel_move);
	        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
	          { doc.sel.ranges[i].goalColumn = goals[i]; } }
	      }),
	
	      // Find the word at the given position (as returned by coordsChar).
	      findWordAt: function(pos) {
	        var doc = this.doc, line = getLine(doc, pos.line).text;
	        var start = pos.ch, end = pos.ch;
	        if (line) {
	          var helper = this.getHelper(pos, "wordChars");
	          if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }
	          var startChar = line.charAt(start);
	          var check = isWordChar(startChar, helper)
	            ? function (ch) { return isWordChar(ch, helper); }
	            : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
	            : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); };
	          while (start > 0 && check(line.charAt(start - 1))) { --start; }
	          while (end < line.length && check(line.charAt(end))) { ++end; }
	        }
	        return new Range(Pos(pos.line, start), Pos(pos.line, end))
	      },
	
	      toggleOverwrite: function(value) {
	        if (value != null && value == this.state.overwrite) { return }
	        if (this.state.overwrite = !this.state.overwrite)
	          { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
	        else
	          { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
	
	        signal(this, "overwriteToggle", this, this.state.overwrite);
	      },
	      hasFocus: function() { return this.display.input.getField() == activeElt() },
	      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },
	
	      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),
	      getScrollInfo: function() {
	        var scroller = this.display.scroller;
	        return {left: scroller.scrollLeft, top: scroller.scrollTop,
	                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
	                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
	                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
	      },
	
	      scrollIntoView: methodOp(function(range, margin) {
	        if (range == null) {
	          range = {from: this.doc.sel.primary().head, to: null};
	          if (margin == null) { margin = this.options.cursorScrollMargin; }
	        } else if (typeof range == "number") {
	          range = {from: Pos(range, 0), to: null};
	        } else if (range.from == null) {
	          range = {from: range, to: null};
	        }
	        if (!range.to) { range.to = range.from; }
	        range.margin = margin || 0;
	
	        if (range.from.line != null) {
	          scrollToRange(this, range);
	        } else {
	          scrollToCoordsRange(this, range.from, range.to, range.margin);
	        }
	      }),
	
	      setSize: methodOp(function(width, height) {
	        var this$1 = this;
	
	        var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; };
	        if (width != null) { this.display.wrapper.style.width = interpret(width); }
	        if (height != null) { this.display.wrapper.style.height = interpret(height); }
	        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }
	        var lineNo = this.display.viewFrom;
	        this.doc.iter(lineNo, this.display.viewTo, function (line) {
	          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
	            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo, "widget"); break } } }
	          ++lineNo;
	        });
	        this.curOp.forceUpdate = true;
	        signal(this, "refresh", this);
	      }),
	
	      operation: function(f){return runInOp(this, f)},
	      startOperation: function(){return startOperation(this)},
	      endOperation: function(){return endOperation(this)},
	
	      refresh: methodOp(function() {
	        var oldHeight = this.display.cachedTextHeight;
	        regChange(this);
	        this.curOp.forceUpdate = true;
	        clearCaches(this);
	        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
	        updateGutterSpace(this.display);
	        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
	          { estimateLineHeights(this); }
	        signal(this, "refresh", this);
	      }),
	
	      swapDoc: methodOp(function(doc) {
	        var old = this.doc;
	        old.cm = null;
	        // Cancel the current text selection if any (#5821)
	        if (this.state.selectingText) { this.state.selectingText(); }
	        attachDoc(this, doc);
	        clearCaches(this);
	        this.display.input.reset();
	        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
	        this.curOp.forceScroll = true;
	        signalLater(this, "swapDoc", this, old);
	        return old
	      }),
	
	      phrase: function(phraseText) {
	        var phrases = this.options.phrases;
	        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText
	      },
	
	      getInputField: function(){return this.display.input.getField()},
	      getWrapperElement: function(){return this.display.wrapper},
	      getScrollerElement: function(){return this.display.scroller},
	      getGutterElement: function(){return this.display.gutters}
	    };
	    eventMixin(CodeMirror);
	
	    CodeMirror.registerHelper = function(type, name, value) {
	      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
	      helpers[type][name] = value;
	    };
	    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
	      CodeMirror.registerHelper(type, name, value);
	      helpers[type]._global.push({pred: predicate, val: value});
	    };
	  }
	
	  // Used for horizontal relative motion. Dir is -1 or 1 (left or
	  // right), unit can be "char", "column" (like char, but doesn't
	  // cross line boundaries), "word" (across next word), or "group" (to
	  // the start of next group of word or non-word-non-whitespace
	  // chars). The visually param controls whether, in right-to-left
	  // text, direction 1 means to move towards the next index in the
	  // string, or towards the character to the right of the current
	  // position. The resulting position will have a hitSide=true
	  // property if it reached the end of the document.
	  function findPosH(doc, pos, dir, unit, visually) {
	    var oldPos = pos;
	    var origDir = dir;
	    var lineObj = getLine(doc, pos.line);
	    var lineDir = visually && doc.direction == "rtl" ? -dir : dir;
	    function findNextLine() {
	      var l = pos.line + lineDir;
	      if (l < doc.first || l >= doc.first + doc.size) { return false }
	      pos = new Pos(l, pos.ch, pos.sticky);
	      return lineObj = getLine(doc, l)
	    }
	    function moveOnce(boundToLine) {
	      var next;
	      if (visually) {
	        next = moveVisually(doc.cm, lineObj, pos, dir);
	      } else {
	        next = moveLogically(lineObj, pos, dir);
	      }
	      if (next == null) {
	        if (!boundToLine && findNextLine())
	          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir); }
	        else
	          { return false }
	      } else {
	        pos = next;
	      }
	      return true
	    }
	
	    if (unit == "char") {
	      moveOnce();
	    } else if (unit == "column") {
	      moveOnce(true);
	    } else if (unit == "word" || unit == "group") {
	      var sawType = null, group = unit == "group";
	      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
	      for (var first = true;; first = false) {
	        if (dir < 0 && !moveOnce(!first)) { break }
	        var cur = lineObj.text.charAt(pos.ch) || "\n";
	        var type = isWordChar(cur, helper) ? "w"
	          : group && cur == "\n" ? "n"
	          : !group || /\s/.test(cur) ? null
	          : "p";
	        if (group && !first && !type) { type = "s"; }
	        if (sawType && sawType != type) {
	          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after";}
	          break
	        }
	
	        if (type) { sawType = type; }
	        if (dir > 0 && !moveOnce(!first)) { break }
	      }
	    }
	    var result = skipAtomic(doc, pos, oldPos, origDir, true);
	    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }
	    return result
	  }
	
	  // For relative vertical movement. Dir may be -1 or 1. Unit can be
	  // "page" or "line". The resulting position will have a hitSide=true
	  // property if it reached the end of the document.
	  function findPosV(cm, pos, dir, unit) {
	    var doc = cm.doc, x = pos.left, y;
	    if (unit == "page") {
	      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
	      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
	      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
	
	    } else if (unit == "line") {
	      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
	    }
	    var target;
	    for (;;) {
	      target = coordsChar(cm, x, y);
	      if (!target.outside) { break }
	      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
	      y += dir * 5;
	    }
	    return target
	  }
	
	  // CONTENTEDITABLE INPUT STYLE
	
	  var ContentEditableInput = function(cm) {
	    this.cm = cm;
	    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
	    this.polling = new Delayed();
	    this.composing = null;
	    this.gracePeriod = false;
	    this.readDOMTimeout = null;
	  };
	
	  ContentEditableInput.prototype.init = function (display) {
	      var this$1 = this;
	
	    var input = this, cm = input.cm;
	    var div = input.div = display.lineDiv;
	    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);
	
	    on(div, "paste", function (e) {
	      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
	      // IE doesn't fire input events, so we schedule a read for the pasted content in this way
	      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }
	    });
	
	    on(div, "compositionstart", function (e) {
	      this$1.composing = {data: e.data, done: false};
	    });
	    on(div, "compositionupdate", function (e) {
	      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }
	    });
	    on(div, "compositionend", function (e) {
	      if (this$1.composing) {
	        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }
	        this$1.composing.done = true;
	      }
	    });
	
	    on(div, "touchstart", function () { return input.forceCompositionEnd(); });
	
	    on(div, "input", function () {
	      if (!this$1.composing) { this$1.readFromDOMSoon(); }
	    });
	
	    function onCopyCut(e) {
	      if (signalDOMEvent(cm, e)) { return }
	      if (cm.somethingSelected()) {
	        setLastCopied({lineWise: false, text: cm.getSelections()});
	        if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }
	      } else if (!cm.options.lineWiseCopyCut) {
	        return
	      } else {
	        var ranges = copyableRanges(cm);
	        setLastCopied({lineWise: true, text: ranges.text});
	        if (e.type == "cut") {
	          cm.operation(function () {
	            cm.setSelections(ranges.ranges, 0, sel_dontScroll);
	            cm.replaceSelection("", null, "cut");
	          });
	        }
	      }
	      if (e.clipboardData) {
	        e.clipboardData.clearData();
	        var content = lastCopied.text.join("\n");
	        // iOS exposes the clipboard API, but seems to discard content inserted into it
	        e.clipboardData.setData("Text", content);
	        if (e.clipboardData.getData("Text") == content) {
	          e.preventDefault();
	          return
	        }
	      }
	      // Old-fashioned briefly-focus-a-textarea hack
	      var kludge = hiddenTextarea(), te = kludge.firstChild;
	      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
	      te.value = lastCopied.text.join("\n");
	      var hadFocus = document.activeElement;
	      selectInput(te);
	      setTimeout(function () {
	        cm.display.lineSpace.removeChild(kludge);
	        hadFocus.focus();
	        if (hadFocus == div) { input.showPrimarySelection(); }
	      }, 50);
	    }
	    on(div, "copy", onCopyCut);
	    on(div, "cut", onCopyCut);
	  };
	
	  ContentEditableInput.prototype.prepareSelection = function () {
	    var result = prepareSelection(this.cm, false);
	    result.focus = document.activeElement == this.div;
	    return result
	  };
	
	  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
	    if (!info || !this.cm.display.view.length) { return }
	    if (info.focus || takeFocus) { this.showPrimarySelection(); }
	    this.showMultipleSelections(info);
	  };
	
	  ContentEditableInput.prototype.getSelection = function () {
	    return this.cm.display.wrapper.ownerDocument.getSelection()
	  };
	
	  ContentEditableInput.prototype.showPrimarySelection = function () {
	    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
	    var from = prim.from(), to = prim.to();
	
	    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
	      sel.removeAllRanges();
	      return
	    }
	
	    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
	    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
	    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
	        cmp(minPos(curAnchor, curFocus), from) == 0 &&
	        cmp(maxPos(curAnchor, curFocus), to) == 0)
	      { return }
	
	    var view = cm.display.view;
	    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||
	        {node: view[0].measure.map[2], offset: 0};
	    var end = to.line < cm.display.viewTo && posToDOM(cm, to);
	    if (!end) {
	      var measure = view[view.length - 1].measure;
	      var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
	      end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};
	    }
	
	    if (!start || !end) {
	      sel.removeAllRanges();
	      return
	    }
	
	    var old = sel.rangeCount && sel.getRangeAt(0), rng;
	    try { rng = range(start.node, start.offset, end.offset, end.node); }
	    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
	    if (rng) {
	      if (!gecko && cm.state.focused) {
	        sel.collapse(start.node, start.offset);
	        if (!rng.collapsed) {
	          sel.removeAllRanges();
	          sel.addRange(rng);
	        }
	      } else {
	        sel.removeAllRanges();
	        sel.addRange(rng);
	      }
	      if (old && sel.anchorNode == null) { sel.addRange(old); }
	      else if (gecko) { this.startGracePeriod(); }
	    }
	    this.rememberSelection();
	  };
	
	  ContentEditableInput.prototype.startGracePeriod = function () {
	      var this$1 = this;
	
	    clearTimeout(this.gracePeriod);
	    this.gracePeriod = setTimeout(function () {
	      this$1.gracePeriod = false;
	      if (this$1.selectionChanged())
	        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }
	    }, 20);
	  };
	
	  ContentEditableInput.prototype.showMultipleSelections = function (info) {
	    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
	    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
	  };
	
	  ContentEditableInput.prototype.rememberSelection = function () {
	    var sel = this.getSelection();
	    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
	    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
	  };
	
	  ContentEditableInput.prototype.selectionInEditor = function () {
	    var sel = this.getSelection();
	    if (!sel.rangeCount) { return false }
	    var node = sel.getRangeAt(0).commonAncestorContainer;
	    return contains(this.div, node)
	  };
	
	  ContentEditableInput.prototype.focus = function () {
	    if (this.cm.options.readOnly != "nocursor") {
	      if (!this.selectionInEditor() || document.activeElement != this.div)
	        { this.showSelection(this.prepareSelection(), true); }
	      this.div.focus();
	    }
	  };
	  ContentEditableInput.prototype.blur = function () { this.div.blur(); };
	  ContentEditableInput.prototype.getField = function () { return this.div };
	
	  ContentEditableInput.prototype.supportsTouch = function () { return true };
	
	  ContentEditableInput.prototype.receivedFocus = function () {
	    var input = this;
	    if (this.selectionInEditor())
	      { this.pollSelection(); }
	    else
	      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }
	
	    function poll() {
	      if (input.cm.state.focused) {
	        input.pollSelection();
	        input.polling.set(input.cm.options.pollInterval, poll);
	      }
	    }
	    this.polling.set(this.cm.options.pollInterval, poll);
	  };
	
	  ContentEditableInput.prototype.selectionChanged = function () {
	    var sel = this.getSelection();
	    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
	      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
	  };
	
	  ContentEditableInput.prototype.pollSelection = function () {
	    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
	    var sel = this.getSelection(), cm = this.cm;
	    // On Android Chrome (version 56, at least), backspacing into an
	    // uneditable block element will put the cursor in that element,
	    // and then, because it's not editable, hide the virtual keyboard.
	    // Because Android doesn't allow us to actually detect backspace
	    // presses in a sane way, this code checks for when that happens
	    // and simulates a backspace press in this case.
	    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
	      this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});
	      this.blur();
	      this.focus();
	      return
	    }
	    if (this.composing) { return }
	    this.rememberSelection();
	    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
	    var head = domToPos(cm, sel.focusNode, sel.focusOffset);
	    if (anchor && head) { runInOp(cm, function () {
	      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
	      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }
	    }); }
	  };
	
	  ContentEditableInput.prototype.pollContent = function () {
	    if (this.readDOMTimeout != null) {
	      clearTimeout(this.readDOMTimeout);
	      this.readDOMTimeout = null;
	    }
	
	    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
	    var from = sel.from(), to = sel.to();
	    if (from.ch == 0 && from.line > cm.firstLine())
	      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }
	    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
	      { to = Pos(to.line + 1, 0); }
	    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }
	
	    var fromIndex, fromLine, fromNode;
	    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
	      fromLine = lineNo(display.view[0].line);
	      fromNode = display.view[0].node;
	    } else {
	      fromLine = lineNo(display.view[fromIndex].line);
	      fromNode = display.view[fromIndex - 1].node.nextSibling;
	    }
	    var toIndex = findViewIndex(cm, to.line);
	    var toLine, toNode;
	    if (toIndex == display.view.length - 1) {
	      toLine = display.viewTo - 1;
	      toNode = display.lineDiv.lastChild;
	    } else {
	      toLine = lineNo(display.view[toIndex + 1].line) - 1;
	      toNode = display.view[toIndex + 1].node.previousSibling;
	    }
	
	    if (!fromNode) { return false }
	    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
	    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
	    while (newText.length > 1 && oldText.length > 1) {
	      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
	      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
	      else { break }
	    }
	
	    var cutFront = 0, cutEnd = 0;
	    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
	    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
	      { ++cutFront; }
	    var newBot = lst(newText), oldBot = lst(oldText);
	    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
	                             oldBot.length - (oldText.length == 1 ? cutFront : 0));
	    while (cutEnd < maxCutEnd &&
	           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
	      { ++cutEnd; }
	    // Try to move start of change to start of selection if ambiguous
	    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
	      while (cutFront && cutFront > from.ch &&
	             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
	        cutFront--;
	        cutEnd++;
	      }
	    }
	
	    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
	    newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
	
	    var chFrom = Pos(fromLine, cutFront);
	    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
	    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
	      replaceRange(cm.doc, newText, chFrom, chTo, "+input");
	      return true
	    }
	  };
	
	  ContentEditableInput.prototype.ensurePolled = function () {
	    this.forceCompositionEnd();
	  };
	  ContentEditableInput.prototype.reset = function () {
	    this.forceCompositionEnd();
	  };
	  ContentEditableInput.prototype.forceCompositionEnd = function () {
	    if (!this.composing) { return }
	    clearTimeout(this.readDOMTimeout);
	    this.composing = null;
	    this.updateFromDOM();
	    this.div.blur();
	    this.div.focus();
	  };
	  ContentEditableInput.prototype.readFromDOMSoon = function () {
	      var this$1 = this;
	
	    if (this.readDOMTimeout != null) { return }
	    this.readDOMTimeout = setTimeout(function () {
	      this$1.readDOMTimeout = null;
	      if (this$1.composing) {
	        if (this$1.composing.done) { this$1.composing = null; }
	        else { return }
	      }
	      this$1.updateFromDOM();
	    }, 80);
	  };
	
	  ContentEditableInput.prototype.updateFromDOM = function () {
	      var this$1 = this;
	
	    if (this.cm.isReadOnly() || !this.pollContent())
	      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }
	  };
	
	  ContentEditableInput.prototype.setUneditable = function (node) {
	    node.contentEditable = "false";
	  };
	
	  ContentEditableInput.prototype.onKeyPress = function (e) {
	    if (e.charCode == 0 || this.composing) { return }
	    e.preventDefault();
	    if (!this.cm.isReadOnly())
	      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }
	  };
	
	  ContentEditableInput.prototype.readOnlyChanged = function (val) {
	    this.div.contentEditable = String(val != "nocursor");
	  };
	
	  ContentEditableInput.prototype.onContextMenu = function () {};
	  ContentEditableInput.prototype.resetPosition = function () {};
	
	  ContentEditableInput.prototype.needsContentAttribute = true;
	
	  function posToDOM(cm, pos) {
	    var view = findViewForLine(cm, pos.line);
	    if (!view || view.hidden) { return null }
	    var line = getLine(cm.doc, pos.line);
	    var info = mapFromLineView(view, line, pos.line);
	
	    var order = getOrder(line, cm.doc.direction), side = "left";
	    if (order) {
	      var partPos = getBidiPartAt(order, pos.ch);
	      side = partPos % 2 ? "right" : "left";
	    }
	    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
	    result.offset = result.collapse == "right" ? result.end : result.start;
	    return result
	  }
	
	  function isInGutter(node) {
	    for (var scan = node; scan; scan = scan.parentNode)
	      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
	    return false
	  }
	
	  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }
	
	  function domTextBetween(cm, from, to, fromLine, toLine) {
	    var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
	    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
	    function close() {
	      if (closing) {
	        text += lineSep;
	        if (extraLinebreak) { text += lineSep; }
	        closing = extraLinebreak = false;
	      }
	    }
	    function addText(str) {
	      if (str) {
	        close();
	        text += str;
	      }
	    }
	    function walk(node) {
	      if (node.nodeType == 1) {
	        var cmText = node.getAttribute("cm-text");
	        if (cmText) {
	          addText(cmText);
	          return
	        }
	        var markerID = node.getAttribute("cm-marker"), range;
	        if (markerID) {
	          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
	          if (found.length && (range = found[0].find(0)))
	            { addText(getBetween(cm.doc, range.from, range.to).join(lineSep)); }
	          return
	        }
	        if (node.getAttribute("contenteditable") == "false") { return }
	        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
	        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }
	
	        if (isBlock) { close(); }
	        for (var i = 0; i < node.childNodes.length; i++)
	          { walk(node.childNodes[i]); }
	
	        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }
	        if (isBlock) { closing = true; }
	      } else if (node.nodeType == 3) {
	        addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
	      }
	    }
	    for (;;) {
	      walk(from);
	      if (from == to) { break }
	      from = from.nextSibling;
	      extraLinebreak = false;
	    }
	    return text
	  }
	
	  function domToPos(cm, node, offset) {
	    var lineNode;
	    if (node == cm.display.lineDiv) {
	      lineNode = cm.display.lineDiv.childNodes[offset];
	      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
	      node = null; offset = 0;
	    } else {
	      for (lineNode = node;; lineNode = lineNode.parentNode) {
	        if (!lineNode || lineNode == cm.display.lineDiv) { return null }
	        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
	      }
	    }
	    for (var i = 0; i < cm.display.view.length; i++) {
	      var lineView = cm.display.view[i];
	      if (lineView.node == lineNode)
	        { return locateNodeInLineView(lineView, node, offset) }
	    }
	  }
	
	  function locateNodeInLineView(lineView, node, offset) {
	    var wrapper = lineView.text.firstChild, bad = false;
	    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
	    if (node == wrapper) {
	      bad = true;
	      node = wrapper.childNodes[offset];
	      offset = 0;
	      if (!node) {
	        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
	        return badPos(Pos(lineNo(line), line.text.length), bad)
	      }
	    }
	
	    var textNode = node.nodeType == 3 ? node : null, topNode = node;
	    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
	      textNode = node.firstChild;
	      if (offset) { offset = textNode.nodeValue.length; }
	    }
	    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }
	    var measure = lineView.measure, maps = measure.maps;
	
	    function find(textNode, topNode, offset) {
	      for (var i = -1; i < (maps ? maps.length : 0); i++) {
	        var map = i < 0 ? measure.map : maps[i];
	        for (var j = 0; j < map.length; j += 3) {
	          var curNode = map[j + 2];
	          if (curNode == textNode || curNode == topNode) {
	            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
	            var ch = map[j] + offset;
	            if (offset < 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)]; }
	            return Pos(line, ch)
	          }
	        }
	      }
	    }
	    var found = find(textNode, topNode, offset);
	    if (found) { return badPos(found, bad) }
	
	    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
	    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
	      found = find(after, after.firstChild, 0);
	      if (found)
	        { return badPos(Pos(found.line, found.ch - dist), bad) }
	      else
	        { dist += after.textContent.length; }
	    }
	    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
	      found = find(before, before.firstChild, -1);
	      if (found)
	        { return badPos(Pos(found.line, found.ch + dist$1), bad) }
	      else
	        { dist$1 += before.textContent.length; }
	    }
	  }
	
	  // TEXTAREA INPUT STYLE
	
	  var TextareaInput = function(cm) {
	    this.cm = cm;
	    // See input.poll and input.reset
	    this.prevInput = "";
	
	    // Flag that indicates whether we expect input to appear real soon
	    // now (after some event like 'keypress' or 'input') and are
	    // polling intensively.
	    this.pollingFast = false;
	    // Self-resetting timeout for the poller
	    this.polling = new Delayed();
	    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
	    this.hasSelection = false;
	    this.composing = null;
	  };
	
	  TextareaInput.prototype.init = function (display) {
	      var this$1 = this;
	
	    var input = this, cm = this.cm;
	    this.createField(display);
	    var te = this.textarea;
	
	    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);
	
	    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
	    if (ios) { te.style.width = "0px"; }
	
	    on(te, "input", function () {
	      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }
	      input.poll();
	    });
	
	    on(te, "paste", function (e) {
	      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
	
	      cm.state.pasteIncoming = +new Date;
	      input.fastPoll();
	    });
	
	    function prepareCopyCut(e) {
	      if (signalDOMEvent(cm, e)) { return }
	      if (cm.somethingSelected()) {
	        setLastCopied({lineWise: false, text: cm.getSelections()});
	      } else if (!cm.options.lineWiseCopyCut) {
	        return
	      } else {
	        var ranges = copyableRanges(cm);
	        setLastCopied({lineWise: true, text: ranges.text});
	        if (e.type == "cut") {
	          cm.setSelections(ranges.ranges, null, sel_dontScroll);
	        } else {
	          input.prevInput = "";
	          te.value = ranges.text.join("\n");
	          selectInput(te);
	        }
	      }
	      if (e.type == "cut") { cm.state.cutIncoming = +new Date; }
	    }
	    on(te, "cut", prepareCopyCut);
	    on(te, "copy", prepareCopyCut);
	
	    on(display.scroller, "paste", function (e) {
	      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
	      if (!te.dispatchEvent) {
	        cm.state.pasteIncoming = +new Date;
	        input.focus();
	        return
	      }
	
	      // Pass the `paste` event to the textarea so it's handled by its event listener.
	      var event = new Event("paste");
	      event.clipboardData = e.clipboardData;
	      te.dispatchEvent(event);
	    });
	
	    // Prevent normal selection in the editor (we handle our own)
	    on(display.lineSpace, "selectstart", function (e) {
	      if (!eventInWidget(display, e)) { e_preventDefault(e); }
	    });
	
	    on(te, "compositionstart", function () {
	      var start = cm.getCursor("from");
	      if (input.composing) { input.composing.range.clear(); }
	      input.composing = {
	        start: start,
	        range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
	      };
	    });
	    on(te, "compositionend", function () {
	      if (input.composing) {
	        input.poll();
	        input.composing.range.clear();
	        input.composing = null;
	      }
	    });
	  };
	
	  TextareaInput.prototype.createField = function (_display) {
	    // Wraps and hides input textarea
	    this.wrapper = hiddenTextarea();
	    // The semihidden textarea that is focused when the editor is
	    // focused, and receives input.
	    this.textarea = this.wrapper.firstChild;
	  };
	
	  TextareaInput.prototype.prepareSelection = function () {
	    // Redraw the selection and/or cursor
	    var cm = this.cm, display = cm.display, doc = cm.doc;
	    var result = prepareSelection(cm);
	
	    // Move the hidden textarea near the cursor to prevent scrolling artifacts
	    if (cm.options.moveInputWithCursor) {
	      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
	      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
	      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
	                                          headPos.top + lineOff.top - wrapOff.top));
	      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
	                                           headPos.left + lineOff.left - wrapOff.left));
	    }
	
	    return result
	  };
	
	  TextareaInput.prototype.showSelection = function (drawn) {
	    var cm = this.cm, display = cm.display;
	    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
	    removeChildrenAndAdd(display.selectionDiv, drawn.selection);
	    if (drawn.teTop != null) {
	      this.wrapper.style.top = drawn.teTop + "px";
	      this.wrapper.style.left = drawn.teLeft + "px";
	    }
	  };
	
	  // Reset the input to correspond to the selection (or to be empty,
	  // when not typing and nothing is selected)
	  TextareaInput.prototype.reset = function (typing) {
	    if (this.contextMenuPending || this.composing) { return }
	    var cm = this.cm;
	    if (cm.somethingSelected()) {
	      this.prevInput = "";
	      var content = cm.getSelection();
	      this.textarea.value = content;
	      if (cm.state.focused) { selectInput(this.textarea); }
	      if (ie && ie_version >= 9) { this.hasSelection = content; }
	    } else if (!typing) {
	      this.prevInput = this.textarea.value = "";
	      if (ie && ie_version >= 9) { this.hasSelection = null; }
	    }
	  };
	
	  TextareaInput.prototype.getField = function () { return this.textarea };
	
	  TextareaInput.prototype.supportsTouch = function () { return false };
	
	  TextareaInput.prototype.focus = function () {
	    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
	      try { this.textarea.focus(); }
	      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
	    }
	  };
	
	  TextareaInput.prototype.blur = function () { this.textarea.blur(); };
	
	  TextareaInput.prototype.resetPosition = function () {
	    this.wrapper.style.top = this.wrapper.style.left = 0;
	  };
	
	  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };
	
	  // Poll for input changes, using the normal rate of polling. This
	  // runs as long as the editor is focused.
	  TextareaInput.prototype.slowPoll = function () {
	      var this$1 = this;
	
	    if (this.pollingFast) { return }
	    this.polling.set(this.cm.options.pollInterval, function () {
	      this$1.poll();
	      if (this$1.cm.state.focused) { this$1.slowPoll(); }
	    });
	  };
	
	  // When an event has just come in that is likely to add or change
	  // something in the input textarea, we poll faster, to ensure that
	  // the change appears on the screen quickly.
	  TextareaInput.prototype.fastPoll = function () {
	    var missed = false, input = this;
	    input.pollingFast = true;
	    function p() {
	      var changed = input.poll();
	      if (!changed && !missed) {missed = true; input.polling.set(60, p);}
	      else {input.pollingFast = false; input.slowPoll();}
	    }
	    input.polling.set(20, p);
	  };
	
	  // Read input from the textarea, and update the document to match.
	  // When something is selected, it is present in the textarea, and
	  // selected (unless it is huge, in which case a placeholder is
	  // used). When nothing is selected, the cursor sits after previously
	  // seen text (can be empty), which is stored in prevInput (we must
	  // not reset the textarea when typing, because that breaks IME).
	  TextareaInput.prototype.poll = function () {
	      var this$1 = this;
	
	    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
	    // Since this is called a *lot*, try to bail out as cheaply as
	    // possible when it is clear that nothing happened. hasSelection
	    // will be the case when there is a lot of text in the textarea,
	    // in which case reading its value would be expensive.
	    if (this.contextMenuPending || !cm.state.focused ||
	        (hasSelection(input) && !prevInput && !this.composing) ||
	        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
	      { return false }
	
	    var text = input.value;
	    // If nothing changed, bail.
	    if (text == prevInput && !cm.somethingSelected()) { return false }
	    // Work around nonsensical selection resetting in IE9/10, and
	    // inexplicable appearance of private area unicode characters on
	    // some key combos in Mac (#2689).
	    if (ie && ie_version >= 9 && this.hasSelection === text ||
	        mac && /[\uf700-\uf7ff]/.test(text)) {
	      cm.display.input.reset();
	      return false
	    }
	
	    if (cm.doc.sel == cm.display.selForContextMenu) {
	      var first = text.charCodeAt(0);
	      if (first == 0x200b && !prevInput) { prevInput = "\u200b"; }
	      if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
	    }
	    // Find the part of the input that is actually new
	    var same = 0, l = Math.min(prevInput.length, text.length);
	    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }
	
	    runInOp(cm, function () {
	      applyTextInput(cm, text.slice(same), prevInput.length - same,
	                     null, this$1.composing ? "*compose" : null);
	
	      // Don't leave long text in the textarea, since it makes further polling slow
	      if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = ""; }
	      else { this$1.prevInput = text; }
	
	      if (this$1.composing) {
	        this$1.composing.range.clear();
	        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
	                                           {className: "CodeMirror-composing"});
	      }
	    });
	    return true
	  };
	
	  TextareaInput.prototype.ensurePolled = function () {
	    if (this.pollingFast && this.poll()) { this.pollingFast = false; }
	  };
	
	  TextareaInput.prototype.onKeyPress = function () {
	    if (ie && ie_version >= 9) { this.hasSelection = null; }
	    this.fastPoll();
	  };
	
	  TextareaInput.prototype.onContextMenu = function (e) {
	    var input = this, cm = input.cm, display = cm.display, te = input.textarea;
	    if (input.contextMenuPending) { input.contextMenuPending(); }
	    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
	    if (!pos || presto) { return } // Opera is difficult.
	
	    // Reset the current text selection only if the click is done outside of the selection
	    // and 'resetSelectionOnContextMenu' option is true.
	    var reset = cm.options.resetSelectionOnContextMenu;
	    if (reset && cm.doc.sel.contains(pos) == -1)
	      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }
	
	    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
	    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
	    input.wrapper.style.cssText = "position: static";
	    te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
	    var oldScrollY;
	    if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)
	    display.input.focus();
	    if (webkit) { window.scrollTo(null, oldScrollY); }
	    display.input.reset();
	    // Adds "Select all" to context menu in FF
	    if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }
	    input.contextMenuPending = rehide;
	    display.selForContextMenu = cm.doc.sel;
	    clearTimeout(display.detectingSelectAll);
	
	    // Select-all will be greyed out if there's nothing to select, so
	    // this adds a zero-width space so that we can later check whether
	    // it got selected.
	    function prepareSelectAllHack() {
	      if (te.selectionStart != null) {
	        var selected = cm.somethingSelected();
	        var extval = "\u200b" + (selected ? te.value : "");
	        te.value = "\u21da"; // Used to catch context-menu undo
	        te.value = extval;
	        input.prevInput = selected ? "" : "\u200b";
	        te.selectionStart = 1; te.selectionEnd = extval.length;
	        // Re-set this, in case some other handler touched the
	        // selection in the meantime.
	        display.selForContextMenu = cm.doc.sel;
	      }
	    }
	    function rehide() {
	      if (input.contextMenuPending != rehide) { return }
	      input.contextMenuPending = false;
	      input.wrapper.style.cssText = oldWrapperCSS;
	      te.style.cssText = oldCSS;
	      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }
	
	      // Try to detect the user choosing select-all
	      if (te.selectionStart != null) {
	        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }
	        var i = 0, poll = function () {
	          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
	              te.selectionEnd > 0 && input.prevInput == "\u200b") {
	            operation(cm, selectAll)(cm);
	          } else if (i++ < 10) {
	            display.detectingSelectAll = setTimeout(poll, 500);
	          } else {
	            display.selForContextMenu = null;
	            display.input.reset();
	          }
	        };
	        display.detectingSelectAll = setTimeout(poll, 200);
	      }
	    }
	
	    if (ie && ie_version >= 9) { prepareSelectAllHack(); }
	    if (captureRightClick) {
	      e_stop(e);
	      var mouseup = function () {
	        off(window, "mouseup", mouseup);
	        setTimeout(rehide, 20);
	      };
	      on(window, "mouseup", mouseup);
	    } else {
	      setTimeout(rehide, 50);
	    }
	  };
	
	  TextareaInput.prototype.readOnlyChanged = function (val) {
	    if (!val) { this.reset(); }
	    this.textarea.disabled = val == "nocursor";
	  };
	
	  TextareaInput.prototype.setUneditable = function () {};
	
	  TextareaInput.prototype.needsContentAttribute = false;
	
	  function fromTextArea(textarea, options) {
	    options = options ? copyObj(options) : {};
	    options.value = textarea.value;
	    if (!options.tabindex && textarea.tabIndex)
	      { options.tabindex = textarea.tabIndex; }
	    if (!options.placeholder && textarea.placeholder)
	      { options.placeholder = textarea.placeholder; }
	    // Set autofocus to true if this textarea is focused, or if it has
	    // autofocus and no other element is focused.
	    if (options.autofocus == null) {
	      var hasFocus = activeElt();
	      options.autofocus = hasFocus == textarea ||
	        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
	    }
	
	    function save() {textarea.value = cm.getValue();}
	
	    var realSubmit;
	    if (textarea.form) {
	      on(textarea.form, "submit", save);
	      // Deplorable hack to make the submit method do the right thing.
	      if (!options.leaveSubmitMethodAlone) {
	        var form = textarea.form;
	        realSubmit = form.submit;
	        try {
	          var wrappedSubmit = form.submit = function () {
	            save();
	            form.submit = realSubmit;
	            form.submit();
	            form.submit = wrappedSubmit;
	          };
	        } catch(e) {}
	      }
	    }
	
	    options.finishInit = function (cm) {
	      cm.save = save;
	      cm.getTextArea = function () { return textarea; };
	      cm.toTextArea = function () {
	        cm.toTextArea = isNaN; // Prevent this from being ran twice
	        save();
	        textarea.parentNode.removeChild(cm.getWrapperElement());
	        textarea.style.display = "";
	        if (textarea.form) {
	          off(textarea.form, "submit", save);
	          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function")
	            { textarea.form.submit = realSubmit; }
	        }
	      };
	    };
	
	    textarea.style.display = "none";
	    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
	      options);
	    return cm
	  }
	
	  function addLegacyProps(CodeMirror) {
	    CodeMirror.off = off;
	    CodeMirror.on = on;
	    CodeMirror.wheelEventPixels = wheelEventPixels;
	    CodeMirror.Doc = Doc;
	    CodeMirror.splitLines = splitLinesAuto;
	    CodeMirror.countColumn = countColumn;
	    CodeMirror.findColumn = findColumn;
	    CodeMirror.isWordChar = isWordCharBasic;
	    CodeMirror.Pass = Pass;
	    CodeMirror.signal = signal;
	    CodeMirror.Line = Line;
	    CodeMirror.changeEnd = changeEnd;
	    CodeMirror.scrollbarModel = scrollbarModel;
	    CodeMirror.Pos = Pos;
	    CodeMirror.cmpPos = cmp;
	    CodeMirror.modes = modes;
	    CodeMirror.mimeModes = mimeModes;
	    CodeMirror.resolveMode = resolveMode;
	    CodeMirror.getMode = getMode;
	    CodeMirror.modeExtensions = modeExtensions;
	    CodeMirror.extendMode = extendMode;
	    CodeMirror.copyState = copyState;
	    CodeMirror.startState = startState;
	    CodeMirror.innerMode = innerMode;
	    CodeMirror.commands = commands;
	    CodeMirror.keyMap = keyMap;
	    CodeMirror.keyName = keyName;
	    CodeMirror.isModifierKey = isModifierKey;
	    CodeMirror.lookupKey = lookupKey;
	    CodeMirror.normalizeKeyMap = normalizeKeyMap;
	    CodeMirror.StringStream = StringStream;
	    CodeMirror.SharedTextMarker = SharedTextMarker;
	    CodeMirror.TextMarker = TextMarker;
	    CodeMirror.LineWidget = LineWidget;
	    CodeMirror.e_preventDefault = e_preventDefault;
	    CodeMirror.e_stopPropagation = e_stopPropagation;
	    CodeMirror.e_stop = e_stop;
	    CodeMirror.addClass = addClass;
	    CodeMirror.contains = contains;
	    CodeMirror.rmClass = rmClass;
	    CodeMirror.keyNames = keyNames;
	  }
	
	  // EDITOR CONSTRUCTOR
	
	  defineOptions(CodeMirror);
	
	  addEditorMethods(CodeMirror);
	
	  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
	  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
	  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
	    { CodeMirror.prototype[prop] = (function(method) {
	      return function() {return method.apply(this.doc, arguments)}
	    })(Doc.prototype[prop]); } }
	
	  eventMixin(Doc);
	  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};
	
	  // Extra arguments are stored as the mode's dependencies, which is
	  // used by (legacy) mechanisms like loadmode.js to automatically
	  // load a mode. (Preferred mechanism is the require/define calls.)
	  CodeMirror.defineMode = function(name/*, mode, …*/) {
	    if (!CodeMirror.defaults.mode && name != "null") { CodeMirror.defaults.mode = name; }
	    defineMode.apply(this, arguments);
	  };
	
	  CodeMirror.defineMIME = defineMIME;
	
	  // Minimal default mode.
	  CodeMirror.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
	  CodeMirror.defineMIME("text/plain", "null");
	
	  // EXTENSIONS
	
	  CodeMirror.defineExtension = function (name, func) {
	    CodeMirror.prototype[name] = func;
	  };
	  CodeMirror.defineDocExtension = function (name, func) {
	    Doc.prototype[name] = func;
	  };
	
	  CodeMirror.fromTextArea = fromTextArea;
	
	  addLegacyProps(CodeMirror);
	
	  CodeMirror.version = "5.52.2";
	
	  return CodeMirror;
	
	})));


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: https://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(38));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";
	
	  var listRE = /^(\s*)(>[> ]*|[*+-] \[[x ]\]\s|[*+-]\s|(\d+)([.)]))(\s*)/,
	      emptyListRE = /^(\s*)(>[> ]*|[*+-] \[[x ]\]|[*+-]|(\d+)[.)])(\s*)$/,
	      unorderedListRE = /[*+-]\s/;
	
	  CodeMirror.commands.newlineAndIndentContinueMarkdownList = function(cm) {
	    if (cm.getOption("disableInput")) return CodeMirror.Pass;
	    var ranges = cm.listSelections(), replacements = [];
	    for (var i = 0; i < ranges.length; i++) {
	      var pos = ranges[i].head;
	
	      // If we're not in Markdown mode, fall back to normal newlineAndIndent
	      var eolState = cm.getStateAfter(pos.line);
	      var inner = CodeMirror.innerMode(cm.getMode(), eolState);
	      if (inner.mode.name !== "markdown") {
	        cm.execCommand("newlineAndIndent");
	        return;
	      } else {
	        eolState = inner.state;
	      }
	
	      var inList = eolState.list !== false;
	      var inQuote = eolState.quote !== 0;
	
	      var line = cm.getLine(pos.line), match = listRE.exec(line);
	      var cursorBeforeBullet = /^\s*$/.test(line.slice(0, pos.ch));
	      if (!ranges[i].empty() || (!inList && !inQuote) || !match || cursorBeforeBullet) {
	        cm.execCommand("newlineAndIndent");
	        return;
	      }
	      if (emptyListRE.test(line)) {
	        var endOfQuote = inQuote && />\s*$/.test(line)
	        var endOfList = !/>\s*$/.test(line)
	        if (endOfQuote || endOfList) cm.replaceRange("", {
	          line: pos.line, ch: 0
	        }, {
	          line: pos.line, ch: pos.ch + 1
	        });
	        replacements[i] = "\n";
	      } else {
	        var indent = match[1], after = match[5];
	        var numbered = !(unorderedListRE.test(match[2]) || match[2].indexOf(">") >= 0);
	        var bullet = numbered ? (parseInt(match[3], 10) + 1) + match[4] : match[2].replace("x", " ");
	        replacements[i] = "\n" + indent + bullet + after;
	
	        if (numbered) incrementRemainingMarkdownListNumbers(cm, pos);
	      }
	    }
	
	    cm.replaceSelections(replacements);
	  };
	
	  // Auto-updating Markdown list numbers when a new item is added to the
	  // middle of a list
	  function incrementRemainingMarkdownListNumbers(cm, pos) {
	    var startLine = pos.line, lookAhead = 0, skipCount = 0;
	    var startItem = listRE.exec(cm.getLine(startLine)), startIndent = startItem[1];
	
	    do {
	      lookAhead += 1;
	      var nextLineNumber = startLine + lookAhead;
	      var nextLine = cm.getLine(nextLineNumber), nextItem = listRE.exec(nextLine);
	
	      if (nextItem) {
	        var nextIndent = nextItem[1];
	        var newNumber = (parseInt(startItem[3], 10) + lookAhead - skipCount);
	        var nextNumber = (parseInt(nextItem[3], 10)), itemNumber = nextNumber;
	
	        if (startIndent === nextIndent && !isNaN(nextNumber)) {
	          if (newNumber === nextNumber) itemNumber = nextNumber + 1;
	          if (newNumber > nextNumber) itemNumber = newNumber + 1;
	          cm.replaceRange(
	            nextLine.replace(listRE, nextIndent + itemNumber + nextItem[4] + nextItem[5]),
	          {
	            line: nextLineNumber, ch: 0
	          }, {
	            line: nextLineNumber, ch: nextLine.length
	          });
	        } else {
	          if (startIndent.length > nextIndent.length) return;
	          // This doesn't run if the next line immediatley indents, as it is
	          // not clear of the users intention (new indented item or same level)
	          if ((startIndent.length < nextIndent.length) && (lookAhead === 1)) return;
	          skipCount += 1;
	        }
	      }
	    } while (nextItem);
	  }
	});


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: http://codemirror.net/LICENSE
	
	var CodeMirror = __webpack_require__(38);
	
	CodeMirror.commands.tabAndIndentMarkdownList = function (cm) {
		var ranges = cm.listSelections();
		var pos = ranges[0].head;
		var eolState = cm.getStateAfter(pos.line);
		var inList = eolState.list !== false;
	
		if (inList) {
			cm.execCommand("indentMore");
			return;
		}
	
		if (cm.options.indentWithTabs) {
			cm.execCommand("insertTab");
		}
		else {
			var spaces = Array(cm.options.tabSize + 1).join(" ");
			cm.replaceSelection(spaces);
		}
	};
	
	CodeMirror.commands.shiftTabAndUnindentMarkdownList = function (cm) {
		var ranges = cm.listSelections();
		var pos = ranges[0].head;
		var eolState = cm.getStateAfter(pos.line);
		var inList = eolState.list !== false;
	
		if (inList) {
			cm.execCommand("indentLess");
			return;
		}
	
		if (cm.options.indentWithTabs) {
			cm.execCommand("insertTab");
		}
		else {
			var spaces = Array(cm.options.tabSize + 1).join(" ");
			cm.replaceSelection(spaces);
		}
	};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: https://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(38));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";
	
	  CodeMirror.defineOption("fullScreen", false, function(cm, val, old) {
	    if (old == CodeMirror.Init) old = false;
	    if (!old == !val) return;
	    if (val) setFullscreen(cm);
	    else setNormal(cm);
	  });
	
	  function setFullscreen(cm) {
	    var wrap = cm.getWrapperElement();
	    cm.state.fullScreenRestore = {scrollTop: window.pageYOffset, scrollLeft: window.pageXOffset,
	                                  width: wrap.style.width, height: wrap.style.height};
	    wrap.style.width = "";
	    wrap.style.height = "auto";
	    wrap.className += " CodeMirror-fullscreen";
	    document.documentElement.style.overflow = "hidden";
	    cm.refresh();
	  }
	
	  function setNormal(cm) {
	    var wrap = cm.getWrapperElement();
	    wrap.className = wrap.className.replace(/\s*CodeMirror-fullscreen\b/, "");
	    document.documentElement.style.overflow = "";
	    var info = cm.state.fullScreenRestore;
	    wrap.style.width = info.width; wrap.style.height = info.height;
	    window.scrollTo(info.scrollLeft, info.scrollTop);
	    cm.refresh();
	  }
	});


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: https://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(38), __webpack_require__(43), __webpack_require__(44));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror", "../xml/xml", "../meta"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	"use strict";
	
	CodeMirror.defineMode("markdown", function(cmCfg, modeCfg) {
	
	  var htmlMode = CodeMirror.getMode(cmCfg, "text/html");
	  var htmlModeMissing = htmlMode.name == "null"
	
	  function getMode(name) {
	    if (CodeMirror.findModeByName) {
	      var found = CodeMirror.findModeByName(name);
	      if (found) name = found.mime || found.mimes[0];
	    }
	    var mode = CodeMirror.getMode(cmCfg, name);
	    return mode.name == "null" ? null : mode;
	  }
	
	  // Should characters that affect highlighting be highlighted separate?
	  // Does not include characters that will be output (such as `1.` and `-` for lists)
	  if (modeCfg.highlightFormatting === undefined)
	    modeCfg.highlightFormatting = false;
	
	  // Maximum number of nested blockquotes. Set to 0 for infinite nesting.
	  // Excess `>` will emit `error` token.
	  if (modeCfg.maxBlockquoteDepth === undefined)
	    modeCfg.maxBlockquoteDepth = 0;
	
	  // Turn on task lists? ("- [ ] " and "- [x] ")
	  if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;
	
	  // Turn on strikethrough syntax
	  if (modeCfg.strikethrough === undefined)
	    modeCfg.strikethrough = false;
	
	  if (modeCfg.emoji === undefined)
	    modeCfg.emoji = false;
	
	  if (modeCfg.fencedCodeBlockHighlighting === undefined)
	    modeCfg.fencedCodeBlockHighlighting = true;
	
	  if (modeCfg.xml === undefined)
	    modeCfg.xml = true;
	
	  // Allow token types to be overridden by user-provided token types.
	  if (modeCfg.tokenTypeOverrides === undefined)
	    modeCfg.tokenTypeOverrides = {};
	
	  var tokenTypes = {
	    header: "header",
	    code: "comment",
	    quote: "quote",
	    list1: "variable-2",
	    list2: "variable-3",
	    list3: "keyword",
	    hr: "hr",
	    image: "image",
	    imageAltText: "image-alt-text",
	    imageMarker: "image-marker",
	    formatting: "formatting",
	    linkInline: "link",
	    linkEmail: "link",
	    linkText: "link",
	    linkHref: "string",
	    em: "em",
	    strong: "strong",
	    strikethrough: "strikethrough",
	    emoji: "builtin"
	  };
	
	  for (var tokenType in tokenTypes) {
	    if (tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType]) {
	      tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];
	    }
	  }
	
	  var hrRE = /^([*\-_])(?:\s*\1){2,}\s*$/
	  ,   listRE = /^(?:[*\-+]|^[0-9]+([.)]))\s+/
	  ,   taskListRE = /^\[(x| )\](?=\s)/i // Must follow listRE
	  ,   atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/
	  ,   setextHeaderRE = /^ {0,3}(?:\={1,}|-{2,})\s*$/
	  ,   textRE = /^[^#!\[\]*_\\<>` "'(~:]+/
	  ,   fencedCodeRE = /^(~~~+|```+)[ \t]*([\w+#-]*)[^\n`]*$/
	  ,   linkDefRE = /^\s*\[[^\]]+?\]:.*$/ // naive link-definition
	  ,   punctuation = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/
	  ,   expandedTab = "    " // CommonMark specifies tab as 4 spaces
	
	  function switchInline(stream, state, f) {
	    state.f = state.inline = f;
	    return f(stream, state);
	  }
	
	  function switchBlock(stream, state, f) {
	    state.f = state.block = f;
	    return f(stream, state);
	  }
	
	  function lineIsEmpty(line) {
	    return !line || !/\S/.test(line.string)
	  }
	
	  // Blocks
	
	  function blankLine(state) {
	    // Reset linkTitle state
	    state.linkTitle = false;
	    state.linkHref = false;
	    state.linkText = false;
	    // Reset EM state
	    state.em = false;
	    // Reset STRONG state
	    state.strong = false;
	    // Reset strikethrough state
	    state.strikethrough = false;
	    // Reset state.quote
	    state.quote = 0;
	    // Reset state.indentedCode
	    state.indentedCode = false;
	    if (state.f == htmlBlock) {
	      var exit = htmlModeMissing
	      if (!exit) {
	        var inner = CodeMirror.innerMode(htmlMode, state.htmlState)
	        exit = inner.mode.name == "xml" && inner.state.tagStart === null &&
	          (!inner.state.context && inner.state.tokenize.isInText)
	      }
	      if (exit) {
	        state.f = inlineNormal;
	        state.block = blockNormal;
	        state.htmlState = null;
	      }
	    }
	    // Reset state.trailingSpace
	    state.trailingSpace = 0;
	    state.trailingSpaceNewLine = false;
	    // Mark this line as blank
	    state.prevLine = state.thisLine
	    state.thisLine = {stream: null}
	    return null;
	  }
	
	  function blockNormal(stream, state) {
	    var firstTokenOnLine = stream.column() === state.indentation;
	    var prevLineLineIsEmpty = lineIsEmpty(state.prevLine.stream);
	    var prevLineIsIndentedCode = state.indentedCode;
	    var prevLineIsHr = state.prevLine.hr;
	    var prevLineIsList = state.list !== false;
	    var maxNonCodeIndentation = (state.listStack[state.listStack.length - 1] || 0) + 3;
	
	    state.indentedCode = false;
	
	    var lineIndentation = state.indentation;
	    // compute once per line (on first token)
	    if (state.indentationDiff === null) {
	      state.indentationDiff = state.indentation;
	      if (prevLineIsList) {
	        state.list = null;
	        // While this list item's marker's indentation is less than the deepest
	        //  list item's content's indentation,pop the deepest list item
	        //  indentation off the stack, and update block indentation state
	        while (lineIndentation < state.listStack[state.listStack.length - 1]) {
	          state.listStack.pop();
	          if (state.listStack.length) {
	            state.indentation = state.listStack[state.listStack.length - 1];
	          // less than the first list's indent -> the line is no longer a list
	          } else {
	            state.list = false;
	          }
	        }
	        if (state.list !== false) {
	          state.indentationDiff = lineIndentation - state.listStack[state.listStack.length - 1]
	        }
	      }
	    }
	
	    // not comprehensive (currently only for setext detection purposes)
	    var allowsInlineContinuation = (
	        !prevLineLineIsEmpty && !prevLineIsHr && !state.prevLine.header &&
	        (!prevLineIsList || !prevLineIsIndentedCode) &&
	        !state.prevLine.fencedCodeEnd
	    );
	
	    var isHr = (state.list === false || prevLineIsHr || prevLineLineIsEmpty) &&
	      state.indentation <= maxNonCodeIndentation && stream.match(hrRE);
	
	    var match = null;
	    if (state.indentationDiff >= 4 && (prevLineIsIndentedCode || state.prevLine.fencedCodeEnd ||
	         state.prevLine.header || prevLineLineIsEmpty)) {
	      stream.skipToEnd();
	      state.indentedCode = true;
	      return tokenTypes.code;
	    } else if (stream.eatSpace()) {
	      return null;
	    } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(atxHeaderRE)) && match[1].length <= 6) {
	      state.quote = 0;
	      state.header = match[1].length;
	      state.thisLine.header = true;
	      if (modeCfg.highlightFormatting) state.formatting = "header";
	      state.f = state.inline;
	      return getType(state);
	    } else if (state.indentation <= maxNonCodeIndentation && stream.eat('>')) {
	      state.quote = firstTokenOnLine ? 1 : state.quote + 1;
	      if (modeCfg.highlightFormatting) state.formatting = "quote";
	      stream.eatSpace();
	      return getType(state);
	    } else if (!isHr && !state.setext && firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(listRE))) {
	      var listType = match[1] ? "ol" : "ul";
	
	      state.indentation = lineIndentation + stream.current().length;
	      state.list = true;
	      state.quote = 0;
	
	      // Add this list item's content's indentation to the stack
	      state.listStack.push(state.indentation);
	      // Reset inline styles which shouldn't propagate aross list items
	      state.em = false;
	      state.strong = false;
	      state.code = false;
	      state.strikethrough = false;
	
	      if (modeCfg.taskLists && stream.match(taskListRE, false)) {
	        state.taskList = true;
	      }
	      state.f = state.inline;
	      if (modeCfg.highlightFormatting) state.formatting = ["list", "list-" + listType];
	      return getType(state);
	    } else if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(fencedCodeRE, true))) {
	      state.quote = 0;
	      state.fencedEndRE = new RegExp(match[1] + "+ *$");
	      // try switching mode
	      state.localMode = modeCfg.fencedCodeBlockHighlighting && getMode(match[2]);
	      if (state.localMode) state.localState = CodeMirror.startState(state.localMode);
	      state.f = state.block = local;
	      if (modeCfg.highlightFormatting) state.formatting = "code-block";
	      state.code = -1
	      return getType(state);
	    // SETEXT has lowest block-scope precedence after HR, so check it after
	    //  the others (code, blockquote, list...)
	    } else if (
	      // if setext set, indicates line after ---/===
	      state.setext || (
	        // line before ---/===
	        (!allowsInlineContinuation || !prevLineIsList) && !state.quote && state.list === false &&
	        !state.code && !isHr && !linkDefRE.test(stream.string) &&
	        (match = stream.lookAhead(1)) && (match = match.match(setextHeaderRE))
	      )
	    ) {
	      if ( !state.setext ) {
	        state.header = match[0].charAt(0) == '=' ? 1 : 2;
	        state.setext = state.header;
	      } else {
	        state.header = state.setext;
	        // has no effect on type so we can reset it now
	        state.setext = 0;
	        stream.skipToEnd();
	        if (modeCfg.highlightFormatting) state.formatting = "header";
	      }
	      state.thisLine.header = true;
	      state.f = state.inline;
	      return getType(state);
	    } else if (isHr) {
	      stream.skipToEnd();
	      state.hr = true;
	      state.thisLine.hr = true;
	      return tokenTypes.hr;
	    } else if (stream.peek() === '[') {
	      return switchInline(stream, state, footnoteLink);
	    }
	
	    return switchInline(stream, state, state.inline);
	  }
	
	  function htmlBlock(stream, state) {
	    var style = htmlMode.token(stream, state.htmlState);
	    if (!htmlModeMissing) {
	      var inner = CodeMirror.innerMode(htmlMode, state.htmlState)
	      if ((inner.mode.name == "xml" && inner.state.tagStart === null &&
	           (!inner.state.context && inner.state.tokenize.isInText)) ||
	          (state.md_inside && stream.current().indexOf(">") > -1)) {
	        state.f = inlineNormal;
	        state.block = blockNormal;
	        state.htmlState = null;
	      }
	    }
	    return style;
	  }
	
	  function local(stream, state) {
	    var currListInd = state.listStack[state.listStack.length - 1] || 0;
	    var hasExitedList = state.indentation < currListInd;
	    var maxFencedEndInd = currListInd + 3;
	    if (state.fencedEndRE && state.indentation <= maxFencedEndInd && (hasExitedList || stream.match(state.fencedEndRE))) {
	      if (modeCfg.highlightFormatting) state.formatting = "code-block";
	      var returnType;
	      if (!hasExitedList) returnType = getType(state)
	      state.localMode = state.localState = null;
	      state.block = blockNormal;
	      state.f = inlineNormal;
	      state.fencedEndRE = null;
	      state.code = 0
	      state.thisLine.fencedCodeEnd = true;
	      if (hasExitedList) return switchBlock(stream, state, state.block);
	      return returnType;
	    } else if (state.localMode) {
	      return state.localMode.token(stream, state.localState);
	    } else {
	      stream.skipToEnd();
	      return tokenTypes.code;
	    }
	  }
	
	  // Inline
	  function getType(state) {
	    var styles = [];
	
	    if (state.formatting) {
	      styles.push(tokenTypes.formatting);
	
	      if (typeof state.formatting === "string") state.formatting = [state.formatting];
	
	      for (var i = 0; i < state.formatting.length; i++) {
	        styles.push(tokenTypes.formatting + "-" + state.formatting[i]);
	
	        if (state.formatting[i] === "header") {
	          styles.push(tokenTypes.formatting + "-" + state.formatting[i] + "-" + state.header);
	        }
	
	        // Add `formatting-quote` and `formatting-quote-#` for blockquotes
	        // Add `error` instead if the maximum blockquote nesting depth is passed
	        if (state.formatting[i] === "quote") {
	          if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
	            styles.push(tokenTypes.formatting + "-" + state.formatting[i] + "-" + state.quote);
	          } else {
	            styles.push("error");
	          }
	        }
	      }
	    }
	
	    if (state.taskOpen) {
	      styles.push("meta");
	      return styles.length ? styles.join(' ') : null;
	    }
	    if (state.taskClosed) {
	      styles.push("property");
	      return styles.length ? styles.join(' ') : null;
	    }
	
	    if (state.linkHref) {
	      styles.push(tokenTypes.linkHref, "url");
	    } else { // Only apply inline styles to non-url text
	      if (state.strong) { styles.push(tokenTypes.strong); }
	      if (state.em) { styles.push(tokenTypes.em); }
	      if (state.strikethrough) { styles.push(tokenTypes.strikethrough); }
	      if (state.emoji) { styles.push(tokenTypes.emoji); }
	      if (state.linkText) { styles.push(tokenTypes.linkText); }
	      if (state.code) { styles.push(tokenTypes.code); }
	      if (state.image) { styles.push(tokenTypes.image); }
	      if (state.imageAltText) { styles.push(tokenTypes.imageAltText, "link"); }
	      if (state.imageMarker) { styles.push(tokenTypes.imageMarker); }
	    }
	
	    if (state.header) { styles.push(tokenTypes.header, tokenTypes.header + "-" + state.header); }
	
	    if (state.quote) {
	      styles.push(tokenTypes.quote);
	
	      // Add `quote-#` where the maximum for `#` is modeCfg.maxBlockquoteDepth
	      if (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote) {
	        styles.push(tokenTypes.quote + "-" + state.quote);
	      } else {
	        styles.push(tokenTypes.quote + "-" + modeCfg.maxBlockquoteDepth);
	      }
	    }
	
	    if (state.list !== false) {
	      var listMod = (state.listStack.length - 1) % 3;
	      if (!listMod) {
	        styles.push(tokenTypes.list1);
	      } else if (listMod === 1) {
	        styles.push(tokenTypes.list2);
	      } else {
	        styles.push(tokenTypes.list3);
	      }
	    }
	
	    if (state.trailingSpaceNewLine) {
	      styles.push("trailing-space-new-line");
	    } else if (state.trailingSpace) {
	      styles.push("trailing-space-" + (state.trailingSpace % 2 ? "a" : "b"));
	    }
	
	    return styles.length ? styles.join(' ') : null;
	  }
	
	  function handleText(stream, state) {
	    if (stream.match(textRE, true)) {
	      return getType(state);
	    }
	    return undefined;
	  }
	
	  function inlineNormal(stream, state) {
	    var style = state.text(stream, state);
	    if (typeof style !== 'undefined')
	      return style;
	
	    if (state.list) { // List marker (*, +, -, 1., etc)
	      state.list = null;
	      return getType(state);
	    }
	
	    if (state.taskList) {
	      var taskOpen = stream.match(taskListRE, true)[1] === " ";
	      if (taskOpen) state.taskOpen = true;
	      else state.taskClosed = true;
	      if (modeCfg.highlightFormatting) state.formatting = "task";
	      state.taskList = false;
	      return getType(state);
	    }
	
	    state.taskOpen = false;
	    state.taskClosed = false;
	
	    if (state.header && stream.match(/^#+$/, true)) {
	      if (modeCfg.highlightFormatting) state.formatting = "header";
	      return getType(state);
	    }
	
	    var ch = stream.next();
	
	    // Matches link titles present on next line
	    if (state.linkTitle) {
	      state.linkTitle = false;
	      var matchCh = ch;
	      if (ch === '(') {
	        matchCh = ')';
	      }
	      matchCh = (matchCh+'').replace(/([.?*+^\[\]\\(){}|-])/g, "\\$1");
	      var regex = '^\\s*(?:[^' + matchCh + '\\\\]+|\\\\\\\\|\\\\.)' + matchCh;
	      if (stream.match(new RegExp(regex), true)) {
	        return tokenTypes.linkHref;
	      }
	    }
	
	    // If this block is changed, it may need to be updated in GFM mode
	    if (ch === '`') {
	      var previousFormatting = state.formatting;
	      if (modeCfg.highlightFormatting) state.formatting = "code";
	      stream.eatWhile('`');
	      var count = stream.current().length
	      if (state.code == 0 && (!state.quote || count == 1)) {
	        state.code = count
	        return getType(state)
	      } else if (count == state.code) { // Must be exact
	        var t = getType(state)
	        state.code = 0
	        return t
	      } else {
	        state.formatting = previousFormatting
	        return getType(state)
	      }
	    } else if (state.code) {
	      return getType(state);
	    }
	
	    if (ch === '\\') {
	      stream.next();
	      if (modeCfg.highlightFormatting) {
	        var type = getType(state);
	        var formattingEscape = tokenTypes.formatting + "-escape";
	        return type ? type + " " + formattingEscape : formattingEscape;
	      }
	    }
	
	    if (ch === '!' && stream.match(/\[[^\]]*\] ?(?:\(|\[)/, false)) {
	      state.imageMarker = true;
	      state.image = true;
	      if (modeCfg.highlightFormatting) state.formatting = "image";
	      return getType(state);
	    }
	
	    if (ch === '[' && state.imageMarker && stream.match(/[^\]]*\](\(.*?\)| ?\[.*?\])/, false)) {
	      state.imageMarker = false;
	      state.imageAltText = true
	      if (modeCfg.highlightFormatting) state.formatting = "image";
	      return getType(state);
	    }
	
	    if (ch === ']' && state.imageAltText) {
	      if (modeCfg.highlightFormatting) state.formatting = "image";
	      var type = getType(state);
	      state.imageAltText = false;
	      state.image = false;
	      state.inline = state.f = linkHref;
	      return type;
	    }
	
	    if (ch === '[' && !state.image) {
	      if (state.linkText && stream.match(/^.*?\]/)) return getType(state)
	      state.linkText = true;
	      if (modeCfg.highlightFormatting) state.formatting = "link";
	      return getType(state);
	    }
	
	    if (ch === ']' && state.linkText) {
	      if (modeCfg.highlightFormatting) state.formatting = "link";
	      var type = getType(state);
	      state.linkText = false;
	      state.inline = state.f = stream.match(/\(.*?\)| ?\[.*?\]/, false) ? linkHref : inlineNormal
	      return type;
	    }
	
	    if (ch === '<' && stream.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, false)) {
	      state.f = state.inline = linkInline;
	      if (modeCfg.highlightFormatting) state.formatting = "link";
	      var type = getType(state);
	      if (type){
	        type += " ";
	      } else {
	        type = "";
	      }
	      return type + tokenTypes.linkInline;
	    }
	
	    if (ch === '<' && stream.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, false)) {
	      state.f = state.inline = linkInline;
	      if (modeCfg.highlightFormatting) state.formatting = "link";
	      var type = getType(state);
	      if (type){
	        type += " ";
	      } else {
	        type = "";
	      }
	      return type + tokenTypes.linkEmail;
	    }
	
	    if (modeCfg.xml && ch === '<' && stream.match(/^(!--|\?|!\[CDATA\[|[a-z][a-z0-9-]*(?:\s+[a-z_:.\-]+(?:\s*=\s*[^>]+)?)*\s*(?:>|$))/i, false)) {
	      var end = stream.string.indexOf(">", stream.pos);
	      if (end != -1) {
	        var atts = stream.string.substring(stream.start, end);
	        if (/markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(atts)) state.md_inside = true;
	      }
	      stream.backUp(1);
	      state.htmlState = CodeMirror.startState(htmlMode);
	      return switchBlock(stream, state, htmlBlock);
	    }
	
	    if (modeCfg.xml && ch === '<' && stream.match(/^\/\w*?>/)) {
	      state.md_inside = false;
	      return "tag";
	    } else if (ch === "*" || ch === "_") {
	      var len = 1, before = stream.pos == 1 ? " " : stream.string.charAt(stream.pos - 2)
	      while (len < 3 && stream.eat(ch)) len++
	      var after = stream.peek() || " "
	      // See http://spec.commonmark.org/0.27/#emphasis-and-strong-emphasis
	      var leftFlanking = !/\s/.test(after) && (!punctuation.test(after) || /\s/.test(before) || punctuation.test(before))
	      var rightFlanking = !/\s/.test(before) && (!punctuation.test(before) || /\s/.test(after) || punctuation.test(after))
	      var setEm = null, setStrong = null
	      if (len % 2) { // Em
	        if (!state.em && leftFlanking && (ch === "*" || !rightFlanking || punctuation.test(before)))
	          setEm = true
	        else if (state.em == ch && rightFlanking && (ch === "*" || !leftFlanking || punctuation.test(after)))
	          setEm = false
	      }
	      if (len > 1) { // Strong
	        if (!state.strong && leftFlanking && (ch === "*" || !rightFlanking || punctuation.test(before)))
	          setStrong = true
	        else if (state.strong == ch && rightFlanking && (ch === "*" || !leftFlanking || punctuation.test(after)))
	          setStrong = false
	      }
	      if (setStrong != null || setEm != null) {
	        if (modeCfg.highlightFormatting) state.formatting = setEm == null ? "strong" : setStrong == null ? "em" : "strong em"
	        if (setEm === true) state.em = ch
	        if (setStrong === true) state.strong = ch
	        var t = getType(state)
	        if (setEm === false) state.em = false
	        if (setStrong === false) state.strong = false
	        return t
	      }
	    } else if (ch === ' ') {
	      if (stream.eat('*') || stream.eat('_')) { // Probably surrounded by spaces
	        if (stream.peek() === ' ') { // Surrounded by spaces, ignore
	          return getType(state);
	        } else { // Not surrounded by spaces, back up pointer
	          stream.backUp(1);
	        }
	      }
	    }
	
	    if (modeCfg.strikethrough) {
	      if (ch === '~' && stream.eatWhile(ch)) {
	        if (state.strikethrough) {// Remove strikethrough
	          if (modeCfg.highlightFormatting) state.formatting = "strikethrough";
	          var t = getType(state);
	          state.strikethrough = false;
	          return t;
	        } else if (stream.match(/^[^\s]/, false)) {// Add strikethrough
	          state.strikethrough = true;
	          if (modeCfg.highlightFormatting) state.formatting = "strikethrough";
	          return getType(state);
	        }
	      } else if (ch === ' ') {
	        if (stream.match(/^~~/, true)) { // Probably surrounded by space
	          if (stream.peek() === ' ') { // Surrounded by spaces, ignore
	            return getType(state);
	          } else { // Not surrounded by spaces, back up pointer
	            stream.backUp(2);
	          }
	        }
	      }
	    }
	
	    if (modeCfg.emoji && ch === ":" && stream.match(/^(?:[a-z_\d+][a-z_\d+-]*|\-[a-z_\d+][a-z_\d+-]*):/)) {
	      state.emoji = true;
	      if (modeCfg.highlightFormatting) state.formatting = "emoji";
	      var retType = getType(state);
	      state.emoji = false;
	      return retType;
	    }
	
	    if (ch === ' ') {
	      if (stream.match(/^ +$/, false)) {
	        state.trailingSpace++;
	      } else if (state.trailingSpace) {
	        state.trailingSpaceNewLine = true;
	      }
	    }
	
	    return getType(state);
	  }
	
	  function linkInline(stream, state) {
	    var ch = stream.next();
	
	    if (ch === ">") {
	      state.f = state.inline = inlineNormal;
	      if (modeCfg.highlightFormatting) state.formatting = "link";
	      var type = getType(state);
	      if (type){
	        type += " ";
	      } else {
	        type = "";
	      }
	      return type + tokenTypes.linkInline;
	    }
	
	    stream.match(/^[^>]+/, true);
	
	    return tokenTypes.linkInline;
	  }
	
	  function linkHref(stream, state) {
	    // Check if space, and return NULL if so (to avoid marking the space)
	    if(stream.eatSpace()){
	      return null;
	    }
	    var ch = stream.next();
	    if (ch === '(' || ch === '[') {
	      state.f = state.inline = getLinkHrefInside(ch === "(" ? ")" : "]");
	      if (modeCfg.highlightFormatting) state.formatting = "link-string";
	      state.linkHref = true;
	      return getType(state);
	    }
	    return 'error';
	  }
	
	  var linkRE = {
	    ")": /^(?:[^\\\(\)]|\\.|\((?:[^\\\(\)]|\\.)*\))*?(?=\))/,
	    "]": /^(?:[^\\\[\]]|\\.|\[(?:[^\\\[\]]|\\.)*\])*?(?=\])/
	  }
	
	  function getLinkHrefInside(endChar) {
	    return function(stream, state) {
	      var ch = stream.next();
	
	      if (ch === endChar) {
	        state.f = state.inline = inlineNormal;
	        if (modeCfg.highlightFormatting) state.formatting = "link-string";
	        var returnState = getType(state);
	        state.linkHref = false;
	        return returnState;
	      }
	
	      stream.match(linkRE[endChar])
	      state.linkHref = true;
	      return getType(state);
	    };
	  }
	
	  function footnoteLink(stream, state) {
	    if (stream.match(/^([^\]\\]|\\.)*\]:/, false)) {
	      state.f = footnoteLinkInside;
	      stream.next(); // Consume [
	      if (modeCfg.highlightFormatting) state.formatting = "link";
	      state.linkText = true;
	      return getType(state);
	    }
	    return switchInline(stream, state, inlineNormal);
	  }
	
	  function footnoteLinkInside(stream, state) {
	    if (stream.match(/^\]:/, true)) {
	      state.f = state.inline = footnoteUrl;
	      if (modeCfg.highlightFormatting) state.formatting = "link";
	      var returnType = getType(state);
	      state.linkText = false;
	      return returnType;
	    }
	
	    stream.match(/^([^\]\\]|\\.)+/, true);
	
	    return tokenTypes.linkText;
	  }
	
	  function footnoteUrl(stream, state) {
	    // Check if space, and return NULL if so (to avoid marking the space)
	    if(stream.eatSpace()){
	      return null;
	    }
	    // Match URL
	    stream.match(/^[^\s]+/, true);
	    // Check for link title
	    if (stream.peek() === undefined) { // End of line, set flag to check next line
	      state.linkTitle = true;
	    } else { // More content on line, check if link title
	      stream.match(/^(?:\s+(?:"(?:[^"\\]|\\\\|\\.)+"|'(?:[^'\\]|\\\\|\\.)+'|\((?:[^)\\]|\\\\|\\.)+\)))?/, true);
	    }
	    state.f = state.inline = inlineNormal;
	    return tokenTypes.linkHref + " url";
	  }
	
	  var mode = {
	    startState: function() {
	      return {
	        f: blockNormal,
	
	        prevLine: {stream: null},
	        thisLine: {stream: null},
	
	        block: blockNormal,
	        htmlState: null,
	        indentation: 0,
	
	        inline: inlineNormal,
	        text: handleText,
	
	        formatting: false,
	        linkText: false,
	        linkHref: false,
	        linkTitle: false,
	        code: 0,
	        em: false,
	        strong: false,
	        header: 0,
	        setext: 0,
	        hr: false,
	        taskList: false,
	        list: false,
	        listStack: [],
	        quote: 0,
	        trailingSpace: 0,
	        trailingSpaceNewLine: false,
	        strikethrough: false,
	        emoji: false,
	        fencedEndRE: null
	      };
	    },
	
	    copyState: function(s) {
	      return {
	        f: s.f,
	
	        prevLine: s.prevLine,
	        thisLine: s.thisLine,
	
	        block: s.block,
	        htmlState: s.htmlState && CodeMirror.copyState(htmlMode, s.htmlState),
	        indentation: s.indentation,
	
	        localMode: s.localMode,
	        localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,
	
	        inline: s.inline,
	        text: s.text,
	        formatting: false,
	        linkText: s.linkText,
	        linkTitle: s.linkTitle,
	        linkHref: s.linkHref,
	        code: s.code,
	        em: s.em,
	        strong: s.strong,
	        strikethrough: s.strikethrough,
	        emoji: s.emoji,
	        header: s.header,
	        setext: s.setext,
	        hr: s.hr,
	        taskList: s.taskList,
	        list: s.list,
	        listStack: s.listStack.slice(0),
	        quote: s.quote,
	        indentedCode: s.indentedCode,
	        trailingSpace: s.trailingSpace,
	        trailingSpaceNewLine: s.trailingSpaceNewLine,
	        md_inside: s.md_inside,
	        fencedEndRE: s.fencedEndRE
	      };
	    },
	
	    token: function(stream, state) {
	
	      // Reset state.formatting
	      state.formatting = false;
	
	      if (stream != state.thisLine.stream) {
	        state.header = 0;
	        state.hr = false;
	
	        if (stream.match(/^\s*$/, true)) {
	          blankLine(state);
	          return null;
	        }
	
	        state.prevLine = state.thisLine
	        state.thisLine = {stream: stream}
	
	        // Reset state.taskList
	        state.taskList = false;
	
	        // Reset state.trailingSpace
	        state.trailingSpace = 0;
	        state.trailingSpaceNewLine = false;
	
	        if (!state.localState) {
	          state.f = state.block;
	          if (state.f != htmlBlock) {
	            var indentation = stream.match(/^\s*/, true)[0].replace(/\t/g, expandedTab).length;
	            state.indentation = indentation;
	            state.indentationDiff = null;
	            if (indentation > 0) return null;
	          }
	        }
	      }
	      return state.f(stream, state);
	    },
	
	    innerMode: function(state) {
	      if (state.block == htmlBlock) return {state: state.htmlState, mode: htmlMode};
	      if (state.localState) return {state: state.localState, mode: state.localMode};
	      return {state: state, mode: mode};
	    },
	
	    indent: function(state, textAfter, line) {
	      if (state.block == htmlBlock && htmlMode.indent) return htmlMode.indent(state.htmlState, textAfter, line)
	      if (state.localState && state.localMode.indent) return state.localMode.indent(state.localState, textAfter, line)
	      return CodeMirror.Pass
	    },
	
	    blankLine: blankLine,
	
	    getType: getType,
	
	    blockCommentStart: "<!--",
	    blockCommentEnd: "-->",
	    closeBrackets: "()[]{}''\"\"``",
	    fold: "markdown"
	  };
	  return mode;
	}, "xml");
	
	CodeMirror.defineMIME("text/markdown", "markdown");
	
	CodeMirror.defineMIME("text/x-markdown", "markdown");
	
	});


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: https://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(38));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	"use strict";
	
	var htmlConfig = {
	  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
	                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
	                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
	                    'track': true, 'wbr': true, 'menuitem': true},
	  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
	                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
	                     'th': true, 'tr': true},
	  contextGrabbers: {
	    'dd': {'dd': true, 'dt': true},
	    'dt': {'dd': true, 'dt': true},
	    'li': {'li': true},
	    'option': {'option': true, 'optgroup': true},
	    'optgroup': {'optgroup': true},
	    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
	          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
	          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
	          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
	          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},
	    'rp': {'rp': true, 'rt': true},
	    'rt': {'rp': true, 'rt': true},
	    'tbody': {'tbody': true, 'tfoot': true},
	    'td': {'td': true, 'th': true},
	    'tfoot': {'tbody': true},
	    'th': {'td': true, 'th': true},
	    'thead': {'tbody': true, 'tfoot': true},
	    'tr': {'tr': true}
	  },
	  doNotIndent: {"pre": true},
	  allowUnquoted: true,
	  allowMissing: true,
	  caseFold: true
	}
	
	var xmlConfig = {
	  autoSelfClosers: {},
	  implicitlyClosed: {},
	  contextGrabbers: {},
	  doNotIndent: {},
	  allowUnquoted: false,
	  allowMissing: false,
	  allowMissingTagName: false,
	  caseFold: false
	}
	
	CodeMirror.defineMode("xml", function(editorConf, config_) {
	  var indentUnit = editorConf.indentUnit
	  var config = {}
	  var defaults = config_.htmlMode ? htmlConfig : xmlConfig
	  for (var prop in defaults) config[prop] = defaults[prop]
	  for (var prop in config_) config[prop] = config_[prop]
	
	  // Return variables for tokenizers
	  var type, setStyle;
	
	  function inText(stream, state) {
	    function chain(parser) {
	      state.tokenize = parser;
	      return parser(stream, state);
	    }
	
	    var ch = stream.next();
	    if (ch == "<") {
	      if (stream.eat("!")) {
	        if (stream.eat("[")) {
	          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
	          else return null;
	        } else if (stream.match("--")) {
	          return chain(inBlock("comment", "-->"));
	        } else if (stream.match("DOCTYPE", true, true)) {
	          stream.eatWhile(/[\w\._\-]/);
	          return chain(doctype(1));
	        } else {
	          return null;
	        }
	      } else if (stream.eat("?")) {
	        stream.eatWhile(/[\w\._\-]/);
	        state.tokenize = inBlock("meta", "?>");
	        return "meta";
	      } else {
	        type = stream.eat("/") ? "closeTag" : "openTag";
	        state.tokenize = inTag;
	        return "tag bracket";
	      }
	    } else if (ch == "&") {
	      var ok;
	      if (stream.eat("#")) {
	        if (stream.eat("x")) {
	          ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
	        } else {
	          ok = stream.eatWhile(/[\d]/) && stream.eat(";");
	        }
	      } else {
	        ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
	      }
	      return ok ? "atom" : "error";
	    } else {
	      stream.eatWhile(/[^&<]/);
	      return null;
	    }
	  }
	  inText.isInText = true;
	
	  function inTag(stream, state) {
	    var ch = stream.next();
	    if (ch == ">" || (ch == "/" && stream.eat(">"))) {
	      state.tokenize = inText;
	      type = ch == ">" ? "endTag" : "selfcloseTag";
	      return "tag bracket";
	    } else if (ch == "=") {
	      type = "equals";
	      return null;
	    } else if (ch == "<") {
	      state.tokenize = inText;
	      state.state = baseState;
	      state.tagName = state.tagStart = null;
	      var next = state.tokenize(stream, state);
	      return next ? next + " tag error" : "tag error";
	    } else if (/[\'\"]/.test(ch)) {
	      state.tokenize = inAttribute(ch);
	      state.stringStartCol = stream.column();
	      return state.tokenize(stream, state);
	    } else {
	      stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
	      return "word";
	    }
	  }
	
	  function inAttribute(quote) {
	    var closure = function(stream, state) {
	      while (!stream.eol()) {
	        if (stream.next() == quote) {
	          state.tokenize = inTag;
	          break;
	        }
	      }
	      return "string";
	    };
	    closure.isInAttribute = true;
	    return closure;
	  }
	
	  function inBlock(style, terminator) {
	    return function(stream, state) {
	      while (!stream.eol()) {
	        if (stream.match(terminator)) {
	          state.tokenize = inText;
	          break;
	        }
	        stream.next();
	      }
	      return style;
	    }
	  }
	
	  function doctype(depth) {
	    return function(stream, state) {
	      var ch;
	      while ((ch = stream.next()) != null) {
	        if (ch == "<") {
	          state.tokenize = doctype(depth + 1);
	          return state.tokenize(stream, state);
	        } else if (ch == ">") {
	          if (depth == 1) {
	            state.tokenize = inText;
	            break;
	          } else {
	            state.tokenize = doctype(depth - 1);
	            return state.tokenize(stream, state);
	          }
	        }
	      }
	      return "meta";
	    };
	  }
	
	  function Context(state, tagName, startOfLine) {
	    this.prev = state.context;
	    this.tagName = tagName;
	    this.indent = state.indented;
	    this.startOfLine = startOfLine;
	    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))
	      this.noIndent = true;
	  }
	  function popContext(state) {
	    if (state.context) state.context = state.context.prev;
	  }
	  function maybePopContext(state, nextTagName) {
	    var parentTagName;
	    while (true) {
	      if (!state.context) {
	        return;
	      }
	      parentTagName = state.context.tagName;
	      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||
	          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
	        return;
	      }
	      popContext(state);
	    }
	  }
	
	  function baseState(type, stream, state) {
	    if (type == "openTag") {
	      state.tagStart = stream.column();
	      return tagNameState;
	    } else if (type == "closeTag") {
	      return closeTagNameState;
	    } else {
	      return baseState;
	    }
	  }
	  function tagNameState(type, stream, state) {
	    if (type == "word") {
	      state.tagName = stream.current();
	      setStyle = "tag";
	      return attrState;
	    } else if (config.allowMissingTagName && type == "endTag") {
	      setStyle = "tag bracket";
	      return attrState(type, stream, state);
	    } else {
	      setStyle = "error";
	      return tagNameState;
	    }
	  }
	  function closeTagNameState(type, stream, state) {
	    if (type == "word") {
	      var tagName = stream.current();
	      if (state.context && state.context.tagName != tagName &&
	          config.implicitlyClosed.hasOwnProperty(state.context.tagName))
	        popContext(state);
	      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {
	        setStyle = "tag";
	        return closeState;
	      } else {
	        setStyle = "tag error";
	        return closeStateErr;
	      }
	    } else if (config.allowMissingTagName && type == "endTag") {
	      setStyle = "tag bracket";
	      return closeState(type, stream, state);
	    } else {
	      setStyle = "error";
	      return closeStateErr;
	    }
	  }
	
	  function closeState(type, _stream, state) {
	    if (type != "endTag") {
	      setStyle = "error";
	      return closeState;
	    }
	    popContext(state);
	    return baseState;
	  }
	  function closeStateErr(type, stream, state) {
	    setStyle = "error";
	    return closeState(type, stream, state);
	  }
	
	  function attrState(type, _stream, state) {
	    if (type == "word") {
	      setStyle = "attribute";
	      return attrEqState;
	    } else if (type == "endTag" || type == "selfcloseTag") {
	      var tagName = state.tagName, tagStart = state.tagStart;
	      state.tagName = state.tagStart = null;
	      if (type == "selfcloseTag" ||
	          config.autoSelfClosers.hasOwnProperty(tagName)) {
	        maybePopContext(state, tagName);
	      } else {
	        maybePopContext(state, tagName);
	        state.context = new Context(state, tagName, tagStart == state.indented);
	      }
	      return baseState;
	    }
	    setStyle = "error";
	    return attrState;
	  }
	  function attrEqState(type, stream, state) {
	    if (type == "equals") return attrValueState;
	    if (!config.allowMissing) setStyle = "error";
	    return attrState(type, stream, state);
	  }
	  function attrValueState(type, stream, state) {
	    if (type == "string") return attrContinuedState;
	    if (type == "word" && config.allowUnquoted) {setStyle = "string"; return attrState;}
	    setStyle = "error";
	    return attrState(type, stream, state);
	  }
	  function attrContinuedState(type, stream, state) {
	    if (type == "string") return attrContinuedState;
	    return attrState(type, stream, state);
	  }
	
	  return {
	    startState: function(baseIndent) {
	      var state = {tokenize: inText,
	                   state: baseState,
	                   indented: baseIndent || 0,
	                   tagName: null, tagStart: null,
	                   context: null}
	      if (baseIndent != null) state.baseIndent = baseIndent
	      return state
	    },
	
	    token: function(stream, state) {
	      if (!state.tagName && stream.sol())
	        state.indented = stream.indentation();
	
	      if (stream.eatSpace()) return null;
	      type = null;
	      var style = state.tokenize(stream, state);
	      if ((style || type) && style != "comment") {
	        setStyle = null;
	        state.state = state.state(type || style, stream, state);
	        if (setStyle)
	          style = setStyle == "error" ? style + " error" : setStyle;
	      }
	      return style;
	    },
	
	    indent: function(state, textAfter, fullLine) {
	      var context = state.context;
	      // Indent multi-line strings (e.g. css).
	      if (state.tokenize.isInAttribute) {
	        if (state.tagStart == state.indented)
	          return state.stringStartCol + 1;
	        else
	          return state.indented + indentUnit;
	      }
	      if (context && context.noIndent) return CodeMirror.Pass;
	      if (state.tokenize != inTag && state.tokenize != inText)
	        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
	      // Indent the starts of attribute names.
	      if (state.tagName) {
	        if (config.multilineTagIndentPastTag !== false)
	          return state.tagStart + state.tagName.length + 2;
	        else
	          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
	      }
	      if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
	      var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
	      if (tagAfter && tagAfter[1]) { // Closing tag spotted
	        while (context) {
	          if (context.tagName == tagAfter[2]) {
	            context = context.prev;
	            break;
	          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {
	            context = context.prev;
	          } else {
	            break;
	          }
	        }
	      } else if (tagAfter) { // Opening tag spotted
	        while (context) {
	          var grabbers = config.contextGrabbers[context.tagName];
	          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))
	            context = context.prev;
	          else
	            break;
	        }
	      }
	      while (context && context.prev && !context.startOfLine)
	        context = context.prev;
	      if (context) return context.indent + indentUnit;
	      else return state.baseIndent || 0;
	    },
	
	    electricInput: /<\/[\s\w:]+>$/,
	    blockCommentStart: "<!--",
	    blockCommentEnd: "-->",
	
	    configuration: config.htmlMode ? "html" : "xml",
	    helperType: config.htmlMode ? "html" : "xml",
	
	    skipAttribute: function(state) {
	      if (state.state == attrValueState)
	        state.state = attrState
	    },
	
	    xmlCurrentTag: function(state) {
	      return state.tagName ? {name: state.tagName, close: state.type == "closeTag"} : null
	    },
	
	    xmlCurrentContext: function(state) {
	      var context = []
	      for (var cx = state.context; cx; cx = cx.prev)
	        if (cx.tagName) context.push(cx.tagName)
	      return context.reverse()
	    }
	  };
	});
	
	CodeMirror.defineMIME("text/xml", "xml");
	CodeMirror.defineMIME("application/xml", "xml");
	if (!CodeMirror.mimeModes.hasOwnProperty("text/html"))
	  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});
	
	});


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: https://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(38));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";
	
	  CodeMirror.modeInfo = [
	    {name: "APL", mime: "text/apl", mode: "apl", ext: ["dyalog", "apl"]},
	    {name: "PGP", mimes: ["application/pgp", "application/pgp-encrypted", "application/pgp-keys", "application/pgp-signature"], mode: "asciiarmor", ext: ["asc", "pgp", "sig"]},
	    {name: "ASN.1", mime: "text/x-ttcn-asn", mode: "asn.1", ext: ["asn", "asn1"]},
	    {name: "Asterisk", mime: "text/x-asterisk", mode: "asterisk", file: /^extensions\.conf$/i},
	    {name: "Brainfuck", mime: "text/x-brainfuck", mode: "brainfuck", ext: ["b", "bf"]},
	    {name: "C", mime: "text/x-csrc", mode: "clike", ext: ["c", "h", "ino"]},
	    {name: "C++", mime: "text/x-c++src", mode: "clike", ext: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"], alias: ["cpp"]},
	    {name: "Cobol", mime: "text/x-cobol", mode: "cobol", ext: ["cob", "cpy"]},
	    {name: "C#", mime: "text/x-csharp", mode: "clike", ext: ["cs"], alias: ["csharp", "cs"]},
	    {name: "Clojure", mime: "text/x-clojure", mode: "clojure", ext: ["clj", "cljc", "cljx"]},
	    {name: "ClojureScript", mime: "text/x-clojurescript", mode: "clojure", ext: ["cljs"]},
	    {name: "Closure Stylesheets (GSS)", mime: "text/x-gss", mode: "css", ext: ["gss"]},
	    {name: "CMake", mime: "text/x-cmake", mode: "cmake", ext: ["cmake", "cmake.in"], file: /^CMakeLists.txt$/},
	    {name: "CoffeeScript", mimes: ["application/vnd.coffeescript", "text/coffeescript", "text/x-coffeescript"], mode: "coffeescript", ext: ["coffee"], alias: ["coffee", "coffee-script"]},
	    {name: "Common Lisp", mime: "text/x-common-lisp", mode: "commonlisp", ext: ["cl", "lisp", "el"], alias: ["lisp"]},
	    {name: "Cypher", mime: "application/x-cypher-query", mode: "cypher", ext: ["cyp", "cypher"]},
	    {name: "Cython", mime: "text/x-cython", mode: "python", ext: ["pyx", "pxd", "pxi"]},
	    {name: "Crystal", mime: "text/x-crystal", mode: "crystal", ext: ["cr"]},
	    {name: "CSS", mime: "text/css", mode: "css", ext: ["css"]},
	    {name: "CQL", mime: "text/x-cassandra", mode: "sql", ext: ["cql"]},
	    {name: "D", mime: "text/x-d", mode: "d", ext: ["d"]},
	    {name: "Dart", mimes: ["application/dart", "text/x-dart"], mode: "dart", ext: ["dart"]},
	    {name: "diff", mime: "text/x-diff", mode: "diff", ext: ["diff", "patch"]},
	    {name: "Django", mime: "text/x-django", mode: "django"},
	    {name: "Dockerfile", mime: "text/x-dockerfile", mode: "dockerfile", file: /^Dockerfile$/},
	    {name: "DTD", mime: "application/xml-dtd", mode: "dtd", ext: ["dtd"]},
	    {name: "Dylan", mime: "text/x-dylan", mode: "dylan", ext: ["dylan", "dyl", "intr"]},
	    {name: "EBNF", mime: "text/x-ebnf", mode: "ebnf"},
	    {name: "ECL", mime: "text/x-ecl", mode: "ecl", ext: ["ecl"]},
	    {name: "edn", mime: "application/edn", mode: "clojure", ext: ["edn"]},
	    {name: "Eiffel", mime: "text/x-eiffel", mode: "eiffel", ext: ["e"]},
	    {name: "Elm", mime: "text/x-elm", mode: "elm", ext: ["elm"]},
	    {name: "Embedded Javascript", mime: "application/x-ejs", mode: "htmlembedded", ext: ["ejs"]},
	    {name: "Embedded Ruby", mime: "application/x-erb", mode: "htmlembedded", ext: ["erb"]},
	    {name: "Erlang", mime: "text/x-erlang", mode: "erlang", ext: ["erl"]},
	    {name: "Esper", mime: "text/x-esper", mode: "sql"},
	    {name: "Factor", mime: "text/x-factor", mode: "factor", ext: ["factor"]},
	    {name: "FCL", mime: "text/x-fcl", mode: "fcl"},
	    {name: "Forth", mime: "text/x-forth", mode: "forth", ext: ["forth", "fth", "4th"]},
	    {name: "Fortran", mime: "text/x-fortran", mode: "fortran", ext: ["f", "for", "f77", "f90", "f95"]},
	    {name: "F#", mime: "text/x-fsharp", mode: "mllike", ext: ["fs"], alias: ["fsharp"]},
	    {name: "Gas", mime: "text/x-gas", mode: "gas", ext: ["s"]},
	    {name: "Gherkin", mime: "text/x-feature", mode: "gherkin", ext: ["feature"]},
	    {name: "GitHub Flavored Markdown", mime: "text/x-gfm", mode: "gfm", file: /^(readme|contributing|history).md$/i},
	    {name: "Go", mime: "text/x-go", mode: "go", ext: ["go"]},
	    {name: "Groovy", mime: "text/x-groovy", mode: "groovy", ext: ["groovy", "gradle"], file: /^Jenkinsfile$/},
	    {name: "HAML", mime: "text/x-haml", mode: "haml", ext: ["haml"]},
	    {name: "Haskell", mime: "text/x-haskell", mode: "haskell", ext: ["hs"]},
	    {name: "Haskell (Literate)", mime: "text/x-literate-haskell", mode: "haskell-literate", ext: ["lhs"]},
	    {name: "Haxe", mime: "text/x-haxe", mode: "haxe", ext: ["hx"]},
	    {name: "HXML", mime: "text/x-hxml", mode: "haxe", ext: ["hxml"]},
	    {name: "ASP.NET", mime: "application/x-aspx", mode: "htmlembedded", ext: ["aspx"], alias: ["asp", "aspx"]},
	    {name: "HTML", mime: "text/html", mode: "htmlmixed", ext: ["html", "htm", "handlebars", "hbs"], alias: ["xhtml"]},
	    {name: "HTTP", mime: "message/http", mode: "http"},
	    {name: "IDL", mime: "text/x-idl", mode: "idl", ext: ["pro"]},
	    {name: "Pug", mime: "text/x-pug", mode: "pug", ext: ["jade", "pug"], alias: ["jade"]},
	    {name: "Java", mime: "text/x-java", mode: "clike", ext: ["java"]},
	    {name: "Java Server Pages", mime: "application/x-jsp", mode: "htmlembedded", ext: ["jsp"], alias: ["jsp"]},
	    {name: "JavaScript", mimes: ["text/javascript", "text/ecmascript", "application/javascript", "application/x-javascript", "application/ecmascript"],
	     mode: "javascript", ext: ["js"], alias: ["ecmascript", "js", "node"]},
	    {name: "JSON", mimes: ["application/json", "application/x-json"], mode: "javascript", ext: ["json", "map"], alias: ["json5"]},
	    {name: "JSON-LD", mime: "application/ld+json", mode: "javascript", ext: ["jsonld"], alias: ["jsonld"]},
	    {name: "JSX", mime: "text/jsx", mode: "jsx", ext: ["jsx"]},
	    {name: "Jinja2", mime: "text/jinja2", mode: "jinja2", ext: ["j2", "jinja", "jinja2"]},
	    {name: "Julia", mime: "text/x-julia", mode: "julia", ext: ["jl"]},
	    {name: "Kotlin", mime: "text/x-kotlin", mode: "clike", ext: ["kt"]},
	    {name: "LESS", mime: "text/x-less", mode: "css", ext: ["less"]},
	    {name: "LiveScript", mime: "text/x-livescript", mode: "livescript", ext: ["ls"], alias: ["ls"]},
	    {name: "Lua", mime: "text/x-lua", mode: "lua", ext: ["lua"]},
	    {name: "Markdown", mime: "text/x-markdown", mode: "markdown", ext: ["markdown", "md", "mkd"]},
	    {name: "mIRC", mime: "text/mirc", mode: "mirc"},
	    {name: "MariaDB SQL", mime: "text/x-mariadb", mode: "sql"},
	    {name: "Mathematica", mime: "text/x-mathematica", mode: "mathematica", ext: ["m", "nb", "wl", "wls"]},
	    {name: "Modelica", mime: "text/x-modelica", mode: "modelica", ext: ["mo"]},
	    {name: "MUMPS", mime: "text/x-mumps", mode: "mumps", ext: ["mps"]},
	    {name: "MS SQL", mime: "text/x-mssql", mode: "sql"},
	    {name: "mbox", mime: "application/mbox", mode: "mbox", ext: ["mbox"]},
	    {name: "MySQL", mime: "text/x-mysql", mode: "sql"},
	    {name: "Nginx", mime: "text/x-nginx-conf", mode: "nginx", file: /nginx.*\.conf$/i},
	    {name: "NSIS", mime: "text/x-nsis", mode: "nsis", ext: ["nsh", "nsi"]},
	    {name: "NTriples", mimes: ["application/n-triples", "application/n-quads", "text/n-triples"],
	     mode: "ntriples", ext: ["nt", "nq"]},
	    {name: "Objective-C", mime: "text/x-objectivec", mode: "clike", ext: ["m"], alias: ["objective-c", "objc"]},
	    {name: "Objective-C++", mime: "text/x-objectivec++", mode: "clike", ext: ["mm"], alias: ["objective-c++", "objc++"]},
	    {name: "OCaml", mime: "text/x-ocaml", mode: "mllike", ext: ["ml", "mli", "mll", "mly"]},
	    {name: "Octave", mime: "text/x-octave", mode: "octave", ext: ["m"]},
	    {name: "Oz", mime: "text/x-oz", mode: "oz", ext: ["oz"]},
	    {name: "Pascal", mime: "text/x-pascal", mode: "pascal", ext: ["p", "pas"]},
	    {name: "PEG.js", mime: "null", mode: "pegjs", ext: ["jsonld"]},
	    {name: "Perl", mime: "text/x-perl", mode: "perl", ext: ["pl", "pm"]},
	    {name: "PHP", mimes: ["text/x-php", "application/x-httpd-php", "application/x-httpd-php-open"], mode: "php", ext: ["php", "php3", "php4", "php5", "php7", "phtml"]},
	    {name: "Pig", mime: "text/x-pig", mode: "pig", ext: ["pig"]},
	    {name: "Plain Text", mime: "text/plain", mode: "null", ext: ["txt", "text", "conf", "def", "list", "log"]},
	    {name: "PLSQL", mime: "text/x-plsql", mode: "sql", ext: ["pls"]},
	    {name: "PostgreSQL", mime: "text/x-pgsql", mode: "sql"},
	    {name: "PowerShell", mime: "application/x-powershell", mode: "powershell", ext: ["ps1", "psd1", "psm1"]},
	    {name: "Properties files", mime: "text/x-properties", mode: "properties", ext: ["properties", "ini", "in"], alias: ["ini", "properties"]},
	    {name: "ProtoBuf", mime: "text/x-protobuf", mode: "protobuf", ext: ["proto"]},
	    {name: "Python", mime: "text/x-python", mode: "python", ext: ["BUILD", "bzl", "py", "pyw"], file: /^(BUCK|BUILD)$/},
	    {name: "Puppet", mime: "text/x-puppet", mode: "puppet", ext: ["pp"]},
	    {name: "Q", mime: "text/x-q", mode: "q", ext: ["q"]},
	    {name: "R", mime: "text/x-rsrc", mode: "r", ext: ["r", "R"], alias: ["rscript"]},
	    {name: "reStructuredText", mime: "text/x-rst", mode: "rst", ext: ["rst"], alias: ["rst"]},
	    {name: "RPM Changes", mime: "text/x-rpm-changes", mode: "rpm"},
	    {name: "RPM Spec", mime: "text/x-rpm-spec", mode: "rpm", ext: ["spec"]},
	    {name: "Ruby", mime: "text/x-ruby", mode: "ruby", ext: ["rb"], alias: ["jruby", "macruby", "rake", "rb", "rbx"]},
	    {name: "Rust", mime: "text/x-rustsrc", mode: "rust", ext: ["rs"]},
	    {name: "SAS", mime: "text/x-sas", mode: "sas", ext: ["sas"]},
	    {name: "Sass", mime: "text/x-sass", mode: "sass", ext: ["sass"]},
	    {name: "Scala", mime: "text/x-scala", mode: "clike", ext: ["scala"]},
	    {name: "Scheme", mime: "text/x-scheme", mode: "scheme", ext: ["scm", "ss"]},
	    {name: "SCSS", mime: "text/x-scss", mode: "css", ext: ["scss"]},
	    {name: "Shell", mimes: ["text/x-sh", "application/x-sh"], mode: "shell", ext: ["sh", "ksh", "bash"], alias: ["bash", "sh", "zsh"], file: /^PKGBUILD$/},
	    {name: "Sieve", mime: "application/sieve", mode: "sieve", ext: ["siv", "sieve"]},
	    {name: "Slim", mimes: ["text/x-slim", "application/x-slim"], mode: "slim", ext: ["slim"]},
	    {name: "Smalltalk", mime: "text/x-stsrc", mode: "smalltalk", ext: ["st"]},
	    {name: "Smarty", mime: "text/x-smarty", mode: "smarty", ext: ["tpl"]},
	    {name: "Solr", mime: "text/x-solr", mode: "solr"},
	    {name: "SML", mime: "text/x-sml", mode: "mllike", ext: ["sml", "sig", "fun", "smackspec"]},
	    {name: "Soy", mime: "text/x-soy", mode: "soy", ext: ["soy"], alias: ["closure template"]},
	    {name: "SPARQL", mime: "application/sparql-query", mode: "sparql", ext: ["rq", "sparql"], alias: ["sparul"]},
	    {name: "Spreadsheet", mime: "text/x-spreadsheet", mode: "spreadsheet", alias: ["excel", "formula"]},
	    {name: "SQL", mime: "text/x-sql", mode: "sql", ext: ["sql"]},
	    {name: "SQLite", mime: "text/x-sqlite", mode: "sql"},
	    {name: "Squirrel", mime: "text/x-squirrel", mode: "clike", ext: ["nut"]},
	    {name: "Stylus", mime: "text/x-styl", mode: "stylus", ext: ["styl"]},
	    {name: "Swift", mime: "text/x-swift", mode: "swift", ext: ["swift"]},
	    {name: "sTeX", mime: "text/x-stex", mode: "stex"},
	    {name: "LaTeX", mime: "text/x-latex", mode: "stex", ext: ["text", "ltx", "tex"], alias: ["tex"]},
	    {name: "SystemVerilog", mime: "text/x-systemverilog", mode: "verilog", ext: ["v", "sv", "svh"]},
	    {name: "Tcl", mime: "text/x-tcl", mode: "tcl", ext: ["tcl"]},
	    {name: "Textile", mime: "text/x-textile", mode: "textile", ext: ["textile"]},
	    {name: "TiddlyWiki ", mime: "text/x-tiddlywiki", mode: "tiddlywiki"},
	    {name: "Tiki wiki", mime: "text/tiki", mode: "tiki"},
	    {name: "TOML", mime: "text/x-toml", mode: "toml", ext: ["toml"]},
	    {name: "Tornado", mime: "text/x-tornado", mode: "tornado"},
	    {name: "troff", mime: "text/troff", mode: "troff", ext: ["1", "2", "3", "4", "5", "6", "7", "8", "9"]},
	    {name: "TTCN", mime: "text/x-ttcn", mode: "ttcn", ext: ["ttcn", "ttcn3", "ttcnpp"]},
	    {name: "TTCN_CFG", mime: "text/x-ttcn-cfg", mode: "ttcn-cfg", ext: ["cfg"]},
	    {name: "Turtle", mime: "text/turtle", mode: "turtle", ext: ["ttl"]},
	    {name: "TypeScript", mime: "application/typescript", mode: "javascript", ext: ["ts"], alias: ["ts"]},
	    {name: "TypeScript-JSX", mime: "text/typescript-jsx", mode: "jsx", ext: ["tsx"], alias: ["tsx"]},
	    {name: "Twig", mime: "text/x-twig", mode: "twig"},
	    {name: "Web IDL", mime: "text/x-webidl", mode: "webidl", ext: ["webidl"]},
	    {name: "VB.NET", mime: "text/x-vb", mode: "vb", ext: ["vb"]},
	    {name: "VBScript", mime: "text/vbscript", mode: "vbscript", ext: ["vbs"]},
	    {name: "Velocity", mime: "text/velocity", mode: "velocity", ext: ["vtl"]},
	    {name: "Verilog", mime: "text/x-verilog", mode: "verilog", ext: ["v"]},
	    {name: "VHDL", mime: "text/x-vhdl", mode: "vhdl", ext: ["vhd", "vhdl"]},
	    {name: "Vue.js Component", mimes: ["script/x-vue", "text/x-vue"], mode: "vue", ext: ["vue"]},
	    {name: "XML", mimes: ["application/xml", "text/xml"], mode: "xml", ext: ["xml", "xsl", "xsd", "svg"], alias: ["rss", "wsdl", "xsd"]},
	    {name: "XQuery", mime: "application/xquery", mode: "xquery", ext: ["xy", "xquery"]},
	    {name: "Yacas", mime: "text/x-yacas", mode: "yacas", ext: ["ys"]},
	    {name: "YAML", mimes: ["text/x-yaml", "text/yaml"], mode: "yaml", ext: ["yaml", "yml"], alias: ["yml"]},
	    {name: "Z80", mime: "text/x-z80", mode: "z80", ext: ["z80"]},
	    {name: "mscgen", mime: "text/x-mscgen", mode: "mscgen", ext: ["mscgen", "mscin", "msc"]},
	    {name: "xu", mime: "text/x-xu", mode: "mscgen", ext: ["xu"]},
	    {name: "msgenny", mime: "text/x-msgenny", mode: "mscgen", ext: ["msgenny"]}
	  ];
	  // Ensure all modes have a mime property for backwards compatibility
	  for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
	    var info = CodeMirror.modeInfo[i];
	    if (info.mimes) info.mime = info.mimes[0];
	  }
	
	  CodeMirror.findModeByMIME = function(mime) {
	    mime = mime.toLowerCase();
	    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
	      var info = CodeMirror.modeInfo[i];
	      if (info.mime == mime) return info;
	      if (info.mimes) for (var j = 0; j < info.mimes.length; j++)
	        if (info.mimes[j] == mime) return info;
	    }
	    if (/\+xml$/.test(mime)) return CodeMirror.findModeByMIME("application/xml")
	    if (/\+json$/.test(mime)) return CodeMirror.findModeByMIME("application/json")
	  };
	
	  CodeMirror.findModeByExtension = function(ext) {
	    ext = ext.toLowerCase();
	    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
	      var info = CodeMirror.modeInfo[i];
	      if (info.ext) for (var j = 0; j < info.ext.length; j++)
	        if (info.ext[j] == ext) return info;
	    }
	  };
	
	  CodeMirror.findModeByFileName = function(filename) {
	    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
	      var info = CodeMirror.modeInfo[i];
	      if (info.file && info.file.test(filename)) return info;
	    }
	    var dot = filename.lastIndexOf(".");
	    var ext = dot > -1 && filename.substring(dot + 1, filename.length);
	    if (ext) return CodeMirror.findModeByExtension(ext);
	  };
	
	  CodeMirror.findModeByName = function(name) {
	    name = name.toLowerCase();
	    for (var i = 0; i < CodeMirror.modeInfo.length; i++) {
	      var info = CodeMirror.modeInfo[i];
	      if (info.name.toLowerCase() == name) return info;
	      if (info.alias) for (var j = 0; j < info.alias.length; j++)
	        if (info.alias[j].toLowerCase() == name) return info;
	    }
	  };
	});


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: https://codemirror.net/LICENSE
	
	// Utility function that allows modes to be combined. The mode given
	// as the base argument takes care of most of the normal mode
	// functionality, but a second (typically simple) mode is used, which
	// can override the style of text. Both modes get to parse all of the
	// text, but when both assign a non-null style to a piece of code, the
	// overlay wins, unless the combine argument was true and not overridden,
	// or state.overlay.combineTokens was true, in which case the styles are
	// combined.
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(38));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	"use strict";
	
	CodeMirror.overlayMode = function(base, overlay, combine) {
	  return {
	    startState: function() {
	      return {
	        base: CodeMirror.startState(base),
	        overlay: CodeMirror.startState(overlay),
	        basePos: 0, baseCur: null,
	        overlayPos: 0, overlayCur: null,
	        streamSeen: null
	      };
	    },
	    copyState: function(state) {
	      return {
	        base: CodeMirror.copyState(base, state.base),
	        overlay: CodeMirror.copyState(overlay, state.overlay),
	        basePos: state.basePos, baseCur: null,
	        overlayPos: state.overlayPos, overlayCur: null
	      };
	    },
	
	    token: function(stream, state) {
	      if (stream != state.streamSeen ||
	          Math.min(state.basePos, state.overlayPos) < stream.start) {
	        state.streamSeen = stream;
	        state.basePos = state.overlayPos = stream.start;
	      }
	
	      if (stream.start == state.basePos) {
	        state.baseCur = base.token(stream, state.base);
	        state.basePos = stream.pos;
	      }
	      if (stream.start == state.overlayPos) {
	        stream.pos = stream.start;
	        state.overlayCur = overlay.token(stream, state.overlay);
	        state.overlayPos = stream.pos;
	      }
	      stream.pos = Math.min(state.basePos, state.overlayPos);
	
	      // state.overlay.combineTokens always takes precedence over combine,
	      // unless set to null
	      if (state.overlayCur == null) return state.baseCur;
	      else if (state.baseCur != null &&
	               state.overlay.combineTokens ||
	               combine && state.overlay.combineTokens == null)
	        return state.baseCur + " " + state.overlayCur;
	      else return state.overlayCur;
	    },
	
	    indent: base.indent && function(state, textAfter, line) {
	      return base.indent(state.base, textAfter, line);
	    },
	    electricChars: base.electricChars,
	
	    innerMode: function(state) { return {state: state.base, mode: base}; },
	
	    blankLine: function(state) {
	      var baseToken, overlayToken;
	      if (base.blankLine) baseToken = base.blankLine(state.base);
	      if (overlay.blankLine) overlayToken = overlay.blankLine(state.overlay);
	
	      return overlayToken == null ?
	        baseToken :
	        (combine && baseToken != null ? baseToken + " " + overlayToken : overlayToken);
	    }
	  };
	};
	
	});


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: https://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(38));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  CodeMirror.defineOption("placeholder", "", function(cm, val, old) {
	    var prev = old && old != CodeMirror.Init;
	    if (val && !prev) {
	      cm.on("blur", onBlur);
	      cm.on("change", onChange);
	      cm.on("swapDoc", onChange);
	      onChange(cm);
	    } else if (!val && prev) {
	      cm.off("blur", onBlur);
	      cm.off("change", onChange);
	      cm.off("swapDoc", onChange);
	      clearPlaceholder(cm);
	      var wrapper = cm.getWrapperElement();
	      wrapper.className = wrapper.className.replace(" CodeMirror-empty", "");
	    }
	
	    if (val && !cm.hasFocus()) onBlur(cm);
	  });
	
	  function clearPlaceholder(cm) {
	    if (cm.state.placeholder) {
	      cm.state.placeholder.parentNode.removeChild(cm.state.placeholder);
	      cm.state.placeholder = null;
	    }
	  }
	  function setPlaceholder(cm) {
	    clearPlaceholder(cm);
	    var elt = cm.state.placeholder = document.createElement("pre");
	    elt.style.cssText = "height: 0; overflow: visible";
	    elt.style.direction = cm.getOption("direction");
	    elt.className = "CodeMirror-placeholder CodeMirror-line-like";
	    var placeHolder = cm.getOption("placeholder")
	    if (typeof placeHolder == "string") placeHolder = document.createTextNode(placeHolder)
	    elt.appendChild(placeHolder)
	    cm.display.lineSpace.insertBefore(elt, cm.display.lineSpace.firstChild);
	  }
	
	  function onBlur(cm) {
	    if (isEmpty(cm)) setPlaceholder(cm);
	  }
	  function onChange(cm) {
	    var wrapper = cm.getWrapperElement(), empty = isEmpty(cm);
	    wrapper.className = wrapper.className.replace(" CodeMirror-empty", "") + (empty ? " CodeMirror-empty" : "");
	
	    if (empty) setPlaceholder(cm);
	    else clearPlaceholder(cm);
	  }
	
	  function isEmpty(cm) {
	    return (cm.lineCount() === 1) && (cm.getLine(0) === "");
	  }
	});


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: https://codemirror.net/LICENSE
	
	// Because sometimes you need to mark the selected *text*.
	//
	// Adds an option 'styleSelectedText' which, when enabled, gives
	// selected text the CSS class given as option value, or
	// "CodeMirror-selectedtext" when the value is not a string.
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(38));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	  "use strict";
	
	  CodeMirror.defineOption("styleSelectedText", false, function(cm, val, old) {
	    var prev = old && old != CodeMirror.Init;
	    if (val && !prev) {
	      cm.state.markedSelection = [];
	      cm.state.markedSelectionStyle = typeof val == "string" ? val : "CodeMirror-selectedtext";
	      reset(cm);
	      cm.on("cursorActivity", onCursorActivity);
	      cm.on("change", onChange);
	    } else if (!val && prev) {
	      cm.off("cursorActivity", onCursorActivity);
	      cm.off("change", onChange);
	      clear(cm);
	      cm.state.markedSelection = cm.state.markedSelectionStyle = null;
	    }
	  });
	
	  function onCursorActivity(cm) {
	    if (cm.state.markedSelection)
	      cm.operation(function() { update(cm); });
	  }
	
	  function onChange(cm) {
	    if (cm.state.markedSelection && cm.state.markedSelection.length)
	      cm.operation(function() { clear(cm); });
	  }
	
	  var CHUNK_SIZE = 8;
	  var Pos = CodeMirror.Pos;
	  var cmp = CodeMirror.cmpPos;
	
	  function coverRange(cm, from, to, addAt) {
	    if (cmp(from, to) == 0) return;
	    var array = cm.state.markedSelection;
	    var cls = cm.state.markedSelectionStyle;
	    for (var line = from.line;;) {
	      var start = line == from.line ? from : Pos(line, 0);
	      var endLine = line + CHUNK_SIZE, atEnd = endLine >= to.line;
	      var end = atEnd ? to : Pos(endLine, 0);
	      var mark = cm.markText(start, end, {className: cls});
	      if (addAt == null) array.push(mark);
	      else array.splice(addAt++, 0, mark);
	      if (atEnd) break;
	      line = endLine;
	    }
	  }
	
	  function clear(cm) {
	    var array = cm.state.markedSelection;
	    for (var i = 0; i < array.length; ++i) array[i].clear();
	    array.length = 0;
	  }
	
	  function reset(cm) {
	    clear(cm);
	    var ranges = cm.listSelections();
	    for (var i = 0; i < ranges.length; i++)
	      coverRange(cm, ranges[i].from(), ranges[i].to());
	  }
	
	  function update(cm) {
	    if (!cm.somethingSelected()) return clear(cm);
	    if (cm.listSelections().length > 1) return reset(cm);
	
	    var from = cm.getCursor("start"), to = cm.getCursor("end");
	
	    var array = cm.state.markedSelection;
	    if (!array.length) return coverRange(cm, from, to);
	
	    var coverStart = array[0].find(), coverEnd = array[array.length - 1].find();
	    if (!coverStart || !coverEnd || to.line - from.line <= CHUNK_SIZE ||
	        cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0)
	      return reset(cm);
	
	    while (cmp(from, coverStart.from) > 0) {
	      array.shift().clear();
	      coverStart = array[0].find();
	    }
	    if (cmp(from, coverStart.from) < 0) {
	      if (coverStart.to.line - from.line < CHUNK_SIZE) {
	        array.shift().clear();
	        coverRange(cm, from, coverStart.to, 0);
	      } else {
	        coverRange(cm, from, coverStart.from, 0);
	      }
	    }
	
	    while (cmp(to, coverEnd.to) < 0) {
	      array.pop().clear();
	      coverEnd = array[array.length - 1].find();
	    }
	    if (cmp(to, coverEnd.to) > 0) {
	      if (to.line - coverEnd.from.line < CHUNK_SIZE) {
	        array.pop().clear();
	        coverRange(cm, coverEnd.from, to);
	      } else {
	        coverRange(cm, coverEnd.to, to);
	      }
	    }
	  }
	});


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	// CodeMirror, copyright (c) by Marijn Haverbeke and others
	// Distributed under an MIT license: https://codemirror.net/LICENSE
	
	(function(mod) {
	  if (true) // CommonJS
	    mod(__webpack_require__(38), __webpack_require__(42), __webpack_require__(45));
	  else if (typeof define == "function" && define.amd) // AMD
	    define(["../../lib/codemirror", "../markdown/markdown", "../../addon/mode/overlay"], mod);
	  else // Plain browser env
	    mod(CodeMirror);
	})(function(CodeMirror) {
	"use strict";
	
	var urlRE = /^((?:(?:aaas?|about|acap|adiumxtra|af[ps]|aim|apt|attachment|aw|beshare|bitcoin|bolo|callto|cap|chrome(?:-extension)?|cid|coap|com-eventbrite-attendee|content|crid|cvs|data|dav|dict|dlna-(?:playcontainer|playsingle)|dns|doi|dtn|dvb|ed2k|facetime|feed|file|finger|fish|ftp|geo|gg|git|gizmoproject|go|gopher|gtalk|h323|hcp|https?|iax|icap|icon|im|imap|info|ipn|ipp|irc[6s]?|iris(?:\.beep|\.lwz|\.xpc|\.xpcs)?|itms|jar|javascript|jms|keyparc|lastfm|ldaps?|magnet|mailto|maps|market|message|mid|mms|ms-help|msnim|msrps?|mtqp|mumble|mupdate|mvn|news|nfs|nih?|nntp|notes|oid|opaquelocktoken|palm|paparazzi|platform|pop|pres|proxy|psyc|query|res(?:ource)?|rmi|rsync|rtmp|rtsp|secondlife|service|session|sftp|sgn|shttp|sieve|sips?|skype|sm[bs]|snmp|soap\.beeps?|soldat|spotify|ssh|steam|svn|tag|teamspeak|tel(?:net)?|tftp|things|thismessage|tip|tn3270|tv|udp|unreal|urn|ut2004|vemmi|ventrilo|view-source|webcal|wss?|wtai|wyciwyg|xcon(?:-userid)?|xfire|xmlrpc\.beeps?|xmpp|xri|ymsgr|z39\.50[rs]?):(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]|\([^\s()<>]*\))+(?:\([^\s()<>]*\)|[^\s`*!()\[\]{};:'".,<>?«»“”‘’]))/i
	
	CodeMirror.defineMode("gfm", function(config, modeConfig) {
	  var codeDepth = 0;
	  function blankLine(state) {
	    state.code = false;
	    return null;
	  }
	  var gfmOverlay = {
	    startState: function() {
	      return {
	        code: false,
	        codeBlock: false,
	        ateSpace: false
	      };
	    },
	    copyState: function(s) {
	      return {
	        code: s.code,
	        codeBlock: s.codeBlock,
	        ateSpace: s.ateSpace
	      };
	    },
	    token: function(stream, state) {
	      state.combineTokens = null;
	
	      // Hack to prevent formatting override inside code blocks (block and inline)
	      if (state.codeBlock) {
	        if (stream.match(/^```+/)) {
	          state.codeBlock = false;
	          return null;
	        }
	        stream.skipToEnd();
	        return null;
	      }
	      if (stream.sol()) {
	        state.code = false;
	      }
	      if (stream.sol() && stream.match(/^```+/)) {
	        stream.skipToEnd();
	        state.codeBlock = true;
	        return null;
	      }
	      // If this block is changed, it may need to be updated in Markdown mode
	      if (stream.peek() === '`') {
	        stream.next();
	        var before = stream.pos;
	        stream.eatWhile('`');
	        var difference = 1 + stream.pos - before;
	        if (!state.code) {
	          codeDepth = difference;
	          state.code = true;
	        } else {
	          if (difference === codeDepth) { // Must be exact
	            state.code = false;
	          }
	        }
	        return null;
	      } else if (state.code) {
	        stream.next();
	        return null;
	      }
	      // Check if space. If so, links can be formatted later on
	      if (stream.eatSpace()) {
	        state.ateSpace = true;
	        return null;
	      }
	      if (stream.sol() || state.ateSpace) {
	        state.ateSpace = false;
	        if (modeConfig.gitHubSpice !== false) {
	          if(stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+@)?(?=.{0,6}\d)(?:[a-f0-9]{7,40}\b)/)) {
	            // User/Project@SHA
	            // User@SHA
	            // SHA
	            state.combineTokens = true;
	            return "link";
	          } else if (stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+)?#[0-9]+\b/)) {
	            // User/Project#Num
	            // User#Num
	            // #Num
	            state.combineTokens = true;
	            return "link";
	          }
	        }
	      }
	      if (stream.match(urlRE) &&
	          stream.string.slice(stream.start - 2, stream.start) != "](" &&
	          (stream.start == 0 || /\W/.test(stream.string.charAt(stream.start - 1)))) {
	        // URLs
	        // Taken from http://daringfireball.net/2010/07/improved_regex_for_matching_urls
	        // And then (issue #1160) simplified to make it not crash the Chrome Regexp engine
	        // And then limited url schemes to the CommonMark list, so foo:bar isn't matched as a URL
	        state.combineTokens = true;
	        return "link";
	      }
	      stream.next();
	      return null;
	    },
	    blankLine: blankLine
	  };
	
	  var markdownConfig = {
	    taskLists: true,
	    strikethrough: true,
	    emoji: true
	  };
	  for (var attr in modeConfig) {
	    markdownConfig[attr] = modeConfig[attr];
	  }
	  markdownConfig.name = "markdown";
	  return CodeMirror.overlayMode(CodeMirror.getMode(config, markdownConfig), gfmOverlay);
	
	}, "markdown");
	
	  CodeMirror.defineMIME("text/x-gfm", "gfm");
	});


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	// Use strict mode (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)
	"use strict";
	
	
	// Requires
	var Typo = __webpack_require__(50);
	
	
	// Create function
	function CodeMirrorSpellChecker(options) {
		// Initialize
		options = options || {};
	
	
		// Verify
		if(typeof options.codeMirrorInstance !== "function" || typeof options.codeMirrorInstance.defineMode !== "function") {
			console.log("CodeMirror Spell Checker: You must provide an instance of CodeMirror via the option `codeMirrorInstance`");
			return;
		}
	
	
		// Because some browsers don't support this functionality yet
		if(!String.prototype.includes) {
			String.prototype.includes = function() {
				"use strict";
				return String.prototype.indexOf.apply(this, arguments) !== -1;
			};
		}
	
	
		// Define the new mode
		options.codeMirrorInstance.defineMode("spell-checker", function(config) {
			// Load AFF/DIC data
			if(!CodeMirrorSpellChecker.aff_loading) {
				CodeMirrorSpellChecker.aff_loading = true;
				var xhr_aff = new XMLHttpRequest();
				xhr_aff.open("GET", "https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.aff", true);
				xhr_aff.onload = function() {
					if(xhr_aff.readyState === 4 && xhr_aff.status === 200) {
						CodeMirrorSpellChecker.aff_data = xhr_aff.responseText;
						CodeMirrorSpellChecker.num_loaded++;
	
						if(CodeMirrorSpellChecker.num_loaded == 2) {
							CodeMirrorSpellChecker.typo = new Typo("en_US", CodeMirrorSpellChecker.aff_data, CodeMirrorSpellChecker.dic_data, {
								platform: "any"
							});
						}
					}
				};
				xhr_aff.send(null);
			}
	
			if(!CodeMirrorSpellChecker.dic_loading) {
				CodeMirrorSpellChecker.dic_loading = true;
				var xhr_dic = new XMLHttpRequest();
				xhr_dic.open("GET", "https://cdn.jsdelivr.net/codemirror.spell-checker/latest/en_US.dic", true);
				xhr_dic.onload = function() {
					if(xhr_dic.readyState === 4 && xhr_dic.status === 200) {
						CodeMirrorSpellChecker.dic_data = xhr_dic.responseText;
						CodeMirrorSpellChecker.num_loaded++;
	
						if(CodeMirrorSpellChecker.num_loaded == 2) {
							CodeMirrorSpellChecker.typo = new Typo("en_US", CodeMirrorSpellChecker.aff_data, CodeMirrorSpellChecker.dic_data, {
								platform: "any"
							});
						}
					}
				};
				xhr_dic.send(null);
			}
	
	
			// Define what separates a word
			var rx_word = "!\"#$%&()*+,-./:;<=>?@[\\]^_`{|}~ ";
	
	
			// Create the overlay and such
			var overlay = {
				token: function(stream) {
					var ch = stream.peek();
					var word = "";
	
					if(rx_word.includes(ch)) {
						stream.next();
						return null;
					}
	
					while((ch = stream.peek()) != null && !rx_word.includes(ch)) {
						word += ch;
						stream.next();
					}
	
					if(CodeMirrorSpellChecker.typo && !CodeMirrorSpellChecker.typo.check(word))
						return "spell-error"; // CSS class: cm-spell-error
	
					return null;
				}
			};
	
			var mode = options.codeMirrorInstance.getMode(
				config, config.backdrop || "text/plain"
			);
	
			return options.codeMirrorInstance.overlayMode(mode, overlay, true);
		});
	}
	
	
	// Initialize data globally to reduce memory consumption
	CodeMirrorSpellChecker.num_loaded = 0;
	CodeMirrorSpellChecker.aff_loading = false;
	CodeMirrorSpellChecker.dic_loading = false;
	CodeMirrorSpellChecker.aff_data = "";
	CodeMirrorSpellChecker.dic_data = "";
	CodeMirrorSpellChecker.typo;
	
	
	// Export
	module.exports = CodeMirrorSpellChecker;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {/* globals chrome: false */
	/* globals __dirname: false */
	/* globals require: false */
	/* globals Buffer: false */
	/* globals module: false */
	
	/**
	 * Typo is a JavaScript implementation of a spellchecker using hunspell-style 
	 * dictionaries.
	 */
	
	var Typo;
	
	(function () {
	"use strict";
	
	/**
	 * Typo constructor.
	 *
	 * @param {String} [dictionary] The locale code of the dictionary being used. e.g.,
	 *                              "en_US". This is only used to auto-load dictionaries.
	 * @param {String} [affData]    The data from the dictionary's .aff file. If omitted
	 *                              and Typo.js is being used in a Chrome extension, the .aff
	 *                              file will be loaded automatically from
	 *                              lib/typo/dictionaries/[dictionary]/[dictionary].aff
	 *                              In other environments, it will be loaded from
	 *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].aff
	 * @param {String} [wordsData]  The data from the dictionary's .dic file. If omitted
	 *                              and Typo.js is being used in a Chrome extension, the .dic
	 *                              file will be loaded automatically from
	 *                              lib/typo/dictionaries/[dictionary]/[dictionary].dic
	 *                              In other environments, it will be loaded from
	 *                              [settings.dictionaryPath]/dictionaries/[dictionary]/[dictionary].dic
	 * @param {Object} [settings]   Constructor settings. Available properties are:
	 *                              {String} [dictionaryPath]: path to load dictionary from in non-chrome
	 *                              environment.
	 *                              {Object} [flags]: flag information.
	 *                              {Boolean} [asyncLoad]: If true, affData and wordsData will be loaded
	 *                              asynchronously.
	 *                              {Function} [loadedCallback]: Called when both affData and wordsData
	 *                              have been loaded. Only used if asyncLoad is set to true. The parameter
	 *                              is the instantiated Typo object.
	 *
	 * @returns {Typo} A Typo object.
	 */
	
	Typo = function (dictionary, affData, wordsData, settings) {
		settings = settings || {};
	
		this.dictionary = null;
		
		this.rules = {};
		this.dictionaryTable = {};
		
		this.compoundRules = [];
		this.compoundRuleCodes = {};
		
		this.replacementTable = [];
		
		this.flags = settings.flags || {}; 
		
		this.memoized = {};
	
		this.loaded = false;
		
		var self = this;
		
		var path;
		
		// Loop-control variables.
		var i, j, _len, _jlen;
		
		if (dictionary) {
			self.dictionary = dictionary;
			
			// If the data is preloaded, just setup the Typo object.
			if (affData && wordsData) {
				setup();
			}
			// Loading data for Chrome extentions.
			else if (typeof window !== 'undefined' && 'chrome' in window && 'extension' in window.chrome && 'getURL' in window.chrome.extension) {
				if (settings.dictionaryPath) {
					path = settings.dictionaryPath;
				}
				else {
					path = "typo/dictionaries";
				}
				
				if (!affData) readDataFile(chrome.extension.getURL(path + "/" + dictionary + "/" + dictionary + ".aff"), setAffData);
				if (!wordsData) readDataFile(chrome.extension.getURL(path + "/" + dictionary + "/" + dictionary + ".dic"), setWordsData);
			}
			else {
				if (settings.dictionaryPath) {
					path = settings.dictionaryPath;
				}
				else if (true) {
					path = __dirname + '/dictionaries';
				}
				else {
					path = './dictionaries';
				}
				
				if (!affData) readDataFile(path + "/" + dictionary + "/" + dictionary + ".aff", setAffData);
				if (!wordsData) readDataFile(path + "/" + dictionary + "/" + dictionary + ".dic", setWordsData);
			}
		}
		
		function readDataFile(url, setFunc) {
			var response = self._readFile(url, null, settings.asyncLoad);
			
			if (settings.asyncLoad) {
				response.then(function(data) {
					setFunc(data);
				});
			}
			else {
				setFunc(response);
			}
		}
	
		function setAffData(data) {
			affData = data;
	
			if (wordsData) {
				setup();
			}
		}
	
		function setWordsData(data) {
			wordsData = data;
	
			if (affData) {
				setup();
			}
		}
	
		function setup() {
			self.rules = self._parseAFF(affData);
			
			// Save the rule codes that are used in compound rules.
			self.compoundRuleCodes = {};
			
			for (i = 0, _len = self.compoundRules.length; i < _len; i++) {
				var rule = self.compoundRules[i];
				
				for (j = 0, _jlen = rule.length; j < _jlen; j++) {
					self.compoundRuleCodes[rule[j]] = [];
				}
			}
			
			// If we add this ONLYINCOMPOUND flag to self.compoundRuleCodes, then _parseDIC
			// will do the work of saving the list of words that are compound-only.
			if ("ONLYINCOMPOUND" in self.flags) {
				self.compoundRuleCodes[self.flags.ONLYINCOMPOUND] = [];
			}
			
			self.dictionaryTable = self._parseDIC(wordsData);
			
			// Get rid of any codes from the compound rule codes that are never used 
			// (or that were special regex characters).  Not especially necessary... 
			for (i in self.compoundRuleCodes) {
				if (self.compoundRuleCodes[i].length === 0) {
					delete self.compoundRuleCodes[i];
				}
			}
			
			// Build the full regular expressions for each compound rule.
			// I have a feeling (but no confirmation yet) that this method of 
			// testing for compound words is probably slow.
			for (i = 0, _len = self.compoundRules.length; i < _len; i++) {
				var ruleText = self.compoundRules[i];
				
				var expressionText = "";
				
				for (j = 0, _jlen = ruleText.length; j < _jlen; j++) {
					var character = ruleText[j];
					
					if (character in self.compoundRuleCodes) {
						expressionText += "(" + self.compoundRuleCodes[character].join("|") + ")";
					}
					else {
						expressionText += character;
					}
				}
				
				self.compoundRules[i] = new RegExp(expressionText, "i");
			}
			
			self.loaded = true;
			
			if (settings.asyncLoad && settings.loadedCallback) {
				settings.loadedCallback(self);
			}
		}
		
		return this;
	};
	
	Typo.prototype = {
		/**
		 * Loads a Typo instance from a hash of all of the Typo properties.
		 *
		 * @param object obj A hash of Typo properties, probably gotten from a JSON.parse(JSON.stringify(typo_instance)).
		 */
		
		load : function (obj) {
			for (var i in obj) {
				if (obj.hasOwnProperty(i)) {
					this[i] = obj[i];
				}
			}
			
			return this;
		},
		
		/**
		 * Read the contents of a file.
		 * 
		 * @param {String} path The path (relative) to the file.
		 * @param {String} [charset="ISO8859-1"] The expected charset of the file
		 * @param {Boolean} async If true, the file will be read asynchronously. For node.js this does nothing, all
		 *        files are read synchronously.
		 * @returns {String} The file data if async is false, otherwise a promise object. If running node.js, the data is
		 *          always returned.
		 */
		
		_readFile : function (path, charset, async) {
			charset = charset || "utf8";
			
			if (typeof XMLHttpRequest !== 'undefined') {
				var promise;
				var req = new XMLHttpRequest();
				req.open("GET", path, async);
				
				if (async) {
					promise = new Promise(function(resolve, reject) {
						req.onload = function() {
							if (req.status === 200) {
								resolve(req.responseText);
							}
							else {
								reject(req.statusText);
							}
						};
						
						req.onerror = function() {
							reject(req.statusText);
						}
					});
				}
			
				if (req.overrideMimeType)
					req.overrideMimeType("text/plain; charset=" + charset);
			
				req.send(null);
				
				return async ? promise : req.responseText;
			}
			else if (true) {
				// Node.js
				var fs = __webpack_require__(51);
				
				try {
					if (fs.existsSync(path)) {
						return fs.readFileSync(path, charset);
					}
					else {
						console.log("Path " + path + " does not exist.");
					}
				} catch (e) {
					console.log(e);
					return '';
				}
			}
		},
		
		/**
		 * Parse the rules out from a .aff file.
		 *
		 * @param {String} data The contents of the affix file.
		 * @returns object The rules from the file.
		 */
		
		_parseAFF : function (data) {
			var rules = {};
			
			var line, subline, numEntries, lineParts;
			var i, j, _len, _jlen;
			
			// Remove comment lines
			data = this._removeAffixComments(data);
			
			var lines = data.split(/\r?\n/);
			
			for (i = 0, _len = lines.length; i < _len; i++) {
				line = lines[i];
				
				var definitionParts = line.split(/\s+/);
				
				var ruleType = definitionParts[0];
				
				if (ruleType == "PFX" || ruleType == "SFX") {
					var ruleCode = definitionParts[1];
					var combineable = definitionParts[2];
					numEntries = parseInt(definitionParts[3], 10);
					
					var entries = [];
					
					for (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {
						subline = lines[j];
						
						lineParts = subline.split(/\s+/);
						var charactersToRemove = lineParts[2];
						
						var additionParts = lineParts[3].split("/");
						
						var charactersToAdd = additionParts[0];
						if (charactersToAdd === "0") charactersToAdd = "";
						
						var continuationClasses = this.parseRuleCodes(additionParts[1]);
						
						var regexToMatch = lineParts[4];
						
						var entry = {};
						entry.add = charactersToAdd;
						
						if (continuationClasses.length > 0) entry.continuationClasses = continuationClasses;
						
						if (regexToMatch !== ".") {
							if (ruleType === "SFX") {
								entry.match = new RegExp(regexToMatch + "$");
							}
							else {
								entry.match = new RegExp("^" + regexToMatch);
							}
						}
						
						if (charactersToRemove != "0") {
							if (ruleType === "SFX") {
								entry.remove = new RegExp(charactersToRemove  + "$");
							}
							else {
								entry.remove = charactersToRemove;
							}
						}
						
						entries.push(entry);
					}
					
					rules[ruleCode] = { "type" : ruleType, "combineable" : (combineable == "Y"), "entries" : entries };
					
					i += numEntries;
				}
				else if (ruleType === "COMPOUNDRULE") {
					numEntries = parseInt(definitionParts[1], 10);
					
					for (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {
						line = lines[j];
						
						lineParts = line.split(/\s+/);
						this.compoundRules.push(lineParts[1]);
					}
					
					i += numEntries;
				}
				else if (ruleType === "REP") {
					lineParts = line.split(/\s+/);
					
					if (lineParts.length === 3) {
						this.replacementTable.push([ lineParts[1], lineParts[2] ]);
					}
				}
				else {
					// ONLYINCOMPOUND
					// COMPOUNDMIN
					// FLAG
					// KEEPCASE
					// NEEDAFFIX
					
					this.flags[ruleType] = definitionParts[1];
				}
			}
			
			return rules;
		},
		
		/**
		 * Removes comment lines and then cleans up blank lines and trailing whitespace.
		 *
		 * @param {String} data The data from an affix file.
		 * @return {String} The cleaned-up data.
		 */
		
		_removeAffixComments : function (data) {
			// Remove comments
			// This used to remove any string starting with '#' up to the end of the line,
			// but some COMPOUNDRULE definitions include '#' as part of the rule.
			// I haven't seen any affix files that use comments on the same line as real data,
			// so I don't think this will break anything.
			data = data.replace(/^\s*#.*$/mg, "");
			
			// Trim each line
			data = data.replace(/^\s\s*/m, '').replace(/\s\s*$/m, '');
			
			// Remove blank lines.
			data = data.replace(/\n{2,}/g, "\n");
			
			// Trim the entire string
			data = data.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
			
			return data;
		},
		
		/**
		 * Parses the words out from the .dic file.
		 *
		 * @param {String} data The data from the dictionary file.
		 * @returns object The lookup table containing all of the words and
		 *                 word forms from the dictionary.
		 */
		
		_parseDIC : function (data) {
			data = this._removeDicComments(data);
			
			var lines = data.split(/\r?\n/);
			var dictionaryTable = {};
			
			function addWord(word, rules) {
				// Some dictionaries will list the same word multiple times with different rule sets.
				if (!dictionaryTable.hasOwnProperty(word)) {
					dictionaryTable[word] = null;
				}
				
				if (rules.length > 0) {
					if (dictionaryTable[word] === null) {
						dictionaryTable[word] = [];
					}
	
					dictionaryTable[word].push(rules);
				}
			}
			
			// The first line is the number of words in the dictionary.
			for (var i = 1, _len = lines.length; i < _len; i++) {
				var line = lines[i];
				
				if (!line) {
					// Ignore empty lines.
					continue;
				}
	
				var parts = line.split("/", 2);
				
				var word = parts[0];
	
				// Now for each affix rule, generate that form of the word.
				if (parts.length > 1) {
					var ruleCodesArray = this.parseRuleCodes(parts[1]);
					
					// Save the ruleCodes for compound word situations.
					if (!("NEEDAFFIX" in this.flags) || ruleCodesArray.indexOf(this.flags.NEEDAFFIX) == -1) {
						addWord(word, ruleCodesArray);
					}
					
					for (var j = 0, _jlen = ruleCodesArray.length; j < _jlen; j++) {
						var code = ruleCodesArray[j];
						
						var rule = this.rules[code];
						
						if (rule) {
							var newWords = this._applyRule(word, rule);
							
							for (var ii = 0, _iilen = newWords.length; ii < _iilen; ii++) {
								var newWord = newWords[ii];
								
								addWord(newWord, []);
								
								if (rule.combineable) {
									for (var k = j + 1; k < _jlen; k++) {
										var combineCode = ruleCodesArray[k];
										
										var combineRule = this.rules[combineCode];
										
										if (combineRule) {
											if (combineRule.combineable && (rule.type != combineRule.type)) {
												var otherNewWords = this._applyRule(newWord, combineRule);
												
												for (var iii = 0, _iiilen = otherNewWords.length; iii < _iiilen; iii++) {
													var otherNewWord = otherNewWords[iii];
													addWord(otherNewWord, []);
												}
											}
										}
									}
								}
							}
						}
						
						if (code in this.compoundRuleCodes) {
							this.compoundRuleCodes[code].push(word);
						}
					}
				}
				else {
					addWord(word.trim(), []);
				}
			}
			
			return dictionaryTable;
		},
		
		
		/**
		 * Removes comment lines and then cleans up blank lines and trailing whitespace.
		 *
		 * @param {String} data The data from a .dic file.
		 * @return {String} The cleaned-up data.
		 */
		
		_removeDicComments : function (data) {
			// I can't find any official documentation on it, but at least the de_DE
			// dictionary uses tab-indented lines as comments.
			
			// Remove comments
			data = data.replace(/^\t.*$/mg, "");
			
			return data;
		},
		
		parseRuleCodes : function (textCodes) {
			if (!textCodes) {
				return [];
			}
			else if (!("FLAG" in this.flags)) {
				return textCodes.split("");
			}
			else if (this.flags.FLAG === "long") {
				var flags = [];
				
				for (var i = 0, _len = textCodes.length; i < _len; i += 2) {
					flags.push(textCodes.substr(i, 2));
				}
				
				return flags;
			}
			else if (this.flags.FLAG === "num") {
				return textCodes.split(",");
			}
		},
		
		/**
		 * Applies an affix rule to a word.
		 *
		 * @param {String} word The base word.
		 * @param {Object} rule The affix rule.
		 * @returns {String[]} The new words generated by the rule.
		 */
		
		_applyRule : function (word, rule) {
			var entries = rule.entries;
			var newWords = [];
			
			for (var i = 0, _len = entries.length; i < _len; i++) {
				var entry = entries[i];
				
				if (!entry.match || word.match(entry.match)) {
					var newWord = word;
					
					if (entry.remove) {
						newWord = newWord.replace(entry.remove, "");
					}
					
					if (rule.type === "SFX") {
						newWord = newWord + entry.add;
					}
					else {
						newWord = entry.add + newWord;
					}
					
					newWords.push(newWord);
					
					if ("continuationClasses" in entry) {
						for (var j = 0, _jlen = entry.continuationClasses.length; j < _jlen; j++) {
							var continuationRule = this.rules[entry.continuationClasses[j]];
							
							if (continuationRule) {
								newWords = newWords.concat(this._applyRule(newWord, continuationRule));
							}
							/*
							else {
								// This shouldn't happen, but it does, at least in the de_DE dictionary.
								// I think the author mistakenly supplied lower-case rule codes instead 
								// of upper-case.
							}
							*/
						}
					}
				}
			}
			
			return newWords;
		},
		
		/**
		 * Checks whether a word or a capitalization variant exists in the current dictionary.
		 * The word is trimmed and several variations of capitalizations are checked.
		 * If you want to check a word without any changes made to it, call checkExact()
		 *
		 * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function
		 *
		 * @param {String} aWord The word to check.
		 * @returns {Boolean}
		 */
		
		check : function (aWord) {
			if (!this.loaded) {
				throw "Dictionary not loaded.";
			}
			
			// Remove leading and trailing whitespace
			var trimmedWord = aWord.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
			
			if (this.checkExact(trimmedWord)) {
				return true;
			}
			
			// The exact word is not in the dictionary.
			if (trimmedWord.toUpperCase() === trimmedWord) {
				// The word was supplied in all uppercase.
				// Check for a capitalized form of the word.
				var capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();
				
				if (this.hasFlag(capitalizedWord, "KEEPCASE")) {
					// Capitalization variants are not allowed for this word.
					return false;
				}
				
				if (this.checkExact(capitalizedWord)) {
					return true;
				}
			}
			
			var lowercaseWord = trimmedWord.toLowerCase();
			
			if (lowercaseWord !== trimmedWord) {
				if (this.hasFlag(lowercaseWord, "KEEPCASE")) {
					// Capitalization variants are not allowed for this word.
					return false;
				}
				
				// Check for a lowercase form
				if (this.checkExact(lowercaseWord)) {
					return true;
				}
			}
			
			return false;
		},
		
		/**
		 * Checks whether a word exists in the current dictionary.
		 *
		 * @param {String} word The word to check.
		 * @returns {Boolean}
		 */
		
		checkExact : function (word) {
			if (!this.loaded) {
				throw "Dictionary not loaded.";
			}
	
			var ruleCodes = this.dictionaryTable[word];
			
			var i, _len;
			
			if (typeof ruleCodes === 'undefined') {
				// Check if this might be a compound word.
				if ("COMPOUNDMIN" in this.flags && word.length >= this.flags.COMPOUNDMIN) {
					for (i = 0, _len = this.compoundRules.length; i < _len; i++) {
						if (word.match(this.compoundRules[i])) {
							return true;
						}
					}
				}
			}
			else if (ruleCodes === null) {
				// a null (but not undefined) value for an entry in the dictionary table
				// means that the word is in the dictionary but has no flags.
				return true;
			}
			else if (typeof ruleCodes === 'object') { // this.dictionary['hasOwnProperty'] will be a function.
				for (i = 0, _len = ruleCodes.length; i < _len; i++) {
					if (!this.hasFlag(word, "ONLYINCOMPOUND", ruleCodes[i])) {
						return true;
					}
				}
			}
	
			return false;
		},
		
		/**
		 * Looks up whether a given word is flagged with a given flag.
		 *
		 * @param {String} word The word in question.
		 * @param {String} flag The flag in question.
		 * @return {Boolean}
		 */
		 
		hasFlag : function (word, flag, wordFlags) {
			if (!this.loaded) {
				throw "Dictionary not loaded.";
			}
	
			if (flag in this.flags) {
				if (typeof wordFlags === 'undefined') {
					wordFlags = Array.prototype.concat.apply([], this.dictionaryTable[word]);
				}
				
				if (wordFlags && wordFlags.indexOf(this.flags[flag]) !== -1) {
					return true;
				}
			}
			
			return false;
		},
		
		/**
		 * Returns a list of suggestions for a misspelled word.
		 *
		 * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.
		 * This suggestor is primitive, but it works.
		 *
		 * @param {String} word The misspelling.
		 * @param {Number} [limit=5] The maximum number of suggestions to return.
		 * @returns {String[]} The array of suggestions.
		 */
		
		alphabet : "",
		
		suggest : function (word, limit) {
			if (!this.loaded) {
				throw "Dictionary not loaded.";
			}
	
			limit = limit || 5;
	
			if (this.memoized.hasOwnProperty(word)) {
				var memoizedLimit = this.memoized[word]['limit'];
	
				// Only return the cached list if it's big enough or if there weren't enough suggestions
				// to fill a smaller limit.
				if (limit <= memoizedLimit || this.memoized[word]['suggestions'].length < memoizedLimit) {
					return this.memoized[word]['suggestions'].slice(0, limit);
				}
			}
			
			if (this.check(word)) return [];
			
			// Check the replacement table.
			for (var i = 0, _len = this.replacementTable.length; i < _len; i++) {
				var replacementEntry = this.replacementTable[i];
				
				if (word.indexOf(replacementEntry[0]) !== -1) {
					var correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);
					
					if (this.check(correctedWord)) {
						return [ correctedWord ];
					}
				}
			}
			
			var self = this;
			self.alphabet = "abcdefghijklmnopqrstuvwxyz";
			
			/*
			if (!self.alphabet) {
				// Use the alphabet as implicitly defined by the words in the dictionary.
				var alphaHash = {};
				
				for (var i in self.dictionaryTable) {
					for (var j = 0, _len = i.length; j < _len; j++) {
						alphaHash[i[j]] = true;
					}
				}
				
				for (var i in alphaHash) {
					self.alphabet += i;
				}
				
				var alphaArray = self.alphabet.split("");
				alphaArray.sort();
				self.alphabet = alphaArray.join("");
			}
			*/
			
			/**
			 * Returns a hash keyed by all of the strings that can be made by making a single edit to the word (or words in) `words`
			 * The value of each entry is the number of unique ways that the resulting word can be made.
			 *
			 * @arg mixed words Either a hash keyed by words or a string word to operate on.
			 * @arg bool known_only Whether this function should ignore strings that are not in the dictionary.
			 */
			function edits1(words, known_only) {
				var rv = {};
				
				var i, j, _iilen, _len, _jlen, _edit;
				
				if (typeof words == 'string') {
					var word = words;
					words = {};
					words[word] = true;
				}
	
				for (var word in words) {
					for (i = 0, _len = word.length + 1; i < _len; i++) {
						var s = [ word.substring(0, i), word.substring(i) ];
					
						if (s[1]) {
							_edit = s[0] + s[1].substring(1);
	
							if (!known_only || self.check(_edit)) {
								if (!(_edit in rv)) {
									rv[_edit] = 1;
								}
								else {
									rv[_edit] += 1;
								}
							}
						}
						
						// Eliminate transpositions of identical letters
						if (s[1].length > 1 && s[1][1] !== s[1][0]) {
							_edit = s[0] + s[1][1] + s[1][0] + s[1].substring(2);
	
							if (!known_only || self.check(_edit)) {
								if (!(_edit in rv)) {
									rv[_edit] = 1;
								}
								else {
									rv[_edit] += 1;
								}
							}
						}
	
						if (s[1]) {
							for (j = 0, _jlen = self.alphabet.length; j < _jlen; j++) {
								// Eliminate replacement of a letter by itself
								if (self.alphabet[j] != s[1].substring(0,1)){
									_edit = s[0] + self.alphabet[j] + s[1].substring(1);
	
									if (!known_only || self.check(_edit)) {
										if (!(_edit in rv)) {
											rv[_edit] = 1;
										}
										else {
											rv[_edit] += 1;
										}
									}
								}
							}
						}
	
						if (s[1]) {
							for (j = 0, _jlen = self.alphabet.length; j < _jlen; j++) {
								_edit = s[0] + self.alphabet[j] + s[1];
	
								if (!known_only || self.check(_edit)) {
									if (!(_edit in rv)) {
										rv[_edit] = 1;
									}
									else {
										rv[_edit] += 1;
									}
								}
							}
						}
					}
				}
				
				return rv;
			}
	
			function correct(word) {
				// Get the edit-distance-1 and edit-distance-2 forms of this word.
				var ed1 = edits1(word);
				var ed2 = edits1(ed1, true);
				
				// Sort the edits based on how many different ways they were created.
				var weighted_corrections = ed2;
				
				for (var ed1word in ed1) {
					if (!self.check(ed1word)) {
						continue;
					}
	
					if (ed1word in weighted_corrections) {
						weighted_corrections[ed1word] += ed1[ed1word];
					}
					else {
						weighted_corrections[ed1word] = ed1[ed1word];
					}
				}
				
				var i, _len;
	
				var sorted_corrections = [];
				
				for (i in weighted_corrections) {
					if (weighted_corrections.hasOwnProperty(i)) {
						sorted_corrections.push([ i, weighted_corrections[i] ]);
					}
				}
	
				function sorter(a, b) {
					var a_val = a[1];
					var b_val = b[1];
					if (a_val < b_val) {
						return -1;
					} else if (a_val > b_val) {
						return 1;
					}
					// @todo If a and b are equally weighted, add our own weight based on something like the key locations on this language's default keyboard.
					return b[0].localeCompare(a[0]);
				}
				
				sorted_corrections.sort(sorter).reverse();
	
				var rv = [];
	
				var capitalization_scheme = "lowercase";
				
				if (word.toUpperCase() === word) {
					capitalization_scheme = "uppercase";
				}
				else if (word.substr(0, 1).toUpperCase() + word.substr(1).toLowerCase() === word) {
					capitalization_scheme = "capitalized";
				}
				
				var working_limit = limit;
	
				for (i = 0; i < Math.min(working_limit, sorted_corrections.length); i++) {
					if ("uppercase" === capitalization_scheme) {
						sorted_corrections[i][0] = sorted_corrections[i][0].toUpperCase();
					}
					else if ("capitalized" === capitalization_scheme) {
						sorted_corrections[i][0] = sorted_corrections[i][0].substr(0, 1).toUpperCase() + sorted_corrections[i][0].substr(1);
					}
					
					if (!self.hasFlag(sorted_corrections[i][0], "NOSUGGEST") && rv.indexOf(sorted_corrections[i][0]) == -1) {
						rv.push(sorted_corrections[i][0]);
					}
					else {
						// If one of the corrections is not eligible as a suggestion , make sure we still return the right number of suggestions.
						working_limit++;
					}
				}
	
				return rv;
			}
			
			this.memoized[word] = {
				'suggestions': correct(word),
				'limit': limit
			};
	
			return this.memoized[word]['suggestions'];
		}
	};
	})();
	
	// Support for use as a node.js module.
	if (true) {
		module.exports = Typo;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ }),
/* 51 */
/***/ (function(module, exports) {

	/* (ignored) */

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	const Lexer = __webpack_require__(53);
	const Parser = __webpack_require__(57);
	const Renderer = __webpack_require__(58);
	const TextRenderer = __webpack_require__(61);
	const InlineLexer = __webpack_require__(60);
	const Slugger = __webpack_require__(59);
	const {
	  merge,
	  checkSanitizeDeprecation,
	  escape
	} = __webpack_require__(56);
	const {
	  getDefaults,
	  changeDefaults,
	  defaults
	} = __webpack_require__(54);
	
	/**
	 * Marked
	 */
	function marked(src, opt, callback) {
	  // throw error in case of non string input
	  if (typeof src === 'undefined' || src === null) {
	    throw new Error('marked(): input parameter is undefined or null');
	  }
	  if (typeof src !== 'string') {
	    throw new Error('marked(): input parameter is of type '
	      + Object.prototype.toString.call(src) + ', string expected');
	  }
	
	  if (callback || typeof opt === 'function') {
	    if (!callback) {
	      callback = opt;
	      opt = null;
	    }
	
	    opt = merge({}, marked.defaults, opt || {});
	    checkSanitizeDeprecation(opt);
	    const highlight = opt.highlight;
	    let tokens,
	      pending,
	      i = 0;
	
	    try {
	      tokens = Lexer.lex(src, opt);
	    } catch (e) {
	      return callback(e);
	    }
	
	    pending = tokens.length;
	
	    const done = function(err) {
	      if (err) {
	        opt.highlight = highlight;
	        return callback(err);
	      }
	
	      let out;
	
	      try {
	        out = Parser.parse(tokens, opt);
	      } catch (e) {
	        err = e;
	      }
	
	      opt.highlight = highlight;
	
	      return err
	        ? callback(err)
	        : callback(null, out);
	    };
	
	    if (!highlight || highlight.length < 3) {
	      return done();
	    }
	
	    delete opt.highlight;
	
	    if (!pending) return done();
	
	    for (; i < tokens.length; i++) {
	      (function(token) {
	        if (token.type !== 'code') {
	          return --pending || done();
	        }
	        return highlight(token.text, token.lang, function(err, code) {
	          if (err) return done(err);
	          if (code == null || code === token.text) {
	            return --pending || done();
	          }
	          token.text = code;
	          token.escaped = true;
	          --pending || done();
	        });
	      })(tokens[i]);
	    }
	
	    return;
	  }
	  try {
	    opt = merge({}, marked.defaults, opt || {});
	    checkSanitizeDeprecation(opt);
	    return Parser.parse(Lexer.lex(src, opt), opt);
	  } catch (e) {
	    e.message += '\nPlease report this to https://github.com/markedjs/marked.';
	    if ((opt || marked.defaults).silent) {
	      return '<p>An error occurred:</p><pre>'
	        + escape(e.message + '', true)
	        + '</pre>';
	    }
	    throw e;
	  }
	}
	
	/**
	 * Options
	 */
	
	marked.options =
	marked.setOptions = function(opt) {
	  merge(marked.defaults, opt);
	  changeDefaults(marked.defaults);
	  return marked;
	};
	
	marked.getDefaults = getDefaults;
	
	marked.defaults = defaults;
	
	/**
	 * Expose
	 */
	
	marked.Parser = Parser;
	marked.parser = Parser.parse;
	
	marked.Renderer = Renderer;
	marked.TextRenderer = TextRenderer;
	
	marked.Lexer = Lexer;
	marked.lexer = Lexer.lex;
	
	marked.InlineLexer = InlineLexer;
	marked.inlineLexer = InlineLexer.output;
	
	marked.Slugger = Slugger;
	
	marked.parse = marked;
	
	module.exports = marked;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	const { defaults } = __webpack_require__(54);
	const { block } = __webpack_require__(55);
	const {
	  rtrim,
	  splitCells,
	  escape
	} = __webpack_require__(56);
	
	/**
	 * Block Lexer
	 */
	module.exports = class Lexer {
	  constructor(options) {
	    this.tokens = [];
	    this.tokens.links = Object.create(null);
	    this.options = options || defaults;
	    this.rules = block.normal;
	
	    if (this.options.pedantic) {
	      this.rules = block.pedantic;
	    } else if (this.options.gfm) {
	      this.rules = block.gfm;
	    }
	  }
	
	  /**
	   * Expose Block Rules
	   */
	  static get rules() {
	    return block;
	  }
	
	  /**
	   * Static Lex Method
	   */
	  static lex(src, options) {
	    const lexer = new Lexer(options);
	    return lexer.lex(src);
	  };
	
	  /**
	   * Preprocessing
	   */
	  lex(src) {
	    src = src
	      .replace(/\r\n|\r/g, '\n')
	      .replace(/\t/g, '    ');
	
	    return this.token(src, true);
	  };
	
	  /**
	   * Lexing
	   */
	  token(src, top) {
	    src = src.replace(/^ +$/gm, '');
	    let next,
	      loose,
	      cap,
	      bull,
	      b,
	      item,
	      listStart,
	      listItems,
	      t,
	      space,
	      i,
	      tag,
	      l,
	      isordered,
	      istask,
	      ischecked;
	
	    while (src) {
	      // newline
	      if (cap = this.rules.newline.exec(src)) {
	        src = src.substring(cap[0].length);
	        if (cap[0].length > 1) {
	          this.tokens.push({
	            type: 'space'
	          });
	        }
	      }
	
	      // code
	      if (cap = this.rules.code.exec(src)) {
	        const lastToken = this.tokens[this.tokens.length - 1];
	        src = src.substring(cap[0].length);
	        // An indented code block cannot interrupt a paragraph.
	        if (lastToken && lastToken.type === 'paragraph') {
	          lastToken.text += '\n' + cap[0].trimRight();
	        } else {
	          cap = cap[0].replace(/^ {4}/gm, '');
	          this.tokens.push({
	            type: 'code',
	            codeBlockStyle: 'indented',
	            text: !this.options.pedantic
	              ? rtrim(cap, '\n')
	              : cap
	          });
	        }
	        continue;
	      }
	
	      // fences
	      if (cap = this.rules.fences.exec(src)) {
	        src = src.substring(cap[0].length);
	        this.tokens.push({
	          type: 'code',
	          lang: cap[2] ? cap[2].trim() : cap[2],
	          text: cap[3] || ''
	        });
	        continue;
	      }
	
	      // heading
	      if (cap = this.rules.heading.exec(src)) {
	        src = src.substring(cap[0].length);
	        this.tokens.push({
	          type: 'heading',
	          depth: cap[1].length,
	          text: cap[2]
	        });
	        continue;
	      }
	
	      // table no leading pipe (gfm)
	      if (cap = this.rules.nptable.exec(src)) {
	        item = {
	          type: 'table',
	          header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
	          align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
	          cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
	        };
	
	        if (item.header.length === item.align.length) {
	          src = src.substring(cap[0].length);
	
	          for (i = 0; i < item.align.length; i++) {
	            if (/^ *-+: *$/.test(item.align[i])) {
	              item.align[i] = 'right';
	            } else if (/^ *:-+: *$/.test(item.align[i])) {
	              item.align[i] = 'center';
	            } else if (/^ *:-+ *$/.test(item.align[i])) {
	              item.align[i] = 'left';
	            } else {
	              item.align[i] = null;
	            }
	          }
	
	          for (i = 0; i < item.cells.length; i++) {
	            item.cells[i] = splitCells(item.cells[i], item.header.length);
	          }
	
	          this.tokens.push(item);
	
	          continue;
	        }
	      }
	
	      // hr
	      if (cap = this.rules.hr.exec(src)) {
	        src = src.substring(cap[0].length);
	        this.tokens.push({
	          type: 'hr'
	        });
	        continue;
	      }
	
	      // blockquote
	      if (cap = this.rules.blockquote.exec(src)) {
	        src = src.substring(cap[0].length);
	
	        this.tokens.push({
	          type: 'blockquote_start'
	        });
	
	        cap = cap[0].replace(/^ *> ?/gm, '');
	
	        // Pass `top` to keep the current
	        // "toplevel" state. This is exactly
	        // how markdown.pl works.
	        this.token(cap, top);
	
	        this.tokens.push({
	          type: 'blockquote_end'
	        });
	
	        continue;
	      }
	
	      // list
	      if (cap = this.rules.list.exec(src)) {
	        src = src.substring(cap[0].length);
	        bull = cap[2];
	        isordered = bull.length > 1;
	
	        listStart = {
	          type: 'list_start',
	          ordered: isordered,
	          start: isordered ? +bull : '',
	          loose: false
	        };
	
	        this.tokens.push(listStart);
	
	        // Get each top-level item.
	        cap = cap[0].match(this.rules.item);
	
	        listItems = [];
	        next = false;
	        l = cap.length;
	        i = 0;
	
	        for (; i < l; i++) {
	          item = cap[i];
	
	          // Remove the list item's bullet
	          // so it is seen as the next token.
	          space = item.length;
	          item = item.replace(/^ *([*+-]|\d+\.) */, '');
	
	          // Outdent whatever the
	          // list item contains. Hacky.
	          if (~item.indexOf('\n ')) {
	            space -= item.length;
	            item = !this.options.pedantic
	              ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
	              : item.replace(/^ {1,4}/gm, '');
	          }
	
	          // Determine whether the next list item belongs here.
	          // Backpedal if it does not belong in this list.
	          if (i !== l - 1) {
	            b = block.bullet.exec(cap[i + 1])[0];
	            if (bull.length > 1 ? b.length === 1
	              : (b.length > 1 || (this.options.smartLists && b !== bull))) {
	              src = cap.slice(i + 1).join('\n') + src;
	              i = l - 1;
	            }
	          }
	
	          // Determine whether item is loose or not.
	          // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
	          // for discount behavior.
	          loose = next || /\n\n(?!\s*$)/.test(item);
	          if (i !== l - 1) {
	            next = item.charAt(item.length - 1) === '\n';
	            if (!loose) loose = next;
	          }
	
	          if (loose) {
	            listStart.loose = true;
	          }
	
	          // Check for task list items
	          istask = /^\[[ xX]\] /.test(item);
	          ischecked = undefined;
	          if (istask) {
	            ischecked = item[1] !== ' ';
	            item = item.replace(/^\[[ xX]\] +/, '');
	          }
	
	          t = {
	            type: 'list_item_start',
	            task: istask,
	            checked: ischecked,
	            loose: loose
	          };
	
	          listItems.push(t);
	          this.tokens.push(t);
	
	          // Recurse.
	          this.token(item, false);
	
	          this.tokens.push({
	            type: 'list_item_end'
	          });
	        }
	
	        if (listStart.loose) {
	          l = listItems.length;
	          i = 0;
	          for (; i < l; i++) {
	            listItems[i].loose = true;
	          }
	        }
	
	        this.tokens.push({
	          type: 'list_end'
	        });
	
	        continue;
	      }
	
	      // html
	      if (cap = this.rules.html.exec(src)) {
	        src = src.substring(cap[0].length);
	        this.tokens.push({
	          type: this.options.sanitize
	            ? 'paragraph'
	            : 'html',
	          pre: !this.options.sanitizer
	            && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
	          text: this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0]
	        });
	        continue;
	      }
	
	      // def
	      if (top && (cap = this.rules.def.exec(src))) {
	        src = src.substring(cap[0].length);
	        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
	        tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
	        if (!this.tokens.links[tag]) {
	          this.tokens.links[tag] = {
	            href: cap[2],
	            title: cap[3]
	          };
	        }
	        continue;
	      }
	
	      // table (gfm)
	      if (cap = this.rules.table.exec(src)) {
	        item = {
	          type: 'table',
	          header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
	          align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
	          cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
	        };
	
	        if (item.header.length === item.align.length) {
	          src = src.substring(cap[0].length);
	
	          for (i = 0; i < item.align.length; i++) {
	            if (/^ *-+: *$/.test(item.align[i])) {
	              item.align[i] = 'right';
	            } else if (/^ *:-+: *$/.test(item.align[i])) {
	              item.align[i] = 'center';
	            } else if (/^ *:-+ *$/.test(item.align[i])) {
	              item.align[i] = 'left';
	            } else {
	              item.align[i] = null;
	            }
	          }
	
	          for (i = 0; i < item.cells.length; i++) {
	            item.cells[i] = splitCells(
	              item.cells[i].replace(/^ *\| *| *\| *$/g, ''),
	              item.header.length);
	          }
	
	          this.tokens.push(item);
	
	          continue;
	        }
	      }
	
	      // lheading
	      if (cap = this.rules.lheading.exec(src)) {
	        src = src.substring(cap[0].length);
	        this.tokens.push({
	          type: 'heading',
	          depth: cap[2].charAt(0) === '=' ? 1 : 2,
	          text: cap[1]
	        });
	        continue;
	      }
	
	      // top-level paragraph
	      if (top && (cap = this.rules.paragraph.exec(src))) {
	        src = src.substring(cap[0].length);
	        this.tokens.push({
	          type: 'paragraph',
	          text: cap[1].charAt(cap[1].length - 1) === '\n'
	            ? cap[1].slice(0, -1)
	            : cap[1]
	        });
	        continue;
	      }
	
	      // text
	      if (cap = this.rules.text.exec(src)) {
	        // Top-level should never reach here.
	        src = src.substring(cap[0].length);
	        this.tokens.push({
	          type: 'text',
	          text: cap[0]
	        });
	        continue;
	      }
	
	      if (src) {
	        throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
	      }
	    }
	
	    return this.tokens;
	  };
	};


/***/ }),
/* 54 */
/***/ (function(module, exports) {

	function getDefaults() {
	  return {
	    baseUrl: null,
	    breaks: false,
	    gfm: true,
	    headerIds: true,
	    headerPrefix: '',
	    highlight: null,
	    langPrefix: 'language-',
	    mangle: true,
	    pedantic: false,
	    renderer: null,
	    sanitize: false,
	    sanitizer: null,
	    silent: false,
	    smartLists: false,
	    smartypants: false,
	    xhtml: false
	  };
	}
	
	function changeDefaults(newDefaults) {
	  module.exports.defaults = newDefaults;
	}
	
	module.exports = {
	  defaults: getDefaults(),
	  getDefaults,
	  changeDefaults
	};


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	const {
	  noopTest,
	  edit,
	  merge
	} = __webpack_require__(56);
	
	/**
	 * Block-Level Grammar
	 */
	const block = {
	  newline: /^\n+/,
	  code: /^( {4}[^\n]+\n*)+/,
	  fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
	  hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
	  heading: /^ {0,3}(#{1,6}) +([^\n]*?)(?: +#+)? *(?:\n+|$)/,
	  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
	  list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
	  html: '^ {0,3}(?:' // optional indentation
	    + '<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
	    + '|comment[^\\n]*(\\n+|$)' // (2)
	    + '|<\\?[\\s\\S]*?\\?>\\n*' // (3)
	    + '|<![A-Z][\\s\\S]*?>\\n*' // (4)
	    + '|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>\\n*' // (5)
	    + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)' // (6)
	    + '|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) open tag
	    + '|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) closing tag
	    + ')',
	  def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
	  nptable: noopTest,
	  table: noopTest,
	  lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
	  // regex template, placeholders will be replaced according to different paragraph
	  // interruption rules of commonmark and the original markdown spec:
	  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html)[^\n]+)*)/,
	  text: /^[^\n]+/
	};
	
	block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
	block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
	block.def = edit(block.def)
	  .replace('label', block._label)
	  .replace('title', block._title)
	  .getRegex();
	
	block.bullet = /(?:[*+-]|\d{1,9}\.)/;
	block.item = /^( *)(bull) ?[^\n]*(?:\n(?!\1bull ?)[^\n]*)*/;
	block.item = edit(block.item, 'gm')
	  .replace(/bull/g, block.bullet)
	  .getRegex();
	
	block.list = edit(block.list)
	  .replace(/bull/g, block.bullet)
	  .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
	  .replace('def', '\\n+(?=' + block.def.source + ')')
	  .getRegex();
	
	block._tag = 'address|article|aside|base|basefont|blockquote|body|caption'
	  + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
	  + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
	  + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
	  + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'
	  + '|track|ul';
	block._comment = /<!--(?!-?>)[\s\S]*?-->/;
	block.html = edit(block.html, 'i')
	  .replace('comment', block._comment)
	  .replace('tag', block._tag)
	  .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
	  .getRegex();
	
	block.paragraph = edit(block._paragraph)
	  .replace('hr', block.hr)
	  .replace('heading', ' {0,3}#{1,6} ')
	  .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
	  .replace('blockquote', ' {0,3}>')
	  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
	  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
	  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)')
	  .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
	  .getRegex();
	
	block.blockquote = edit(block.blockquote)
	  .replace('paragraph', block.paragraph)
	  .getRegex();
	
	/**
	 * Normal Block Grammar
	 */
	
	block.normal = merge({}, block);
	
	/**
	 * GFM Block Grammar
	 */
	
	block.gfm = merge({}, block.normal, {
	  nptable: '^ *([^|\\n ].*\\|.*)\\n' // Header
	    + ' *([-:]+ *\\|[-| :]*)' // Align
	    + '(?:\\n((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)', // Cells
	  table: '^ *\\|(.+)\\n' // Header
	    + ' *\\|?( *[-:]+[-| :]*)' // Align
	    + '(?:\\n *((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)' // Cells
	});
	
	block.gfm.nptable = edit(block.gfm.nptable)
	  .replace('hr', block.hr)
	  .replace('heading', ' {0,3}#{1,6} ')
	  .replace('blockquote', ' {0,3}>')
	  .replace('code', ' {4}[^\\n]')
	  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
	  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
	  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)')
	  .replace('tag', block._tag) // tables can be interrupted by type (6) html blocks
	  .getRegex();
	
	block.gfm.table = edit(block.gfm.table)
	  .replace('hr', block.hr)
	  .replace('heading', ' {0,3}#{1,6} ')
	  .replace('blockquote', ' {0,3}>')
	  .replace('code', ' {4}[^\\n]')
	  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
	  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
	  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)')
	  .replace('tag', block._tag) // tables can be interrupted by type (6) html blocks
	  .getRegex();
	
	/**
	 * Pedantic grammar (original John Gruber's loose markdown specification)
	 */
	
	block.pedantic = merge({}, block.normal, {
	  html: edit(
	    '^ *(?:comment *(?:\\n|\\s*$)'
	    + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
	    + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
	    .replace('comment', block._comment)
	    .replace(/tag/g, '(?!(?:'
	      + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
	      + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
	      + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
	    .getRegex(),
	  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
	  heading: /^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n+|$)/,
	  fences: noopTest, // fences not supported
	  paragraph: edit(block.normal._paragraph)
	    .replace('hr', block.hr)
	    .replace('heading', ' *#{1,6} *[^\n]')
	    .replace('lheading', block.lheading)
	    .replace('blockquote', ' {0,3}>')
	    .replace('|fences', '')
	    .replace('|list', '')
	    .replace('|html', '')
	    .getRegex()
	});
	
	/**
	 * Inline-Level Grammar
	 */
	const inline = {
	  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
	  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
	  url: noopTest,
	  tag: '^comment'
	    + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
	    + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
	    + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
	    + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
	    + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>', // CDATA section
	  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
	  reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
	  nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
	  strong: /^__([^\s_])__(?!_)|^\*\*([^\s*])\*\*(?!\*)|^__([^\s][\s\S]*?[^\s])__(?!_)|^\*\*([^\s][\s\S]*?[^\s])\*\*(?!\*)/,
	  em: /^_([^\s_])_(?!_)|^\*([^\s*<\[])\*(?!\*)|^_([^\s<][\s\S]*?[^\s_])_(?!_|[^\spunctuation])|^_([^\s_<][\s\S]*?[^\s])_(?!_|[^\spunctuation])|^\*([^\s<"][\s\S]*?[^\s\*])\*(?!\*|[^\spunctuation])|^\*([^\s*"<\[][\s\S]*?[^\s])\*(?!\*)/,
	  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
	  br: /^( {2,}|\\)\n(?!\s*$)/,
	  del: noopTest,
	  text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*]|\b_|$)|[^ ](?= {2,}\n))|(?= {2,}\n))/
	};
	
	// list of punctuation marks from common mark spec
	// without ` and ] to workaround Rule 17 (inline code blocks/links)
	inline._punctuation = '!"#$%&\'()*+,\\-./:;<=>?@\\[^_{|}~';
	inline.em = edit(inline.em).replace(/punctuation/g, inline._punctuation).getRegex();
	
	inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
	
	inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
	inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
	inline.autolink = edit(inline.autolink)
	  .replace('scheme', inline._scheme)
	  .replace('email', inline._email)
	  .getRegex();
	
	inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
	
	inline.tag = edit(inline.tag)
	  .replace('comment', block._comment)
	  .replace('attribute', inline._attribute)
	  .getRegex();
	
	inline._label = /(?:\[[^\[\]]*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
	inline._href = /<(?:\\[<>]?|[^\s<>\\])*>|[^\s\x00-\x1f]*/;
	inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
	
	inline.link = edit(inline.link)
	  .replace('label', inline._label)
	  .replace('href', inline._href)
	  .replace('title', inline._title)
	  .getRegex();
	
	inline.reflink = edit(inline.reflink)
	  .replace('label', inline._label)
	  .getRegex();
	
	/**
	 * Normal Inline Grammar
	 */
	
	inline.normal = merge({}, inline);
	
	/**
	 * Pedantic Inline Grammar
	 */
	
	inline.pedantic = merge({}, inline.normal, {
	  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
	  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/,
	  link: edit(/^!?\[(label)\]\((.*?)\)/)
	    .replace('label', inline._label)
	    .getRegex(),
	  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
	    .replace('label', inline._label)
	    .getRegex()
	});
	
	/**
	 * GFM Inline Grammar
	 */
	
	inline.gfm = merge({}, inline.normal, {
	  escape: edit(inline.escape).replace('])', '~|])').getRegex(),
	  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
	  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
	  _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
	  del: /^~+(?=\S)([\s\S]*?\S)~+/,
	  text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*~]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))|(?= {2,}\n|[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))/
	});
	
	inline.gfm.url = edit(inline.gfm.url, 'i')
	  .replace('email', inline.gfm._extended_email)
	  .getRegex();
	/**
	 * GFM + Line Breaks Inline Grammar
	 */
	
	inline.breaks = merge({}, inline.gfm, {
	  br: edit(inline.br).replace('{2,}', '*').getRegex(),
	  text: edit(inline.gfm.text)
	    .replace('\\b_', '\\b_| {2,}\\n')
	    .replace(/\{2,\}/g, '*')
	    .getRegex()
	});
	
	module.exports = {
	  block,
	  inline
	};


/***/ }),
/* 56 */
/***/ (function(module, exports) {

	/**
	 * Helpers
	 */
	const escapeTest = /[&<>"']/;
	const escapeReplace = /[&<>"']/g;
	const escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
	const escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
	const escapeReplacements = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  "'": '&#39;'
	};
	const getEscapeReplacement = (ch) => escapeReplacements[ch];
	function escape(html, encode) {
	  if (encode) {
	    if (escapeTest.test(html)) {
	      return html.replace(escapeReplace, getEscapeReplacement);
	    }
	  } else {
	    if (escapeTestNoEncode.test(html)) {
	      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
	    }
	  }
	
	  return html;
	}
	
	const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
	
	function unescape(html) {
	  // explicitly match decimal, hex, and named HTML entities
	  return html.replace(unescapeTest, (_, n) => {
	    n = n.toLowerCase();
	    if (n === 'colon') return ':';
	    if (n.charAt(0) === '#') {
	      return n.charAt(1) === 'x'
	        ? String.fromCharCode(parseInt(n.substring(2), 16))
	        : String.fromCharCode(+n.substring(1));
	    }
	    return '';
	  });
	}
	
	const caret = /(^|[^\[])\^/g;
	function edit(regex, opt) {
	  regex = regex.source || regex;
	  opt = opt || '';
	  const obj = {
	    replace: (name, val) => {
	      val = val.source || val;
	      val = val.replace(caret, '$1');
	      regex = regex.replace(name, val);
	      return obj;
	    },
	    getRegex: () => {
	      return new RegExp(regex, opt);
	    }
	  };
	  return obj;
	}
	
	const nonWordAndColonTest = /[^\w:]/g;
	const originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
	function cleanUrl(sanitize, base, href) {
	  if (sanitize) {
	    let prot;
	    try {
	      prot = decodeURIComponent(unescape(href))
	        .replace(nonWordAndColonTest, '')
	        .toLowerCase();
	    } catch (e) {
	      return null;
	    }
	    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
	      return null;
	    }
	  }
	  if (base && !originIndependentUrl.test(href)) {
	    href = resolveUrl(base, href);
	  }
	  try {
	    href = encodeURI(href).replace(/%25/g, '%');
	  } catch (e) {
	    return null;
	  }
	  return href;
	}
	
	const baseUrls = {};
	const justDomain = /^[^:]+:\/*[^/]*$/;
	const protocol = /^([^:]+:)[\s\S]*$/;
	const domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
	
	function resolveUrl(base, href) {
	  if (!baseUrls[' ' + base]) {
	    // we can ignore everything in base after the last slash of its path component,
	    // but we might need to add _that_
	    // https://tools.ietf.org/html/rfc3986#section-3
	    if (justDomain.test(base)) {
	      baseUrls[' ' + base] = base + '/';
	    } else {
	      baseUrls[' ' + base] = rtrim(base, '/', true);
	    }
	  }
	  base = baseUrls[' ' + base];
	  const relativeBase = base.indexOf(':') === -1;
	
	  if (href.substring(0, 2) === '//') {
	    if (relativeBase) {
	      return href;
	    }
	    return base.replace(protocol, '$1') + href;
	  } else if (href.charAt(0) === '/') {
	    if (relativeBase) {
	      return href;
	    }
	    return base.replace(domain, '$1') + href;
	  } else {
	    return base + href;
	  }
	}
	
	const noopTest = { exec: function noopTest() {} };
	
	function merge(obj) {
	  let i = 1,
	    target,
	    key;
	
	  for (; i < arguments.length; i++) {
	    target = arguments[i];
	    for (key in target) {
	      if (Object.prototype.hasOwnProperty.call(target, key)) {
	        obj[key] = target[key];
	      }
	    }
	  }
	
	  return obj;
	}
	
	function splitCells(tableRow, count) {
	  // ensure that every cell-delimiting pipe has a space
	  // before it to distinguish it from an escaped pipe
	  const row = tableRow.replace(/\|/g, (match, offset, str) => {
	      let escaped = false,
	        curr = offset;
	      while (--curr >= 0 && str[curr] === '\\') escaped = !escaped;
	      if (escaped) {
	        // odd number of slashes means | is escaped
	        // so we leave it alone
	        return '|';
	      } else {
	        // add space before unescaped |
	        return ' |';
	      }
	    }),
	    cells = row.split(/ \|/);
	  let i = 0;
	
	  if (cells.length > count) {
	    cells.splice(count);
	  } else {
	    while (cells.length < count) cells.push('');
	  }
	
	  for (; i < cells.length; i++) {
	    // leading or trailing whitespace is ignored per the gfm spec
	    cells[i] = cells[i].trim().replace(/\\\|/g, '|');
	  }
	  return cells;
	}
	
	// Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
	// /c*$/ is vulnerable to REDOS.
	// invert: Remove suffix of non-c chars instead. Default falsey.
	function rtrim(str, c, invert) {
	  const l = str.length;
	  if (l === 0) {
	    return '';
	  }
	
	  // Length of suffix matching the invert condition.
	  let suffLen = 0;
	
	  // Step left until we fail to match the invert condition.
	  while (suffLen < l) {
	    const currChar = str.charAt(l - suffLen - 1);
	    if (currChar === c && !invert) {
	      suffLen++;
	    } else if (currChar !== c && invert) {
	      suffLen++;
	    } else {
	      break;
	    }
	  }
	
	  return str.substr(0, l - suffLen);
	}
	
	function findClosingBracket(str, b) {
	  if (str.indexOf(b[1]) === -1) {
	    return -1;
	  }
	  const l = str.length;
	  let level = 0,
	    i = 0;
	  for (; i < l; i++) {
	    if (str[i] === '\\') {
	      i++;
	    } else if (str[i] === b[0]) {
	      level++;
	    } else if (str[i] === b[1]) {
	      level--;
	      if (level < 0) {
	        return i;
	      }
	    }
	  }
	  return -1;
	}
	
	function checkSanitizeDeprecation(opt) {
	  if (opt && opt.sanitize && !opt.silent) {
	    console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
	  }
	}
	
	module.exports = {
	  escape,
	  unescape,
	  edit,
	  cleanUrl,
	  resolveUrl,
	  noopTest,
	  merge,
	  splitCells,
	  rtrim,
	  findClosingBracket,
	  checkSanitizeDeprecation
	};


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	const Renderer = __webpack_require__(58);
	const Slugger = __webpack_require__(59);
	const InlineLexer = __webpack_require__(60);
	const TextRenderer = __webpack_require__(61);
	const { defaults } = __webpack_require__(54);
	const {
	  merge,
	  unescape
	} = __webpack_require__(56);
	
	/**
	 * Parsing & Compiling
	 */
	module.exports = class Parser {
	  constructor(options) {
	    this.tokens = [];
	    this.token = null;
	    this.options = options || defaults;
	    this.options.renderer = this.options.renderer || new Renderer();
	    this.renderer = this.options.renderer;
	    this.renderer.options = this.options;
	    this.slugger = new Slugger();
	  }
	
	  /**
	   * Static Parse Method
	   */
	  static parse(tokens, options) {
	    const parser = new Parser(options);
	    return parser.parse(tokens);
	  };
	
	  /**
	   * Parse Loop
	   */
	  parse(tokens) {
	    this.inline = new InlineLexer(tokens.links, this.options);
	    // use an InlineLexer with a TextRenderer to extract pure text
	    this.inlineText = new InlineLexer(
	      tokens.links,
	      merge({}, this.options, { renderer: new TextRenderer() })
	    );
	    this.tokens = tokens.reverse();
	
	    let out = '';
	    while (this.next()) {
	      out += this.tok();
	    }
	
	    return out;
	  };
	
	  /**
	   * Next Token
	   */
	  next() {
	    this.token = this.tokens.pop();
	    return this.token;
	  };
	
	  /**
	   * Preview Next Token
	   */
	  peek() {
	    return this.tokens[this.tokens.length - 1] || 0;
	  };
	
	  /**
	   * Parse Text Tokens
	   */
	  parseText() {
	    let body = this.token.text;
	
	    while (this.peek().type === 'text') {
	      body += '\n' + this.next().text;
	    }
	
	    return this.inline.output(body);
	  };
	
	  /**
	   * Parse Current Token
	   */
	  tok() {
	    let body = '';
	    switch (this.token.type) {
	      case 'space': {
	        return '';
	      }
	      case 'hr': {
	        return this.renderer.hr();
	      }
	      case 'heading': {
	        return this.renderer.heading(
	          this.inline.output(this.token.text),
	          this.token.depth,
	          unescape(this.inlineText.output(this.token.text)),
	          this.slugger);
	      }
	      case 'code': {
	        return this.renderer.code(this.token.text,
	          this.token.lang,
	          this.token.escaped);
	      }
	      case 'table': {
	        let header = '',
	          i,
	          row,
	          cell,
	          j;
	
	        // header
	        cell = '';
	        for (i = 0; i < this.token.header.length; i++) {
	          cell += this.renderer.tablecell(
	            this.inline.output(this.token.header[i]),
	            { header: true, align: this.token.align[i] }
	          );
	        }
	        header += this.renderer.tablerow(cell);
	
	        for (i = 0; i < this.token.cells.length; i++) {
	          row = this.token.cells[i];
	
	          cell = '';
	          for (j = 0; j < row.length; j++) {
	            cell += this.renderer.tablecell(
	              this.inline.output(row[j]),
	              { header: false, align: this.token.align[j] }
	            );
	          }
	
	          body += this.renderer.tablerow(cell);
	        }
	        return this.renderer.table(header, body);
	      }
	      case 'blockquote_start': {
	        body = '';
	
	        while (this.next().type !== 'blockquote_end') {
	          body += this.tok();
	        }
	
	        return this.renderer.blockquote(body);
	      }
	      case 'list_start': {
	        body = '';
	        const ordered = this.token.ordered,
	          start = this.token.start;
	
	        while (this.next().type !== 'list_end') {
	          body += this.tok();
	        }
	
	        return this.renderer.list(body, ordered, start);
	      }
	      case 'list_item_start': {
	        body = '';
	        const loose = this.token.loose;
	        const checked = this.token.checked;
	        const task = this.token.task;
	
	        if (this.token.task) {
	          if (loose) {
	            if (this.peek().type === 'text') {
	              const nextToken = this.peek();
	              nextToken.text = this.renderer.checkbox(checked) + ' ' + nextToken.text;
	            } else {
	              this.tokens.push({
	                type: 'text',
	                text: this.renderer.checkbox(checked)
	              });
	            }
	          } else {
	            body += this.renderer.checkbox(checked);
	          }
	        }
	
	        while (this.next().type !== 'list_item_end') {
	          body += !loose && this.token.type === 'text'
	            ? this.parseText()
	            : this.tok();
	        }
	        return this.renderer.listitem(body, task, checked);
	      }
	      case 'html': {
	        // TODO parse inline content if parameter markdown=1
	        return this.renderer.html(this.token.text);
	      }
	      case 'paragraph': {
	        return this.renderer.paragraph(this.inline.output(this.token.text));
	      }
	      case 'text': {
	        return this.renderer.paragraph(this.parseText());
	      }
	      default: {
	        const errMsg = 'Token with "' + this.token.type + '" type was not found.';
	        if (this.options.silent) {
	          console.log(errMsg);
	        } else {
	          throw new Error(errMsg);
	        }
	      }
	    }
	  };
	};


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	const { defaults } = __webpack_require__(54);
	const {
	  cleanUrl,
	  escape
	} = __webpack_require__(56);
	
	/**
	 * Renderer
	 */
	module.exports = class Renderer {
	  constructor(options) {
	    this.options = options || defaults;
	  }
	
	  code(code, infostring, escaped) {
	    const lang = (infostring || '').match(/\S*/)[0];
	    if (this.options.highlight) {
	      const out = this.options.highlight(code, lang);
	      if (out != null && out !== code) {
	        escaped = true;
	        code = out;
	      }
	    }
	
	    if (!lang) {
	      return '<pre><code>'
	        + (escaped ? code : escape(code, true))
	        + '</code></pre>';
	    }
	
	    return '<pre><code class="'
	      + this.options.langPrefix
	      + escape(lang, true)
	      + '">'
	      + (escaped ? code : escape(code, true))
	      + '</code></pre>\n';
	  };
	
	  blockquote(quote) {
	    return '<blockquote>\n' + quote + '</blockquote>\n';
	  };
	
	  html(html) {
	    return html;
	  };
	
	  heading(text, level, raw, slugger) {
	    if (this.options.headerIds) {
	      return '<h'
	        + level
	        + ' id="'
	        + this.options.headerPrefix
	        + slugger.slug(raw)
	        + '">'
	        + text
	        + '</h'
	        + level
	        + '>\n';
	    }
	    // ignore IDs
	    return '<h' + level + '>' + text + '</h' + level + '>\n';
	  };
	
	  hr() {
	    return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
	  };
	
	  list(body, ordered, start) {
	    const type = ordered ? 'ol' : 'ul',
	      startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
	    return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
	  };
	
	  listitem(text) {
	    return '<li>' + text + '</li>\n';
	  };
	
	  checkbox(checked) {
	    return '<input '
	      + (checked ? 'checked="" ' : '')
	      + 'disabled="" type="checkbox"'
	      + (this.options.xhtml ? ' /' : '')
	      + '> ';
	  };
	
	  paragraph(text) {
	    return '<p>' + text + '</p>\n';
	  };
	
	  table(header, body) {
	    if (body) body = '<tbody>' + body + '</tbody>';
	
	    return '<table>\n'
	      + '<thead>\n'
	      + header
	      + '</thead>\n'
	      + body
	      + '</table>\n';
	  };
	
	  tablerow(content) {
	    return '<tr>\n' + content + '</tr>\n';
	  };
	
	  tablecell(content, flags) {
	    const type = flags.header ? 'th' : 'td';
	    const tag = flags.align
	      ? '<' + type + ' align="' + flags.align + '">'
	      : '<' + type + '>';
	    return tag + content + '</' + type + '>\n';
	  };
	
	  // span level renderer
	  strong(text) {
	    return '<strong>' + text + '</strong>';
	  };
	
	  em(text) {
	    return '<em>' + text + '</em>';
	  };
	
	  codespan(text) {
	    return '<code>' + text + '</code>';
	  };
	
	  br() {
	    return this.options.xhtml ? '<br/>' : '<br>';
	  };
	
	  del(text) {
	    return '<del>' + text + '</del>';
	  };
	
	  link(href, title, text) {
	    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
	    if (href === null) {
	      return text;
	    }
	    let out = '<a href="' + escape(href) + '"';
	    if (title) {
	      out += ' title="' + title + '"';
	    }
	    out += '>' + text + '</a>';
	    return out;
	  };
	
	  image(href, title, text) {
	    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
	    if (href === null) {
	      return text;
	    }
	
	    let out = '<img src="' + href + '" alt="' + text + '"';
	    if (title) {
	      out += ' title="' + title + '"';
	    }
	    out += this.options.xhtml ? '/>' : '>';
	    return out;
	  };
	
	  text(text) {
	    return text;
	  };
	};


/***/ }),
/* 59 */
/***/ (function(module, exports) {

	/**
	 * Slugger generates header id
	 */
	module.exports = class Slugger {
	  constructor() {
	    this.seen = {};
	  }
	
	  /**
	   * Convert string to unique id
	   */
	  slug(value) {
	    let slug = value
	      .toLowerCase()
	      .trim()
	      // remove html tags
	      .replace(/<[!\/a-z].*?>/ig, '')
	      // remove unwanted chars
	      .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '')
	      .replace(/\s/g, '-');
	
	    if (this.seen.hasOwnProperty(slug)) {
	      const originalSlug = slug;
	      do {
	        this.seen[originalSlug]++;
	        slug = originalSlug + '-' + this.seen[originalSlug];
	      } while (this.seen.hasOwnProperty(slug));
	    }
	    this.seen[slug] = 0;
	
	    return slug;
	  };
	};


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	const Renderer = __webpack_require__(58);
	const { defaults } = __webpack_require__(54);
	const { inline } = __webpack_require__(55);
	const {
	  findClosingBracket,
	  escape
	} = __webpack_require__(56);
	
	/**
	 * Inline Lexer & Compiler
	 */
	module.exports = class InlineLexer {
	  constructor(links, options) {
	    this.options = options || defaults;
	    this.links = links;
	    this.rules = inline.normal;
	    this.options.renderer = this.options.renderer || new Renderer();
	    this.renderer = this.options.renderer;
	    this.renderer.options = this.options;
	
	    if (!this.links) {
	      throw new Error('Tokens array requires a `links` property.');
	    }
	
	    if (this.options.pedantic) {
	      this.rules = inline.pedantic;
	    } else if (this.options.gfm) {
	      if (this.options.breaks) {
	        this.rules = inline.breaks;
	      } else {
	        this.rules = inline.gfm;
	      }
	    }
	  }
	
	  /**
	   * Expose Inline Rules
	   */
	  static get rules() {
	    return inline;
	  }
	
	  /**
	   * Static Lexing/Compiling Method
	   */
	  static output(src, links, options) {
	    const inline = new InlineLexer(links, options);
	    return inline.output(src);
	  }
	
	  /**
	   * Lexing/Compiling
	   */
	  output(src) {
	    let out = '',
	      link,
	      text,
	      href,
	      title,
	      cap,
	      prevCapZero;
	
	    while (src) {
	      // escape
	      if (cap = this.rules.escape.exec(src)) {
	        src = src.substring(cap[0].length);
	        out += escape(cap[1]);
	        continue;
	      }
	
	      // tag
	      if (cap = this.rules.tag.exec(src)) {
	        if (!this.inLink && /^<a /i.test(cap[0])) {
	          this.inLink = true;
	        } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
	          this.inLink = false;
	        }
	        if (!this.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
	          this.inRawBlock = true;
	        } else if (this.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
	          this.inRawBlock = false;
	        }
	
	        src = src.substring(cap[0].length);
	        out += this.renderer.html(this.options.sanitize
	          ? (this.options.sanitizer
	            ? this.options.sanitizer(cap[0])
	            : escape(cap[0]))
	          : cap[0]);
	        continue;
	      }
	
	      // link
	      if (cap = this.rules.link.exec(src)) {
	        const lastParenIndex = findClosingBracket(cap[2], '()');
	        if (lastParenIndex > -1) {
	          const start = cap[0].indexOf('!') === 0 ? 5 : 4;
	          const linkLen = start + cap[1].length + lastParenIndex;
	          cap[2] = cap[2].substring(0, lastParenIndex);
	          cap[0] = cap[0].substring(0, linkLen).trim();
	          cap[3] = '';
	        }
	        src = src.substring(cap[0].length);
	        this.inLink = true;
	        href = cap[2];
	        if (this.options.pedantic) {
	          link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
	
	          if (link) {
	            href = link[1];
	            title = link[3];
	          } else {
	            title = '';
	          }
	        } else {
	          title = cap[3] ? cap[3].slice(1, -1) : '';
	        }
	        href = href.trim().replace(/^<([\s\S]*)>$/, '$1');
	        out += this.outputLink(cap, {
	          href: InlineLexer.escapes(href),
	          title: InlineLexer.escapes(title)
	        });
	        this.inLink = false;
	        continue;
	      }
	
	      // reflink, nolink
	      if ((cap = this.rules.reflink.exec(src))
	          || (cap = this.rules.nolink.exec(src))) {
	        src = src.substring(cap[0].length);
	        link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
	        link = this.links[link.toLowerCase()];
	        if (!link || !link.href) {
	          out += cap[0].charAt(0);
	          src = cap[0].substring(1) + src;
	          continue;
	        }
	        this.inLink = true;
	        out += this.outputLink(cap, link);
	        this.inLink = false;
	        continue;
	      }
	
	      // strong
	      if (cap = this.rules.strong.exec(src)) {
	        src = src.substring(cap[0].length);
	        out += this.renderer.strong(this.output(cap[4] || cap[3] || cap[2] || cap[1]));
	        continue;
	      }
	
	      // em
	      if (cap = this.rules.em.exec(src)) {
	        src = src.substring(cap[0].length);
	        out += this.renderer.em(this.output(cap[6] || cap[5] || cap[4] || cap[3] || cap[2] || cap[1]));
	        continue;
	      }
	
	      // code
	      if (cap = this.rules.code.exec(src)) {
	        src = src.substring(cap[0].length);
	        out += this.renderer.codespan(escape(cap[2].trim(), true));
	        continue;
	      }
	
	      // br
	      if (cap = this.rules.br.exec(src)) {
	        src = src.substring(cap[0].length);
	        out += this.renderer.br();
	        continue;
	      }
	
	      // del (gfm)
	      if (cap = this.rules.del.exec(src)) {
	        src = src.substring(cap[0].length);
	        out += this.renderer.del(this.output(cap[1]));
	        continue;
	      }
	
	      // autolink
	      if (cap = this.rules.autolink.exec(src)) {
	        src = src.substring(cap[0].length);
	        if (cap[2] === '@') {
	          text = escape(this.mangle(cap[1]));
	          href = 'mailto:' + text;
	        } else {
	          text = escape(cap[1]);
	          href = text;
	        }
	        out += this.renderer.link(href, null, text);
	        continue;
	      }
	
	      // url (gfm)
	      if (!this.inLink && (cap = this.rules.url.exec(src))) {
	        if (cap[2] === '@') {
	          text = escape(cap[0]);
	          href = 'mailto:' + text;
	        } else {
	          // do extended autolink path validation
	          do {
	            prevCapZero = cap[0];
	            cap[0] = this.rules._backpedal.exec(cap[0])[0];
	          } while (prevCapZero !== cap[0]);
	          text = escape(cap[0]);
	          if (cap[1] === 'www.') {
	            href = 'http://' + text;
	          } else {
	            href = text;
	          }
	        }
	        src = src.substring(cap[0].length);
	        out += this.renderer.link(href, null, text);
	        continue;
	      }
	
	      // text
	      if (cap = this.rules.text.exec(src)) {
	        src = src.substring(cap[0].length);
	        if (this.inRawBlock) {
	          out += this.renderer.text(this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0]);
	        } else {
	          out += this.renderer.text(escape(this.smartypants(cap[0])));
	        }
	        continue;
	      }
	
	      if (src) {
	        throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
	      }
	    }
	
	    return out;
	  }
	
	  static escapes(text) {
	    return text ? text.replace(InlineLexer.rules._escapes, '$1') : text;
	  }
	
	  /**
	   * Compile Link
	   */
	  outputLink(cap, link) {
	    const href = link.href,
	      title = link.title ? escape(link.title) : null;
	
	    return cap[0].charAt(0) !== '!'
	      ? this.renderer.link(href, title, this.output(cap[1]))
	      : this.renderer.image(href, title, escape(cap[1]));
	  }
	
	  /**
	   * Smartypants Transformations
	   */
	  smartypants(text) {
	    if (!this.options.smartypants) return text;
	    return text
	      // em-dashes
	      .replace(/---/g, '\u2014')
	      // en-dashes
	      .replace(/--/g, '\u2013')
	      // opening singles
	      .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
	      // closing singles & apostrophes
	      .replace(/'/g, '\u2019')
	      // opening doubles
	      .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
	      // closing doubles
	      .replace(/"/g, '\u201d')
	      // ellipses
	      .replace(/\.{3}/g, '\u2026');
	  }
	
	  /**
	   * Mangle Links
	   */
	  mangle(text) {
	    if (!this.options.mangle) return text;
	    const l = text.length;
	    let out = '',
	      i = 0,
	      ch;
	
	    for (; i < l; i++) {
	      ch = text.charCodeAt(i);
	      if (Math.random() > 0.5) {
	        ch = 'x' + ch.toString(16);
	      }
	      out += '&#' + ch + ';';
	    }
	
	    return out;
	  }
	};


/***/ }),
/* 61 */
/***/ (function(module, exports) {

	/**
	 * TextRenderer
	 * returns only the textual part of the token
	 */
	module.exports = class TextRenderer {
	  // no need for block level renderers
	  strong(text) {
	    return text;
	  }
	
	  em(text) {
	    return text;
	  }
	
	  codespan(text) {
	    return text;
	  }
	
	  del(text) {
	    return text;
	  }
	
	  html(text) {
	    return text;
	  }
	
	  text(text) {
	    return text;
	  }
	
	  link(href, title, text) {
	    return '' + text;
	  }
	
	  image(href, title, text) {
	    return '' + text;
	  }
	
	  br() {
	    return '';
	  }
	};


/***/ })
/******/ ]);